<?xml version="1.0" encoding="utf-8"?>
<rules>
<rule>
<key>BD-MISC-TRANS</key>
<configkey>BD-MISC-TRANS</configkey>
<name><![CDATA[ 始终关闭事务 [BD-MISC-TRANS] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
始终关闭事务 [BD-MISC-TRANS-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
规范检测特定变量（'交易对象'）的交易情形
未被关闭.


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
规范必须在使用前参数化.

在参数化对话框里包含了两个表: '开始事务的函数'
和 '终止事务的函数'.

事务开始及终止对象都可使用参数化
'启用的' 栏位:
用来包含/排除分析时可用的那些已定义之事务
启始/终止对象.

'完全修饰的类型名称或命名空间' 栏位:
为事务实体的启动/终止规范允许范围内的声明.
如果此栏位空白, 只有在'函数名称' 栏位中指
定的全局函数名会被当成事务开始/终止对象.
如果此栏位使用通配符 '*', 则任何类型或任何
命名空间声明的函数-- 或在任何类型及命名空
间外声明的全局函数-- 会被当成事务开始/终止对象.

'函数名称' 栏位:
事务开始/终止函数名在此指定.

'+ 子类中的定义' 栏位:
这是用来决定在子类中的函数定义是否当成事务
开始/终止对象. 这适用于实例和非实例函数，
只有指定声明类型才有用.


设定事务开始对象
'开始事务的函数' 表格可以填入开始事务的函数
描述. 只要这些函数能处理底下任何一项:
	a) 返回一个事务对象.
	b) 启动了该函数被要求的事务对象. 例如, 在对
	   transaction-&gt;open() 的调用之后; "transaction" 是一个开始的事务而必须关闭.
	c) 启动它的一个实际参数为交易对象.

对开始函数而言, 这些 '返回一个事务对象', '"此" 对象 
是一个事务对象' 和 '事务对象的参数序号 (从 1 开始)'栏位
应该用来描述在发生的情况（a，b 或 c）. 最后栏位的值
应是受影响的参数序号 (从 1 开始).
例如, 如果该函数的第二个参数指定为事务对象，
这应该设为 "2" . 如果所有参数为事务对象则使用 '*'.

构造函数需要注意的地方
任何事务开始函数的名字 (在'函数名称' 栏位
指定) 和其声明类型中未经修饰名称完全相同
(在 '完全修饰的类型名称或命名空间' 栏位中该字段的值最后部分)
视为构造函数. 当构造函数代表 开始函数时，'"此" 对象是一个事务对象'
栏位必须勾选.
改变 '+ 子类中的定义', '返回一个事务对象' 和
 '事务对象的参数序号 (从 1 开始)' 栏位的值对构
造函数的分析是没有影响的.

设定事务终止对象:
第二个窗格可以填入事务对象指定的对象所调用的那些
终止事务的函数, 或以传递事务对象来成为他们的参数
之一.
对于事务开始对象, 在标识 '"此" 对象是一个事务对象'
和 '事务对象的参数序号' 的栏位应适当的填入事务终止
对象.

在这份文档的 '示例' 段落有着详细的示例说明该如何正
确的引用参数化的功能.

指定接近程序终止时违规的报告
"不要在应用程序终止时报告违规" 的
参数允许用户管理程序终止时违规的报
告. 因为一般建议需手动关闭事务所以
默认的设置是 "禁能".



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

示例 1(C-类型的参数化):
考虑底下参数化的规则:
 - 开始事务的函数名称是以 'start' 命名的
        且相应的 '返回一个事务对象' 选项是勾选的.
 - 终止事务的函数是以 'terminate' 为名
        且在 '事务对象的参数序号' 表格栏位中相应
        单元格的值设定 '1'.

以这种方式参数化, 规范会在底下代码检测到
违规:

#include&lt;stdio.h&gt;

void* start() { }

void terminate(void * a) { }

static void notClosedTransaction()
{
	void* transaction;
	transaction = start();
}



示例 2(C++-类型的参数化):
如下例子:

namespace mySpace {
	class MyTransaction
	{
		public:
			void start();
			void terminate();
			static void terminateTransaction(MyTransaction* p)
			{
			};
	};
}

static void transactionUse()
{
    mySpace::MyTransaction* t = new mySpace::MyTransaction();
    t-&gt;start();
} // 't' is not terminated


为了检测如上代码中未关闭的事务, 应以底下方式参数化:

 - 开始事务的函数:
       '完全修饰的类型名称或命名空间' 单元格内容: "mySpace::MyTransaction";
       '函数名称' 单元格内容: "start";
       '"此" 对象是一个事务对象' 复选框状态: 勾选.
 - 终止函数:
       '完全修饰的类型名称或命名空间' 单元格内容: "mySpace::MyTransaction";
       '函数名称' 单元格内容: "terminate";
       '"此" 对象是一个事务对象' 复选框状态: 勾选.
 - 额外终止的函数:
       '完全修饰的类型名称或命名空间' 单元格内容: "mySpace::MyTransaction";
       '函数名称' 单元格内容: "terminateTransaction";
       '事务对象的参数序号 (从 1 开始)' 单元格内容: 1.



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
针对示例 1:
利用添加对终止函数的调用, 可以修复代码的问题
且不会再引发报错:

#include&lt;stdio.h&gt;

void* start() { }

void terminate(void * a) { }

static void notClosedTransaction()
{
	void* transaction;
	transaction = start();
	terminate(transaction);
}


针对示例 2:
利用添加对终止函数的调用, 可以修复代码的问题
且不会再引发报错:

namespace mySpace {
	class MyTransaction
	{
		public:
			void start();
			void terminate();
			static void terminateTransaction(MyTransaction* p)
			{
			};
	};
}

static void transactionUse()
{
    mySpace::MyTransaction* t = new mySpace::MyTransaction();
    t-&gt;start();
    t-&gt;terminate(); // mySpace::MyTransaction::terminateTransaction(t); may be used as well
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-ARRAY</key>
<configkey>BD-PB-ARRAY</configkey>
<name><![CDATA[ 避免访问数组越界 [BD-PB-ARRAY] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免访问数组越界 [BD-PB-ARRAY-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
该规则检测可能导致数组越界的数组访问。
尤其是当明显的越界发生时，将报告违规。
当数组下标值为负，零或者大于数组个数时，将发生数组越界。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.0.22


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
数组越界将造成严重的安全性隐患。
若应用程序包含此漏洞，它可能被人通过执行恶意代码获取整个程序的控制权。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
"积极报告关于索引在循环内部更改的违规" 模式提示 BugDetective 
在任何时候当它怀疑会有问题存在于使用一个会在循环内部更改的变量作为
访问数组的索引时，就报告一个违规 -- 即使可能存在很高概率这个情况
会是一个误报。 使用这个模式可能将导致更多的错误被报告出来，但是也
可以增加假报警的数量。

"报告未验证的违规" 参数对很多 BugDetective 规则来说是常见的。它被
描述在 Parasoft C++test 用户手册的 "BugDetective 的数据流静态分析
-&gt; 自定义 BugDetective 静态分析 -&gt; 配置规则参数" 章节。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

void fillArray(int array[], int size)
{
	int i;
	for (i = 0; i &lt;= size; i++) { // iterate from 0 to 100
		array[i] = 0; // VIOLATION (accessing array out of bounds: "array[i]" where (i == 100))
	}
}

void example()
{
	int array[100];
	fillArray(array, 100);
	// ...
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

void fillArray(int array[], int size)
{
	int i;
	for (i = 0; i &lt; size; i++) { // iterate from 0 to 99
		array[i] = 0; // NO VIOLATION
	}
}

void example()
{
	int array[100];
	fillArray(array, 100);
	// ...
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-131
<A HREF="http://cwe.mitre.org/top25/#CWE-131">http://cwe.mitre.org/top25/#CWE-131</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-CC</key>
<configkey>BD-PB-CC</configkey>
<name><![CDATA[ 避免始终判断为相同值的条件 [BD-PB-CC] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免始终判断为相同值的条件 [BD-PB-CC-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
该规则检测条件判断始终为真或假的情况。
该情况经常出现在代码重构过程中 -- 特别
是由多个开发人员编辑的代码。这种情况
常常也表示代码中存在逻辑错误。此外，
该情况也表明条件设定不恰当，可能导致
代码效率低下和无用代码段（如下面事
例代码所示）

如何工作：
该规则检测源码中的所有条件并确定他们是否多余。
为实现此目标，该规则将检测所有包含条件判断的
代码分支。若找到其条件判断值始终一样，则报告
一个违规。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
当条件和使得该条件为常量的代码在同一个函数里，
基本上能确定该函数存在一定逻辑错误。当条件和
使得该条件为常量的代码在不同函数中时，在处理
和修复该函数前需要仔细评审。评审非常重要，即
使解决方案可能是移除该判断，但该判断也可能防
范将来代码发送变化。


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>

它可以指定是否使用导致常量条件表达式的命名的编译时间常量应该
作为一个违规被报告出来。这些情况在默认情况下是不会报告的。
但是可以通过启用“报告关于使用命名的编译时间常量的问题”选项来更改。
通常情况下，编译时间常量被用于配置应用程序行为（例如，工作在 debug
(调试)模式或是 release (发布)模式）。如果在被分析的应用程序中
是这种情况，使用编译时间常量的条件是预期的，并且不代表死代码。
否则，启用该选项可能会在检测发生死代码时非常有用。我们可以考虑
下面的代码为例：

const bool DEBUG = false;

/* ... */

if (DEBUG) {
    /* 执行一些调试输出 */
}

虽然这个条件在任何给定的时刻都是常量，但是因为开发
人员可能希望改变命名的编译时间常量的值而故意保留的。
因此通常这不应该被看作是一个违规。


然而，写相同代码的更加有效的方法应该是通过预处理指令：

#define DEBUG 1

/* ... */

#ifdef DEBUG
    /* 执行一些调试输出 */
#endif

并且规则可以帮助更有效地执行这一风格。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
助您保持代码的优良状态，并且立即除去可疑的逻辑。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include "stdio.h"

void processHexValue(char*);

static void checkRange(char* cur)
{
	if ((*cur &lt; '0') || (*cur &gt; '9')) {
		printf("Error: only digits are permitted");
		return;
	}
	// obviously dead code
	if ((*cur &gt;= 'a') &amp;&amp; (*cur &lt;= 'f')) {
		processHexValue(cur);
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

#include "stdio.h"

static void checkRange(char* cur)
{
	if ((*cur &lt; '0') || (*cur &gt; '9')) {
		printf("Error: only decimal digits are permitted");
		return;
	}
}

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-DEREF</key>
<configkey>BD-PB-DEREF</configkey>
<name><![CDATA[ 避免在检查 null 之前解引用 [BD-PB-DEREF] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在检查 null 之前解引用 [BD-PB-DEREF-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
该规则检测这样的情况，若一个在某个分支上已经
做过是否为空判断的指针或引用，在该检测之前使
用该指针。

一类情况是在在重构过程中，空指针检测可能成为冗余。
另一些情况则是一些被使用的指针需要检测为空,
但开发人员错误的在检测该指针为空之前使用该指
针。这容易引致空指针引用的异常。无论何种情况，
这样一般都表明代码中存在一些问题，因此需要去
检测是否会导致严重的问题。

如何工作：
该规则检测代码中判断指针为空是否冗余。
为此，该规则将检测所有将判断指针是否
为空（举例，变量"foo"）的代码路径。若
查找所有路径过程中发现使用变量"foo"，
则将报告一个违规。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
当解引用和空指针检测在同一个函数中时，
这几乎可以肯定表明存在某种逻辑错误。
当两者在不同函数中时，在修复所报告问题
前，需要仔细评审。即使最简单的解决方案
直接去掉空指针检测代码，但该检测有可能
与将来一些改变想违背。


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
帮你检测可能存在空指针引用的错误和找到
无用代码。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include "stdio.h"

static void checkSequence(char cur[])
{
	if (cur[0] == '-') {
		printf("Error: only positive values are permitted");
		return;
	}
	// misplaced null check
	if (cur == 0) {
		printf("Error: null argument provided");
		return;
	}
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

#include "stdio.h"

static void checkSequence(char cur[])
{
	if (cur == 0) {
		printf("Error: null argument provided");
		return;
	}
	if (cur[0] == '-') {
		printf("Error: only positive values are permitted");
		return;
	}
}

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-NOTINIT</key>
<configkey>BD-PB-NOTINIT</configkey>
<name><![CDATA[ 避免在初始化之前使用 [BD-PB-NOTINIT] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在初始化之前使用 [BD-PB-NOTINIT-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
该规则检测变量在使用之前是否进行初始化。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
'当未初始化变量作为常量参数传递给一个没有源代码的函数
时报违规'复选框允许你指定是否允许一个未初始化的变量
作为一个常量参数传递给函数。以防参数为 struct 或 class 类型，
只针对完全为初始化的对象报告违规提醒。举例，若 struct 的
某个域以const参数的形式传递给第三方库函数，若该struct类型
只有部分未初始化，则不报告违规。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
该规则检测多种错误情况。
下面只是其中一个会触发违规的例子。

1.
static void useParameter(int *pi)
{
	int j = *pi;
}

static void usageOfUninializedVariablePassedToMethodByAddress()
{
	int i;
	useParameter(&amp;i); // VIOLATION
}

2.
static void pointerDerefInLhsOfDefinition()
{
    int* notInitializedPointer;
    *notInitializedPointer = 0; // VIOLATION
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
使用之前一定要初始化。


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-NP</key>
<configkey>BD-PB-NP</configkey>
<name><![CDATA[ 避免空指针解引用 [BD-PB-NP] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免空指针解引用 [BD-PB-NP-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
该规则访问空指针的错误。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
"若某变量根据空指针判断从逻辑上表明为空，则报告这样的空指针引用违规"复选框：
该复选框允许你指定哪一种违规规则被报告：

   * 仅那些BD能够证明某个变量确实被赋值为NULL；
   * 除了上面的分类，外加尽管无直接赋值为NULL，但根据空指针判断从逻辑上表明该变量在使用时可能
             发生空指针访问。

后一种情况的事例如下:

    int b = (ptr == 0); // null check that stipulates null dereferencing at violation point
    ...
    if (b) {
        ...
        int i = *ptr; // violation reported if the check box is ticked
    }

以下是关于允许在验证函数表格中定义函数不同方面的列的说明： 

* '启用的' 列可以用来为 BugDetective 分析暂时禁用一些
  定义的函数。

* '完全修饰的类型名称' 列必须填写声明此函数的完全修饰的
  类型名称。 如果您希望描述声明在任何类型或命名空间的函数，
  或者声明在任何类型或命名空间外部的全局函数，使用 '*' 通配符。

* '函数名称' 列应该包含描述的函数的名称。

* '+ 子类中的定义' 列用于表明当前行是否适用于包含
  名称定义在给定类的子类中的函数。 请注意，这个适用于
  实例和非实例的函数。
  
其他列允许描述哪些数据会被给定函数所影响：

* '"此" 对象是已验证的' 列用于指定该函数清除在其上
  调用的对象。

* '返回已验证的数据' 列用于指定该函数清除它的返回值。

* '已验证参数的序号 (从 1 开始)' 列用于指定
  该函数清除它的一些参数。 使用逗号分隔参数列表的索引
  或者使用 '*' 来指定所有受影响的参数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
示例#1 - 这是一个触发违规的示例:

static void nullPointerDereference()
{
    int* pointerToNull = 0;
    int variable = *pointerToNull; // VIOLATION
}

static void zeroTracking()
{
    int* pointerValue = 0;
    int* pointerToNull = pointerValue;
    int variable = *pointerToNull; // VIOLATION
}

static void multiPointer()
{
    int* zero = 0;
    int** ppi = &amp;zero;
    int* pi = *ppi;
    int k = *pi; // VIOLATION
}


示例#2 - 定制返回空指针:
假定createInstance()函数可能返回空指针：

namespace mySpace {
    class MyClass
    {
        public:
            int getNumber();
            static MyClass* createInstance();
    };
}

static void usingFactory()
{
    mySpace::MyClass* instance = mySpace::MyClass::createInstance();
    int num = instance-&gt;getNumber(); // VIOLATION
}

为检测以上代码可能引用空指针的情况，
该规则按如下方式设置参数：

 - 添加返回空指针的函数:
       '完全修饰的类型名称' 一栏填入值: "mySpace::MyClass";
       '函数名称' 一栏: "createInstance";
                     使用'+ 子类中的定义' 如果 createInstance() 在子类中定义;
        mySpace::MyClass 可能返回空指针。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
防止空指针引用。


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-OVERFFMT</key>
<configkey>BD-PB-OVERFFMT</configkey>
<name><![CDATA[ 避免由于定义不正确的格式限制导致的缓冲区溢出 [BD-PB-OVERFFMT] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免由于定义不正确的格式限制导致的缓冲区溢出 [BD-PB-OVERFFMT-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
该规则检测由于scanf系列函数导致的缓存溢出问题。
当格式化的字符串进行读操作，而该读操作可能导致
缓存溢出。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
缓存溢出可能导致严重的安全隐患。
如果应用程序有这种漏洞， 它可以被用来执行
任意代码，并取得应用程序的完全控制。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

FILE* file;

void read(char* buff, int buffSize)
{
	char formatString[100];
	char sizeString[100];
	strcpy(formatString, "%");
	strcat(formatString, itoa(buffSize, sizeString, 10));
	strcat(formatString, "s");
	fscanf(file, formatString, buff);
}

void test()
{
	char buffer[100];
	read(buffer, 101);
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
若通过read()函数传递 "buffSize" 参数给真实的缓存大小赋值，则不会报告该问题：

void test()
{
	char buffer[100];
	read(buffer, 100);
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-120
<A HREF="http://cwe.mitre.org/top25/#CWE-120">http://cwe.mitre.org/top25/#CWE-120</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-OVERFNZT</key>
<configkey>BD-PB-OVERFNZT</configkey>
<name><![CDATA[ 避免由于读取非零终止字符串导致的溢出 [BD-PB-OVERFNZT] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免由于读取非零终止字符串导致的溢出 [BD-PB-OVERFNZT-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测由于在没有正确零终止的字符串
上运行一个字符串函数可能溢出的情况。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
缓冲区溢出的可能性是一个严重的安全威胁。
如果应用程序有这种漏洞， 它可以被用来执行
任意代码，并取得应用程序的完全控制。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char *header, *header2; /* initialized somewhere */

void process(int flag, char* body)
{
	char buffer[100], buffer2[100];
	strcpy(buffer, header);
	if (flag) {
		buffer2[0] = 'a';
		buffer2[1] = 'b';
		strcat(buffer, buffer2);
	} else {
		strncpy(body, "abc", 2);
		strcat(buffer, body);
	}
	/* ... */
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发违规，因为正确添加了零终止符号：

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char *header, *header2; /* initialized somewhere */

void process(int flag, char* body)
{
	char buffer[100], buffer2[100];
	strcpy(buffer, header);
	if (flag) {
		buffer2[0] = 'a';
		buffer2[1] = 'b';
		buffer2[2] = 0;
		strcat(buffer, buffer2);
	} else {
		strcpy(body, "ab");
		strcat(buffer, body);
	}
	/* ... */
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-120
<A HREF="http://cwe.mitre.org/top25/#CWE-120">http://cwe.mitre.org/top25/#CWE-120</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-OVERFRD</key>
<configkey>BD-PB-OVERFRD</configkey>
<name><![CDATA[ 避免读取缓冲区时导致的溢出 [BD-PB-OVERFRD] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免读取缓冲区时导致的溢出 [BD-PB-OVERFRD-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测当代码读取缓冲区并且读操作
能够超越缓冲区边界的情况。

具体来说， 如果可能包含明显的缓冲区溢出的执行路径，
将会报告一个违规。这会发生在 当 'size' 参数的值是负数
或大于实际的缓冲区大小时。

这条规则使用下列函数检测缓冲区溢出：

	void *memcpy(void *dest, const void *src, size_t n);
	void bcopy(const void *src, void *dest, size_t n);
	char *strncpy(char *dest, const char *src, size_t n);
	char *strncat(char *dest, const char *src, size_t n);
	size_t strlcpy(char *dst, const char *src, size_t size);
	size_t strlcat(char *dst, const char *src, size_t size);


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
缓冲区溢出的可能性是一个严重的安全威胁。
如果应用程序有这种漏洞， 它可以被用来执行
任意代码，并取得应用程序的完全控制。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include &lt;string.h&gt;

void example()
{
	int src[100];
	int dest[200];
	// ...
	memcpy(dest, src, sizeof(dest)); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

#include &lt;string.h&gt;

void example()
{
	int src[100];
	int dest[200];
	// ...
	memcpy(dest, src, sizeof(src)); // NO VIOLATION
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-131
<A HREF="http://cwe.mitre.org/top25/#CWE-131">http://cwe.mitre.org/top25/#CWE-131</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-OVERFWR</key>
<configkey>BD-PB-OVERFWR</configkey>
<name><![CDATA[ 避免写入缓冲区时导致的溢出 [BD-PB-OVERFWR] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免写入缓冲区时导致的溢出 [BD-PB-OVERFWR-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
﻿说明
这条规则检测当代码写入缓冲区并且写操作能够
超越缓冲区边界的情况。

具体来说，  如果一个执行路径包含明显的缓冲区溢出， 则会
报告一个违例， 这通常发生在 'size' 参数是负数
或者大于实际实际的缓冲区大小。

当参数少于零或大于数组的真正大小时发生。

规则利用以下函数来捡查是否有超出数组边界的现象：

	void *memset(void *s, int c, size_t n);
	void *memcpy(void *dest, const void *src, size_t n);
	void bcopy(const void *src, void *dest, size_t n);
	char *fgets(char *s, int size, FILE *stream);
	int snprintf(char *str, size_t size, const char *format, ...);
	int vsnprintf(char *str, size_t size, const char *format, va_list ap);
	int swprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, ...);
	int vswprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, va_list args);
	char *strncpy(char *dest, const char *src, size_t n);
	char *strncat(char *dest, const char *src, size_t n);
	size_t strlcpy(char *dst, const char *src, size_t size);
	size_t strlcat(char *dst, const char *src, size_t size);
	int syslog(int type, char *bufp, int len);


</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>

N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>

缓冲区溢出的可能性是一个严重的安全威胁。
如果应用程序有这种漏洞， 它可以被用来执行
任意代码，并取得应用程序的完全控制。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>

N/A


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>

N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
这个示例会报出这个违规:

Example 1:

#include &lt;string.h&gt;

void example()
{
	int src[200];
	int dest[100];
	// ...
	memcpy(dest, src, sizeof(src)); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
这个示例不会报出这个违规:

#include &lt;string.h&gt;

void example()
{
	int src[200];
	int dest[100];
	// ...
	memcpy(dest, src, sizeof(dest)); // 没有违规
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-120
<A HREF="http://cwe.mitre.org/top25/#CWE-120">http://cwe.mitre.org/top25/#CWE-120</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-SWITCH</key>
<configkey>BD-PB-SWITCH</configkey>
<name><![CDATA[ 避免具有无法到达分支的开关语句 [BD-PB-SWITCH] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免具有无法到达分支的开关语句 [BD-PB-SWITCH-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
﻿说明
这条规则识别无法达到的  switch 分支。-- 一种无效代码。
无效代码经常出现在重构过程和代码演化中--
尤其是当代码被多个开发者编辑。 通常， 无法达到的 switch 分支的存在
表示在代码中有逻辑错误 (就如下面的例子部分所示)。

如何工作:
这条规则检查出现在代码中的 switch 语句并确定是否他们 
有无法达到的分支。 为此， 它会检查所有会执行这个 switch 
语句的代码路径。如果它发现在 switch 语句所有这些路径上 
有某些分支无法达到， 它会报告违规。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>

为了能够更好的利用此规则，在 BugDetective 的配置面板中
的 "当原因不能显示的时候不报告违规" 选项必须设空。


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
可以指定对于一个没有明确说明无法达到的默认分支是
否报告一个违规。这是由复选框 "报告无法达到的缺省分支，
包括即使不是明确定义的" 控制的。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
能够帮助您使代码保持良好壮态，并且可尽早除掉反复
无常的逻辑。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

以下是个可触发违规的示例(在 BugDetective
的配置面板中的 "当原因不能显示的时候不报告违规"
复选框必须设空）：


#include "stdio.h"

enum Figures {
	SPHERE,
	CIRCLE,
	CUBE,
	SQUARE,
	HIMESPHERE
};

static void guessFigure(int round, int volumetric)
{
    int figure;
    if (round &amp;&amp; volumetric) {
        figure = SPHERE;
    } else if (round &amp;&amp; !volumetric) {
        figure = CIRCLE; 
    } else if (!round &amp;&amp; volumetric) {
        figure = CUBE;
    } else {
    	figure = SQUARE;
    }
    
    switch (figure) {
		case SQUARE:
			printf("This is a sphere");
			break;
        case HIMESPHERE:
			printf("This is a hemispere");
            break;
        case CIRCLE:
			printf("This is a circle");
            break;
        case CUBE:
			printf("This is a cube");
            break;
		default:
			printf("This is a square");
			break;
	}
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

若欲修复此代码，必须除掉不可进入的分支：

#include "stdio.h"

enum Figures {
	SPHERE,
	CIRCLE,
	CUBE,
	SQUARE,
	HIMESPHERE
};

static void guessFigure(int round, int volumetric)
{
    int figure;
    if (round &amp;&amp; volumetric) {
        figure = SPHERE;
    } else if (round &amp;&amp; !volumetric) {
        figure = CIRCLE; 
    } else if (!round &amp;&amp; volumetric) {
        figure = CUBE;
    } else {
    	figure = SQUARE;
    }
    
    switch (figure) {
		case SQUARE:
			printf("This is a sphere");
			break;
        case CIRCLE:
			printf("This is a circle");
            break;
        case CUBE:
			printf("This is a cube");
            break;
		default:
			printf("This is a square");
			break;
	}
}

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-PB-ZERO</key>
<configkey>BD-PB-ZERO</configkey>
<name><![CDATA[ 避免除零错误 [BD-PB-ZERO] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免除零错误 [BD-PB-ZERO-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
﻿说明
这条规则检测代码的执行路径,以发现其中 0 作为
分母的情况。这个是应该避免的异常情况。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
此规则可检查几种以零为分母的程序。
以下有几个会触发违规的例子：

static int zeroMethod()
{
    return 0;
}

static void assignmentRemainderOfMethodResult()
{
    int a = 5;
    a %= zeroMethod(); // 违规
}

static void assignRemainderOfVar()
{
    int a = 5;
    int b = 0;
    a %= b; // 违规
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
改进代码防止以零为分母的程序。


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-RES-BADFREEF</key>
<configkey>BD-RES-BADFREEF</configkey>
<name><![CDATA[ 确保释放函数保证资源释放 [BD-RES-BADFREEF] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保释放函数保证资源释放 [BD-RES-BADFREEF-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
﻿说明
这条规则检测试图释放资源，但是不保证资源在任何情况下
被释放的函数。这条规则检测名称匹配您指定的函数(默认
设置为 "*free*)。当一个函数通过在某些路径上传递参数
释放资源，但是在其他路径上它们不被释放。这个意味着
在一定条件下调用关闭函数，可能导致资源泄漏。

资源集和与释放函数相关的定义都在
"测试配置 -&gt; 静态 -&gt; 选项 -&gt; BugDetective -&gt; 资源" 选项卡中。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
参数对话框允许定义打算检查函数的名称模式。
默认值是 "*free*"。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
违规例子：（请注意: 希望使测试能够检测出此违规，需使启用
"Memory (standard C)"的选项。其选项存于资源表里。
"测试配置 -&gt; 静态 -&gt; 选项 -&gt; BugDetective -&gt; 资源" 选项卡中 ）

#include &lt;stdlib.h&gt;

void bad_free(void *p, int condition)
{
    if (condition) {
        free(p);
    }
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下列代码将不会报出这个违规:

#include &lt;stdlib.h&gt;

void good_free(void *p)
{
    if (p != 0) {
        free(p);
    }
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-RES-FREE</key>
<configkey>BD-RES-FREE</configkey>
<name><![CDATA[ 不得使用已经释放掉的资源 [BD-RES-FREE] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用已经释放掉的资源 [BD-RES-FREE-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
﻿说明
这条规则检查各种已经被释放的资源，特别是有指向如下
已释放资源的指针或引用时，报告一个违规：

   * 从函数返回,
   * 作为参数传递到函数中,
   * 用在算术运算中,
   * 解除引用, 或者
   * 分配给一个变量/域/数组元素。

此规则可以定位任何类型的资源违规。
资源集可在 "测试配置 -&gt; 静态 -&gt; 选项 -&gt; BugDetective -&gt; 资源" 面板中设置。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
"当指向已释放资源的指针和 null 比较时报告违规" 
复选框用于 不抑制/抑制 一个指向已释放资源的指针
和 null 比较时的违规。由于代码写法和程序设计，
此模式可能被允许。默认情况下不报告这中违规。

"当指向已释放资源的指针和其他指针比较时报告违规" 
复选框用于 不抑制/抑制 一个指向已释放资源的指针
和其他指针比较时的违规。由于代码写法和程序设计，
此模式可能被允许。默认情况下不报告这中违规。

优点预防因使用已被释放的资源而造成异常或不可预知的错误。


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
如下示例会报告这个违规

int compute(int* buffer, const int size)
{
	int result = 0;
	// perform computations
	delete[] buffer;
	return result;
}

void process(const int size)
{
	int* buffer = new int[size];
	int result = compute(buffer, size);
	delete[] buffer;
	// do something
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
移除在 compute() 函数中的 delete 即可修复上面的示例(注意,为了让 BugDetective
找出示例中的违规,必须使能"测试配置 -&gt; 静态 -&gt; 选项 -&gt; BugDetective -&gt; 资源" 
面板中的"Memory (standard C++)"项):

int compute(int* buffer, const int size)
{
	int result = 0;
	// perform computations
	return result;
}

void process(const int size)
{
	int* buffer = new int[size];
	int result = compute(buffer, size);
	delete[] buffer;
	// do something
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-RES-INVFREE</key>
<configkey>BD-RES-INVFREE</configkey>
<name><![CDATA[ 不得使用无效的指针释放资源 [BD-RES-INVFREE] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用无效的指针释放资源 [BD-RES-INVFREE-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
﻿说明
这条规律检测任何试图使用无效指针释放资源的情况。
当指针用于释放任何符合下面条件的资源时，
报告一个违规：

   * 指向一个字符串常量的指针。
   * 从一个整数常量类型转换成的指针 （野指针）。
   * 从一个参数，局部，全局或静态常量类型转换成的指针 (欲释放非堆型的内存）。
   * 不指向分配块开始地址的指针。

这条规则可检查任何资源释放函数的调用。
资源和对应的释放函数可在"测试配置 -&gt; 静态 
-&gt; 选项 -&gt; BugDetective -&gt; 资源" 面板下设置。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
这个示例会报告这一条违规(注意,如果需要BugDetective找到示例中的违规,
需要使能"测试配置 -&gt; 静态 -&gt; 选项 -&gt; BugDetective -&gt; 资源" 
面板下的"Memory (standard C)"项):

#include &lt;stdlib.h&gt;

#define SIZE 100

int buffer[SIZE];

void process(int size)
{
	int* data = buffer;
	if (size &gt; SIZE) {
		data = (int*)malloc(size*sizeof(int));
	}
	/* do something with the data buffer */
	free(data);
}




</PRE>
<STRONG>
修复
</STRONG>
<PRE>
如下示例不会报告这一条违规:

#include &lt;stdlib.h&gt;

#define SIZE 100

int buffer[SIZE];

void process(int size)
{
    int* data = buffer;
    if (size &gt; SIZE) {
        data = (int*)malloc(size*sizeof(int));
    }
	/* do something with the data buffer */
    if (size &gt; SIZE) {
        free(data);
    }
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-RES-LEAKS</key>
<configkey>BD-RES-LEAKS</configkey>
<name><![CDATA[ 确保资源已释放 [BD-RES-LEAKS] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保资源已释放 [BD-RES-LEAKS-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则有助于确保分配的资源在所有的路径被释放。
这条规则在应用程序中资源被泄露的执行路径上
报告违规。

这条规则可以识别任何类型的资源泄漏。 将会检测
哪些泄漏的资源集被定义在
"测试配置 -&gt; 静态 -&gt; 选项 -&gt; BugDetective -&gt; 资源" 选项卡。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.0


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
关闭资源失败可能导致资源匮乏，这可能会有
安全问题。 


</PRE>
<STRONG>
参数
</STRONG>
<PRE>

"假定第三方的方法能够存储资源的引用"
参数允许您当一个资源的引用可能存储在第三方函数中时
决定这条规则检测的严格程度。 例如， 如果有一个第三方
函数 SpecialCollection.add() 和一个作为参数传递给
这个函数的资源， 它就会被存储在集合(collection)中，
并可能在集合迭代结束以后被关闭。 由于 BugDetective 并
不知道任意第三方函数的确切行为， 它的行为为下列任一方式：

   * 当这个参数启用时 (默认)， 如果资源通过参数传递到函数中， 
     BugDetective 假定任何第三方函数可能存储资源的引用。
            如果该资源后来使用存储的引用关闭掉，
            这样则可以防止误报正确的代码。
            但是， 可也可能导致漏报 (真正的泄漏没有被报告
            为违规)。

   * 当这个参数无效时， BugDetective 采取更积极的做法:
            它假定第三方函数不以任何方式影响资源。 这个做法
            可能会导致误报， 但是不会忽略掉默认的做法
            可能会错过的一些真正的泄漏。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
有一个严格的策略在关闭资源方面将有助于使应用程序
更加坚固以防止资源匮乏。


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个触发违规的例子。 (请注意， 为了 BugDetective
在示例中查找违规， "Files (stdio.h)" 必须在资源列表中被打开。
列表在 "测试配置 -&gt; 静态 -&gt; 选项 -&gt; BugDetective -&gt; 资源" 选项卡。):

#include &lt;stdio.h&gt;

static void fileAllocation()
{
	FILE* p = fopen("file.name", "r");
}

static void fileReallocation()
{
	FILE* p = fdopen(0, "file.name");
	p = freopen("file.name", "r", p);
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发违规：

#include &lt;stdio.h&gt;

static void fileAllocation()
{
	FILE* p = fopen("file.name", "r");
	fclose(p);
}

static void fileReallocation()
{
	FILE* p = fdopen(0, "file.name");
	p = freopen("file.name", "r", p);
	fclose(p);
}

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-SECURITY-ARRAY</key>
<configkey>BD-SECURITY-ARRAY</configkey>
<name><![CDATA[ 避免在数组索引中有受污染数据 [BD-SECURITY-ARRAY] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在数组索引中有受污染数据 [BD-SECURITY-ARRAY-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测可能导致越界访问的数组访问操作。
具体来说， 如果数组元素来自于一个可以返回恶意数据的受污染函数 (例如, 用户输入), 
并且使用一个索引来访问该数组元素。则会报告一个违规。 
但是不检查非负 (适用于有符号（ signed ）类型) 并且
小于相应数组的大小的值。

来自于下面数据源的数据被认为是被污染的:

   * main() 函数的参数
   * 网络

受污染数据其他的来源可以通过参数化这条规则来定义。
有关详细信息， 请参见 “参数” 部分。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
这种超越其边界来访问数组的潜在性是一个严重的安全威胁。
如果应用程序有这种漏洞， 它可以被用来执行
任意代码，并取得应用程序的完全控制。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
这条规则可以被参数化，以便来自下列数据源的数据被认为是受污染的
(除了前面在 “说明” 部分列出的那些之外):

   * 文件
   * 管道
   * 面向流式的 API (std::istream, 来自 MFC 的 CArchive 和 CFile)
   * 低层次的输入 (Windows API, POSIX)
   * 控制台
   * 环境变量

这条规则可以使用一列验证函数来参数化。
任何验证函数可以被定义为:
   * 返回良性(benign)数据, 和/或;
   * 使它的参数良性(benign), 和/或;
   * 使这个对象良性(benign)。

验证函数允许这些数据被安全地传递到
危险函数。

以下是关于允许在验证函数表格中定义函数不同方面的列的说明： 

* '启用的' 列可以用来为 BugDetective 分析暂时禁用一些
  定义的函数。

* '完全修饰的类型名称' 列必须填写声明此函数的完全修饰的
  类型名称。 如果您希望描述声明在任何类型或命名空间的函数，
  或者声明在任何类型或命名空间外部的全局函数，使用 '*' 通配符。

* '函数名称' 列应该包含描述的函数的名称。

* '+ 子类中的定义' 列用于表明当前行是否适用于包含
  名称定义在给定类的子类中的函数。 请注意，这个适用于
  实例和非实例的函数。
  
其他列允许描述哪些数据会被给定函数所影响：

* '"此" 对象是已验证的' 列用于指定该函数清除在其上
  调用的对象。

* '返回已验证的数据' 列用于指定该函数清除它的返回值。

* '已验证参数的序号 (从 1 开始)' 列用于指定
  该函数清除它的一些参数。 使用逗号分隔参数列表的索引
  或者使用 '*' 来指定所有受影响的参数。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include &lt;stdio.h&gt;

int example(int array[100])
{
	int i;
	scanf("%d", &amp;i);
	return array[i]; // 违规 ("i" 是一个未知值可能 &lt; 0 或 &gt;= 100)
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

#include &lt;stdio.h&gt;

int example(int array[100])
{
	int i;
	scanf("%d", &amp;i);
	if (i &lt; 0 || i &gt;= 100) {
		return -1; // wrong input
	}
	return array[i]; // NO VIOLATION
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-131
<A HREF="http://cwe.mitre.org/top25/#CWE-131">http://cwe.mitre.org/top25/#CWE-131</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-SECURITY-INTOVERF</key>
<configkey>BD-SECURITY-INTOVERF</configkey>
<name><![CDATA[ 防止来自脏数据的整数溢出/下溢 [BD-SECURITY-INTOVERF] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
防止来自脏数据的整数溢出/下溢 [BD-SECURITY-INTOVERF-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测如下情况，未经验证的输入（受污染数据）
 被用在可能导致数字溢出(当一个算术操作的数学结果
大于操作结果类型所能表示的最大值时)或者下溢 
(当一个算术操作的数学结果小于操作结果类型所能
表示的最小值时)的算术操作中并且后面在危险的操作
中使用。

因为溢出在许多情况下是可以预期的， 这条规则通过只有当
能够导致溢出的值在后面用于下列危险情况之一时才报告
一个违规来尽量避免误报：

 - 在内存分配操作中作为内存缓冲区大小 (溢出可能导致分配
   一个巨大的内存块，并且可能拒绝服务)

 - 在一个循环条件中 (溢出可能导致一个无限循环从而拒绝服务)

 - 在指针的算术运算中 (可能导致在非法地址访问内存从而出现
   未定义的行为， 包括应用程序崩溃)


来自于下面数据源的数据被认为是被污染的:

   * main() 函数的参数
   * 网络

受污染数据其他的来源可以通过参数化这条规则来定义。
有关详细信息， 请参见 “参数” 部分。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.3


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
整数溢出是一个严重的安全威胁，因为它可以被用来导致应用程序崩溃
和拒绝服务。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
这条规则可以被参数化，以便来自下列数据源的数据被认为是受污染的
(除了前面在 “说明” 部分列出的那些之外):

   * 文件
   * 管道
   * 面向流式的 API (std::istream, 来自 MFC 的 CArchive 和 CFile)
   * 低层次的输入 (Windows API, POSIX)
   * 控制台
   * 环境变量

这条规则可以使用一列验证函数来参数化。
任何验证函数可以被定义为:
   * 返回良性(benign)数据, 和/或;
   * 使它的参数良性(benign), 和/或;
   * 使这个对象良性(benign)。

验证函数允许这些数据被安全地传递到
危险函数。

以下是关于允许在验证函数表格中定义函数不同方面的列的说明： 

* '启用的' 列可以用来为 BugDetective 分析暂时禁用一些
  定义的函数。

* '完全修饰的类型名称' 列必须填写声明此函数的完全修饰的
  类型名称。 如果您希望描述声明在任何类型或命名空间的函数，
  或者声明在任何类型或命名空间外部的全局函数，使用 '*' 通配符。

* '函数名称' 列应该包含描述的函数的名称。

* '+ 子类中的定义' 列用于表明当前行是否适用于包含
  名称定义在给定类的子类中的函数。 请注意，这个适用于
  实例和非实例的函数。
  
其他列允许描述哪些数据会被给定函数所影响：

* '"此" 对象是已验证的' 列用于指定该函数清除在其上
  调用的对象。

* '返回已验证的数据' 列用于指定该函数清除它的返回值。

* '已验证参数的序号 (从 1 开始)' 列用于指定
  该函数清除它的一些参数。使用逗号分隔参数列表的索引
  或者使用 '*' 来指定所有受影响的参数。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#define BUFFER_SIZE 64
char buffer[BUFFER_SIZE];

#define MAX_LEN 1000000L

char decode(char c)
{
	/* Decode character */
	return c;
}

char* readMessage(int socket, char *header, int len)
{
	int i, header_len;
	long msg_len, total_len;
	char *msg;

	recv(socket, buffer, BUFFER_SIZE, MSG_NOSIGNAL);
	msg_len = atol(buffer);
	header_len = strlen(header);
	total_len = header_len;
	total_len += msg_len;

	msg = (char*)malloc(total_len); /* 违规, 溢出值的使用 */
	if (!msg) {
		return 0;
	}

	strcpy(msg, header);

	recv(socket, msg + msg_len, msg_len, MSG_NOSIGNAL);

	for (i = header_len; i &lt; total_len; i++) { /* 违规, 溢出值的使用 */
		msg[i] = decode(msg[i]);
	}
	return msg;
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#define BUFFER_SIZE 64
char buffer[BUFFER_SIZE];

#define MAX_LEN 1000000L

char decode(char c)
{
	/* Decode character */
	return c;
}

char* readMessage(int socket, char *header, int len)
{
	int i, header_len;
	long msg_len, total_len;
	char *msg;

	recv(socket, buffer, BUFFER_SIZE, MSG_NOSIGNAL);
	msg_len = atol(buffer);
	header_len = strlen(header);
	total_len = header_len;
	total_len += msg_len;

	if ((total_len &lt; 0) || (total_len &gt; MAX_LEN)) { /* check that total_len is within an acceptable range */
		return 0;
	}

	msg = (char*)malloc(total_len); /* NO VIOLATION */
	if (!msg) {
		return 0;
	}

	strcpy(msg, header);

	recv(socket, msg + msg_len, msg_len, MSG_NOSIGNAL);

	for (i = header_len; i &lt; total_len; i++) { /* NO VIOLATION */
		msg[i] = decode(msg[i]);
	}
	return msg;
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Integer_overflow">http://www.owasp.org/index.php/Integer_overflow</A>

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-190
<A HREF="http://cwe.mitre.org/top25/#CWE-190">http://cwe.mitre.org/top25/#CWE-190</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-SECURITY-OVERFRD</key>
<configkey>BD-SECURITY-OVERFRD</configkey>
<name><![CDATA[ 避免缓冲区读取受污染数据溢出 [BD-SECURITY-OVERFRD] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免缓冲区读取受污染数据溢出 [BD-SECURITY-OVERFRD-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测当代码读取缓冲区并且读操作能够
超越缓冲区边界的情况。

具体来说，  如果一个 'size' 值传递给一个函数，而该函数读取来自于
一个能够返回恶意数据的受污染函数(例如, 用户输入)的缓冲区，则会
报告一个违例， 但是不检查非负 (适用于有符号（ signed ）类型) 并且
不大于相应数组的大小的值。

来自于下面数据源的数据被认为是被污染的:

   * main() 函数的参数
   * 网络

受污染数据其他的来源可以通过参数化这条规则来定义。
有关详细信息， 请参见 “参数” 部分。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
缓冲区溢出的可能性是一个严重的安全威胁。
如果应用程序有这种漏洞， 它可以被用来执行
任意代码，并取得应用程序的完全控制。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
这条规则可以被参数化，以便来自下列数据源的数据被认为是受污染的
(除了前面在 “说明” 部分列出的那些之外):

   * 文件
   * 管道
   * 面向流式的 API (std::istream, 来自 MFC 的 CArchive 和 CFile)
   * 低层次的输入 (Windows API, POSIX)
   * 控制台
   * 环境变量

这条规则可以使用一列验证函数来参数化。
任何验证函数可以被定义为:
   * 返回良性(benign)数据, 和/或;
   * 使它的参数良性(benign), 和/或;
   * 使这个对象良性(benign)。

验证函数允许这些数据被安全地传递到
危险函数。

以下是关于允许在验证函数表格中定义函数不同方面的列的说明： 

* '启用的' 列可以用来为 BugDetective 分析暂时禁用一些
  定义的函数。

* '完全修饰的类型名称' 列必须填写声明此函数的完全修饰的
  类型名称。 如果您希望描述声明在任何类型或命名空间的函数，
  或者声明在任何类型或命名空间外部的全局函数，使用 '*' 通配符。

* '函数名称' 列应该包含描述的函数的名称。

* '+ 子类中的定义' 列用于表明当前行是否适用于包含
  名称定义在给定类的子类中的函数。 请注意，这个适用于
  实例和非实例的函数。
  
其他列允许描述哪些数据会被给定函数所影响：

* '"此" 对象是已验证的' 列用于指定该函数清除在其上
  调用的对象。

* '返回已验证的数据' 列用于指定该函数清除它的返回值。

* '已验证参数的序号 (从 1 开始)' 列用于指定
  该函数清除它的一些参数。 使用逗号分隔参数列表的索引
  或者使用 '*' 来指定所有受影响的参数。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void example(int src[100], int dest[100])
{
	int size;
	scanf("%d", &amp;size);
	memcpy(dest, src, size); // 违规 ("size" 是一个任意的值可能 &lt; 0 或 &gt; 100)
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void example(int src[100], int dest[100])
{
	int size;
	scanf("%d", &amp;size);
	if (size &gt;= 0 &amp;&amp; size &lt;= 100) {
		memcpy(dest, src, size); // NO VIOLATION
	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-131
<A HREF="http://cwe.mitre.org/top25/#CWE-131">http://cwe.mitre.org/top25/#CWE-131</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-SECURITY-OVERFWR</key>
<configkey>BD-SECURITY-OVERFWR</configkey>
<name><![CDATA[ 避免来自受污染数据的缓冲区写溢出 [BD-SECURITY-OVERFWR] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免来自受污染数据的缓冲区写溢出 [BD-SECURITY-OVERFWR-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测当代码写入缓冲区并且写操作能够
超越缓冲区边界的情况。

具体来说，  如果一个 'size' 值传递给一个函数，而该函数写入到来自于
一个能够返回恶意数据的受污染函数(例如, 用户输入)的缓冲区，则会
报告一个违例， 但是不检查非负 (适用于有符号（ signed ）类型) 并且
不大于相应数组的大小的值。

来自于下面数据源的数据被认为是被污染的:

   * main() 函数的参数
   * 网络

受污染数据其他的来源可以通过参数化这条规则来定义。
有关详细信息， 请参见 “参数” 部分。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.1


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
缓冲区溢出的可能性是一个严重的安全威胁。
如果应用程序有这种漏洞， 它可以被用来执行
任意代码，并取得应用程序的完全控制。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
这条规则可以被参数化，以便来自下列数据源的数据被认为是受污染的
(除了前面在 “说明” 部分列出的那些之外):

   * 文件
   * 管道
   * 面向流式的 API (std::istream, 来自 MFC 的 CArchive 和 CFile)
   * 低层次的输入 (Windows API, POSIX)
   * 控制台
   * 环境变量

这条规则可以使用一列验证函数来参数化。
任何验证函数可以被定义为:
   * 返回良性(benign)数据, 和/或;
   * 使它的参数良性(benign), 和/或;
   * 使这个对象良性(benign)。

验证函数允许这些数据被安全地传递到
危险函数。

以下是关于允许在验证函数表格中定义函数不同方面的列的说明： 

* '启用的' 列可以用来为 BugDetective 分析暂时禁用一些
  定义的函数。

* '完全修饰的类型名称' 列必须填写声明此函数的完全修饰的
  类型名称。 如果您希望描述声明在任何类型或命名空间的函数，
  或者声明在任何类型或命名空间外部的全局函数，使用 '*' 通配符。

* '函数名称' 列应该包含描述的函数的名称。

* '+ 子类中的定义' 列用于表明当前行是否适用于包含
  名称定义在给定类的子类中的函数。 请注意，这个适用于
  实例和非实例的函数。
  
其他列允许描述哪些数据会被给定函数所影响：

* '"此" 对象是已验证的' 列用于指定该函数清除在其上
  调用的对象。

* '返回已验证的数据' 列用于指定该函数清除它的返回值。

* '已验证参数的序号 (从 1 开始)' 列用于指定
  该函数清除它的一些参数。 使用逗号分隔参数列表的索引
  或者使用 '*' 来指定所有受影响的参数。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void example(int src[100], int dest[100])
{
	int size;
	scanf("%d", &amp;size);
	memcpy(dest, src, size); // 违规 ("size" 是一个任意的值可能 &lt; 0 或 &gt; 100)
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void example(int src[100], int dest[100])
{
	int size;
	scanf("%d", &amp;size);
	if (size &gt;= 0 &amp;&amp; size &lt;= 100) {
		memcpy(dest, src, size); // NO VIOLATION
	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-120
<A HREF="http://cwe.mitre.org/top25/#CWE-120">http://cwe.mitre.org/top25/#CWE-120</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-SECURITY-TDCMD</key>
<configkey>BD-SECURITY-TDCMD</configkey>
<name><![CDATA[ 防止命令注入 [BD-SECURITY-TDCMD] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
防止命令注入 [BD-SECURITY-TDCMD-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测当直接来自于最终用户的数据可以
影响执行代码的情况 (例如， 来自于将要执行
的文件名称)。

这条规则支持来自于标准 C 库和 POSIX 的过程执行函数。
例如， 它认为广泛地使用 system() 函数和 exec 函数集
是很危险的。

来自于下面数据源的数据被认为是被污染的:

   * main() 函数的参数
   * 网络

受污染数据其他的来源可以通过参数化这条规则来定义。
有关详细信息， 请参见 “参数” 部分。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
执行 'A2 - 注入缺陷', #2 来自于 OWASP 2007 列表的前 10 名.

如果在执行的文件名称中出现一些受污染数据而没有认证，
它可能允许执行会破坏系统的自定义恶意代码。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>

这条规则可以被参数化，以便来自下列数据源的数据被认为是受污染的
(除了前面在 “说明” 部分列出的那些之外):

   * 文件
   * 管道
   * 面向流式的 API (std::istream, 来自 MFC 的 CArchive 和 CFile)
   * 低层次的输入 (Windows API, POSIX)
   * 控制台
   * 环境变量

这条规则可以使用一列验证函数来参数化。
任何验证函数可以被定义为:
   * 返回良性(benign)数据, 和/或;
   * 使它的参数良性(benign), 和/或;
   * 使这个对象良性(benign)。

验证函数允许这些数据被安全地传递到
危险函数。

以下是关于允许在验证函数表格中定义函数不同方面的列的说明： 

* '启用的' 列可以用来为 BugDetective 分析暂时禁用一些
  定义的函数。

* '完全修饰的类型名称' 列必须填写声明此函数的完全修饰的
  类型名称。 如果您希望描述声明在任何类型或命名空间的函数，
  或者声明在任何类型或命名空间外部的全局函数，使用 '*' 通配符。

* '函数名称' 列应该包含描述的函数的名称。

* '+ 子类中的定义' 列用于表明当前行是否适用于包含
  名称定义在给定类的子类中的函数。 请注意，这个适用于
  实例和非实例的函数。
  
其他列允许描述哪些数据会被给定函数所影响：

* '"此" 对象是已验证的' 列用于指定该函数清除在其上
  调用的对象。

* '返回已验证的数据' 列用于指定该函数清除它的返回值。

* '已验证参数的序号 (从 1 开始)' 列用于指定
  该函数清除它的一些参数。 使用逗号分隔参数列表的索引
  或者使用 '*' 来指定所有受影响的参数。

此外， 这里有一个选项用于确定数值数据是否应该被视为受污染数据。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

考虑到网络应用程序从套接字(socket)接受一些用户定义的参数，
并且使用这些参数启动一些进程。 在这种情况下， 放置未认证的用户
数据到一个执行的请求中，可能有一些危险的后果。 例如， 用户
也许能够在服务器上使用应用程序的特权运行自定义的代码。

例如， 如果命令按照以下方式执行，在请求中提供 " &amp; shutdown -s -f -d p" 作为
一个 command_parameter 值将会导致服务器关机：

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

void commandInjection(int socket)
{
	char params[200], command[250];
	recv(socket, params, 200, 0); /* Receiving command parameters from a socket */
	strcpy(command, "process_data -params ");
	strcat(command, params);
	system(command); // Command injection
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
在危险函数中使用受污染数据之前验证它，
可以移除命令注入的风险：

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

char* validate(char*); /* properly implement validation function */

void commandInjection(int socket)
{
	char params[200], command[250];
	recv(socket, params, 200, 0); /* Receiving command parameters from a socket */
	strcpy(command, "process_data -params ");
	strcat(command, validate(params));
	system(command); /* OK, protected from command injection provided that validate() is implemented properly */
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

OWASP Top 10 2007 (A2 - Injection Flaws):
<A HREF="http://www.owasp.org/index.php/Top_10_2007">http://www.owasp.org/index.php/Top_10_2007</A>

Web Application Security Consortium:
<A HREF="http://www.webappsec.org/projects/threat/classes/os_commanding.shtml">http://www.webappsec.org/projects/threat/classes/os_commanding.shtml</A>

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-78
<A HREF="http://cwe.mitre.org/top25/#CWE-78">http://cwe.mitre.org/top25/#CWE-78</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-SECURITY-TDFNAMES</key>
<configkey>BD-SECURITY-TDFNAMES</configkey>
<name><![CDATA[ 防止文件名注入 [BD-SECURITY-TDFNAMES] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
防止文件名注入 [BD-SECURITY-TDFNAMES-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测当在文件处理函数中可能使用受污染数据作为文件名
或路径时的情况， 这可能会引起文件名注入。 此规则支持来自于
标准 C 和 C++ 函数库以及 POSIX 定义的文件处理函数。

来自于下面数据源的数据被认为是被污染的:

   * main() 函数的参数
   * 网络

受污染数据其他的来源可以通过参数化这条规则来定义。
有关详细信息， 请参见 “参数” 部分。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
如果未验证的数据出现在文件名中， 那么攻击者就能够获得
访问系统上任何文件的权限， 提供特殊准备的恶意数据。

执行这条规则将有助于保护系统免于 OWASP 2007 前 10 名
应用程序漏洞的 "A3 - 恶意文件执行"。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>

这条规则可以被参数化，以便来自下列数据源的数据被认为是受污染的
(除了前面在 “说明” 部分列出的那些之外):

   * 文件
   * 管道
   * 面向流式的 API (std::istream, 来自 MFC 的 CArchive 和 CFile)
   * 低层次的输入 (Windows API, POSIX)
   * 控制台
   * 环境变量

这条规则可以使用一列验证函数来参数化。
任何验证函数可以被定义为:
   * 返回良性(benign)数据, 和/或;
   * 使它的参数良性(benign), 和/或;
   * 使这个对象良性(benign)。

验证函数允许这些数据被安全地传递到
危险函数。

以下是关于允许在验证函数表格中定义函数不同方面的列的说明： 

* '启用的' 列可以用来为 BugDetective 分析暂时禁用一些
  定义的函数。

* '完全修饰的类型名称' 列必须填写声明此函数的完全修饰的
  类型名称。 如果您希望描述声明在任何类型或命名空间的函数，
  或者声明在任何类型或命名空间外部的全局函数，使用 '*' 通配符。

* '函数名称' 列应该包含描述的函数的名称。

* '+ 子类中的定义' 列用于表明当前行是否适用于包含
  名称定义在给定类的子类中的函数。 请注意，这个适用于
  实例和非实例的函数。
  
其他列允许描述哪些数据会被给定函数所影响：

* '"此" 对象是已验证的' 列用于指定该函数清除在其上
  调用的对象。

* '返回已验证的数据' 列用于指定该函数清除它的返回值。

* '已验证参数的序号 (从 1 开始)' 列用于指定
  该函数清除它的一些参数。 使用逗号分隔参数列表的索引
  或者使用 '*' 来指定所有受影响的参数。

此外， 这里有一个选项用于确定数值数据是否应该被视为受污染数据。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
考虑到一个应用程序在服务器上的文件中存储一些特定用户的数据 (例如，
包含用户故事的库) 使用用户给予的故事名称作为文件名。

下面的代码可以被用来创建一个特定的文件并添加
故事内容：

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

void saveStory(int socket)
{
    char storyName[50];
    char storyContent[200];

    /* Receive story from socket */
    recv(socket, storyName, 50, 0);
    recv(socket, storyContent, 200, 0);
    FILE* f = fopen(storyName, "w"); /* File name injection */
    fprintf(f, "%s", storyContent);
    fclose(f);
}

在这种情况下， 如果攻击者提供 "c:\\windows\\system.ini" 作为故事名称
和一些特别准备的配置文件内容作为故事的内容，
那么在保存这个 "故事" 之后， 系统关键的 .ini 文件可能被修改并且
一些危险的内容可以保存在这里。


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
在使用之前验证数据：

	void saveStory(int socket)
	{
		/* ... */
		recv(socket, storyName, 50, MSG_WAITALL);
		storyName = validate(storyName);

		recv(socket, storyContent, 200, MSG_WAITALL);
		storyContent = validate(storyContent);
		/* ... */
	}

	char* validate(char*)
	{
	   // verify the input so that the file can only be stored in the current directory only,
	   // not under a user defined path
	}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

OWASP Top 10 2007 (A3 - Malicious File Execution):
<A HREF="http://www.owasp.org/index.php/Top_10_2007-A3">http://www.owasp.org/index.php/Top_10_2007-A3</A>

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-22
<A HREF="http://cwe.mitre.org/top25/#CWE-22">http://cwe.mitre.org/top25/#CWE-22</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-SECURITY-TDSQL</key>
<configkey>BD-SECURITY-TDSQL</configkey>
<name><![CDATA[ 防止 SQL 注入 [BD-SECURITY-TDSQL] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
防止 SQL 注入 [BD-SECURITY-TDSQL-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测当受污染数据到达执行或准备 SQL 查询， 检索，
连接等等的函数时可能引起 SQL 注入的情况。

当应用程序使用用户所提供的数据 (或一些未经验证的数据源)
来构建 SQL 查询并且在其使用之前不验证/确认这些数据时，
对于一个攻击者， 他很可能按照开发者不希望的方式改变 
SQL 语句。因此， 攻击者可以完全控制数据库甚至在系统上
执行命令。

这条规则支持以下数据库 API: ODBC, ADO, OLE DB.

来自于下面数据源的数据被认为是被污染的:

   * main() 函数的参数
   * 网络

受污染数据其他的来源可以通过参数化这条规则来定义。
有关详细信息， 请参见 “参数” 部分。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
执行 'A2 - 注入缺陷', #2 来自于 OWASP 2007 列表的前 10 名.

如果数据可以出现在 SQL 查询中而没有认证，
恶意用户可以控制数据库。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>

这条规则可以被参数化，以便来自下列数据源的数据被认为是受污染的
(除了前面在 “说明” 部分列出的那些之外):

   * 文件
   * 管道
   * 面向流式的 API (std::istream, 来自 MFC 的 CArchive 和 CFile)
   * 低层次的输入 (Windows API, POSIX)
   * 控制台
   * 环境变量

这条规则可以使用一列验证函数来参数化。
任何验证函数可以被定义为:
   * 返回良性(benign)数据, 和/或;
   * 使它的参数良性(benign), 和/或;
   * 使这个对象良性(benign)。

验证函数允许这些数据被安全地传递到
危险函数。

以下是关于允许在验证函数表格中定义函数不同方面的列的说明： 

* '启用的' 列可以用来为 BugDetective 分析暂时禁用一些
  定义的函数。

* '完全修饰的类型名称' 列必须填写声明此函数的完全修饰的
  类型名称。 如果您希望描述声明在任何类型或命名空间的函数，
  或者声明在任何类型或命名空间外部的全局函数，使用 '*' 通配符。

* '函数名称' 列应该包含描述的函数的名称。

* '+ 子类中的定义' 列用于表明当前行是否适用于包含
  名称定义在给定类的子类中的函数。 请注意，这个适用于
  实例和非实例的函数。
  
其他列允许描述哪些数据会被给定函数所影响：

* '"此" 对象是已验证的' 列用于指定该函数清除在其上
  调用的对象。

* '返回已验证的数据' 列用于指定该函数清除它的返回值。

* '已验证参数的序号 (从 1 开始)' 列用于指定
  该函数清除它的一些参数。 使用逗号分隔参数列表的索引
  或者使用 '*' 来指定所有受影响的参数。

此外， 这里有一个选项用于确定数值数据是否应该被视为受污染数据。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
考虑一个例子，一个应用程序从文件中读取用户名和密码， 
然后为了认证的目的， 试图在数据库中查找该用户信息。
支持这个功能 的代码可能如下所示：

#include &lt;sql.h&gt;
#include &lt;stdio.h&gt;

const int BUFFER_SIZE = 1000;

const char* requestBeginning = "SELECT user_id, user_class, rights FROM users WHERE user_name = '";
const char* requestPassword = "' and password = '";
const char* requestEnding = "'";

extern char* extractUsername(const char*);
extern char* extractPassword(const char*);

extern SQLHSTMT statementHandle;

void handleRequest(FILE *file)
{
	char parametersString[BUFFER_SIZE];
	fread(parametersString, 1, BUFFER_SIZE, file);
    SQLCHAR request[BUFFER_SIZE];
    strcpy(request, requestBeginning);
    strcat(request, extractUsername(parametersString));
    strcat(request, requestPassword);
    strcat(request, extractPassword(parametersString));
    strcat(request, requestEnding);
	SQLExecDirect(statementHandle, request, strlen(request));
}

如果用户输入下面的字符串既作为用户名也作为密码：

' or ''='

那么 SQL 语句如下所示：

SELECT user_id, user_class, rights FROM users WHERE user_name = '' or ''='' and password = '' or ''=''

这将得到所有用户的信息， 因此攻击者将在用户表中作为
第一个认证的用户 -- 尽管他没有提供任何必要的许可
信息。


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
使用 SQLPrepare() 函数和设置通过 SQLBindParameter() 函数获得用户数据
(而不是直接创建一个包括参数值的文字上的查询) 确保保护避免
SQL 注入：

#include &lt;sql.h&gt;
#include &lt;sqltypes.h&gt;
#include &lt;sqlext.h&gt;
#include &lt;stdio.h&gt;

const int BUFFER_SIZE = 1000;

const char* requestString = "SELECT user_id, user_class, rights FROM users WHERE user_name = '?' and password = '?'";

extern char* extractUsername(const char*);
extern char* extractPassword(const char*);

extern SQLHSTMT statementHandle;
SQLINTEGER nameLen = SQL_NTS, passLen = SQL_NTS;


void handleRequest(FILE *file)
{
	char parametersString[BUFFER_SIZE];
	fread(parametersString, 1, BUFFER_SIZE, file);
    
	char *name = extractUsername(parametersString);
    char *pass = extractPassword(parametersString);
	
	SQLBindParameter(statementHandle, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 20, 0, name, 0, &amp;nameLen);
	SQLBindParameter(statementHandle, 2, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 20, 0, pass, 0, &amp;passLen);
	
	SQLPrepare(statementHandle, requestString, SQL_NTS);
	SQLExecute(statementHandle);
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

OWASP Top 10 2007 (A2 - Injection Flaws):
<A HREF="http://www.owasp.org/index.php/Top_10_2007">http://www.owasp.org/index.php/Top_10_2007</A>

Web Application Security Consortium:
<A HREF="http://www.webappsec.org/projects/threat/classes/sql_injection.shtml">http://www.webappsec.org/projects/threat/classes/sql_injection.shtml</A>

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-89
<A HREF="http://cwe.mitre.org/top25/#CWE-89">http://cwe.mitre.org/top25/#CWE-89</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-TRS-DLOCK</key>
<configkey>BD-TRS-DLOCK</configkey>
<name><![CDATA[ 避免双重锁定 [BD-TRS-DLOCK] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免双重锁定 [BD-TRS-DLOCK-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检测在没有中间体释放的情况下一个锁被申请两次。
在嵌套互斥体的情况下这是合法的，但是在正常加锁的情况下，
这是不允许的，而且这是可能会引发死锁的情况。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v9.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
这条规则可以被定制化，以便用来来检测对特定的通用的APIs（在
列表里所支持的APIs）的两次加锁申请，通过提供相应函数的详细
说明，这条规则也可以用来说明来自第三方APIs的多线程函数。要
查看所有支持的APIs，配置这条规则将要查看的APIs，并且定义将
要使用这条规则来查看的来自第三方API的函数，请参考测试配置里
的“BugDetective选项”中的”多线程“子面板。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
防止应用程序死锁


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
这是一个触发违规的示例:

#include &lt;pthread.h&gt;

pthread_mutex_t *mutex;
bool preconditionHolds();

void exclusivelyCompute()
{
    pthread_mutex_lock(mutex);
    if (preconditionHolds()) {
        /* perform some computations */
        exclusivelyCompute(); // VIOLATION: recursive call will cause double locking
    }
    pthread_mutex_unlock(mutex);
}

void run()
{
	mutex = new pthread_mutex_t;
	pthread_mutex_init(mutex, (const pthread_mutexattr_t*)0);
	exclusivelyCompute();
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
这个例子可以通过在不同的函数里来区分加锁和计算来修复。
（但是需要确保的是执行解锁计算的函数只能被执行相应
加锁的函数来调用）：

#include &lt;pthread.h&gt;

pthread_mutex_t *mutex;
bool preconditionHolds();

static void nonexclusivelyCompute()
{
    if (preconditionHolds()) {
        /* perform some computations */
        nonexclusivelyCompute(); // NO VIOLATION: locking is done only once
    }
}

void exclusivelyCompute()
{
    pthread_mutex_lock(mutex);
	nonexclusivelyCompute();
    pthread_mutex_unlock(mutex);
}

void run()
{
	mutex = new pthread_mutex_t;
	pthread_mutex_init(mutex, (const pthread_mutexattr_t*)0);
	exclusivelyCompute();
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-TRS-LOCK</key>
<configkey>BD-TRS-LOCK</configkey>
<name><![CDATA[ 不要抛弃未释放的锁 [BD-TRS-LOCK] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要抛弃未释放的锁 [BD-TRS-LOCK-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则检查在一个应用程序里面一个互斥资源被加锁
但是没有被解锁，这会造成应用程序死锁。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
这条规范可被客制化来检查某些共同 APIs 中的非锁住互斥
体(所支持的 APIs 列表), 它同时也可以指定从第三方的 API
中相关线程功能的多线程函数。
查看支持的 APIs 列表, 和配置这些 APIs 使规范来检查
这些第三方 API 函数定义的线程能被检测,
请参考在测试配置的 "BugDetective 选项" 中 "多线程"
的子面板。

参数"被锁目标可被解锁函数调用级别"允许管理调用分析的深度。
高的参数值可以得到一个更精准的分析，但是速度会慢一些。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
避免应用程序死锁。


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
示例 1. 这个程序会触发一个违规:

#include &lt;pthread.h&gt;

pthread_mutex_t *mutex;
bool preconditionHolds();

void exclusivelyCompute()
{
    pthread_mutex_lock(mutex);
    if (preconditionHolds()) {
        /* perform some computations */
        pthread_mutex_unlock(mutex);
    }
}

示例 2. 为了适当地分析下面程序，
参数"被锁目标可被解锁函数调用级别"应该设置为3或者更高。

#include &lt;pthread.h&gt;

pthread_mutex_t mutex;

void lockLevel1() { pthread_mutex_lock(&amp;mutex); }
void unlockLevel1() { pthread_mutex_unlock(&amp;mutex); }
void lockLevel2() { lockLevel1(); }
void unlockLevel2() { unlockLevel1(); }
void lockLevel3() { lockLevel2(); }
void unlockLevel3() { unlockLevel2(); }

bool preconditionHolds();

void exclusivelyCompute()
{
	lockLevel3();
    if (preconditionHolds()) {
        /* perform some computations */
		unlockLevel3();
    }
}




</PRE>
<STRONG>
修复
</STRONG>
<PRE>
示例 1. 这个例子可以被修复通过在所有分支加上解锁的操作:

#include &lt;pthread.h&gt;

pthread_mutex_t *mutex;
bool preconditionHolds();

void exclusivelyCompute()
{
    pthread_mutex_lock(mutex);
    if (preconditionHolds()) {
        /* perform some computations */
    }
    pthread_mutex_unlock(mutex);
}

示例 2.

#include &lt;pthread.h&gt;

pthread_mutex_t mutex;

void lockLevel1() { pthread_mutex_lock(&amp;mutex); }
void unlockLevel1() { pthread_mutex_unlock(&amp;mutex); }
void lockLevel2() { lockLevel1(); }
void unlockLevel2() { unlockLevel1(); }
void lockLevel3() { lockLevel2(); }
void unlockLevel3() { unlockLevel2(); }

bool preconditionHolds();

void exclusivelyCompute()
{
	lockLevel3();
    if (preconditionHolds()) {
        /* perform some computations */
    }
	unlockLevel3();
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>BD-TRS-TSHL</key>
<configkey>BD-TRS-TSHL</configkey>
<name><![CDATA[ 不要在持有一个锁的同时使用阻塞函数 [BD-TRS-TSHL] ]]></name>
<tag>bd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在持有一个锁的同时使用阻塞函数 [BD-TRS-TSHL-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规范检测是否有函数让线程在某些重要的段落
停止一段时间的执行 (例如 sleep())--因此增加了
线程间不必要的资源争夺.


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
这条规范可被客制化来检查某些共同 APIs 中的非锁住互斥
体(所支持的 APIs 列表), 它同时也可以指定从第三方的 API
中相关线程功能的多线程函数.
查看支持的 APIs 列表, 和配置这些 APIs 使规范来检查
这些第三方 API 函数定义的线程能被检测,
请参考在测试配置的 "BugDetective 选项" 中 "多线程"
的子面板.


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
帮助防止不必要的线程间的资源争夺及
线程缺少.


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
这是一个触发违规的示例:

#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

pthread_mutex_t *mutex;

static void testLock()
{
	pthread_mutex_lock(mutex);
    sleep(10);
    /* do something */
	pthread_mutex_unlock(mutex);
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
移除对 sleep() 的调用可修复:

#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

pthread_mutex_t *mutex;

static void testLock()
{
	pthread_mutex_lock(mutex);
    /* do something */
	pthread_mutex_unlock(mutex);
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CDD-001</key>
<configkey>CDD-001</configkey>
<name><![CDATA[ Avoid duplication of #include directives [CDD-001] ]]></name>
<tag>cdd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid duplication of #include directives [CDD-001-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>


</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CDD-002</key>
<configkey>CDD-002</configkey>
<name><![CDATA[ 避免代码重复 [CDD-002] ]]></name>
<tag>cdd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免代码重复 [CDD-002-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则识别重复的代码。规则在跨越所有被测试代码中查找重复片段，
无论该重复的代码是否出现在同一个文件中。

代码重复性检测的的重点是提供最有用的结果， 
所以执行的分析不再只是简单的文字记号比较。 
这条规则也可以设置其他参数来覆盖针对不同 
类型节点的比较结果。   
重复的代码块的开始和结束位置是通过使用多种
内部规则来计算的，如:  
- 起点只能放在语句的开头
- 终点只能放在语句的结束
- 终点不能离开起点的范围 (例如重复的代码块，无法
  在一个函数体的中间开始却在另一个不同的函数中结束)

例如:

@int foo(int a, int b)
{
    @int r;%
    @if (a &lt; b) { 
        @r = b - a;%
    } else {       
        @r = a - b;%
    }         
    @return r;%
}

@ - 标记重复代码部分可能的起点 
% - 标记重复代码部分可能的终点

 每出现一次就将报告一个违规。
参见: CDD-004


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v9.2

</PRE>
<STRONG>
参数
</STRONG>
<PRE>

此规则可以被参数化，以达到最佳效果。

* 最小重复符号的大小 (默认值是 80) 
  此参数值定义可能被这条规则报告的最小代码片段的大小。
  变量名，字符串和数值文字，关键字，操作符都会被算作一个符号。   
  例如:
   
  if (param1 == 0) {   // 7 个符号
      return a;        // 3 个符号
  }                    // 1 个符号

"忽略 ..." 参数允许可以作为重复代码忽略
和报告的一定的差异:    

* 忽略字符串和字符常量 (默认是关闭的) 
  打开它以忽略字符串常量的差异
     
* 忽略数字量 (默认是关闭的) 
  打开它以忽略数字量的差异
       
* 忽略布尔量 (默认是关闭的) 
  打开它以忽略布尔量的差异
     
* 忽略标识符 (局部/全局变量, 函数名称, ...) (默认是关闭的) 
  打开它以忽略标识符的差异   


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
规则提高可读性和可维护性。简化并减少代码大小。
复制和粘贴代码将增加代码维护的成本，因为每次
需要进行修改时，相同的代码的多个实例将需要
被定位出来然后进行修改。减少或消除重复的代码量
可以防止这个问题。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

参数: 忽略标识符是打开的，最小重复符号的大小设置为 20。

int foo(int a, int b)
{
    int r;
    if (a &lt; b) {      // 重复的代码
        r = b - a;    // 重复的代码
    } else {          // 重复的代码
        r = a - b;    // 重复的代码
    }                 // 重复的代码
    return r;
}

int bar(int p, int q, bool v)
{
    int result;
    if (v) {
        if (p &lt; q) {           // 重复的代码
            result = q - p;    // 重复的代码
        } else {               // 重复的代码
            result = p - q;    // 重复的代码
        }                      // 重复的代码
    } else {
        return p + q;
    }
    return result;
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int a, int b)
{
    int r;
    if (a &lt; b) {      
        r = b - a;  
    } else {          
        r = a - b;    
    }                 
    return r;
}

int bar(int p, int q, bool v)
{
    int result;
    if (v) {
        result = foo(p, q);   // 在这里使用 foo 函数
    } else {
        result =  p + q;
    }
    return result;
}


</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CDD-003</key>
<configkey>CDD-003</configkey>
<name><![CDATA[ 避免字符串常量重复 [CDD-003] ]]></name>
<tag>cdd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免字符串常量重复 [CDD-003-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则识别具有重复字符串文字的代码。规则在跨越所有
被测试代码中查找重复的字符串文字，无论该重复的文字是否
出现在同一个文件中。 每出现一次就将报告一个违规。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v9.2

</PRE>
<STRONG>
参数
</STRONG>
<PRE>

此规则可以被参数化，以达到最佳效果。

* 被视为违规的最小出现次数 (默认值是 5) 
  只有在发现最小出现次数时才报告违规
   
* 忽略字符串的长度小于 (默认值是 2)
  所有的字符串文字的大小小于参数值时将不会报告
   
* 忽略匹配指定的正则表达式的字符串常量 
  所有的字符串文字匹配任何定义的正则表达式时将不会报告


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
规则提高可读性和可维护性。
如果字符串文字是反复使用，应该把它存放在一个常量中。
这样对于开发人员更容易改变一个重复的字符串值，他只需要
改变单一的字符串常量，而不是寻找所有的重复的字符串文字
并逐个改变它们。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

const char* foo(int a, int b) 
{
    if (a &gt; 0) {
        return "pass";    // 重复的字符串
    }
    if (b &gt; 0) {
        return "pass";    // 重复的字符串
    }
    if (a &lt; b) {
        return "pass";    // 重复的字符串
    }
    if (a == b) {
        return "pass";    // 重复的字符串
    }
    if (a + b &gt; 0) {
        return "pass";    // 重复的字符串
    }
    return "fail";
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const char* foo(int a, int b) 
{
    const char* pass = "pass";
    if (a &gt; 0) {
        return pass;
    }
    if (b &gt; 0) {
        return pass;
    }
    if (a &lt; b) {
        return pass;
    }
    if (a == b) {
        return pass;
    }
    if (a + b &gt; 0) {
        return pass;
    }
    return "fail";
}


</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CDD-004</key>
<configkey>CDD-004</configkey>
<name><![CDATA[ 避免函数重复 [CDD-004] ]]></name>
<tag>cdd</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免函数重复 [CDD-004-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
这条规则识别重复的函数实现。规则在跨越所有被测试代码中查找重复的实现，
无论该重复的代码是否出现在同一个文件中。 每出现一次就将报告一个违规。
参见: CDD-002


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v9.2

</PRE>
<STRONG>
参数
</STRONG>
<PRE>

此规则可以被参数化，以达到最佳效果。
* 最小重复符号的大小 (默认值是 80) 
  此参数值定义可能被这条规则报告的最小函数的大小。
  变量名，字符串和数值文字，关键字，操作符都会被算作一个符号。   
  例如:
   
  if (param1 == 0) {   // 7 个符号
      return a;        // 3 个符号
  }                    // 1 个符号

"忽略 ..." 参数允许可以作为重复代码忽略
和报告的一定的差异:    

* 忽略字符串和字符常量 (默认是关闭的) 
   打开它以忽略字符串常量的差异   

* 忽略数字量 (默认是关闭的) 
  打开它以忽略数字量的差异     

* 忽略布尔量 (默认是关闭的)
   打开它以忽略布尔量的差异   

* 忽略标识符 (局部/全局变量, 函数名称, ...) (默认是关闭的) 
  打开它以忽略标识符的差异   


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
规则提高可读性和可维护性。简化并减少代码大小。
复制和粘贴代码将增加代码维护的成本，因为每次
需要进行修改时，相同的代码的多个实例将需要
被定位出来然后进行修改。减少或消除重复的代码量
可以防止这个问题。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

参数: 忽略标识符是打开的，最小重复符号的大小设置为 20。

int foo(int a, int b)
{
    int r;            
    if (a &lt; b) {
        r = b - a;
    } else {
        r = a - b;
    }
    return r;
}

int bar(int p, int q)
{
    int result;
    if (p &lt; q) {
        result = q - p;
    } else {
        result = p - q;
    }
    return result;
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

其中一个这些函数可以被删除并且所有对函数的引用
都可以切换到第二个。


</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-01</key>
<configkey>CODSTA-CPP-01</configkey>
<name><![CDATA[ 最好使用头文件 iostream.h 而非 stdio.h [CODSTA-CPP-01] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
最好使用头文件 iostream.h 而非 stdio.h [CODSTA-CPP-01-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则找到stdio.h中所声明函数（如scanf/printf）
同时建议改变这些函数而使用iostream.h提供的函数
（诸如 operator&gt;&gt; and operator&lt;&lt;）。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用stdio.h提供的函数（如scanf/printf）。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
int main( ) {
    printf("%s\n", "Hello World"); // 违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;
int main( ) {
    cout&lt;&lt;"Hello World"&lt;&lt;endl; // OK
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., Chapter: "Shifting from C to C++", Item 2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-02</key>
<configkey>CODSTA-CPP-02</configkey>
<name><![CDATA[ 使赋值操作符返回一个 *this 指向的引用；且其返回类型是指向自身类类型的非 const 引用 [CODSTA-CPP-02] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使赋值操作符返回一个 *this 指向的引用；且其返回类型是指向自身类类型的非 const 引用 [CODSTA-CPP-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规范确保赋值操作符的返回类型是一个指向 
自身类型的非 const 引用或返回一个指向
*this 的引用。 赋值操作符operator= 返
回一个指向 *this 的引用将使你不用知道其
在哪里销毁而允许你声明 operator= 的参数
为一个指向 const 类型的引用，这样会比仅
仅声明为一个引用更安全。 
参见: CODSTA-CPP-21, CODSTA-CPP-24, MRM-04, MRM-37, MRM-40, MRM-47, OOP-27,
          OOP-30, OOP-34



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

 赋值操作符operator= 返回一个指向 *this 的引用将
使你不用知道其在哪里销毁而允许你声
明 operator= 的参数为一个指向 const 类型的引用，
这样会比仅仅声明为一个引用更安全。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( ) { }
    void operator=( A&amp; a ) {         // 违规
        return;
    }
};
class C {
public:
    C( ) { }
    C operator=( C&amp; c ) {            // 违规
        C *cp;
        return *cp;
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A( ) { }
    A&amp; operator=( A&amp; a ) {           // OK
        return *this;
    }
};
class C {
public:
    C( ) { }
    C&amp; operator=( C&amp; c ) {           // OK
        return *this;
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 章节 3, 项 15

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc.,
   章节: "Constructors, Destructors, and Assignment Operators", Item 15

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   章节 4.10 Classes, AV Rule 82

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-03</key>
<configkey>CODSTA-CPP-03</configkey>
<name><![CDATA[ 位操作符，比较操作符，逻辑操作符，逗号操作符应该为 const [CODSTA-CPP-03] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
位操作符，比较操作符，逻辑操作符，逗号操作符应该为 const [CODSTA-CPP-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

位操作符，比较操作符，逻辑操作符， 
逗号操作符应该为const.
参见: CODSTA-CPP-38, CODSTA-CPP-43, CODSTA-CPP-44, 
              MISRA-104, MISRA2004-16_7, OPT-21



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C++ 强大的const性质应该被尽量使用, 
以提供代码行为正确性的附加检查. 
这些操作的语义 "&amp;", "^", "|", "~", "!=", "&lt;=", "&lt;", 
"==", "&gt;=", "&gt;", "!", "&amp;&amp;", "||" ,and ","
假设其不会改变调用对象的内部。
因此，声明其为const是很好的做法。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A&amp; operator^( int x );  // 违规
    A&amp; operator==( int x ); // 违规
    A&amp; operator&amp;&amp;( int x ); // 违规
    A&amp; operator,( int x );  // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A&amp; operator^( int x ) const;  // OK
    A&amp; operator==( int x ) const; // OK
    A&amp; operator&amp;&amp;( int x ) const; // OK
    A&amp; operator,( int x ) const;  // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-04</key>
<configkey>CODSTA-CPP-04</configkey>
<name><![CDATA[ 饰构造函数允许使用 explicit 进行显示转换 [CODSTA-CPP-04] ]]></name>
<tag>codsta</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
饰构造函数允许使用 explicit 进行显示转换 [CODSTA-CPP-04-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

注意用户定义的转换函数。
饰构造函数允许使用 explicit 进行显示转换。
带参数的构造函数能够通过编译器执行显示转换。
这样的访问即便在最好的情况下也可能导致创建
和销毁临时对象， 影响运行， 同时最糟糕的情况是
运行无意义的代码被编译。 而后者，编译时能被检
测的问题被引入到运行时的测试阶段方能检测。
参见： CODSTA-CPP-05



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

一般而言该规则能改善运行时效率和可预见的程序
行为。编译器可能检测到严重的代码缺陷。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( int i ) : _i( i ) {}  // 违规
    virtual ~A( ) {}
private:
    int _i;
};
 
int main( ) {
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* One argument constructors that are not meant for type conversion should
   be declared explicit. Conversions should be performed by conversion 
   functions rather than relying on implicit constructor calls. */

class A {
public:
    explicit A( int i ) : _i( i ) {}  // OK
    virtual ~A( ) {}
private:
    int _i;
};
 
int main( ) {
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   Chapter: "Operators", Item 5

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Class Design and Inheritance", Rule 40

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-05</key>
<configkey>CODSTA-CPP-05</configkey>
<name><![CDATA[ 不要使用用户自定义的转换函数 [CODSTA-CPP-05] ]]></name>
<tag>codsta</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用用户自定义的转换函数 [CODSTA-CPP-05-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

小心使用用户自定义的转换函数。 如果找到用户自定义转换函数，该规则
将给出警告。这样的访问即便在最好的情况下也可能导致创建
和销毁临时对象， 影响运行， 同时最糟糕的情况是
运行无意义的代码被编译。 而后者，编译时能被检
测的问题被引入到运行时的测试阶段方能检测。
参见: CODSTA-CPP-04



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

一般而言该规则能改善运行时效率和可预见的程序
行为。编译器可能检测到严重的代码缺陷。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    operator const char*( ) const;  // 违规
};

void foo(){
	A a;
	const char* ch_ptr = a; // 隐式转换
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    const char* asPointerToConstChar( ) const; // OK
};

void foo(){
	A a;
	const char* ch_ptr = a.asPointerToConstChar(); // 显式转换
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   Chapter: "Operators", Item 5

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Class Design and Inheritance", Rule 40

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 177

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-06</key>
<configkey>CODSTA-CPP-06</configkey>
<name><![CDATA[ 避免从成员函数返回指向类数据的非 const 句柄(指针或引用) [CODSTA-CPP-06] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免从成员函数返回指向类数据的非 const 句柄(指针或引用) [CODSTA-CPP-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“函数返回指向对象的内部数据的句柄
是危险的。 不管句柄是一个指针，一个引用，
还是一个迭代器(iterator)。不论是否被 const 修饰。
也不论成员函数返回句柄本身是否是 const。 
所有关键点是返回一个句柄，
因为一旦这样做，句柄将比对象生命期长 
意味着运行风险” 
如果成员函数返回指向类数据的引用和指针，
该规则报告违规。
参见: CODSTA-CPP-77, OOP-12, OOP-36



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

指向类数据的句柄是:
- 指向成员变量的引用
- 指向成员变量的指针
- 在构造函数中指向数据分配或在析构函数中指向数据释放的指针/引用
静态变量不被视为类数据。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增强封装，帮助 const 成员函数操作 const，
并最大限度地减少了创建悬挂句柄。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test
{
    public:
        Test(int &amp; p) : _i(p)
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        ~Test()
        {
            if (_k) {
                delete _k;
            }
        }
        int* GetI1()
        {
            return &amp;_i; // 违规
        }
        int&amp; GetI2() const
        {
            return _i; // 违规
        }
    protected:
        const int * GetI3() const
        {
            return _k; // 违规
        }
    private:
        int &amp; _i;
        int * _k;
};
const int * ptr = 0;
class Child: public Test
{
    public:
        Child() : Test(z)
        {
        }
        void foo() const
        {
            ptr = GetI3(); // Pointer to internal object saved
        }
    private:
        int z;
};
void bar()
{
    int * i1 = 0;
    {
        Child c;
        i1 = c.GetI1(); // Pointer to internal object saved
    }
    int &amp; i2 = Child().GetI2(); // Reference to internal object saved
    // Now "ptr", "i2" and "i3" are dangling pointers/references
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免返回指向类数据的句柄。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范" Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Class Design and Inheritance", 第 42 条规则

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 5, Item 28

3. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   Chapter: "Classes and Functions: Implementation", Item 29

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-07</key>
<configkey>CODSTA-CPP-07</configkey>
<name><![CDATA[ 后缀增量和减量应该依据其前缀的实际情况实现 [CODSTA-CPP-07] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
后缀增量和减量应该依据其前缀的实际情况实现 [CODSTA-CPP-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"前缀和后缀形式的操作符返回不同的类型。
特别的，前缀形式返回一个引用，后缀形式返回
一个常量对象。 让我们针对前缀和后缀增量操作符
做更深入的观察。除了他们的返回值，同时：
他们将自增。也就是说，他们原本将做自增运算。 
你如何能确定后缀增量运算和前缀增量运算保
持一致？ 你应该保证的是你代码实现功能不随
时间而发生变化， 不同的程序员针对这些代码的
维护或增强，功能还能保持一致吗？ 除非你遵守 
如下代码的设计原则，否则你不能做任何保证。 
原则就是后缀增量和减量应该依据其前缀的实际
情况实现。 你仅仅需要维护前缀版本， 
因为后缀版本将会自动的与其保持一致的行为。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规划预防代码错误发生并增加代码坚固性和灵活性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    explicit A( int i = 0 ) : _i( i ) {}
    ~A( ) {}
    A operator++( )                  // 违规 - return type is not reference
    {
        ++_i;
        return *this;
    }
    A operator++( int )              // 违规 - return type is non const
    {
        A temp = *this;
        ++(*this);
        return temp;
    }
private:
    int _i;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    explicit A( int i = 0 ) : _i( i ) {}
    ~A( ) {}
    A&amp; operator++( ) {              // OK    Prefix  increment operator
        ++_i;
        return *this;
    }
    const A operator++( int ) {   // OK    Postfix increment operator
        A temp = *this;
        ++(*this);
        return temp;
    }
private:
    int _i;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节： "Operators", 项 6

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-08</key>
<configkey>CODSTA-CPP-08</configkey>
<name><![CDATA[ 避免重载 &&, || 或者 , （逗号） [CODSTA-CPP-08] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免重载 &amp;&amp;, || 或者 , （逗号） [CODSTA-CPP-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“内建的 &amp;&amp;, || 或者, （逗号） 会受到编译器的特殊处理。
如果用户重载它们，他们会变成具有特殊语义的普通功能，
并且这是一个肯定会引入隐蔽的缺陷和脆弱性的方式。"
此规则用于检测用户重载运算符 &amp;&amp;, || 或者 ,（逗号）时。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

重载这些操作符将改变编译器读取表达式语义 
的方式，造成不可预知的程序行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( int i ) : _i( i ) {}
    ~A( );

    int value( ) { return _i; }
private:
    int _i;
};

int operator&amp;&amp;( A&amp; lhs, A&amp; rhs ) {              // 违规
    return lhs.value( ) &amp;&amp; rhs.value( );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要重载运算符 &amp;&amp;, || 或者 ,（逗号）。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范” Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Functions and Operators", 第30条规则

2. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: “操作符”， 第7项

3. 联合攻击战斗机， 飞行器， C++ 编码规范
   章节 4.21 操作符, AV 第159条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第5节, 规则5-2-11

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-09</key>
<configkey>CODSTA-CPP-09</configkey>
<name><![CDATA[ 避免使用强制类型转换符 reinterpret_cast [CODSTA-CPP-09] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用强制类型转换符 reinterpret_cast [CODSTA-CPP-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不要试图使用 reinterpret_cast 去强制编译器 
重新解释一个对象的 bits 位为不同类型的对象的 
bits 位。 这种使用方式导致维护代码类型不安全，
 reinterpret_cast 引发的行为可能多种多样。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止数据被重新表示，那样将对代码的 
安全性和稳定性造成重大影响。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A{};
class B{};

void foo( ) {
    A *a;
    B *b = reinterpret_cast&lt;B*&gt;( a );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A{};
class B{};

void foo( ) {
    A *a;
    void *pv = a;
    B *b = static_cast&lt;B*&gt;( pv );      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
章节： "Type Safety", 规则 92

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-10</key>
<configkey>CODSTA-CPP-10</configkey>
<name><![CDATA[ 不要定义包含成员函数的结构体 [CODSTA-CPP-10] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要定义包含成员函数的结构体 [CODSTA-CPP-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

成员函数应该被包含在类中，而不是在结构体中， 因为类 
支持多实例和封装。 结构体同样可以经常声明为 
公共类型 public ： 因此默认的针对一个类的成员和基类 
的访问级别为私有的。 该规则检查你定义的结构体是否 
包含成员函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可读性。 一般成员函数归于类中， 
很多程序员依然按照 C 语言中的
结构体思维进行编码。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct A
{
    public:
        int foo( );     // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
    public:
        int foo( );     // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-11</key>
<configkey>CODSTA-CPP-11</configkey>
<name><![CDATA[ 倾向于使用 C++ 风格的转换 [CODSTA-CPP-11] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
倾向于使用 C++ 风格的转换 [CODSTA-CPP-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查代码中的c风格转换.
"c风格转换的语义依赖于上下文, 
隐藏在单一的符号之后。" 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

c++风格转换比c风格转换更加明确 
并且更加易于定位和阅读.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {
public:
    Base( );
    virtual ~Base( );
};

class Derived : public Base {
public:
    Derived( );
    ~Derived( );
};

void foo( ) {
    Base *pB;
    Derived *pD2 = (Derived *) pB;     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    Base( );
    virtual ~Base( );
};

class Derived : public Base {
public:
    Derived( );
    ~Derived( );
};

void foo( ) {
    Base *pB;
    Derived *pD1 = dynamic_cast&lt;Derived*&gt;( pB );   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   Chapter: "Basics", Item 2

2. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Type Safety", Rule 95

3. 联合攻击战斗机, 飞行器, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 185

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-12</key>
<configkey>CODSTA-CPP-12</configkey>
<name><![CDATA[ 基类和成员变量的类应放在不同的头文件当中 [CODSTA-CPP-12] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
基类和成员变量的类应放在不同的头文件当中 [CODSTA-CPP-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当如下的定义被使用时(在实现文件或者其他头
文件中)， 他们必须被包含在独立的头文件中： 
- 被用作其他类的基类，
- 被用作其他类的成员函数，
参见: CODSTA-CPP-15, CODSTA-CPP-14, CODSTA-CPP-13



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};               // 违规
class B : public A {
    A* a;                 // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// header.h
class A {};               // OK

// source.cpp
#include "header.h"
class B : public A {
    A* a;                 // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 4 Source Code in Files - 4.4 Include Files - Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-13</key>
<configkey>CODSTA-CPP-13</configkey>
<name><![CDATA[ 作为函数返回类型的类应该放在单独的头文件中 [CODSTA-CPP-13] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
作为函数返回类型的类应该放在单独的头文件中 [CODSTA-CPP-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当如下的定义被使用时(在实现文件或者其他头
文件中)， 他们必须被包含在独立的头文件中： 
- 被用作返回类型的类
参见： CODSTA-CPP-15, CODSTA-CPP-14, CODSTA-CPP-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

改进代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
A* moo( );               // 违规
class B {
    A* foo( );           // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// header.h
class A {};

// source.cpp
#include "header.h"
A* moo( );               // OK
class B {
    A* foo( );           // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 4 Source Code in Files - 4.4 Include Files - Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-14</key>
<configkey>CODSTA-CPP-14</configkey>
<name><![CDATA[ 在函数原形中作为入口参数类型的类应该放在单独的头文件中 [CODSTA-CPP-14] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数原形中作为入口参数类型的类应该放在单独的头文件中 [CODSTA-CPP-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当如下的定义被使用时(在实现文件或者其他头
文件中)， 他们必须被包含在独立的头文件中： 
- 被用作函数或成员函数原型参 
  数的类。
参见： CODSTA-CPP-15, CODSTA-CPP-13, CODSTA-CPP-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
void moo( A* a );        // 违规
class B {
    void foo( A* a );    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// header.h
class A {};

// source.cpp
#include "header.h"
void moo( A* a );        // OK
class B {
    void foo( A* a );    // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 4 Source Code in Files - 4.4 Include Files - Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-15</key>
<configkey>CODSTA-CPP-15</configkey>
<name><![CDATA[ 使用在内联成员函数内部的函数应该放在单独的头文件中 [CODSTA-CPP-15] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用在内联成员函数内部的函数应该放在单独的头文件中 [CODSTA-CPP-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当如下的定义被使用时(在实现文件或者其他头
文件中)， 他们必须被包含在独立的头文件中： 
- 在内联函数中用作函数或成员函数的函数声明 
  应该放在单独的头文件中。"
参见： CODSTA-CPP-14, CODSTA-CPP-13, CODSTA-CPP-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

改善代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void moo( );
class A 
{
    inline void foo( )
    {
        moo( );             // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// header.h
void moo( );

// source.cpp
#include "header.h"
class A 
{
    inline void foo( )
    {
        moo( );             // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 4 Source Code in Files - 4.4 Include Files - Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-16</key>
<configkey>CODSTA-CPP-16</configkey>
<name><![CDATA[ 当两个操作符作用相反的时候(例如 == 和 !=)，两个都应该定义 [CODSTA-CPP-16] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当两个操作符作用相反的时候(例如 == 和 !=)，两个都应该定义 [CODSTA-CPP-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当类的对象通过相应操作符与另一个类进行 
运算时，同样需要实现其针对该类相对应的操作符。 
一个很好的例子是操作符 ==，其相反操作符是 !=， 
当操作符 == 被定义时，!= 操作符同样需要被定义。"

该规划预防：
- '==' 操作符没有 '!=' 操作符
- '&lt;=' 操作符没有 '&gt;=' 操作符
- '&lt;' 操作符没有 '&gt;' 操作符
- '++' 操作符没有 '--' 操作符
- '+' 操作符没有 '-' 操作符
- '&lt;&lt;' 操作符没有 '&gt;&gt;' 操作符
- '&amp;&amp;' 操作符没有 '||' 操作符



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范可提高代码可读性和代码可维护性并 
防止误解重载操作符的含义。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C { // 违规
public:
    bool operator&lt;=( C&amp; c );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C { // OK
public:
    bool operator&lt;=( C&amp; c );
    bool operator&gt;=( C&amp; c );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 7 Classes - 7.7 Operator Overloading - Rec. 36

2. 联合攻击战斗机，飞行器， C++ 编码规范
   章节 4.10 Classes, AV 规则 85

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-17</key>
<configkey>CODSTA-CPP-17</configkey>
<name><![CDATA[ 不要使用 'struct' 关键字来声明 C++ 的变量 [CODSTA-CPP-17] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 'struct' 关键字来声明 C++ 的变量 [CODSTA-CPP-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查，是否你的c++代码使用struct关键字来声明
一个变量. 这条规则只作用在c++语言上。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

不使用struct关键字来声明变量会改进代码的可阅读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct Position_t {};
struct Position_t Pos;  // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct Position_t {};
Position_t Pos;         // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-18</key>
<configkey>CODSTA-CPP-18</configkey>
<name><![CDATA[ 将全局变量，常量，枚举类型和自定义类型变量(typedefs)封装在一个类中 [CODSTA-CPP-18] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
将全局变量，常量，枚举类型和自定义类型变量(typedefs)封装在一个类中 [CODSTA-CPP-18-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在一个类中封装全局变量和常量，枚举类型，typedefs
类型。 类中的静态变量应该使用全局变量，常量，枚举
类型和typedefs等类型进行替代。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范增强代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Days {yesterday};  // 违规
typedef int myint;      // 违规
myint glob;             // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    enum Days {yesterday};  // OK
    typedef int MyInt;      // OK
    static MyInt glob;      // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 5 Assigning Names - Rec. 19

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   章节 4.26 Memory Allocation, AV 规则 207

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-19</key>
<configkey>CODSTA-CPP-19</configkey>
<name><![CDATA[ 至少声明一个构造函数以防止编译器提供一个公共的构造函数 [CODSTA-CPP-19] ]]></name>
<tag>codsta</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
至少声明一个构造函数以防止编译器提供一个公共的构造函数 [CODSTA-CPP-19-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果类中没有实现构造函数，编译器将
提供一个默认的构造函数。 该规则确保
类中至少提供一个构造函数。
参见: MRM-05, MRM-38, MRM-40, MRM-48, OOP-27, OOP-30, OOP-34



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可读性。当你遵从该规范，将使类进行显示的初始化
从而预防编译器默认的初始化导致不当，
尤其是指针成员。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {    // OK
    A(){}
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., 章节 1, 项 5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-20</key>
<configkey>CODSTA-CPP-20</configkey>
<name><![CDATA[ 如果想支持混合模式的操作, 操作符应该是非成员函数 [CODSTA-CPP-20] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果想支持混合模式的操作, 操作符应该是非成员函数 [CODSTA-CPP-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规范检查双参数的操作符以确保他们能够
符合类的类型。 你可能更乐意支持算术操
作符如加，减，乘等，但你无法保证你是
否通过成员函数或者非成员函数实现它们。 
如果类包含一个转换操作符或者允许隐式
转换的构造函数，则你应该将操作符定义
为全局的，因为这样能使这些操作可转换。
 操作符 &gt;&gt; 和操作符 &lt;&lt; 不要作为成员函数。
如果 f 是操作符 &gt;&gt; 或操作符 &lt;&lt;, 将 f 设为
非成员函数目的是使访问该操作符的语法更
自然；早期我们关心隐式类型转换。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

区分那些更趋向于面向对象代码的函数行
为对于我们使用和维护他们更直观。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class A{
public:
    A(int x=0);
    A&amp; operator+(A&amp; a); // 违规 (could be global)
};

class B{
public:
    istream&amp; operator&gt;&gt;(istream&amp; input);                   // 违规
                                                           // should be global
    ostream&amp; operator&lt;&lt;(ostream&amp; output) { as = "aaaa"; }; // 违规
                                                           // should be friend
private: 
    char* as;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A{
public:
    A(int x=0);
};

A&amp; operator+(A&amp; a, A&amp; b); // OK

class B{
public:
    friend ostream&amp; operator&lt;&lt;(ostream&amp; output, B&amp; out);
private:
    char* as;
};

istream&amp; operator&gt;&gt;(istream&amp; input,const B&amp; in);   // OK
ostream&amp; operator&lt;&lt;(ostream&amp; output, B&amp; out) {     // OK
    out.as = "aaaa";
    return output; 
}; 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., Chapter: "Classes and Functions:
   Design and Declaration", Item 19

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-21</key>
<configkey>CODSTA-CPP-21</configkey>
<name><![CDATA[ 赋值操作符必须返回常引用 [CODSTA-CPP-21] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
赋值操作符必须返回常引用 [CODSTA-CPP-21-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"赋值操作符 '$name' 应该返回一个常量引用给赋
值对象。"
参见: CODSTA-CPP-02, CODSTA-CPP-24, MRM-04, MRM-37, MRM-40, MRM-47, OOP-27,
          OOP-30, OOP-34



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规范已经过时因为新的规范 (Herb Sutter,Andrei
Alexandrescu, "C++ Coding Standards," Addison-Wesley, (C) 2005 Pearson
Education, Inc. Chapter: "Construction, Destruction, and Copying", Rule 55 )
这个新规划为： CODSTA-CPP-24 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范提高代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class MyClass {
public:
    void operator=( const MyClass&amp; );   // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass {
public:
    const MyClass&amp; operator=( const MyClass&amp; ); // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
from: 7 Classes - 7.6 Assignment Operators - Rec. 34

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-22</key>
<configkey>CODSTA-CPP-22</configkey>
<name><![CDATA[ 最好使用非成员非友元函数(non-member non-friend)替代成员函数 [CODSTA-CPP-22] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
最好使用非成员非友元函数(non-member non-friend)替代成员函数 [CODSTA-CPP-22-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"非成员方法在很多情况下都优于成员函数。
成员函数在封装性方面优于非成员函数。
此外，提供非成员函数能够提高封装的灵活性， 
相关功能实现上，可以减少编译依赖并提高 
其扩展性。
友元函数与类的其他函数一样对于类的私有
成员具备相同的访问权限，因此对于封装具
有相同的影响。 从封装的角度看， 并非在
成员和非成员函数间选择，而是在成员和非
成员非友元函数间选择。"
该规范将报告访问公共函数而没有访问私
有和保护成员函数的成员函数违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规划增强代码的灵活性和安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class WebBrowser {
public:
    void clearCache();
    void clearHistory();
    void removeCookies();
    void clearEverything();          // 违规
};

void WebBrowser::clearEverything()
{
    clearCache();
    clearHistory();
    removeCookies();
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class WebBrowser {
public:
    void clearCache();
    void clearHistory();
    void removeCookies();
};

void clearEverything(WebBrowser&amp; wb)  // OK
{
    wb.clearCache();
    wb.clearHistory();
    wb.removeCookies();
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 4, Item 23

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-23</key>
<configkey>CODSTA-CPP-23</configkey>
<name><![CDATA[ 每当一个全局函数被引用时，使用::作用域运算符 [CODSTA-CPP-23] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每当一个全局函数被引用时，使用::作用域运算符 [CODSTA-CPP-23-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

无论任何时候使用全局函数，使用 :: 操作符。 
该规划检查你是否使用操作符 :: 当使用全局函 
数时。使用 :: 操作符将使其更易于决定哪个变 
量被使用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可读性和可维护性。 使用 :: 操作符帮助维护 
者清楚识别被函数使用的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace N {
    void globalFoo1( );
}

void globalFoo1( ) {
}

void globalFoo2( ) {
    globalFoo1( );      // 违规
    N::globalFoo1( );   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace N {
    void globalFoo1( );
}

void globalFoo1( ) {
}

void globalFoo2( ) {
    ::globalFoo1( );    // OK
    ::N::globalFoo1( ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-24</key>
<configkey>CODSTA-CPP-24</configkey>
<name><![CDATA[ 避免使用任何虚的赋值操作符。赋值操作符不能返回 const T& [CODSTA-CPP-24] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用任何虚的赋值操作符。赋值操作符不能返回 const T&amp; [CODSTA-CPP-24-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"避免使用任何虚的操作符。"
如果你需要使用虚操作符，推荐使用命 
名函数替代(例如 virtual void Assign(const &amp;T))。 "不要返回 const T&amp; 。 
尽管这样写能够预防出现比如 (a=b)=c 这样的奇怪代码， 它的 
缺点是：你不能将 T 对象放到标准容器中； 
容器需要赋值返回 T&amp; 。"
参见: CODSTA-CPP-02, CODSTA-CPP-21, MRM-04, MRM-37, MRM-40, MRM-47, OOP-27,
          OOP-30, OOP-34



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范提高代码安全性并改进良好的编码风格。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    virtual int&amp; operator=(const int&amp;); // 违规
    const A&amp; operator=(const A&amp;);       // 违规
};

template&lt;class T&gt; class B {
public:
    virtual T&amp; operator=(const T&amp;);     // 违规
    const B&lt;T&gt;&amp; operator=(B&lt;T&gt;&amp;);       // 违规
};

template&lt;class T&gt; class C {
public:
    const C&lt;T&gt;&amp; operator=(const C&lt;T&gt;&amp;); // 违规
    virtual T&amp; operator=(T&amp;);           // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    const int&amp; operator=(const int&amp;);   // OK
    A&amp; operator=(const A&amp;);             // OK
};

template&lt;class T&gt; class B {
public:
    T&amp; operator=(const T&amp;);             // OK
    B&lt;T&gt;&amp; operator=(B&lt;T&gt;&amp;);             // OK
};

template&lt;class T&gt; class C {
public:
    C&lt;T&gt;&amp; operator=(const C&lt;T&gt;&amp;);       // OK
    T&amp; operator=(T&amp;);                   // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Construction, Destruction, and Copying", Rule 55

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-25</key>
<configkey>CODSTA-CPP-25</configkey>
<name><![CDATA[ 非公共成员应为虚函数，公共函数应为非虚函数 [CODSTA-CPP-25] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非公共成员应为虚函数，公共函数应为非虚函数 [CODSTA-CPP-25-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"公共函数应为非虚函数。
如果继承类需要访问基类，虚函数应 
为私有成员函数或保护类成员函数。"


例外:

"该规则对析构函数无效，因为析构函数有特殊 
的执行顺序。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范使代码保持良好的封装性，增强基类的坚固性以 
应对不同的情况。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A{
public: 
	virtual void foo(); // 违规
	void goo();
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B{
public: 
	void goo();
	
private:
	virtual void foo(); // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Class Design and Inheritance", Rule 39

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-26</key>
<configkey>CODSTA-CPP-26</configkey>
<name><![CDATA[ 保持类型和函数在分开的namespace中，除非它们确实需要一起运行 [CODSTA-CPP-26] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
保持类型和函数在分开的namespace中，除非它们确实需要一起运行 [CODSTA-CPP-26-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"我们都遇到过这样的情况，可能出现前述的问题，
当ADL不适当的拉起一个其他namespace的名称，
仅仅是因为这些在namespace中的名称在其附近。
这个问题不单单出现在使用标准库时. 这个确实 
会发生在c++中，当使用任何定义在同样的namespace中
的类型和函数时。
 - 特别是模板函数，以及一些操作符 - 
这些和类型无关。不要这样做。
跳开这些类型问题的最简单方法是，不要将非成员函数
（即不是类型x的接口的一部分）放入和类型x一样的namespace中，
并且，永远不要放置模板函数或者操作符到有用户定义类型的namespace中。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则预防无法解释的及令人费解的编译问题， 
主要是当使用标准库时.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace NS1 {
    class Class {};
    void foo01( );          // 违规
    void foo02( int x );    // 违规
    void foo03( Class x );  // OK
    void foo04( Class* x ); // OK
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace NS1 {
    class Class {};
    void foo03( Class x );  // OK
    void foo04( Class* x ); // OK
}
namespace NS2 {
    void foo01( );          // OK
    void foo02( int x );    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Namespaces and Modules", Rule 58

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-27</key>
<configkey>CODSTA-CPP-27</configkey>
<name><![CDATA[ 保持一个类型和它的非成员函数接口在同一个命名空间 [CODSTA-CPP-27] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
保持一个类型和它的非成员函数接口在同一个命名空间 [CODSTA-CPP-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"被设计为类 X  (操作符和帮助函数)接口的非成员函数 
a class X (operators and helper functions) 必须与类 X 放 
在同一个命名空间里，这样访问时才正确。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改善代码的效率和可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace N{
	class X{
	     public:
		void foo();
	};
}

N::X operator+(const N::X&amp;, const N::X&amp;); // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace N{
	class X{
	     public:
		void foo();
		X operator+(const X&amp;);    // OK
	};
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
章节： "Namespaces and Modules", 规则 57

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-28</key>
<configkey>CODSTA-CPP-28</configkey>
<name><![CDATA[ 如果定义了二进制运算操作符 ( + , - , * , / , ^ , % , | , & , >> , << )，应同时定义其对应的赋值操作符 [CODSTA-CPP-28] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果定义了二进制运算操作符 ( + , - , * , / , ^ , % , | , &amp; , &gt;&gt; , &lt;&lt; )，应同时定义其对应的赋值操作符 [CODSTA-CPP-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

定义了二进制操作符 
( + , - , * , / , ^ , % , | , &amp; , &gt;&gt; , &lt;&lt; ),应同时
定义其赋值操作符。
当发现二进制操作符而没有相应的赋值操作符时， 
该规范将给出警告。
参见: CODSTA-CPP-29



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

操作符的赋值版本比独立版本更有效率。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A{};
A operator+( A&amp; a, A&amp; b );  // 违规 operator+ without operator+=

class B{
    B operator+( B&amp; a );    // 违规 operator+ without operator+=
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A{};
A operator+( A&amp; a, A&amp; b );  // OK
A operator+=( A&amp; a, A&amp; b ); // OK

class B{
    B operator+( B&amp; a );    // OK
    B operator+=( B&amp; a );   // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Functions and Operators", Rule 27

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-29</key>
<configkey>CODSTA-CPP-29</configkey>
<name><![CDATA[ 算术和赋值操作符应该有规范的形式 [CODSTA-CPP-29] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
算术和赋值操作符应该有规范的形式 [CODSTA-CPP-29-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

定义二进制操作符 @ ( @ 包括 + , - , * , / , ^ , % , | , &amp; , &gt;&gt; , &lt;&lt; )
根据其赋值操作符版本， @= so a@=b and a=a@b
表示相同操作。 达成这些目的规范性的方式
是就操作符 @= 定义 @ , 如下：

T&amp; T::operator@=(const T&amp;){
 // implementation
 return *this;
}

T operator@( const T&amp; lhs, const T&amp; rhs){
 T templ(lhs);
 return temp @= rhs;
}

这样可能是操作符 @= 为一个非成员函数。
有了操作符 @ 则可接受首参数通过值传递
并且返回一个 const 值。

规范检查是否声明二进制操作符 @, @= 并且按
如上方式进行编码。
参见: CODSTA-CPP-28, CODSTA-CPP-52



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果操作符 @ 是非成员函数， 他应该具备
一种属性：接受左值和右值隐式转换。
通过操作符 @ 可是首参数可通过值传递，
你可以使用编译器的隐式拷贝函数，
这能够给编译器留更多余地进行优化。
使操作符 @ 返回一个 const 值，其优点是：
能使一些明显错误的代码如 a + b = c 无效。
 但同时它也使一些有用的构造函数如 a = (b + c) 无效。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A{
public:
    A( const A&amp; );
    A operator+=( A&amp; a ){}
    A operator-=( A&amp; a ){}
    A&amp; operator-( A&amp; a ){}   // 违规 - Operator method should result
                             //             class as a direct type
                             //           - Operator method should be global
    A operator*=( A&amp; a ){}   // 违规 - The function's return type should
                             //             be a reference to class
                             //           - The last operation of "*=" function
                             //             should be return *this
};
A operator+( A&amp; a, A&amp; b ){   // 违规 - No return statement...
    return a.operator+=( a );//           - Declare and initialize temporary
                             //             local variable by first parameter
};

A operator*( A&amp; a, A&amp; b ){   // 违规 - Code does not match with example
                             //             code from rule description
    A tmp(a);    
    return tmp += b;         // 违规 - Incorrect operation name
    return tmp *= b;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A{
public:
    A&amp; operator+=( A&amp; a ){  // OK
        // ... implementation ...
        return *this;
    }
    A&amp; operator-=( A&amp; a ){  // OK
        // ... implementation ...
        return *this;
    }
    A&amp; operator*=( A&amp; a ){  // OK
        // ... implementation ...
        return *this;
    }
};
A operator-( A&amp; a, A&amp; b ){   // OK
    A tmp(a);                // OK
    return tmp -= b;         // OK
}

A operator+( A&amp; a, A&amp; b ){   // OK
    A tmp(a);                // OK
    return tmp += b;         // OK
};

A operator*( A&amp; a, A&amp; b ){   // OK
    A tmp(a);                // OK
    return tmp *= b;         // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Functions and Operators", Rule 27

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-30</key>
<configkey>CODSTA-CPP-30</configkey>
<name><![CDATA[ 非成员操作符比成员操作符更支持混合形式的算术运算 [CODSTA-CPP-30] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非成员操作符比成员操作符更支持混合形式的算术运算 [CODSTA-CPP-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"声明非成员函数类型转换时，应当适用于所有的
参数。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

声明非成员函数允许编译器在所有参数上去执行隐式类型
转换并支持混合模式计算。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class complex {
    double re, im;
public:
    complex( double r, double i ) : re( r ), im( i ) {}
    complex operator+ ( complex );                        // 违规
    complex operator+=( complex );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class complex {
    double re, im;
public:
    complex( double r, double i ) : re( r ), im( i ) {}
    complex&amp; operator+=( complex a );
};

complex operator+( complex a, complex b ) {        // OK
    complex r = a;
    return r += b;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 4, Item 24

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-31</key>
<configkey>CODSTA-CPP-31</configkey>
<name><![CDATA[ 不要在构造函数上使用关键字 'explicit' [CODSTA-CPP-31] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在构造函数上使用关键字 'explicit' [CODSTA-CPP-31-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则检查你是否在构造函数上使用关键字 `explicit' 。
参见: CODSTA-CPP-04


说明:

不要使用关键字 `explicit'.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public: 
    explicit A( int );            // 违规
    explicit A( double ) {}    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public: 
    A( int );            // OK
    A( double ) {}    // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-32</key>
<configkey>CODSTA-CPP-32</configkey>
<name><![CDATA[ 非模板类的定义中不能定义成员函数 [CODSTA-CPP-32] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非模板类的定义中不能定义成员函数 [CODSTA-CPP-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在类定义内定义函数是隐式内联的；然而，
在类定义内定义成员函数同样使得类
的定义不紧凑并且很难读。这条规则会检测是否你的
成员函数定义实在类的定以内。
参见: CODSTA-CPP-33



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则通过分离接口和实现确保更好的数据隐藏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    int foo( ) {};      // 违规
    inline int bar( );
};

inline int A::bar( ) {
    return 0;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    int foo( );         // OK
    inline int bar( );
};

int A::foo( ) {};
inline int A::bar( ) {
    return 0;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 6 Style  - 6.1 Classes - Rule 21

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.13章节 Functions, 第109条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-33</key>
<configkey>CODSTA-CPP-33</configkey>
<name><![CDATA[ 模板类的定义中不能定义成员函数 [CODSTA-CPP-33] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
模板类的定义中不能定义成员函数 [CODSTA-CPP-33-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在类定义内定义函数是隐式内联的；然而，
在类定义内定义成员函数同样使得类
的定义不紧凑并且很难读。这条规则会检测是否你的
成员函数定义实在类的定以内。
参见： CODSTA-CPP-32



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则通过分离接口和实现确保更好的数据隐藏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template &lt;class T&gt;
class A {
public:
    void foo( ) {}      // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

template &lt;class T&gt;
class A {
public:
    void foo( );
};
template &lt;class T&gt; void A&lt;T&gt;::foo( ) {}    // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft 推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-34</key>
<configkey>CODSTA-CPP-34</configkey>
<name><![CDATA[ 避免在指针上使用 static_cast [CODSTA-CPP-34] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在指针上使用 static_cast [CODSTA-CPP-34-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"指向动态对象的指针不要使用 static_cast: 安全的替换方式是使用 
 dynamic_cast 来反射到指定对象. 考虑使用dynamic_cast来替换static_cast，
并且你就不需要记忆何时static_cast是安全的何时是危险的。 "



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改进代码的安全性和可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B {};
class D : public B {};

void foo( B* pb, D* pd ) {
    B* pb2 = static_cast&lt;B*&gt;( pd );     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B {};
class D : public B {};

void foo( B* pb, D* pd ) {
    B* pb2 = dynamic_cast&lt;B*&gt;( pd );     // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Type Safety", Rule 93

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-35</key>
<configkey>CODSTA-CPP-35</configkey>
<name><![CDATA[ 避免使用dynamic_casts [CODSTA-CPP-35] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用dynamic_casts [CODSTA-CPP-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这个示例也演示了，如果你希望进行类型转换,
这也就表明，你可能使用了错误的方法实现了目标. 特别是当你 
希望使用 dynamic_cast 时. 任何时候避免使用转换
, 特别是在性能敏感的代码中使用dynamic_casts . "



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则不允许使用 dynamic_casts.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"(...) 很多 dynamic_cast 的实现是很慢的. 例如,
至少一个普遍的实现就是基于四层的单继承的字符串的比较，每一个基于如此实现的dynamic_cast
可能会调用四次的strcmp来比较类的名称。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;boost/tr1/memory.hpp&gt;

using namespace std;

class Window {
    virtual void onResize( );
};

class SpecialWindow : public Window {
public:
    virtual void onResize( );
    void blink( );
};

void foo( )
{
    typedef vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;
    VPW winPtrs;

    for (VPW::iterator iter = winPtrs.begin( ); iter != winPtrs.end( ); ++iter)
    {
        if (SpecialWindow *psw = 
                dynamic_cast&lt;SpecialWindow*&gt;( iter-&gt;get( ) ))      // 违规
        psw-&gt;blink( );
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;boost/tr1/memory.hpp&gt;

using namespace std;

class Window {
    virtual void onResize( );
};

class SpecialWindow : public Window {
public:
    virtual void onResize( );
    void blink( );
};

void foo( ) {
    typedef std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW;
    VPSW winPtrs;
    for (VPSW::iterator iter = 
             winPtrs.begin( ); iter != winPtrs.end( );++iter)
        (*iter)-&gt;blink( );                                                // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., Chapter 5, Item 27

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-36</key>
<configkey>CODSTA-CPP-36</configkey>
<name><![CDATA[ 避免在文件中使用命名空间外的全局变量，全局函数，和类 [CODSTA-CPP-36] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在文件中使用命名空间外的全局变量，全局函数，和类 [CODSTA-CPP-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测命名空间外的全局变量，
类，和全局函数的使用。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用命名空间外的全局变量，类，和全局函数。
一个文件中的所有数据和函数都应该在一个或多个
命名空间的内部。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int var = 0;        // 违规

void globalfoo( ) { // 违规
}

class A {           // 违规
    int i;
    void foo( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace name1 {
    int var = 0;        // OK

    void globalfoo( ) { // OK
    }

    class A {           // OK
        int i;
        void foo();
    };
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机， 飞行器 C++ 编码规范
   章节 4.11 命名空间, AV 第98条规则

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第7节, 规则7-3-1

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-37</key>
<configkey>CODSTA-CPP-37</configkey>
<name><![CDATA[ 在函数的执行体中不应定义类，结构体，联合体(class/struct/union) [CODSTA-CPP-37] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数的执行体中不应定义类，结构体，联合体(class/struct/union) [CODSTA-CPP-37-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在函数的执行体中不应定义类，结构体，联合体。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果你在函数中定义一个结构体或类（相当
于定义），那它相当于一个局部类型，相当于
- 不能被编译器重复使用。
- 会导致同类型定义的不相容。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(){
    class A { // 违规
        // ...
    };
    // ...
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A { // OK
    // ...
};
void foo(){
    // ...
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft 推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-38</key>
<configkey>CODSTA-CPP-38</configkey>
<name><![CDATA[ 转换操作符, operator->, operator(), operator[] 应该 const 类型的 [CODSTA-CPP-38] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
转换操作符, operator-&gt;, operator(), operator[] 应该 const 类型的 [CODSTA-CPP-38-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

转换操作符，operator-&gt;,operator(),operator[] 应该是 const 类型的。
参见: CODSTA-CPP-03, CODSTA-CPP-43, CODSTA-CPP-44,
MISRA-104, MISRA2004-16_7, OPT-21



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C++ 强大的 const 属性应该视情况使用，
对于编码提供额外的正确形态检查， 
语义操作符 "()", "[]", "-&gt;", 和强制转换操作符
它们是用来假定不改变对象
内部结构。因此，这是一个好的做法对于声明 const.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
    public:
        A&amp; operator()( int x ); // 违规
        A&amp; operator[]( int x ); // 违规
        A&amp; operator-&gt;( );       // 违规
        operator int( );        // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A 
{
    public:
        A&amp; operator()( int x ) const; // OK
        A&amp; operator[]( int x ) const; // OK
        A&amp; operator-&gt;( ) const;       // OK
        operator int( ) const;        // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., 第1章, 第3项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-39</key>
<configkey>CODSTA-CPP-39</configkey>
<name><![CDATA[ 在头文件中或 #include 之前不要写命名空间的 using [CODSTA-CPP-39] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在头文件中或 #include 之前不要写命名空间的 using [CODSTA-CPP-39-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"命名空间的使用是为你提供便利的, 不是让你影响其他人的：
在 #include 指示符之前绝不要使用声明或者
指示符。在头文件里，不要写命名空间-级别使用的指示符
或者使用声明；反而，明确的命名空间-限制所有的列举。
第二个规则由第一个规则产生, 因为头部永远不知道
其他的什么 #includes 头可能出现在它们的后面。"


例外:

按照需要在被集成扩展的类中规则不支持
类成员的定义。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防在头文件里使用指令类
那意味文件包含了一个无限执行的。
规则还预防修改其它头文件的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file1.cpp
#include &lt;stdio.h&gt;
using namespace std;    // 违规
#include &lt;stddef.h&gt;

// file.h
#include &lt;stdio.h&gt;
using namespace std;    // 违规

// file2.cpp
#include "file.h"
#include &lt;stddef.h&gt;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cpp
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
using namespace std;    // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Namespaces and Modules", Rule 59

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-40</key>
<configkey>CODSTA-CPP-40</configkey>
<name><![CDATA[ 限制一个类的对象个数 [CODSTA-CPP-40] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制一个类的对象个数 [CODSTA-CPP-40-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测在一个类中需要限制对象个数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在一个类中限制对象个数可以减少代码的复杂度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {                         // 违规
public:
    class X {}; // exception definition
    Base( ) {
        // limit missing
        // constructor stuff here
        ++numObjects;
    }
    ~Base( ) {
        --numObjects;
        // destructor stuff here
    }
private:
    static int numObjects;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {                         // OK
public:
    class X {}; // exception definition
    Base( ) {
        if (numObjects &gt;= 1) throw X( );
        // constructor stuff here
        ++numObjects;
    }
    ~Base( ) {
        --numObjects;
        // destructor stuff here
    }
private:
    static int numObjects;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "More Effective C++: 35 New Ways to Improve 
Your Programs and Designs", Addison-Wesley, Copyright 1996, 
章节: "Techniques", 第26项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-41</key>
<configkey>CODSTA-CPP-41</configkey>
<name><![CDATA[ 不要使用 'enum' 关键字在 C++ 中声明变量 [CODSTA-CPP-41] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 'enum' 关键字在 C++ 中声明变量 [CODSTA-CPP-41-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则检查你的 C++ 代码是否使用 enum 关键字声明变量。
在 C++ 中声明变量时 'enum' 关键字是多余的
规则仅仅适用于 C++ 语言。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

易读。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Colors { RED, BLUE, GREEN };
enum Colors c;     // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum Colors { RED, BLUE, GREEN };
Colors c;        // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-42</key>
<configkey>CODSTA-CPP-42</configkey>
<name><![CDATA[ 不使用 'mutable' 关键字声明成员变量 [CODSTA-CPP-42] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不使用 'mutable' 关键字声明成员变量 [CODSTA-CPP-42-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则检测你是否使用  'mutable' 关键字声明成员变量。 
规则仅适应 C++ 编程语言。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用关键字  'mutable' 。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Date{
public:
    int getMonth( ) const;
private: 
    mutable int month;    // 违规
    int year;
    int day;
};

int Date::getMonth( ) const {
    month++;
    return month;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用  'mutable'  关键字声明成员变量



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft 推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-43</key>
<configkey>CODSTA-CPP-43</configkey>
<name><![CDATA[ 尽可能声明引用参数为 const 引用 [CODSTA-CPP-43] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽可能声明引用参数为 const 引用 [CODSTA-CPP-43-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否用户声明引用参数为 const 引用。
当用户的函数不会修改其所引用的参数时，用户 
应该使用 const 来防止当函数返回时变量意外 
的修改。
参见: CODSTA-CPP-03, CODSTA-CPP-38, CODSTA-CPP-44, 
          MISRA-104, MISRA2004-16_7, OPT-21



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

声明不会被修改的参数为 const 引用而不是引用 
提高了可读性。它也防止将来修订会意外的 
改变调用函数的数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct Foo {
    int x;
    int y;
};

int Bar( Foo &amp;f ) {  // 违规
    return f.x;
}

int FooBar( Foo &amp;f ) { // OK
    return f.x++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct Foo {
    int x;
    int y;
};

int Bar( const Foo &amp;f ) {  // OK
    return f.x;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章, 第3项

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第7节, 规则 7-1-2

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-44</key>
<configkey>CODSTA-CPP-44</configkey>
<name><![CDATA[ 应使非 const 成员函数调用 const 成员函数，而非复制 const 的定义 [CODSTA-CPP-44] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应使非 const 成员函数调用 const 成员函数，而非复制 const 的定义 [CODSTA-CPP-44-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当  const 和 非  const 成员函数有本质上的相同的
实现方式时，代码复制能避免出现有非 const
成员函数调用 const 成员。"
参见： CODSTA-CPP-03, CODSTA-CPP-38, CODSTA-CPP-43,
MISRA-104, MISRA2004-16_7, OPT-21



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"减少编译时间，维护，代码膨胀的局面。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;

class TextBlock {
public:
    const char&amp; operator[]( size_t position ) const  { // OK
        // do bounds checking
        // log access data
        // verify data integrity
        return text[ position ];
    }
    char&amp; operator[]( size_t position ) {            // 违规
        // do bounds checking 
        // log access data
        // verify data integrity
        return text[ position ];
    }
private:
    string text;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;
class TextBlock {
public:
    const char&amp; operator[]( size_t position ) const { // OK
        // some code
        return text[ position ];
    }
    char&amp; operator[]( size_t position ) {            // OK
        return const_cast&lt;char&amp;&gt;(
            static_cast&lt;const TextBlock&amp;&gt;(*this)[ position ] );
    }
private:
    string text;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., 第1章, 第3项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-45</key>
<configkey>CODSTA-CPP-45</configkey>
<name><![CDATA[ 一个类的私有成员部分应该声明成以下顺序:构造函数、析构函数、成员函数、成员操作符函数、枚举以及其他 [CODSTA-CPP-45] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个类的私有成员部分应该声明成以下顺序:构造函数、析构函数、成员函数、成员操作符函数、枚举以及其他 [CODSTA-CPP-45-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

准照上述约定，使之更容易了解
不熟悉的类去理解它的功能。
参见： CODSTA-CPP-46, CODSTA-CPP-47, CODSTA-CPP-48, CODSTA-CPP-49



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则使源码更易读。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A   // 违规
{    
    private:
        A( );
        int foo( );
        ~A( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A    // OK
{   
    private:
        A( );
        ~A( );
        int foo( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft 推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-46</key>
<configkey>CODSTA-CPP-46</configkey>
<name><![CDATA[ 在一个类的范围顺序中： public 位置应在最前面 [CODSTA-CPP-46] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在一个类的范围顺序中： public 位置应在最前面 [CODSTA-CPP-46-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

Public 位置必须在 protected and private 之前。
参见： CODSTA-CPP-45, CODSTA-CPP-47, CODSTA-CPP-48, CODSTA-CPP-49



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

易读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test {  // 违规
protected:
    void foo2( );
private:
    void foo3( );
public:
    void foo1( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test {  // OK
public:
    void foo1( );
protected:
    void foo2( );
private:
    void foo3( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 6 Style - 6.1 Classes - 第20条规则

2. J联合攻击战斗机, 飞行器, C++ 编码规范
   第4.9章 Style, AV 第57条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-47</key>
<configkey>CODSTA-CPP-47</configkey>
<name><![CDATA[ 在一个类的范围顺序中： protected 位于 private 之前 [CODSTA-CPP-47] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在一个类的范围顺序中： protected 位于 private 之前 [CODSTA-CPP-47-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

Protected 必须位于 private 之前。
参见： CODSTA-CPP-45, CODSTA-CPP-46, CODSTA-CPP-48, CODSTA-CPP-49



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增加易读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test {	// 违规
public:
    void foo1( );
private:
    void foo3( );
protected:
    void foo2( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test {	// OK
public:
    void foo1( );
protected:
    void foo2( );
private:
    void foo3( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 6 Style - 6.1 Classes - 第20条规则

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.9章 Style, AV 第57条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-48</key>
<configkey>CODSTA-CPP-48</configkey>
<name><![CDATA[ 在类的protected域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型, 其他 [CODSTA-CPP-48] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在类的protected域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型, 其他 [CODSTA-CPP-48-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

遵守以上的转换顺序可以让那些不熟悉类的人理解其功能。 
参见: CODSTA-CPP-45, CODSTA-CPP-46, CODSTA-CPP-47, CODSTA-CPP-49



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则使代码更加易读。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A    //违规 
{   
    protected:
        A( );
        int foo( );
        ~A( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A    // OK
{    
    protected:
        A( );
        ~A( );
        int foo( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-49</key>
<configkey>CODSTA-CPP-49</configkey>
<name><![CDATA[ 在类的public域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型, 其他 [CODSTA-CPP-49] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在类的public域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型, 其他 [CODSTA-CPP-49-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

遵守以上的转换顺序可以让那些不熟悉类的人理解其功能。
参见: CODSTA-CPP-45, CODSTA-CPP-46, CODSTA-CPP-47, CODSTA-CPP-48



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {  // 违规
public:
    A( );
    int foo( );
    ~A( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {  // OK
public:
    A( );
    ~A( );
    int foo( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-50</key>
<configkey>CODSTA-CPP-50</configkey>
<name><![CDATA[ 不要使用 static 关键字，除非在函数或者类中 [CODSTA-CPP-50] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 static 关键字，除非在函数或者类中 [CODSTA-CPP-50-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用static关键字，除非是在函数或者类中 (C++ only).
注意，c语言倾向于在文件域中使用static关键字.
"为了反对这一功能, 标准委员会表达了希望剔出这个功能的愿望。
但是，委员会无法剔除这个被频繁使用的功能——
尽管这很多余且危险。
因此，需要提示用户不要使用这个功能。
关键字 s t a t i c , 经常表示‘‘静态分配,’’的意思，能够被
用来指示函数或者对象是本地的单元。
例如:

// file1:
static int glob ;

// file2:
static int glob ;

这个程序有两个整数，名为 g l o b . 每一个 g l o b 被单独的用来
给其传输单元中定义的函数使用. 使用 static 来表明
 "本地的传输单元" 是被c++标准所反对的. 使用匿名的
namespaces 来替换."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则避免使用c++语言反对的结构.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static int glob;    // 违规
static int goo( );  // 违规

namespace N {
    static int c;   // 违规
}

static struct S {
    int a;
    static int b;   // 违规
} S_var;            // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace{
   static int glob;    // OK
}

class A {
    static void foo( ); // OK
};

void zoo( ) {
    static int c;       // OK
}

class B {
public:
    static struct S {
        int a;
        static int b;   // OK
    } S_var;            // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Stroustroup C++ Programming Language 3rd Edition. 9.2, p200.

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-51</key>
<configkey>CODSTA-CPP-51</configkey>
<name><![CDATA[ 在源文件中不要定义内联函数 [CODSTA-CPP-51] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在源文件中不要定义内联函数 [CODSTA-CPP-51-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要在源文件中定义 inline 函数 - inline 函数 
必须在每一个被使用的传输单元中相等的被定义. 
因此, inline 函数应该只在头文件中被定义，或者是 .i 文件。


例外:

静态内联函数以及内联函数定义在匿名 namespace 中是允许的。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则帮助来防止无法预测的程序动作.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

inline int foo( ) {     // 违规
    return 10;
}

class LocalClass {
public:
    int bar( ) {        // 违规
        return 20;
    }
};

int test( ) {
    LocalClass lc;
    return foo() + lc.bar();
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static inline int foo( ) {  // OK
    return 10;
}

namespace {
    class LocalClass {
    public:
        int bar( ) {        // OK
            return 20;
        }
    };
}

int test( ) {
    LocalClass lc;
    return foo() + lc.bar();
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Stroustroup C++ Programming Language 3rd Edition. 9.2, p199.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-52</key>
<configkey>CODSTA-CPP-52</configkey>
<name><![CDATA[ 构造函数使用赋值型的操作符和独立型的操作符的自然的关系 [CODSTA-CPP-52] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
构造函数使用赋值型的操作符和独立型的操作符的自然的关系 [CODSTA-CPP-52-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"确保赋值型操作符(例如, operator+=)和独立型操作符(例如, operator+)间的天然关系的好办法是使用前者来实现后者。
例如:"

class Rational {
public:
  Rational&amp; operator+=(const Rational&amp; rhs);
};

const Rational operator+(const Rational&amp; lhs,
                         const Rational&amp; rhs)
{
  return Rational(lhs) += rhs;
}



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"在示例中，操作符operators += 被实现, 同时 
操作符operator+ 调用operators +=以实现其功能. 通过这种设计, 只有 
赋值型操作符需要被维护. 更多的, 
也不需要独立操作符作为友元函数了。
参见: OOP-11, CODSTA-CPP-29



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A operator+=( A&amp; b );
    A operator-=( A&amp; b );
    A operator*=( A&amp; b );
    friend A operator*( A&amp; a, A&amp; b );   // 违规
};

A operator+( A&amp; a, A&amp; b ){    // 违规
    return A( a );
}

A operator-( A&amp; a, A&amp; b ){    // 违规
    return A( a );
}

A operator*( A&amp; a, A&amp; b ){    // OK
    return A( a ) *= b;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A operator+=( A&amp; b );
    A operator-=( A&amp; b );
    A operator*=( A&amp; b );
    // OK - 移出友元函数声明
};

A operator+( A&amp; a, A&amp; b ){    // OK
    return A( a ) += b;
}

A operator-( A&amp; a, A&amp; b ){    // OK
    A result( a );
    return result -= b;
}

A operator*( A&amp; a, A&amp; b ){    // OK
    return A( a ) *= b;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   Chapter: "Efficiency", Item 22

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-53</key>
<configkey>CODSTA-CPP-53</configkey>
<name><![CDATA[ 尽可能声明参数或局部变量为 const [CODSTA-CPP-53] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽可能声明参数或局部变量为 const [CODSTA-CPP-53-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否用户声明参数或局部变量为 const。 
不可变的值更容易理解，跟踪和定位原因，因此 
只要在合理的情况下多用常量而不是变量，当定义一个值的时候 
使 const 作为默认的选择:
参见: CODSTA-CPP-43, MISRA2004-16_7



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对于指针类型的参数和变量， cost 修饰符
应该适用于指针，而不是指向的对象。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这样是安全的，它是在编译时检查，而且与 C++ 的
类型系统相集成。它还可以防止今后修订
无意地修改被调用函数的数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>
int foo1(int param1,          // 违规
         int* param2,         // 违规
         const int* param3)   // 违规- const is applied to the
                              // pointed object, not to the pointer
{
    int var1 = 0;             // 违规
    return  param1 + *param2 + *param3 + var1;
}

int foo2(int param1,          // OK - param1 is modified
         int* param2,         // OK - param2 is modified
         const int* param3)   // OK - param3 is modified
{
    int var1 = 0;             // OK - var1 is modified
    param1++;
    param2++;
    param3++;
    var1 = param1 + *param2 + *param3;
    return var1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// Fixed violations - const added
int foo1(const int param1,          // OK
         int* const param2,         // OK - const is applied to the pointer
         const int* const param3)   // OK - const is applied to the pointed
                                    // object and to the pointer
{
    const int var1 = 0;             // OK
    return  param1 + *param2 + *param3 + var1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范”, Addison-Wesley, 
  (C) 2005 Pearson Education, Inc., 章节: “编码风格”, 第15条规则

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第7节, 规则7-1-1

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-54</key>
<configkey>CODSTA-CPP-54</configkey>
<name><![CDATA[ 成员函数应该被尽可能的声明为 const [CODSTA-CPP-54] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
成员函数应该被尽可能的声明为 const [CODSTA-CPP-54-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"const是值得的，有效的，高度推荐的。
理解在何处以及如何一个程序的状态改变是至关重要的，同时const
直接地书写在代码中，使编译器可以帮助其确保为不变。
如果你发现无法使成员函数为 const, 你通常会获得
对成员函数可能修改的一个对象状态的途径的更好的理解和
信息。"
参见: CODSTA-CPP-78



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"书写const可以帮助你获得对你设计的更好的理解
并确保你的代码强健和安全."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
     int foo(int a)  // 违规
     {
         return a;
     }	
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
     int foo(int a) const  // OK
     {
         return a;
     }	
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Coding Style", Rule 15

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Functions, AV Rule 69

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-55</key>
<configkey>CODSTA-CPP-55</configkey>
<name><![CDATA[ 在接口中不应该使用数组类型参数 [CODSTA-CPP-55] ]]></name>
<tag>codsta</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在接口中不应该使用数组类型参数 [CODSTA-CPP-55-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在公共方法中不应该使用数组类型参数。
反而，用该使用数组类。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则定义接口作为一个公共方法。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

当作为参数时，数组退化成指针。
"数组 衰退" 长期以来认识到问题的来源。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Sample
{
  public:
    void foo(int a[]); //违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Array
{
  /* Array implementation*/
};


class Sample
{
  public:
    void goo(Array a); // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编码规范
第4.10章 Classes, AV 第97条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-56</key>
<configkey>CODSTA-CPP-56</configkey>
<name><![CDATA[ 类，结构体或枚举不应该在定义时作为变量类型声明变量 [CODSTA-CPP-56] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类，结构体或枚举不应该在定义时作为变量类型声明变量 [CODSTA-CPP-56-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类，结构体或枚举不应该在定义时作为变量类
型声明变量。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增加易读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum
{
  up,
  down
} direction;             //违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum direction_e
{
  up,
  down
};

direction_e direction; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编码规范
第4.15章 Declarations and Definitions, AV 第141条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-57</key>
<configkey>CODSTA-CPP-57</configkey>
<name><![CDATA[ 命名空间的嵌套不能超过两层 [CODSTA-CPP-57] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
命名空间的嵌套不能超过两层 [CODSTA-CPP-57-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

命名空间的嵌套不能超过两层。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

简洁和清晰。
深嵌套命名空间难理解和正确的使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace A
{
  namespace B
  {
  	namespace C
  	{
  		namespace D //违规
  		{
  		}
  	}
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace A
{
  namespace B
  {
  	namespace C  // OK
  	{
  	}
	namespace D // OK
	{
	}
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编码规范
第4.11章 Namespaces, AV 第99条规范

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-58</key>
<configkey>CODSTA-CPP-58</configkey>
<name><![CDATA[ 从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用 [CODSTA-CPP-58] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用 [CODSTA-CPP-58-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在 C++ 中调用一个函数而不使用其返回值，
这可能是一个错误。函数的返回值应始终被使用。”


例外:

“函数的返回值可能会由于 (void) 强制类型转换被丢失。
重载运算符除外，因为它们应该表现出和内建的运算符
同样的方式。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

short func ( short para1 )
{
    return para1;
}

void discarded ( short para2 )
{
    func ( para2 );       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

short func ( short para1 )
{
    return para1;
}

void discarded ( short para2 )
{
    (void)func ( para2 );       // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 0 节, 规则 0-1-7

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-59</key>
<configkey>CODSTA-CPP-59</configkey>
<name><![CDATA[ 不得使用 C 语言库 [CODSTA-CPP-59] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 C 语言库 [CODSTA-CPP-59-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一些 C++ 库 (例如 &lt;cstdio&gt;) 也有相应的 C 语言版本
(例如 &lt;stdio.h&gt;)。这条规则规定当 C++ 版本在使用时。 "
检查下列的标准 C 库头文件:
&lt;assert.h&gt;
&lt;ctype.h&gt;
&lt;errno.h&gt;
&lt;float.h&gt;
&lt;iso646.h&gt;
&lt;limits.h&gt;
&lt;locale.h&gt;
&lt;math.h&gt;
&lt;setjmp.h&gt;
&lt;signal.h&gt;
&lt;stdarg.h&gt;
&lt;stddef.h&gt;
&lt;stdio.h&gt;
&lt;stdlib.h&gt;
&lt;string.h&gt;
&lt;time.h&gt;
&lt;wchar.h&gt;
&lt;wctype.h&gt;



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义的和实现定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;cstdio&gt;  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 18 节, 规则 18-0-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-60</key>
<configkey>CODSTA-CPP-60</configkey>
<name><![CDATA[ 只得使用那些定义在 ISO/IEC 14882:2003 中的转义序列 [CODSTA-CPP-60] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只得使用那些定义在 ISO/IEC 14882:2003 中的转义序列 [CODSTA-CPP-60-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只得使用那些定义在 ISO/IEC 14882:2003 中的
转义序列。定义的转义字符 (ISO/IEC 14882:2003) 是:
\n, \t, \v, \b, \r, \f, \a, \\, \?, \', \", \&lt;Octal Number&gt;,
\x&lt;Hexadecimal Number&gt;"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

未定义的转义序列导致未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
void foo( ) {
    printf("ABCD\u1111");     // 违规
    printf("abcd\hgf");       // 违规
    printf("\k");             // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用不符合 ISO / IEC14882:2003 标准中定义的转义序列。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 2 节, 规则 2-13-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-61</key>
<configkey>CODSTA-CPP-61</configkey>
<name><![CDATA[ 具有外部链接的对象或函数应该被声明在头文件中 [CODSTA-CPP-61] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
具有外部链接的对象或函数应该被声明在头文件中 [CODSTA-CPP-61-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“放置具有外部链接的对象或函数的声明到 
头文件中，目的是能够从其他翻译单元来访问。
如果外部链接不是必须的，那么该对象或函数应该
要么被声明在一个不具名的命名空间或者声明为 static 静态的。”


例外:

这条规则并不适用于 main，或不具名命名空间的成员。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则减少对象和函数的可见性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
int a1 = 0;   // 违规
void fun(){}  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.h
extern int a1;      // OK
extern void fun();  // OK

// file.cpp
#include "file.h"
int a1 = 0;   // OK
void fun(){}  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 3 节, 规则 3-3-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-62</key>
<configkey>CODSTA-CPP-62</configkey>
<name><![CDATA[ NULL 不得用作一个整数值 [CODSTA-CPP-62] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
NULL 不得用作一个整数值 [CODSTA-CPP-62-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在 C++ 中，字面量 0 既是整数类型又是空指针常数
(null-pointer-constant)。为了满足开发人员的期望，NULL 应作为
空指针常数(null-pointer-constant)，0 为整数零。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“作为此规则的一个结果，NULL 被认为包括指针类型。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;cstddef&gt;

void f1( int );

void foo( )
{
	f1( NULL ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void f1( int );

void foo( )
{
	f1( 0 ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 4 节, 规则 4-10-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-63</key>
<configkey>CODSTA-CPP-63</configkey>
<name><![CDATA[ 字面量零 (0) 不得用作空指针常量 (null-pointer-constant) [CODSTA-CPP-63] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字面量零 (0) 不得用作空指针常量 (null-pointer-constant) [CODSTA-CPP-63-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在 C++ 中，字面量 0 既是整数类型又是空指针常数
(null-pointer-constant)。为了满足开发人员的期望，NULL 应作为
空指针常数(null-pointer-constant)，0 为整数零。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“作为此规则的一个结果，NULL 被认为包括指针类型。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;cstddef&gt;

void f1( int* );

void foo( )
{
	f1( 0 ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;cstddef&gt;

void f1( int* );

void foo( )
{
	f1( NULL ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 4 节, 规则 4-10-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-64</key>
<configkey>CODSTA-CPP-64</configkey>
<name><![CDATA[ if 语句的条件和循环语句的条件应该是布尔类型 [CODSTA-CPP-64] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
if 语句的条件和循环语句的条件应该是布尔类型 [CODSTA-CPP-64-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在 if 语句或循环语句的条件中
使用具有不是布尔类型(bool)的表达式，那么其结果将会
被隐式地转换为布尔类型(bool)”。 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果条件表达式是调用一个转换函数，
此函数转换为名称中包含命名为 'bool' 指针成员的类型定义(typedef)。
规则不报告违规。


例外:

“类型限定序列(type-specifier-seq)声明符形式的条件不需要
有布尔类型(bool)。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“条件表达式应包含一个显式地判断（产生了 bool 类型的结果）
以明确开发人员的意图。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int i;
    if (i){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int i;
    if (i != 0){} // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-0-13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-65</key>
<configkey>CODSTA-CPP-65</configkey>
<name><![CDATA[ 条件运算符的第一个操作数应该具有布尔类型 [CODSTA-CPP-65] ]]></name>
<tag>codsta</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
条件运算符的第一个操作数应该具有布尔类型 [CODSTA-CPP-65-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“条件运算符的第一个操作数应该具有布尔类型。
如果一个表达式不是由布尔类型作为条件运算符
的第一个操作数，那么其结果将是隐式转换为
布尔类型(bool)。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“第一个操作数应包含一个显式地判断（产生了 bool 类型的结果）
以明确开发人员的意图。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i, int j, int k, int l)
{
    i = j ? k : l;               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i, int j, int k, int l)
{
    i = (j != 0) ? k : l;        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 5 节, 规则 5-0-14

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-66</key>
<configkey>CODSTA-CPP-66</configkey>
<name><![CDATA[ 不得使用 C 语言风格的强制类型转换(除 void 强制类型转换)和函数符号式强制类型转换(除了显式的构造函数调用) [CODSTA-CPP-66] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 C 语言风格的强制类型转换(除 void 强制类型转换)和函数符号式强制类型转换(除了显式的构造函数调用) [CODSTA-CPP-66-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“C语言风格 (强制转换符号), 不调用转换构造函数的
函数符号式强制转换能够执行不相关类型之间的
强制转换。” 


例外:

“C语言风格的强制类型转换为 void 可能用于表示
非 void 函数调用的返回值将会被忽略。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C++ 语言的强制类型转换比 C 语言强制转换更具体
并且更容易查找和阅读。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {
public:
    Base( );
    virtual ~Base( );
};

class Derived : public Base {
public:
    Derived( );
    ~Derived( );
};

void foo( ) {
    Base *pB;
    Derived *pD2 = (Derived *) pB;     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    Base( );
    virtual ~Base( );
};

class Derived : public Base {
public:
    Derived( );
    ~Derived( );
};

void foo( ) {
    Base *pB;
    Derived *pD1 = dynamic_cast&lt;Derived*&gt;( pB );   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-2-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-67</key>
<configkey>CODSTA-CPP-67</configkey>
<name><![CDATA[ ! 运算符，逻辑 && 或逻辑 || 运算符的每个操作数应该都是布尔类型 [CODSTA-CPP-67] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
! 运算符，逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型 [CODSTA-CPP-67-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这些操作符使用布尔以外的其他类型作为操作数是
没有多大意义（或者目的）。这条规则用于检测这种使用情况，
这往往是因为逻辑运算符 (&amp;&amp;, || 和 !)
很容易地与位运算符 (&amp;, | 和 ~)相混淆。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。
规则可防止逻辑运算符和位运算符之间的混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* examples of incorrect code */
void foo(int a, int b, int c, int d, int* ptr)
{
    if ( 1 &amp;&amp; ( c &lt; d ) ) {}        // 违规
    if ( ( a &lt; b ) &amp;&amp; ( c + d ) ){} // 违规
    if ( a || ( c + d ) ) {}        // 违规
    if ( !ptr ) {}                  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* examples of correct code */
void foo(int a, int b, int c, int d)
{
    if ( ( a &lt; b ) &amp;&amp; ( c &lt; d ) ){}   // OK
    if ( ( a == b ) || ( c != d ) ){} // OK
    if ( !false ) {}                  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
Chapter 6, Section 5, Rule 5-3-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-68</key>
<configkey>CODSTA-CPP-68</configkey>
<name><![CDATA[ 一元 & 运算符不得被重载 [CODSTA-CPP-68] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一元 &amp; 运算符不得被重载 [CODSTA-CPP-68-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在完整类型包含用户声明的操作符 &amp; 时，
取不完整类型对象的地址将导致不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
    A * operator &amp; ( );   // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要重载一元 '&amp;' 运算符



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-3-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-69</key>
<configkey>CODSTA-CPP-69</configkey>
<name><![CDATA[ for 循环应该包含一个没有浮动类型的单一的循环计数器 [CODSTA-CPP-69] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
for 循环应该包含一个没有浮动类型的单一的循环计数器 [CODSTA-CPP-69-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“for 循环没有准确的循环计数器只是一个 while 循环。
如果这是期望的行为，则 while 循环更为合适。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改.
循环控制变量是任何出现在 for 初始化语句，
条件或表达式中的变量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于确保确定性循环终止。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int x = 0;
    int y;
    y = 0;
    for (x = 0; x &lt; y; x = y++){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo3()
{
    int x = 0;
    int y;
    y = 0;
    x = 0;
    while(x &lt; y) // OK
    {
        x = y++;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-70</key>
<configkey>CODSTA-CPP-70</configkey>
<name><![CDATA[ 如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 <=, <, > 或 >= 的操作数 [CODSTA-CPP-70] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=, &lt;, &gt; 或 &gt;= 的操作数 [CODSTA-CPP-70-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当循环计数器不是使用  -- 或 ++ 运算符来修改，
那么不得使用 == 和 != 来判断，因为循环终止可能不会发生， 
这可能与开发人员的预期不符。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改。
循环控制变量是任何出现在 for 初始化语句，
条件或表达式中的变量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于确保确定性循环终止。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int i;
    for ( i = 1; i != 10; i += 2 ){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int i;
    for ( i = 1; i &lt;= 10; i += 2 ){} // OK
    for ( i = 1; i != 10; ++i ){}    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-71</key>
<configkey>CODSTA-CPP-71</configkey>
<name><![CDATA[ 循环计数器应该被 --, ++, -=n, 或 +=n 之一修改；这里的 n 在整个循环期间保持不变 [CODSTA-CPP-71] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
循环计数器应该被 --, ++, -=n, 或 +=n 之一修改；这里的 n 在整个循环期间保持不变 [CODSTA-CPP-71-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“循环计数器应该被以下之一修改: --, ++, -=n, 或 +=n;
这里的 n 在整个循环期间保持不变”。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改.
循环控制变量是任何出现在 for 初始化语句，
条件或表达式中的变量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于确保确定性循环终止。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int x;
    for ( x = 0; x &lt; 10; x = x + 1 ){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int x;
    for ( x = 0; x &lt; 10; ++x ){} // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-72</key>
<configkey>CODSTA-CPP-72</configkey>
<name><![CDATA[ 循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改 [CODSTA-CPP-72] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改 [CODSTA-CPP-72-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了循环计数器以外的循环控制变量不得
在判定条件或者表达式中被修改。
循环控制变量是任何出现在 for 始化语句，
判定条件或表达式中的变量。
循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改。
循环控制变量要么是循环计数器，要么是用于提前终止
循环的标识。如果这些在判定条件或表达式中不被修改，
那么代码更容易理解。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则假定变量或参数可能会通过传递
其非 const 指针或引用到外部函数而被修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

bool test(int x);
void foo(int x, bool flag)
{
    for ( x = 0; x &lt; 10; flag = test(++x) ) {}  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

bool test(int x);
void foo(int x, bool flag)
{
    for ( x = 0; x &lt; 10; ++x ) // OK
    {
        flag = test(x);   
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-73</key>
<configkey>CODSTA-CPP-73</configkey>
<name><![CDATA[ 在循环体语句中被修改的循环计数器以外的循环控制变量应该是布尔类型的 [CODSTA-CPP-73] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在循环体语句中被修改的循环计数器以外的循环控制变量应该是布尔类型的 [CODSTA-CPP-73-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在循环体语句中被修改的循环计数器以外的循环控制变量
应该是布尔类型的。
循环控制变量是任何出现在 for 始化语句，
判定条件或表达式中的变量。
循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改。
循环控制变量通常用于提前终止一个 for 循环。
如果使用布尔值来实现这个目的，
那么代码更容易理解。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则假定变量或参数可能会通过传递
其非 const 指针或引用到外部函数而被修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int x, unsigned int u8a, bool flag)
{
    for ( x = 0; ( x &lt; 10 ) &amp;&amp; ( u8a != 3U ); ++x )
    {
        u8a = 5;                         // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int x, unsigned int u8a, bool flag)
{
    for ( x = 0; ( x &lt; 10 ) &amp;&amp; flag; ++x )
    {
        u8a = 5;                         // OK
        flag = u8a != 3U;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-74</key>
<configkey>CODSTA-CPP-74</configkey>
<name><![CDATA[ 在头文件中不得有不具名的命名空间 [CODSTA-CPP-74] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在头文件中不得有不具名的命名空间 [CODSTA-CPP-74-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不具名的命名空间在每个翻译单元中将是独一无二的。
任何出现在头文件的不具名的命名空间中的声明
将适用于每个翻译单元中的不同实体，
这些可能不符合开发人员的期望。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.hpp
namespace // 违规
{
    extern int x;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在头文件中定义不具名的命名空间。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则  7-3-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-75</key>
<configkey>CODSTA-CPP-75</configkey>
<name><![CDATA[ 不得使用 using 指示符 [CODSTA-CPP-75] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 using 指示符 [CODSTA-CPP-75-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“using 指示符在名称查找过程的搜索范围集中
添加额外的范围，这些范围所有标识符变得可见，
增加编译器查找标识符的可能性不符合开发人员
的期望。
using 声明或完全合格的名称限制了名称集为
只有明确指定的名称，以及其他更安全的选项。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32_t;
namespace NS1
{
    int32_t i1;
    int32_t j1;
    int32_t k1;
}
using namespace NS1; // 违规

void f ()
{
    ++j1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int32_t;
namespace NS1
{
    int32_t i1;
    int32_t j1;
    int32_t k1;
}
using NS1::j1;      // OK

void f ()
{
    ++j1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-3-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-76</key>
<configkey>CODSTA-CPP-76</configkey>
<name><![CDATA[ 在同一个命名空间中标识符的多重声明不得跨越该标识符的 using 声明 [CODSTA-CPP-76] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在同一个命名空间中标识符的多重声明不得跨越该标识符的 using 声明 [CODSTA-CPP-76-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“由一个 using 声明引入的标识符集不包括
任何可能在命名空间的后续添加的声明。
任何后续的声明将不会通过 using 声明被找到，
这可能并不符合开发人员的期望。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止意外的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace NS
{
    void foo( unsigned short );
}

using NS::foo;

namespace NS
{
    void foo( unsigned int );  // 违规
}

void some()
{
    foo( 0U );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace NS
{
    void foo( unsigned short );
}

namespace NS
{
    void foo( unsigned int );  // OK
}

using NS::foo;

void some()
{
    foo( 0U );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-3-5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-77</key>
<configkey>CODSTA-CPP-77</configkey>
<name><![CDATA[ Const 成员函数不得返回指向类数据的非 const 指针或引用 [CODSTA-CPP-77] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Const 成员函数不得返回指向类数据的非 const 指针或引用 [CODSTA-CPP-77-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一个对象声明为 const 类的类型时，只有 const 成员
函数可以调用该对象。const 成员函数的共同期望是
对象的状态不会在调用函数的时候被修改。
然而，从一个 const 函数返回一个指向类数据的
非 const 指针或引用，则会允许修改对象的
概念性状态。”。
参见: CODSTA-CPP-06, OOP-12, OOP-36



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

指向类数据的句柄是:
- 指向成员变量/成员函数的引用
- 指向成员变量/成员函数的指针
- 在构造函数中指向数据分配或在析构函数中指向数据释放的指针/引用
静态变量不被视为类数据。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止暴露对象的内部状态给客户，所以他们不会 
失控地修改对象的状态。增强数据封装 
是一种面向对象编程的基石。提高代码的可维护性。
帮助 const 函数操作 const。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test
{
    public:
        Test(int &amp; p) : _i(p)
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        int* GetI1() const
        {
            return &amp;_i; // 违规
        }
    protected:
        int&amp; GetI2() const
        {
            return _i; // 违规
        }
        int * GetI3() const
        {
            return _k; // 违规
        }
    private:
        int &amp; _i;
        int * _k;
};
class Child: public Test
{
    public:
        Child() : Test(z)
        {
        }
        void foo() const
        {
            GetI2() = 0; // Modification of possibly-const object
            *(GetI3()) = 0; // Modification of possibly-const object
        }
    private:
        int z;
};
void bar()
{
    const Child c;
    *(c.GetI1()) = 0; // Modification of possibly-const object
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test
{
    public:
        Test(int &amp; p) : _i(p)
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        const int* GetI1() const
        {
            return &amp;_i; // OK
        }
    protected:
        const int&amp; GetI2() const
        {
            return _i; // OK
        }
        const int * GetI3() const
        {
            return _k; // OK
        }
    private:
        int &amp; _i;
        int * _k;
};
class Child: public Test
{
    public:
        Child() : Test(z)
        {
        }
        void foo() const
        {
            // GetI2() = 0; // Not compilable - can't modify const object
            // *(GetI3()) = 0; // Not compilable - can't modify const object
        }
    private:
        int z;
};
void bar()
{
    const Child c;
    // *(c.GetI1()) = 0; // Not compilable - can't modify const object
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范" Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Class Design and Inheritance", 第 42 条规则

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 5, Item 28

3. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 29 项

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 7 节, 规则 9-3-1

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-CPP-78</key>
<configkey>CODSTA-CPP-78</configkey>
<name><![CDATA[ 如果一个成员函数可以被设为 static 那么它应该被设为 static，否则如果可以被设为 const 那么它应该被设为 const [CODSTA-CPP-78] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个成员函数可以被设为 static 那么它应该被设为 static，否则如果可以被设为 const 那么它应该被设为 const [CODSTA-CPP-78-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"声明一个 static 或者 const 成员函数限制它存取
非静态的数据成员。"
参见: CODSTA-CPP-54



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则预防无意的修改数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
    int foo1 ()         //违规 - can be static
    {
        return m_s;
    }
    int foo2 ()         //违规 - can be const
    {
        return m_i;
    }
    
private:
    int m_i;
    static int m_s;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
public:
    static int foo1 ()        // OK
    {
        return m_s;
    }
    int foo2 () const         // OK
    {
        return m_i;
    }
    
private:
    int m_i;
    static int m_s;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2008 C++语言在关键系统中的使用指南
   第6章, 第9部分 , 第9-3-3条规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-01</key>
<configkey>CODSTA-01</configkey>
<name><![CDATA[ 数组元素必须由数组操作符[ ]访问 [CODSTA-01] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
数组元素必须由数组操作符[ ]访问 [CODSTA-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether array elements are accessed by the array operator [].



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Array elements shall be accessed by the array operator [] rather than 
the dereference operator '*'. Access to array by the dereference operator 
'*' is cryptic and hides the real intention.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{    
     int array[2];	 
     *(array+1) = 0; // Violation
     *array = 0;      // Violation              
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{    
     int array[2];	 
     array[1] = 0; // OK         
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards R-46

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-02</key>
<configkey>CODSTA-02</configkey>
<name><![CDATA[ 不能将成员变量声明为位域 [CODSTA-02] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将成员变量声明为位域 [CODSTA-02-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule is purely informational.
It will report a message when a bitfield is declared.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Prevents error prone code.
The ordering of bits in memory varies from compiler to
compiler. In addition, many popular compilers generate
inefficient code for reading and writing bit members,
and there are potentially severe thread safety issues
relating to bit fields (especially on multiprocessor
systems) due to the fact that most machines cannot
manipulate arbitrary sets of bits in memory, but must
instead load and store whole words. 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct A
{
    int iVarBitField : 8;  // Violation
    int iVar;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not declare bitfield.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by Parasoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-03</key>
<configkey>CODSTA-03</configkey>
<name><![CDATA[ 不要通过#define定义常量 [CODSTA-03] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要通过#define定义常量 [CODSTA-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用 const 或者 enum 定义常量，而不要使用 #define。
预处理器会将源码中的宏替换为相应的定义，然后编译 
这将导致很多负面效应。例如，如果通过#define定义 
一个常量，而该常量的名字很多调试器均不认得。
如果该常量用于表示一个表达式，则该表达式在 
不同的情况下表达式的值不一样，他依赖于该名字的
范围。此外，宏常常容易写错”
See also: MISRA2004-19_7, CODSTA-37, CODSTA-38, CODSTA-39, CODSTA-40



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

代码调试方便。防止宏定义错误。


事例：

#define PI 3.1416    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const float PI = 3.1416; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 2

2. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 10 Constants - Rule 36

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.6 Pre-Processing Directives, AV Rule 30

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-04</key>
<configkey>CODSTA-04</configkey>
<name><![CDATA[ 不能使用 'static' 关键字声明本地变量 [CODSTA-04] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用 'static' 关键字声明本地变量 [CODSTA-04-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule is purely informational and will report a message when a variable
declaration is found with the 'static' keyword.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Makes code more readable.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Foo()
{
    int static iVar = 9; // Violation
    return;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int iVar = 9; // OK
void Foo()
{
    iVar++;
    return;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-05</key>
<configkey>CODSTA-05</configkey>
<name><![CDATA[ 任何时候都应该避免使用指向指针的指针 [CODSTA-05] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
任何时候都应该避免使用指向指针的指针 [CODSTA-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则用于检测代码中是否存在指向指针的指针。
“任何时候都应该避免使用指向指针的指针。
通过提升代码的可读性，从而降低错误率。”


例外：

“该规则例外的情况是对于提供其他语言（如C语言）的接口的函数。 
这类接口函数的参数常常是预定义数据类型，这种情况下指向指针的指针
是需要用到的。另外一个例外是 main 函数的第二个参数，其类型一般为
 char*[]。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性，并提倡数据抽象。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int** a;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

相反， 声明一个有指针类型
成员变量的类。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#12">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#12</A>
   From: 12 Pointers and References - Rec. 48

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 169

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-06</key>
<configkey>CODSTA-06</configkey>
<name><![CDATA[ 谨慎使用 '?:' 三重表达式 [CODSTA-06] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 '?:' 三重表达式 [CODSTA-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测是否使用 '?:' 三重表达式。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性. 三重表达式 '?:' 不容易了解
且容易造成混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int main( ) 
{
    return (1 ? 1 : 0); // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int main( ) 
{
    if (1)             // OK
        return 1;
    else
        return 0;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Parasoft 推荐

2. 国军军用标准 航天型号软件 C 语言安全子集
4.8.2.4  谨慎使用三重表达式

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-07</key>
<configkey>CODSTA-07</configkey>
<name><![CDATA[ 如何函数没有参数，使用 ( ) 而非 (void) [CODSTA-07] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如何函数没有参数，使用 ( ) 而非 (void) [CODSTA-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule detects if you use (void) instead of () if a function
has no parameters. Maintaining this consistency of declarations
results in easier code readability.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule is enabled only for C++ language.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule improves readability of code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef void (*fpt)(void);  // Violation
typedef void TD_void;

void f1(void);   // Violation
void f1(void){   // Violation
}

void foo2(TD_void); // Violation

void (*fp1)(void);  // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef void (*fpt)();  // OK
typedef void TD_void;

void f1();   // OK
void f1(){   // OK
}

TD_void foo2(); // OK

void (*fp1)();  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-08</key>
<configkey>CODSTA-08</configkey>
<name><![CDATA[ 不要在 for 循环内使用 break [CODSTA-08] ]]></name>
<tag>codsta</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在 for 循环内使用 break [CODSTA-08-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks if there are breaks in for loops. Breaks which
are in direct context of do/while, while and switch are skipped.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Avoiding breaks in the for loop makes your code easier to follow.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void func() 
{
  for (int j = 0; j &lt; 10; j++) {        
    if (j==5) 
    {
      break;                 // Violation
    }
   break;                    // Violation		
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void func() 
{
  for (int j = 0; j &lt; 10; j++) {        
    while (true) 
    {
      break;        // OK - 'break' in while context           
    }	
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-09</key>
<configkey>CODSTA-09</configkey>
<name><![CDATA[ 不能将函数指针强制类型转换成原始类型指针 [CODSTA-09] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将函数指针强制类型转换成原始类型指针 [CODSTA-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule detects if code casts pointers to functions to pointers
to primitive types. Using a pointer cast in this manner can cause problems.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Casting pointer to function to pointer to primitive 
type can make code error prone.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Foo(char *ptrC)
{ 
    *ptrC = 0;
    return;
}

void f()
{
    void *ptrV = 0;
    void (*funPtr) (char*) = 0;		
    funPtr = &amp;Foo;		
    ptrV = (void*)funPtr;            // Violation
    return;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Remove all function pointer to primitive type pointer casts.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-10</key>
<configkey>CODSTA-10</configkey>
<name><![CDATA[ 存储类型修饰符应仅与类型相关，不能用于变量或函数 [CODSTA-10] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
存储类型修饰符应仅与类型相关，不能用于变量或函数 [CODSTA-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether storage type modifiers 
are associated with the type, not the variable.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Improves the readability of code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int static i; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static char j; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards R-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-11</key>
<configkey>CODSTA-11</configkey>
<name><![CDATA[ 该规则检测断言是否记录内部假定和常量 [CODSTA-11] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
该规则检测断言是否记录内部假定和常量 [CODSTA-11-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检测断言是否记录内部假定和常量。
"使用断言或等价类判断记录内部假定 
不要在断言中写有副作用的表达式。
避免 assert(false) 而推荐使用 assert(!"informational message"). 
大多数编译器将在错误输出中打印这些字符串。“



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改善代码效率同时预防错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;assert.h&gt;
void foo( ) {
   int i = 0;
   assert( i++ != 0 ); // 违规
   assert(i=5);        // 违规
   assert(false);      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;assert.h&gt;
void foo( ) {
   int i = 0;
   assert(i != 0);                   // OK
   assert(!"informational message"); // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Error Handling and Exceptions", Rule 68

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.25 Expressions &amp; References, AV Rule 204

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-12</key>
<configkey>CODSTA-12</configkey>
<name><![CDATA[ 避免使用移位操作，尽量使用算术操作 [CODSTA-12] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用移位操作，尽量使用算术操作 [CODSTA-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule detects code that uses shift operations instead of arithmetic
operations. "Avoid using shift operations instead of arithmetic operations."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule improves readability and maintainability and prevents confusion.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int c = 8 &lt;&lt; 2;  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Avoid using shift operations.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.8">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.8</A>
From: 18 Portable Code - 18.8 Pointer Arithmetic - Port. Rec. 17

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-13</key>
<configkey>CODSTA-13</configkey>
<name><![CDATA[ 避免指针用于算数运算 [CODSTA-13] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免指针用于算数运算 [CODSTA-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule detects code that uses pointer arithmetic.
"Avoid pointer arithmetic. Pointer arithmetic can be portable. 
The operators == and != are defined for all pointers of the same type, 
while the use of the operators &lt;, &gt;, &lt;=, &gt;= are portable 
only if they are used between pointers which point into the same array."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Prevents confusion of types (e.g., in comparison).



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* returnptr();
void foo() {
  int* a;
  char* b;

  if (a == b) {}		// Violation
  if (returnptr( ) &gt;= b) {}	// Violation
  if (b &lt; returnptr( )) {}	// Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not use pointer arithmetic.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.8">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.8</A>
   From: 18 Portable Code - 18.8 Pointer Arithmetic - Port. Rec. 18

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-14</key>
<configkey>CODSTA-14</configkey>
<name><![CDATA[ 禁止将 const 转换成非 const [CODSTA-14] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止将 const 转换成非 const [CODSTA-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

Cast away const on an object whose original definition was const may prove to
undefined behaviour. Compilers can put constant data into ROM or write-protected
RAM pages and casting away const from such a const object often causes
a memory fault.
The rule detects casts that remove a const qualification from the type addressed
by a pointer or reference. 
Besides it detects an implicit cast from a string literal to char*.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents undefined behaviours.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( const int a, const int* b ) {
    int x;
    int* y;
    (int&amp;) a = x;         // Violation
    y = (int*) b;         // Violation
    *y = 10;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Avoid casting away const.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 13 Type Conversions - Rule 46

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Type Safety", Rule 94

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-15</key>
<configkey>CODSTA-15</configkey>
<name><![CDATA[ 当数组作为参数传入一个函数时不要声明数组的大小 [CODSTA-15] ]]></name>
<tag>codsta</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当数组作为参数传入一个函数时不要声明数组的大小 [CODSTA-15-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule detects if the size of an array is declared when the array
is passed into a function as a parameter. Do not declare the
magnitude of a single dimensional array in the argument declaration.
The 'C' language will pass an array argument as a pointer to the first
element in the array.In fact, different invocations of the function
may pass array arguments with different magnitudes. Therefore,
specifying the magnitude of an array in a function argument definition
might complicate software maintenance.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Prevents potential loss of data.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo2(int ii[30])                // Violation
{ 
}
void foo3(char a,int ii[30][30][30]) // Violation
{ 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(int ii[])                  // OK
{ 
}
void foo4(char a,int ii[][30][30])  // OK
{ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards R-7

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-16</key>
<configkey>CODSTA-16</configkey>
<name><![CDATA[ 不要声明已经初始化的数组的大小 [CODSTA-16] ]]></name>
<tag>codsta</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要声明已经初始化的数组的大小 [CODSTA-16-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule detects if the size of an array is declared when the array
is initialized. When global arrays are initialized in the definition,
their magnitude shall be set by initialization. By allowing the
magnitude of an array to be set automatically during definition,
changes to the number of elements in the initialization list do not
require corresponding changes to the explicit array size.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Makes code easier to maintain.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define SIZE 4
int tab1[SIZE] = {1,2,3}; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int tab2[]={1,2,3};       // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards, R-6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-17</key>
<configkey>CODSTA-17</configkey>
<name><![CDATA[ 不允许指针与 NULL 比较或者将 NULL 赋值给指针； 请使用0替代 [CODSTA-17] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许指针与 NULL 比较或者将 NULL 赋值给指针； 请使用0替代 [CODSTA-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检查代码中是否存在指针与NULL比较或者将NULL赋值给指针的情况
“不允许指针与 NULL 比较或者将 NULL 赋值给指针； 请使用0替代”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

按照 ANSI-C 标准, NULL 定义为 (void*)0 或者 0.
若该定义在 ANSI-C++，则可能出现问题。
如果 NULL 被定义为类型 void*, 则没有显示类型转
换的情况下,不能赋给任意其他类型的指针。


事例：

#include &lt;stddef.h&gt;
void foo( ) {
    int *lp = NULL; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
void foo( ) {
    int *lp = 0; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 12 Pointers and References - Rule 42

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 175

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-18</key>
<configkey>CODSTA-18</configkey>
<name><![CDATA[ 选择使用 while 而非 do 语句 [CODSTA-18] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
选择使用 while 而非 do 语句 [CODSTA-18-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks that code prefers "while" statements over "do" statements.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Using do statements can lead to errors and confusion. 
Using while statements instead of do statements can
make code clearer and help prevent errors.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void func( ) 
{
    int i = 0;
    do        // Violation
    {
        i++;
    } while ( i &lt; 10);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void func( ) 
{
    int i = 0;
    while (i &lt; 10)    // OK
    {  
        i++;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-19</key>
<configkey>CODSTA-19</configkey>
<name><![CDATA[ 使用 ctype.h 的函数对字符测试 [CODSTA-19] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 ctype.h 的函数对字符测试 [CODSTA-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks that code uses the ctype.h facilities for character test.
The ctype.h facilities for character tests and upper-lower conversions
(isalnum, isalpha, iscntrl, isdigit, isgraph, islower, isprint, ispunct,
isspace, isupper, isxdigit, tolower, toupper) are portable across different
character code sets, are usually very efficient, and promote international
flexibility.  However, other similarly named functions 
(such as _tolower, _toupper, _isascii) are not universally portable.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Using function from ctype.h for char testing makes
code more portable across different character code sets.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;ctype.h&gt;
void test(char c) {
   if( 'a' &lt;= c &amp;&amp; c &lt;= 'z') {       // Violation
   }
  
   while( 'A' &lt;= c &amp;&amp; c &lt;= 'Z') {	// Violation
   }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;ctype.h&gt;
void test(char c) {
   if(islower(c))	                // OK
    {
    }
   while(isupper(c))           // OK
    {
    }  
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.gnu.org/software/libc/manual/html_node/Character-Handling.html">http://www.gnu.org/software/libc/manual/html_node/Character-Handling.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-20</key>
<configkey>CODSTA-20</configkey>
<name><![CDATA[ 使用 EOS 作为字符串的结尾，不要使用 NULL [CODSTA-20] ]]></name>
<tag>codsta</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 EOS 作为字符串的结尾，不要使用 NULL [CODSTA-20-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks that EOS is used to terminate a string. 
EOS should be used to terminate a string rather than NULL,
since NULL is not guaranteed to be defined as zero.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Promotes the use of defined constants rather than hard coded values.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
#define EOS '\0'

void foo( ) {
    char str[30] = "Sample text.";
    str[7] = NULL;                        // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
#define EOS '\0'
void foo( ) {
    char str[30] = "Sample text.";
    str[7] = EOS;                          // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards G-11

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-21</key>
<configkey>CODSTA-21</configkey>
<name><![CDATA[ 使用 enum 时，每个成员的值必须显式声明 [CODSTA-21] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 enum 时，每个成员的值必须显式声明 [CODSTA-21-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

When using enum, the values of each member should be explicitly declared.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Explicit declarations of each member’s values is valuable documentation
when using an emulator, logic analyzer or other debugging device.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum my_enum1 
{
    a,      // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum my_enum2
{
    a = 0  // OK       
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards G-15

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-22</key>
<configkey>CODSTA-22</configkey>
<name><![CDATA[ 局部变量或参数名和类成员变量或父类、结构体成员变量名称至少要求2个字符或以上不同 [CODSTA-22] ]]></name>
<tag>codsta</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
局部变量或参数名和类成员变量或父类、结构体成员变量名称至少要求2个字符或以上不同 [CODSTA-22-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检查代码中是否局部变量或参数名和
类成员变量或父类、结构体成员变量名称至
少要求2个字符或以上不同。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

不区分大小写字母
只有一个字符的变量直接跳过不做检查



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和防止所写代码混淆。


事例：

class Base {
    void foo( ) {
        float memberF;      // 违规
    }
    int foo1( );
    short foo2( ) {
        for( int _var2 = 0; _var2 &lt; 10; _var2++ ) {    // 违规
        }
        return Var3;
    }
public:
    int Member;
    float Var1;
    float Var2;
    short Var3;
};

int Base::foo1( ) {
    int _var1 = 6;         // 违规
    return _var1;
} 

class A : public Base {
    void foo( ) {
        float memberF;      // 违规
    }
    int foo1( );
    short foo2( ) {
        for( int _var2 = 0; _var2 &lt; 10; _var2++ ) {    // 违规
        }
        return Var3;
    }
};

int A::foo1( ) {
    int _var1 = 6;         // 违规
    return _var1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
    void foo( ) {
        float fLocal;      // OK
    }
    int foo1( );
    int x;
    short foo2( ) {
        int y;             // OK
        for( int iValue = 0; iValue &lt; 10; iValue++ ) {    // OK
        }
        return Var3;
    }
public:
    int Member;
    float Var1;
    float Var2;
    short Var3;
};

int Base::foo1( ) {
    int iValue = 6;        // OK
    return iValue;
} 

class A : public Base {
    void foo( ) {
        float fLocal;      // OK
    }
    int foo1( );
    int x;
    short foo2( ) {
        int y;             // OK
        for( int iValue = 0; iValue &lt; 10; iValue++ ) {    // OK
        }
        return Var3;
    }
};

int A::foo1( ) {
    int iValue = 6;        // OK
    return iValue;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-23</key>
<configkey>CODSTA-23</configkey>
<name><![CDATA[ 所有的 'if' 语句必须有对应的 'else' 子句 [CODSTA-23] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的 'if' 语句必须有对应的 'else' 子句 [CODSTA-23-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation on 'if' statement without an 'else' statement.
See also: MISRA2004-14_10



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule ensures proper data flow and improves readability and maintainability.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int a, int b) {
    if(a &gt; b){          // Violation
        return a - b;
    }

    if(a &lt; b){          // Violation
    	return b - a;
    }

    if(a == b)          // Violation
        return 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int a, int b) {
    if(a &gt; b){          // OK
        return a - b;
    } else if(a &lt; b){   // OK
    	return b - a;
    } else {
    	return 1;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-24</key>
<configkey>CODSTA-24</configkey>
<name><![CDATA[ 如果打算定义 FALSE，#define FALSE 必须为 0 [CODSTA-24] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果打算定义 FALSE，#define FALSE 必须为 0 [CODSTA-24-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether you defined FALSE as 0.
See also: CODSTA-25



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Any use of FALSE-- other than defining FALSE as 0-- is misleading
and will not be guaranteed to work predictably.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define FALSE 1 // Violation
#undef FALSE
#define FALSE   // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define FALSE 0 // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.research.att.com/~bs/glossary.html#Gfalse">http://www.research.att.com/~bs/glossary.html#Gfalse</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-25</key>
<configkey>CODSTA-25</configkey>
<name><![CDATA[ 如果打算定义 FALSE， 枚举值 FALSE 必须为 0 [CODSTA-25] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果打算定义 FALSE， 枚举值 FALSE 必须为 0 [CODSTA-25-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks if FALSE is defined as 0. 
See also: CODSTA-24, CODSTA-43



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Any use of FALSE-- other than defining FALSE as 0-- is misleading
and will not be guaranteed to work predictably.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifndef FALSE
typedef enum
{
    TRUE = 1,
    FALSE = -1  // Violation
} BOOL ;
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef FALSE
typedef enum
{
    TRUE = 1,
    FALSE = 0   // OK
} BOOL ;
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.research.att.com/~bs/glossary.html#Gfalse">http://www.research.att.com/~bs/glossary.html#Gfalse</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-26</key>
<configkey>CODSTA-26</configkey>
<name><![CDATA[ 避免使用幻数 [CODSTA-26] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用幻数 [CODSTA-26-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

代码中避免出现数字常量。 这些数字不具备自我解释的能力。
使用有意义的字符替代。
参见： CODSTA-29



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

初始化的数字常量不在检查之列。
0 和 1 同样被排除因为其值为true或者false。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改善可读性和可维护性。


事例：

void boo(int);

int foo( int a[], int b ) {
    int e;
    int f = 0;  
    a[5] = 56; // 违规
    e= 8;      // 违规
    boo(56);   // 违规
    return 8;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int MAX = 8;       // OK

void boo(int);

int foo( float a[], float b ) {
    int e;
    int f = 0;        // OK  
    int i = 5;        // OK
    a[i] = MAX;       // OK
    e = MAX;          // OK
    boo(a[5]);        // OK
    return  MAX;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Coding Style", Rule 17

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.18 Constants, AV Rule 151

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-27</key>
<configkey>CODSTA-27</configkey>
<name><![CDATA[ 避免在函数内修改全局变量 [CODSTA-27] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在函数内修改全局变量 [CODSTA-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if in function is modified:
- a global variable, or
- a member variable of global object, or
- an element of global array



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

In multithread environment using global
variables makes code extremely error prone.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S {
	int a;
}g_struct;

int g_i;
int g_arr[10];

void foo(){
    g_i++;             // Violation
    g_struct.a = 10;   // Violation
    g_arr[3] += 2;     // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not modify global variables.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://charm.cs.uiuc.edu/manuals/html/tcharm/2_1.html">http://charm.cs.uiuc.edu/manuals/html/tcharm/2_1.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-28</key>
<configkey>CODSTA-28</configkey>
<name><![CDATA[ 必须为联合体的声明定义字段 [CODSTA-28] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
必须为联合体的声明定义字段 [CODSTA-28-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule is purely informational and will report a message
when a union declaration is found which has no field defined.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Prevents form incomplete code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

union UNKNOWN     // Violation
{
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

union KNOWN	// OK
{
   int a;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-29</key>
<configkey>CODSTA-29</configkey>
<name><![CDATA[ 尽可能使用 "#define" 或枚举(enum)常量，而非硬编码的数值 [CODSTA-29] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽可能使用 "#define" 或枚举(enum)常量，而非硬编码的数值 [CODSTA-29-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether you are avoiding using hard coded values. Using #define
or enum constants rather than hard coded values promotes the maintainability
of 'C' code by creating a localized area for changes.
See also: CODSTA-26



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

Rule active for C code only.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Readability and maintainability.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int tabColors[256];         // Violation
    if (tabColors[2] == 1) {    // Violation
        /*...*/
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define buff 256
#define OK 1

enum color {
    RED = 0,
    BLUE = 1,
    GREEN = 2
    /*...*/
};

void foo( ) {
    int tabColors[buff];        // OK
    if (tabColors[RED] == OK) { // OK
        /*...*/
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 10 Constants - Rule 37

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-30</key>
<configkey>CODSTA-30</configkey>
<name><![CDATA[ 避免返回句柄(指针或者引用)给函数的参数 [CODSTA-30] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免返回句柄(指针或者引用)给函数的参数 [CODSTA-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

A function must never return a pointer or reference to a parameter,
it could make your code non-deterministic. If a function returns 
a reference or a pointer to a parameter, the memory to which it refers 
will already have been deallocated, when this reference or pointer 
is used. The compiler may or may not give a warning for this.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents non-deterministic behaviour.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* foo1( int x ){
    return &amp;x;       // Violation
}

int&amp; foo2( int x ){
    return x;        // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1( int x ){
    return x;        // OK
}

int foo2( int x ){
    return x;        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-31</key>
<configkey>CODSTA-31</configkey>
<name><![CDATA[ 不要使用显示类型转换（强制） [CODSTA-31] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用显示类型转换（强制） [CODSTA-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

”不要使用显示类型转换（强制）。“



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则只针对基本类型。


例外：

显示类型转换可能被用于将指针转化为一个指向
继承类的基类指针。
将匿名比特流(bit-stream)转化为一个对象时，必须使用
显示类型转换。
一般地，当读取一个外部的对象时需要用到
显示类型转换。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范使得代码更清晰，增强代码可维护性。


事例：

void foo( ) {
    const int ci = 0;
    int i;
    i = (int) ci;    // 违规
    i = (int) &amp;i;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不使用强制类型转换



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 13 Type Conversions - Rule 43

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 183

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-32</key>
<configkey>CODSTA-32</configkey>
<name><![CDATA[ 如果判断的是指针，则不能使用类似于 if(test) 或 if(!test) 的逻辑表达式 [CODSTA-32] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果判断的是指针，则不能使用类似于 if(test) 或 if(!test) 的逻辑表达式 [CODSTA-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Do not write logical expressions of the type if(test) or if(!test) 
when test is a pointer.(...)
We do not recommend logical tests such as if(pointer) 
if pointer is a variable of pointer-type. 
The only reason is readability, many programmers find it difficult to read
such code."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule improves readability of code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int* ptr;
    if (ptr) {  // Violation
    }
    if (!ptr) { // Violation
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int* ptr;
    if (ptr == 0) { // OK
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Origin: Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 14 Flow Control Structures - Rec. 55

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-33</key>
<configkey>CODSTA-33</configkey>
<name><![CDATA[ 在 if, while 或 switch 语句的条件表达式中不要使用 ++ 或 -- 操作符 [CODSTA-33] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 if, while 或 switch 语句的条件表达式中不要使用 ++ 或 -- 操作符 [CODSTA-33-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

Using the operator ++ or -- in the conditional part of if, while or switch can 
make code difficult-to-read and error-prone.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Makes code more readable.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int Foo (int iVar)
{	
    if (iVar-- &amp;&amp; iVar&lt;10)  // Violation 
    {
        iVar += 10;
    } 
    else 
    {
        iVar -= 10;
    }
    return iVar;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int Foo (int iVar)
{	
    if (iVar&lt;10)  // OK
    {
        iVar += 10;
    } 
    else 
    {
        iVar -= 10;
    }
    return iVar;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-34</key>
<configkey>CODSTA-34</configkey>
<name><![CDATA[ 使用typedef定义函数指针以使其更简洁 [CODSTA-34] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用typedef定义函数指针以使其更简洁 [CODSTA-34-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

”使用typedef定义函数指针以使其更简洁“



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

”使用typedef的另一个原因是增强代码可读性。
如果使用指向函数的指针， 易造成代码可读性差。
通过给函数指定类型声明可以避免此类情况。“


事例：

void (*p)();                 // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef void (*PTF)();

PTF p;              // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 12 Pointers and References - Rec. 49

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 176

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-35</key>
<configkey>CODSTA-35</configkey>
<name><![CDATA[ 为 switch 语句提供 default 分支 [CODSTA-35] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
为 switch 语句提供 default 分支 [CODSTA-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“为 switch 语句提供 default 分支 
用于处理异常情况。”
该规则检测是否为 switch 语句提供默认
分支。 如果所有预期的情况在其他分支中
处理，则 default 分支能用于错误检查。
参见： MISRA2004-15_3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防错误发生的可能性。


事例：

void foo( ) {
    int tag;
    switch ( tag ) {	// 违规
    case 0: {
        break;
            }
    case 1: {
        foo( );
        break;
            }
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int tag;
    switch ( tag ) {	// OK
    case 0: {
        break;
            }
    case 1: {
        foo( );
        break;
            }
    default: break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rule 48

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.24 Flow Control Structures, AV Rule 194

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-36</key>
<configkey>CODSTA-36</configkey>
<name><![CDATA[ 通过值传递内建类型，除非你打算修改该参数 [CODSTA-36] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
通过值传递内建类型，除非你打算修改该参数 [CODSTA-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检查参数是否通过内建的类型进行值传递,
除非需要在函数里修改该参数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

值传递能提高代码效率。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int Foo(int i, int &amp;j)  // 违规
{    
    return i + j;
}
int Bar(int &amp;i, int j)  // 违规
{    
    j += i;
    return j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int Foo(int i, int j)  // OK
{      
    return i + j;
}
int Bar(int i, int j)  // OK
{    
    j += i;
    return j;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc. Chapter: "Take Parameters Appropriately
   by Value, (Smart) Pointer, or Reference", Rule 25

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Functions (Value, Pointer or Reference), AV Rule 116

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-37</key>
<configkey>CODSTA-37</configkey>
<name><![CDATA[ 除了只用于 #ifs 和 #elifs 条件中的以外不要使用防止编译器检查类型的 #define 指令 [CODSTA-37] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
除了只用于 #ifs 和 #elifs 条件中的以外不要使用防止编译器检查类型的 #define 指令 [CODSTA-37-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether you use a #define that the compiler cannot check type. 
Using a #define prevents the compiler from checking the type . 
See also: MISRA2004-19_7, CODSTA-03, CODSTA-38



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

Rule skips #defines which are used only in #ifs and #elifs conditions.
Rule works only within file scope. 
It means that each source and header files are parsed one by one.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

By following this rule, you prevent the compiler from disabling type checking.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define V1 20      // Violation
#define V2 1       // OK
#if V2
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int V1 = 20; // OK
#define V2 1       // OK
#if V2
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., Chapter 1, Item 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-38</key>
<configkey>CODSTA-38</configkey>
<name><![CDATA[ 不要使用防止编译器检查类型的 #define 指令 [CODSTA-38] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用防止编译器检查类型的 #define 指令 [CODSTA-38-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether you use a #define that the compiler cannot check type.
Using a #define prevents using unchecked types.
See also: MISRA2004-19_7, CODSTA-03, CODSTA-37



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

By following this rule, you prevent the compiler from disabling type checking.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MAX_COMPUTERNAME_LENGTH   10
#define MACHINE_NAME_LEN   MAX_COMPUTERNAME_LENGTH + 2    // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int MAX_COMPUTERNAME_LENGTH = 10;
const int MACHINE_NAME_LEN = MAX_COMPUTERNAME_LENGTH + 2; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., Chapter 1, Item 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-39</key>
<configkey>CODSTA-39</configkey>
<name><![CDATA[ 避免内部或外部变量名字与C++保留字冲突 [CODSTA-39] ]]></name>
<tag>codsta</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免内部或外部变量名字与C++保留字冲突 [CODSTA-39-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果编译器用C编译器编译，内部或外部变量名字
与C++保留字冲突时会造成问题。 大多数C编译器不会报告
命名冲突, 这将导致意想不到的问题。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免不可预知的程序行为。


事例：

int bool  = 0;		// 违规
int catch = 0;		// 违规
int class = 0;		// 违规
int const_cast = 0;	// 违规
int delete = 0;		// 违规
int dynamic_cast = 0;	// 违规
int explicit = 0;	// 违规
int export = 0;		// 违规
int false = 0;		// 违规
int friend = 0;		// 违规
int mutable = 0;	// 违规
int namespace = 0;	// 违规
int new = 0;		// 违规
int operator = 0;	// 违规
int private = 0;	// 违规
int public = 0;		// 违规
int protected = 0;	// 违规
int reinterpret_cast = 0;	// 违规
int static_cast = 0;	// 违规
int template = 0;	// 违规
int this = 0;		// 违规
int throw = 0;		// 违规
int true = 0;		// 违规
int try = 0;		// 违规
int typeid = 0;		// 违规
int typename = 0;	// 违规
int using = 0;		// 违规
int virtual = 0;	// 违规
int wchar_t = 0;	// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// 避免使用保留字作为变量名字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-40</key>
<configkey>CODSTA-40</configkey>
<name><![CDATA[ 如果函数没有参数也没有返回值，应使用 'void' [CODSTA-40] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数没有参数也没有返回值，应使用 'void' [CODSTA-40-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

In many compiler implementations, functions which do not declare return
type are automatically assigned int return type. This will conflict with
semantics of function implementation.
The empty parameter list in a function declarator that is not part of
a definition of that function specifies that no information about
the number or types of the parameters is supplied. The special case
of an unnamed parameter of type void as the only item in the list
specifies that the function has no parameters.
Explicitly specifying parameter and return types as void clearly conveys
the function intent.

The rule reports a violation if:
- a function is declared or defined with an empty parameter list or
- a function does not have an explicit return type and does not contain
  return statement with a value
The rule is enabled only for C language.

See also: MISRA2004-8_2_a, MISRA2004-16_5



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1();         /* Violation - there is no 'void' in parameter list */
void foo1() {}       /* Violation - there is no 'void' in parameter list */

foo2(void);          /* Violation - there is no 'void' in return type */
foo2(void) {}        /* Violation - there is no 'void' in return type */
foo3(void) {return;} /* Violation - there is no 'void' in return type */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(void);          /* OK */
void foo1(void) {}        /* OK */

void foo3(void) {return;} /* OK */

foo4(void){ return 0;} /* OK - the 'return' statement with a value in function */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 16

2. Origin: Misra Guidelines - Rule 76

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-41</key>
<configkey>CODSTA-41</configkey>
<name><![CDATA[ 避免只有一个 case 分支的 swtich 语句 [CODSTA-41] ]]></name>
<tag>codsta</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免只有一个 case 分支的 swtich 语句 [CODSTA-41-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

A switch statement should not be used with only one case statement in its body.
Such a switch statement can be described using an if statement.
See also: CODSTA-54, MISRA2004-15_5



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Avoids improper use of switch.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo (int i)
{
    switch(i)          // Violation 
    {
        case 0:
            break;
        default:
            break;
    } 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo (int i)
{
    if(i == 0)         // OK
    {
	// ... 
    } else {
        // ...
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-42</key>
<configkey>CODSTA-42</configkey>
<name><![CDATA[ 如果打算定义 TRUE， #define TRUE 必须为 1 [CODSTA-42] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果打算定义 TRUE， #define TRUE 必须为 1 [CODSTA-42-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether preprocessor 
definition of TRUE is 1. Any other use of TRUE is 
misleading and cannot be guaranteed to work 
predictably.
See also: CODSTA-43



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Readability and maintainability.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define TRUE 0 // Violation
#undef TRUE
#define TRUE   // Violation
#undef TRUE



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define TRUE 1 // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.research.att.com/~bs/glossary.html#Gtrue">http://www.research.att.com/~bs/glossary.html#Gtrue</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-43</key>
<configkey>CODSTA-43</configkey>
<name><![CDATA[ 如果打算定义 TRUE， 枚举值 TRUE 必须为 1 [CODSTA-43] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果打算定义 TRUE， 枚举值 TRUE 必须为 1 [CODSTA-43-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether you defined const enum TRUE as 1. Any 
other use of TRUE is misleading and cannot be 
guaranteed to work predictably.
See also: CODSTA-42, CODSTA-25



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Readability and maintainability.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifndef TRUE
typedef enum
{
    FALSE = 0,
    TRUE = 3    // Violation
} BOOL ;
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef TRUE
typedef enum
{
    FALSE = 0,
    TRUE = 1    // OK
} BOOL ;
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.research.att.com/~bs/glossary.html#Gtrue">http://www.research.att.com/~bs/glossary.html#Gtrue</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-44</key>
<configkey>CODSTA-44</configkey>
<name><![CDATA[ 局部变量和类、父类、父结构体应该有不同的名字 [CODSTA-44] ]]></name>
<tag>codsta</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
局部变量和类、父类、父结构体应该有不同的名字 [CODSTA-44-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检查局部变量和类、父类、父结构体的变量
是否有相同的名字 (大小写敏感)。 
如果这样， 那么将报告违规。
参见： CODSTA-45



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则增强代码可读性，防止出现含混不清的代码。


事例：

class Base {
public:
    int member;
    float var1;
    float var2;
    short var3;

    void foo( ) {
        float member;                                   // 违规
    }

    short foo2( ) {
        for( int var2 = 0; var2 &lt; 10; var2++ ) {  // 违规
        }
        return var3;
    }
};


class A : public Base {
    void foo( ) {
        float member;                                   // 违规
    }
    int foo1( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    int member;
    float var1;
    float var2;
    short var3;

    void foo( ) {
        float member2;                                     // OK
    }

    short foo2( ) {
        for( int var4 = 0; var4 &lt; 10; var4++ ) {     // OK
        }
        return var3;
    }
};

class A : public Base {
    void foo( ) {
        float member2;                                     // OK
    }
    int foo1( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-45</key>
<configkey>CODSTA-45</configkey>
<name><![CDATA[ 该规则检查局部变量和类、父类、父结构体的变量是否有不同的名字 [CODSTA-45] ]]></name>
<tag>codsta</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
该规则检查局部变量和类、父类、父结构体的变量是否有不同的名字 [CODSTA-45-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检查局部变量和类、父类、父结构体的变量
是否有相同的名字 (大小写敏感)。 
如果这样， 那么将报告违规。
参见： CODSTA-44



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则增强代码可读性，防止出现含混不清的代码。


事例：

class Base {
public:
    int member;
    float var1;
    float var2;
    short var3;

    void foo( double var3 ) {  // 违规
        float member;    
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    int member;
    float var1;
    float var2;
    short var3;

    void foo( double var4 ) {   // OK
        float member;    
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-46</key>
<configkey>CODSTA-46</configkey>
<name><![CDATA[ 尽量使用正逻辑而不是负逻辑 [CODSTA-46] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽量使用正逻辑而不是负逻辑 [CODSTA-46-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在实际代码编写中，使用正逻辑而不要使用负逻辑。
在表达式中出现很多逻辑符号 "!" 
使得表达式难以理解和维护。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

增强源代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int *j) 
{
    if(j!=0){     // 违规
        (*j)++;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int *j) 
{
    if(j==0){
    } else {     // OK
        (*j)++; 
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards G-13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-47</key>
<configkey>CODSTA-47</configkey>
<name><![CDATA[ 所有的结构都应该有 typedefs [CODSTA-47] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的结构都应该有 typedefs [CODSTA-47-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在C语言中，结构体声明看起来像一个结构体类型
的变量声明。 针对结构体使用 typedef 可以使结
构体类型的变量声明与内建的类型声明保持一致，
从而增强代码可读性。此外，使用 typedef 预防由于 
变量声明导致的语法错误。


例外：

该规则仅针对C代码。在C++中，关键词 struct 定义
类型， typedefs不行必须的，当然使用也可以。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则增强代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct A {    // 违规 - no typedef
    int i;
};

struct B {    // 违规 - no typedef
    int i;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef struct A {    // OK
    int i;
} A_t;

struct B {                // OK
    int i;
};
typedef struct B B_t;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Customer guidelines

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-48</key>
<configkey>CODSTA-48</configkey>
<name><![CDATA[ 不要使用下列合体字母<%, %>, <:, :>, %:, %:%: [CODSTA-48] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用下列合体字母&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%: [CODSTA-48-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用下列合体字母&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:
该规则中的合体字母使得简单结构体含义不清。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则增强代码的可读性。


源自：

v7.1


事例：

int a &lt;: 2 :&gt; &lt;: 2 :&gt; = &lt;%&lt;%0,1%&gt;,&lt;%2,3%&gt;%&gt;; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int a[2][2] = { {0,1}, {2,3} };              // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.4 Environment, AV Rule 12

2. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 2, Rule 2-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-49</key>
<configkey>CODSTA-49</configkey>
<name><![CDATA[ 如果 'for' 语句中无初始化或者无自增运算符；建议采用while循环替代 [CODSTA-49] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果 'for' 语句中无初始化或者无自增运算符；建议采用while循环替代 [CODSTA-49-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果 'for' 语句中无初始化或者无自增运算符，
建议采用while循环替代。
该规则将报告违规提示，如果 'for' 语句
无初始化或无自增运算。 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

void foo()
{
  for(int i=0; i&lt; 10;) // 违规
  {
     /* ... */
  }

  int j = 0;
  for(; j&lt; 10;)        // 违规
  {
     /* ... */  
  }
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

while循环是一种更自然表示法。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
  int i = 0;

  while(i&lt; 10)     // OK
  {
     /* ... */  
  }
  
  int j = 0;

  while(j&lt; 10)     // OK
  {
     /* ... */  
  }

}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.24 Flow Control Structures, AV Rule 200

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-50</key>
<configkey>CODSTA-50</configkey>
<name><![CDATA[ 十六进制常量应该使用大写字母表示 [CODSTA-50] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
十六进制常量应该使用大写字母表示 [CODSTA-50-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

十六进制常量应该使用大写字母表示。
参见： CODSTA-51



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

int i = 0x3fff;   // 违规



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

改善可读性和可维护性。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int i = 0x3FFF;   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.18 Constants, AV Rule 150

2. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 2, Rule 2-13-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-51</key>
<configkey>CODSTA-51</configkey>
<name><![CDATA[ 字面量后缀将使用大写字母而不是小写字母 [CODSTA-51] ]]></name>
<tag>codsta</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字面量后缀将使用大写字母而不是小写字母 [CODSTA-51-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

字面量后缀将使用大写字母而不是小写字母。
参见: CODSTA-50



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(long param = 64l)  // 违规
{
	const long a = 64l; // 违规
	
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(long param = 64L)  // OK
{
	const long a = 64L;     // OK
}


参考文献:

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.4 章 Environment, AV 规则 14

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 2 节, 规则 2-13-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-52</key>
<configkey>CODSTA-52</configkey>
<name><![CDATA[ 在 for 循环中的除了初始化参数值，不应该执行其他动作。 [CODSTA-52] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 for 循环中的除了初始化参数值，不应该执行其他动作。 [CODSTA-52-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在 for 循环中的除了初始化参数值，
不应该执行其他动作。
注意初始化表达式可能调用一个存储器，
该存储器将返回一个序列中的值用于初始化:
for (Iter_type p = c.begin() ; p != c.end() ; ++p) // Good
{
 // ...
}



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

void foo()
{
 	int k = 0;
	
        /* ... */
 	 	
	for(; k&gt;0; k--){}                // 违规
	for(int i=0, k=2; k&gt;0; k--){}    // 违规
	for(int i = k+2-10; k&gt;0; k--){}  // 违规
	for(k--; k&gt;0; k--){}             // 违规
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改进代码可读性。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
 public:
  int i;
  int moo();
};

void foo()
{
 	int k = 0;
 	A obj;
	
        /* ... */
 	 	
	for(k=2; k&gt;0; k--){}           // OK
	for(int i =0; i&gt;0; i--){}      // OK
	for(k = obj.i; k&gt;0; k--){}     // OK
	for(k = obj.moo(); k&gt;0; k--){} // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.24 Flow Control Structures, AV Rule 198

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-53</key>
<configkey>CODSTA-53</configkey>
<name><![CDATA[ For 循环的增量表达式除了改变循环参数外，不应该执行其他任何动作 [CODSTA-53] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
For 循环的增量表达式除了改变循环参数外，不应该执行其他任何动作 [CODSTA-53-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

for 循环的增量表达式除了改变循环参数外，
不应该执行其他任何动作



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

void foo()
{
    int k = 0;

    for(;k&gt;0; ){}                 // 违规
    for(int i=0; k&gt;0; k--, i++){} // 违规
    for(k--; k&gt;0; k+1){}          // 违规
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改善代码可读性。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void zoo(){}

class A
{
public:
    int i;
};

void foo()
{
    int k = 0;
    A obj;
    
    for(int i = k+2-10; k&gt;0; zoo()){} // OK
    for(k=2; k&gt;0; k--){}              // OK
    for(int i =0; i&gt;0; i=i-1){}       // OK
    for(k = obj.i; k&gt;0; k-=1){}       // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.24 Flow Control Structures, AV Rule 199

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-54</key>
<configkey>CODSTA-54</configkey>
<name><![CDATA[ 每个 switch 语句至少有两个 case 分支和一个 default 分支 [CODSTA-54] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每个 switch 语句至少有两个 case 分支和一个 default 分支 [CODSTA-54-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个 switch 语句至少有两个 case 分支和一个 default 分支。
参见： CODSTA-41, MISRA2004-15_5



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

void foo(int i) 
{
    switch(i)      // 违规
    {
        default:
            ;
    }
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

更自然表示法。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      // OK
    {
      case 1:
      	break;
      case 2:
      	break;
      default:
            ;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.24 Flow Control Structures, AV Rule 196

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-55</key>
<configkey>CODSTA-55</configkey>
<name><![CDATA[ Case 语句的标签应该使用枚举(enum)类型而不是直接使用整数或常数 [CODSTA-55] ]]></name>
<tag>codsta</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Case 语句的标签应该使用枚举(enum)类型而不是直接使用整数或常数 [CODSTA-55-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果需要从有限的数据中做选择，使用枚举类型替代
整数类型（以及常量）。 当整形（常量）被作为
 case 的条件时，规则将报告一个违规信息。


例外：

该规则不会排除字符串 (例如 'A', 'B' 等等)
作为 case 的条件。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

增强代码调试，可读性以及可维护性。 
注意编译器标签（如果可用）应该被设置生
成一个警告，如果有些枚举类型没有出现在 switch 语句中。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int color)
{
	switch(color)
	{

 	case 1:        // 违规
 			break;
 	case 2:        // 违规
 			break;
 	case 3:        // 违规
 			break;
 	default:
			break;
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum color 
{
    RED = 1,
    BLUE = 2,
    GREEN = 3
};

void foo(int color)
{
	switch(color)
	{

 	case RED:      // OK 
 			break;
 	case BLUE:     // OK
 			break ;
 	case GREEN:    // OK
 			break;
 	default: 
			break;
	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.18 Constants, AV Rule 148

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-56</key>
<configkey>CODSTA-56</configkey>
<name><![CDATA[ 开关('switch')语句的所有 'case' 和 'default' 标签应该有一个显式的 'break' 或 'return' 语句， 或者 'fall through'(落空) 注释 [CODSTA-56] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
开关('switch')语句的所有 'case' 和 'default' 标签应该有一个显式的 'break' 或 'return' 语句， 或者 'fall through'(落空) 注释 [CODSTA-56-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

'switch' 语句中的 'case' 和 'default'标签应该包含：
- 一个显示的 'break' 或 a 'return' 语句或
- 如果有 "fall through" 的情况，则添加一个'fall through'的注释
  （用于检测大小写敏感）。


例外：

该规则对空的标签不会报告违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防未预期的程序行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void MyFunction(int i, int j)
{
    switch(i)
    {
    case 1:           // 违规
        i++;
    case 2:
    case 3:           // 违规
        i++;
        /* wrong comment */
    case 4:           // 违规 - 'break' and 'return' are nested 
    	if(j &gt; 5){
    	    i--;
    	    break;
    	} else {
    	    return i;
    	}

    default:          // 违规
        ;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void MyFunction(int i, int j)
{
    switch(i)
    {
    case 1:            // OK
        i++;
        break;
    case 2:            // OK - empty label
    case 3:            // OK
        i++;
        /* fall through */
    case 4:            // OK
    	if(j &gt; 5){
    	    i--;
    	    break;
    	} else {
    	    return i;
    	}
    	break;
    default:           // OK
        break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-57</key>
<configkey>CODSTA-57</configkey>
<name><![CDATA[ 分号的可疑使用 [CODSTA-57] ]]></name>
<tag>codsta</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
分号的可疑使用 [CODSTA-57-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
描述：

该规则报告一个违规如果分号位于圆括号")"
语句体末尾，（例如，if(e); 或者while(e); 
或者for(e;e;e);等等情况）。


例外：

该规则针对当';'与')'位于不同行
时，不会报告违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防'if', 'while', 或者 'for'语句的意外终止。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int param)
{
  if (param);   // 违规
  
  for(;;)  ;    // 违规  

  while(param); // 违规
  {
  
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int param)
{
  if (param)     // OK
  {
  }
  
  for(;;)        // OK
  ; 

  while(param)   // OK
  {
  
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-58</key>
<configkey>CODSTA-58</configkey>
<name><![CDATA[ 不允许强制转换为 void [CODSTA-58] ]]></name>
<tag>codsta</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许强制转换为 void [CODSTA-58-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
描述：

避免强制转换为 void。 一个 (void) 强制类型转换
符不会造成一个值被转成 void - 它仅创建一个 void 
表达式以及抑制警告。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防编译器和静态分析工具警告。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int someFunction();

void foo()
{
    /* ... */
    (void)someFunction();  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int someFunction();

void foo()
{
    /* ... */
    if(someFunction())   // OK
    {
        /* ... */
    } else{
        /* ... */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-59</key>
<configkey>CODSTA-59</configkey>
<name><![CDATA[ 在声明数组大小和 'malloc' 的内存大小时不应该使用硬编码 [CODSTA-59] ]]></name>
<tag>codsta</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在声明数组大小和 'malloc' 的内存大小时不应该使用硬编码 [CODSTA-59-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
描述：

硬编码作为内存大小传递给malloc和硬编码声明数组大
小降低代码的可读性和可维护性。此时应该使用宏作
为代替，这样所有的硬编码都可以通过简单修改单条
语句实现。


例外：

诸如 [ARRAY_SIZE + 1] 这样的表达式是允许
作为 char 类型数组的声明。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;

void myFunction()
{
    int array[10];      // 违规
    malloc(20);         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;

#define ARRAY_SIZE 10
#define MALLOC_SIZE 20

void myFunction()
{
    int array[ARRAY_SIZE];      // OK
    malloc(MALLOC_SIZE);        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-60</key>
<configkey>CODSTA-60</configkey>
<name><![CDATA[ 避免使用等号运算符 ("==", "!=") 来和 TRUE 宏/枚举(enum)常量相比较 [CODSTA-60] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用等号运算符 ("==", "!=") 来和 TRUE 宏/枚举(enum)常量相比较 [CODSTA-60-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
描述：

避免 "== TRUE" and "!= TRUE" 此类条件检查 
这类检查应该被避免因为true有很多可能值（任何 
非零值均视为true），但宏TRUE或者枚举类型常量
往往被定义为一个固定值，例如为1。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

条件语句中检查 "== TRUE" or "!= TRUE"， 如
果变量为true但不是1的情况下，容易造成危险。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define TRUE 1

void foo()
{
  int a = 10;
  
  if(a==TRUE)      // 违规
  {
    /* ... */
  
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define TRUE 1

void foo()
{
  int a = 10;
  
  if(a)               // OK
  {
    /* ... */
  
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-61</key>
<configkey>CODSTA-61</configkey>
<name><![CDATA[ 在 switch 语句中的最后子句应是 default 语句 [CODSTA-61] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 switch 语句中的最后子句应是 default 语句 [CODSTA-61-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在switch语句中最后一句应是default语句。
对最后一句是default语句的要求是种预防性的编程习惯。
这一句也应采取合适的动作，或者包含一个合适的
评论作为不采取动作的原因。”


例外:

“如果switch语句的条件是枚举类型，并且所有的
枚举器被罗列在CASE的标签中，然后default语句
没有被要求作为与枚举相关联的规则，这种规则是为了
确保枚举被分配的值不超出了枚举器所设定的范围。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了 'switch' 语句的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Colours { RED, BLUE, GREEN } colour;

void foo(int i)
{
	switch( i )              // 违规
	{
		case 0:
			break;
		case 1:
		case 2:
			break;
	}

	switch( colour )         // 违规
	{
		case RED:
			break;
		case GREEN:
			break;
			
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum Colours { RED, BLUE, GREEN } colour;

void foo(int i)
{
	switch( i )              // OK
	{
		case 0:
			break;
		case 1:
		case 2:
			break;
		default:
			break;
	}

	switch( colour )         // OK
	{
		case RED:
			break;
		case BLUE:
			break;
		case GREEN:
			break;

	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-6

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-62</key>
<configkey>CODSTA-62</configkey>
<name><![CDATA[ 强制类型转换不能把一个指向函数的指针转换成其他指针类型，包括一个函数类型的指针 [CODSTA-62] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
强制类型转换不能把一个指向函数的指针转换成其他指针类型，包括一个函数类型的指针 [CODSTA-62-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个函数指针转换为一个非函数指针类型的导致了
未定义行为的发生. 如果一个函数调用被用来
使用一个函数指针转换结果的指针，未定义的行为可能会出现.”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以阻止未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void f ( int )
{
    reinterpret_cast&lt; void (*)( ) &gt;( &amp;f ); // 违规
    reinterpret_cast&lt; void * &gt;( &amp;f );      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要把一个指向函数的指针转换为其他类型的指针类型。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-2-6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-63</key>
<configkey>CODSTA-63</configkey>
<name><![CDATA[ 运算符应只适用于无符号的基本类型操作数 [CODSTA-63] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
运算符应只适用于无符号的基本类型操作数 [CODSTA-63-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“按位运算 (~, &lt;&lt;, &lt;&lt;=, &gt;&gt;, &gt;&gt;=, &amp;, &amp;=, ^, ^=, | 和 |=) 
在被定义的整数或者枚举常量通常是没有意义的。
另外，如果在一个负数上实施右移，将得到一个”
被定义的执行结果。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以防止不确定的行为发生。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1( )
{
    signed short   s1;
    unsigned short us1, us2;

    us1 = us2 &amp; s1;        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1( )
{
    signed short   s1;
    unsigned short us1, us2;

    us1 = us2 &amp; (unsigned short)s1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-0-21

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-64</key>
<configkey>CODSTA-64</configkey>
<name><![CDATA[ 无条件的 throw 或 break 语句应终止一切非空的 switch 子句 [CODSTA-64] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
无条件的 throw 或 break 语句应终止一切非空的 switch 子句 [CODSTA-64-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“无条件的throw或break语句应终止一切非空的
switch语句。如果一个开发人员没有在switch语句
的结尾处添加break语句，然后控制流“属于”
下面其他的switch语句，虽然这有时是故意的，
往往是一个错误。为确保这种错误可以发现，
在每一个switch语句应该添加一个break语句，
或者如果switch语句是一个复合语句，则在
复合语句的最后声明处添加break语句。特别的
情况是否存在，如果switch语句是空的，当这些要求
一组语句，这组语句要求相同的语句被创建.”




</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以防止不可预料的程序行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 违规
            i = 4;
            break;
            i++;
        case 1 :         // 违规
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
        case 2 :         // 违规
            {
                i = 3;
            }
        default:         // 违规
            i = 8;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // OK
            i = 4;
            i++;
            break;
        case 1 :         // OK
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
            break;
        case 2 :         // OK
            {
                i = 3;
                break;
            }
        case 3 :         // OK - empty case
        default:         // OK
            i = 8;
            throw;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-5

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-65</key>
<configkey>CODSTA-65</configkey>
<name><![CDATA[ 一个整型或指针为空的对象不能转换为一个指针类型的对象 [CODSTA-65] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个整型或指针为空的对象不能转换为一个指针类型的对象 [CODSTA-65-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型或指针为空的对象不能转换
为一个指针类型的对象”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

一般来说，从整型或指针为空的类型转化为
对象的指针会导致不可预料的结果。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S
{
    int i;
    int j;
};

void f ( void * v, int i )
{
    S * s1 = reinterpret_cast&lt; S * &gt;( v ); // 违规
    S * s2 = reinterpret_cast&lt; S * &gt;( i ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要转换一个整型或指针为空的对象
为一个指针类型的对象



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-2-8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-66</key>
<configkey>CODSTA-66</configkey>
<name><![CDATA[ 非常量的操作数和一个二进制位运算符应具有相同的基本类型 [CODSTA-66] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非常量的操作数和一个二进制位运算符应具有相同的基本类型 [CODSTA-66-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“非常量的操作数和一个二进制位运算符应具有
相同的基本类型。‘基础类型'定义为描述
将要由评估得到的表达式，如果它不是为了
促进整体的提升。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用相同的基础类型的文件操作是位数
在最后（促进和平衡）所使用的类型，
而不是在表达式的原始类型的位数。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    unsigned char mask = ~(0x10);
    unsigned short ushort;
    ushort ^= mask;         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    unsigned short mask = ~(0x10);
    unsigned short ushort;
    ushort ^= mask;         // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-0-20

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-67</key>
<configkey>CODSTA-67</configkey>
<name><![CDATA[ 作为对象，函数返回类型，或函数参数使用的类型在所有声明和再声明中字符应该相同 [CODSTA-67] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
作为对象，函数返回类型，或函数参数使用的类型在所有声明和再声明中字符应该相同 [CODSTA-67-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果再声明有兼容类型但是字符相同，
可能造成再声明不知道应该指向哪个
声明。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int INT;

INT i;        // 违规 
extern int i;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int INT;

INT i;        // OK
extern INT i; 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 3 节, 规则 3-9-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-68</key>
<configkey>CODSTA-68</configkey>
<name><![CDATA[ 后缀 "U" 应该适用于所有无符号类型的八进制或十六进制整型字面量 [CODSTA-68] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
后缀 "U" 应该适用于所有无符号类型的八进制或十六进制整型字面量 [CODSTA-68-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整数类型是取决于各种因素的复杂组合
其中包括:
- 常量的大小;
- 整数类型的实现大小;
- 存在的任何后缀;
- 基于数值表示的数字。
例如，值 0x8000 的类型是在一个16位环境的无符号整型，
但在32位环境为（有符号）类型整型。如果重载集包括
一个无符号整型和整型的候选，那么由 0x8000 匹配
的重载依赖于实现的整数大小。添加一个“U”
后缀的值指定它是无符号的。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高易读性和防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned long var = 02;  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned long var = 02U; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 2 节, 规则 2-13-3 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-69</key>
<configkey>CODSTA-69</configkey>
<name><![CDATA[ 带有char和wchar_t（简单的）类型的表达式不能被当做内置的操作数使用，除了=,  ==, != 和一元 & 运算符 [CODSTA-69] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
带有char和wchar_t（简单的）类型的表达式不能被当做内置的操作数使用，除了=,  ==, != 和一元 &amp; 运算符 [CODSTA-69-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“带有char和wchar_t（简单的）类型的
表达式不能被当做内置的操作数使用，
除了=,  ==, != 和一元 &amp; 运算符”

例外:

特殊的, 如果相关联的约束是可见的，那么下面的
操作符可以使用:
- 二进制 + 运算符可以用来加上一个
  0 到 9 的整数值给‘0’;
- 二进制 – 运算符可以用来减去字符‘0’;
- 关系运算符 &lt;, &lt;=, &gt;, &gt;= 可用于确定
  如果一个字符(或宽字符) 代表一个数字。
  (如果一个字符常量和简单类型的字符变量相比较，
   那么规则不会报告违规)



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“字符数据的处理会产生与开发人员预期
相反的结果。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    char ch = 't';                        // OK
    if ( ( ch &gt;= 'a' ) &amp;&amp; ( ch &lt;= 'z' ) ) // 违规
    {  
    	//...
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    char ch = 't';   // OK
    if ( ch == 't' ) // OK
    {  
    	//...
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 4 节, 规则 4-5-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-70</key>
<configkey>CODSTA-70</configkey>
<name><![CDATA[ 包含枚举类型的表达式不得用作除了 [ ],  =, ==, !=, <, <=, >, >=, 和一元 & 操作符以外内建操作符的操作数 [CODSTA-70] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
包含枚举类型的表达式不得用作除了 [ ],  =, ==, !=, &lt;, &lt;=, &gt;, &gt;=, 和一元 &amp; 操作符以外内建操作符的操作数 [CODSTA-70-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"枚举类型的表达式不应该用作除了
[], =, ==, !=, &amp;, 以及关系操作符
 &lt;, &lt;=, &gt;, &gt;= 操作符外的其他内
建操作符。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"枚举被用来定义实际环境的某种抽象代表，
 因此不应该用作算术操作符中。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 不正确代码示例 */
enum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_3, COLOUR_COUNT } colour;
void foo()
{
    if ( ( COLOUR_0 + COLOUR_1 ) == colour ){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* 正确代码示例 */
enum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_3, COLOUR_COUNT } colour;
void foo()
{
    if ( ( COLOUR_0 &lt; colour) &amp;&amp; (COLOUR_3  &gt; colour ) ){} // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 4, Rule 4-5-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-71</key>
<configkey>CODSTA-71</configkey>
<name><![CDATA[ 由 signed 整型命名的位域应该有超过一位的长度 [CODSTA-71] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
由 signed 整型命名的位域应该有超过一位的长度 [CODSTA-71-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“由 signed 整型命名的位域应该有超过一位的长度。
一个位长度表示的值可能不符合开发人员的预期。
任何长度的匿名有符号位域是被允许的。
”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只对明确有符号类型报告违规



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止潜在缺陷和错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct MyStruct 
{
    signed int si01 : 1;    // 违规
    signed int si02 : 1;    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct MyStruct 
{
    signed int si01 : 2;    // OK
    signed int : 1;         // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 9 节, 规则 9-6-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-73</key>
<configkey>CODSTA-73</configkey>
<name><![CDATA[ 汇编指令应该只能使用 asm 声明来引入 [CODSTA-73] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
汇编指令应该只能使用 asm 声明来引入 [CODSTA-73-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“asm 声明是对所有 C++ 都实现有效，允许
使用一致的机制。然而，asm 的参数
仍然是实现定义的。”
如果找到 '#pragma asm', '#pragma endasm' 
或同 "asm" 格式不一样的汇编指令，那么规则报告一个违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的一致性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    #pragma asm      // 违规
        "NOP";
    #pragma endasm   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    asm ( "NOP" ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-4-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-74</key>
<configkey>CODSTA-74</configkey>
<name><![CDATA[ 位域不得有枚举(enum)类型 [CODSTA-74] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
位域不得有枚举(enum)类型 [CODSTA-74-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在枚举中使用位域是被 ISO/IEC 14882:2003 明令
禁止的，因为其不允许显示的对 signed 或者 unsigned
 类型使用下标表示。因此不可能确定一个精确的位数表
示枚举中的所有值。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防未定义行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Color{RED, BLUE, BLACK};

struct S
{
    Color n : 2;       // 违规
    /* ... */
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S
{
    unsigned int n: 2 // OK
    /* ... */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 9, Rule 9-6-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-75</key>
<configkey>CODSTA-75</configkey>
<name><![CDATA[ 位域应该要么是 bool 类型要么是显式无符号或有符号的整数类型 [CODSTA-75] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
位域应该要么是 bool 类型要么是显式无符号或有符号的整数类型 [CODSTA-75-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"位域要么为 bool 类型或者显示声明为 unsigned 
 或 signed 整型，通过使用 int 实现因为 int 类
型的位域可以为 signed 或 unsigned. wchar_t 作
i为位域类型被 ISO/IEC 14882:2003 禁止。"




</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防未定义行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 不正确的代码 */
struct S 
{
    char c : 2;            // 违规
    short f : 3;           // 违规
    int : 0;               // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* 正确代码 */
struct S
{
    unsigned char c : 2;    // OK
    signed short f : 3;     // OK
    unsigned int : 0;       // OK
    bool b : 4              // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 9, Rule 9-6-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-76</key>
<configkey>CODSTA-76</configkey>
<name><![CDATA[ 标识符 main 除了全局的 main 函数以外不得用于其它函数 [CODSTA-76] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标识符 main 除了全局的 main 函数以外不得用于其它函数 [CODSTA-76-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"main (或等价的函数) 通常用作程序入口并且是在整
个命名空间中的唯一的标志符。main 用作其他函数可
能不符合开发人员预期。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace
{
    int main ( ){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int main ( ){}     // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 7, Rule 7-3-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-77</key>
<configkey>CODSTA-77</configkey>
<name><![CDATA[ goto 语句应该跳转到随后在同一个函数中声明的标签 [CODSTA-77] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
goto 语句应该跳转到随后在同一个函数中声明的标签 [CODSTA-77-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不严格的使用 goto 语句极易导致出现程序超
级难以理解，分析，并且对于 C++ 也可能导致
程序未预期的行为。然而，很多情况下彻底禁止
 goto 就要求引入一些 flags 以确保正确控制流
程，但这些 flags 不如 goto 那样使程序更加
清晰。因此在那些不会对开发人员产生完全相反
的语义的地方严格使用 goto 语句是被允许的。
"向后"跳转是禁止的。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防未预期的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int j)
{
    L1:
    ++j;
    goto L1; // 违规 - 向回跳转
    ++j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int j)
{
    ++j;
    goto L1; // OK -  向前跳转
    ++j;
    L1:
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 6, Rule 6-6-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-78</key>
<configkey>CODSTA-78</configkey>
<name><![CDATA[ 任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包围 goto 语句的模块中 [CODSTA-78] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包围 goto 语句的模块中 [CODSTA-78-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"任何被 goto 语句使用的标签应该被声明在 goto 
语句所在的同一个 block 中，或者在一个包围 goto 
语句的 block 中。 随意使用 goto 可能导致程序极易导
致出现程序超级难以理解，分析，并且对于 C++ 也可
能导致程序未预期的行为。然而，很多情况下彻底禁止
 goto 就要求引入一些 flags 以确保正确控制流
程，但这些 flags 不如 goto 那样使程序更加
清晰。因此在那些不会对开发人员产生完全相反
的语义的地方严格使用 goto 语句是被允许的。
在一个嵌套的 block 中使用 goto 语句是不允许的，
因为它容易导致高度复杂的执行流程。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防未预期的行为



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void f1 ( )
{
	int j = 0;
	goto L1;
	
	for ( j = 0; j &lt; 10 ; ++j )
	{
		/* ... */
		L1: 				// 违规
			j;
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void f1 ( )
{
	int j = 0;
	goto L1;
	
	for ( j = 0; j &lt; 10 ; ++j )
	{
		/* ... */
	}

	L1: 					// OK
		j;

}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 6, Rule 6-6-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-79</key>
<configkey>CODSTA-79</configkey>
<name><![CDATA[ 对于任何循环语句，不要有超过一个 break 或 goto 语句用于循环终止 [CODSTA-79] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对于任何循环语句，不要有超过一个 break 或 goto 语句用于循环终止 [CODSTA-79-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"对于任何循环语句中不应该超过
一个 break 或 goto 语句。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"在循环语句中限制退出语句的个数是一种良Restricting the number of exits from a loop is done in the interests of good
好结构的编程。在一个循环块中存在一个 break structured programming. One break or goto statement is acceptable in a loop
或 goto 语句是可接受的。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a;

    for (a = 0; a &lt; 10; a++) { // 违规
        if (a == 5) {
            break;
        }
        if (a == 7) {
            break;
        }
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int a;

    for (a = 0; a &lt; 10; a++) { // OK
        if (a == 5 || a == 7) {
            break;
        }
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 6, Rule 6-6-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-80</key>
<configkey>CODSTA-80</configkey>
<name><![CDATA[ continue 语句只应该被用于具有良好格式的 for 循环 [CODSTA-80] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
continue 语句只应该被用于具有良好格式的 for 循环 [CODSTA-80-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"continue 语句的反复使用容易导致代码的复
杂度。 这种复杂性可能降低被测代码的测试
效率。 要求的测试可能不能达到由于控制流
的依赖性。"


例外:

如果 'continue' 语句被用在 'for' 循环中，该规则不会报告违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则降低代码的复杂度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
	int x = 0;
	int y;
	y = 10;
	
        while(x &lt; y)
	{
          x++;

	  /* ... */
	  continue;             // 违规

	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

在 'for' 循环之外，不要使用 'continue' 语句。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 6, Rule 6-6-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-81</key>
<configkey>CODSTA-81</configkey>
<name><![CDATA[ 如果一个函数有内部链接，那么所有的再声明应该包括静态(static)存储类关键字 [CODSTA-81] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个函数有内部链接，那么所有的再声明应该包括静态(static)存储类关键字 [CODSTA-81-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果函数的声明使用了静态 static 关键字，
那么该函数有一个内部链接。 再次声明该函数
不需要 static 关键字，但它仍然有内部链接。
然后，这种隐式方式可能对于开发人员而言不
够清晰。因此加一个 static 关键字使其显示的
声明存在内部链接是一种好的习惯。"
参见： MISRA2004-8_11



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则使代码遵守良好的编程习惯并提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static void f1 ( );
void f1 ( ) { }         // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static void f1 ( );
static void f1 ( ) { }  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 3, Rule 3-3-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-82</key>
<configkey>CODSTA-82</configkey>
<name><![CDATA[ 避免无限循环 [CODSTA-82] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免无限循环 [CODSTA-82-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

无限循环通常造成资源耗尽或程序终止错误 
该规则将报告一个违规如果存在循环语句 (while, do while, for)
没有退出点。 该规则假定循环将会终止如果 
循环中包含：
- break
- return
- goto 语句直接跳转到循环外
- 在循环内 try/catch 被截获
- 访问标准退出函数： exit, abort or _Exit



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则不检查被调用函数 - 如果位于循环中的被 
调用函数中存在一个退出点，该退出点将会终止该
循环，这种情况下该规则仍然会报告一个违规。
该规则不检查退出点是否能被触发 (例如 'break'
在一个 if 条件中，该规则将不会考虑 if 条件是 
否成立)。
该规则只限于检查 'catch' 处理函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

找到可能导致不必要的程序终止或资源耗尽或电脑死掉
的无限循环。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(char *s) {
    for (;;) {                 // 违规 - 无限循环           
        switch (*s++) {
        case 'a':  continue;
        case '\0': break;      // 该 break 是针对 'switch'!
        }
    }  
    while(true) {              // 违规 - 无限循环           
        if (!s) {
            // return;         // 误操作注释掉return 
        }
        ++s;
    }  
    do {                       // 违规 - 无限循环           
        char * ptr = s;
        for(; ptr; ++ptr) {
            if (!*ptr) {
                goto END_LOOP; // 在 'do while' 循环中不能退出
            }
        }
        END_LOOP:
    } while(1);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(char *s) {
    for (;;) {                // OK
        switch (*s++) {
        case 'a':  continue;
        case '\0': break;     
        }
        break;
    }  
    while(true) {             // OK           
        if (!s) {
            return;        
        }
        ++s;
    }  
    do {                      // OK           
        char * ptr = s;
        for(; ptr; ++ptr) {
           if (!*ptr) {
               goto END_LOOP;
           }
        }
    } while(1);
    END_LOOP:
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-83</key>
<configkey>CODSTA-83</configkey>
<name><![CDATA[ 所有的循环必须有一个固定的上限或下限 [CODSTA-83] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的循环必须有一个固定的上限或下限 [CODSTA-83-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"有递归但无上限的循环。该规则
当然不是针对功能本需要一直循环的
代码 （例如，一个进程调度）" 
"一种方式是为所有可变的循环次数
增加一个上限值（例如，遍历链表的代码）。
当上限被超过时应该触发一个断言失败，
并且包含该失败断言的循环返回一个错误。"
该规则如果碰到如下情况将报告违规：
- 虽不是无限循环但不包含关系表达式条件
  'variable &lt; FB',  'variable &lt;= FB', 'FB &gt; variable',
  'FB &gt;= variable' 这里的FB 是常量或 const 类型的变量或参数。
- 循环包含上限值但不包含用于判断条
  件值的自增量变量 'variable++', '++variable',
  'variable += PV', 'variable = variable + PV',
  'variable = PV + variable' 
- 循环包含下限值但不包含用于判断条 
  件值的自减变量 'variable--', '--variable',
  'variable -= PV', 'variable = variable - PV'
  该 PV 是:
  - 一个大于0的常量，
  - 一个const类型的变量并且其值大于0，
  - 无符号型的参数/变量/表达式。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止死循环。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int p){
    int i = 0;
    while(i == 5){  // 违规 - 条件中午关系表达式
        i = i + 2;
    }  

    while(i &lt; p){   // 违规 - 变量不是与常量比较
        i++;
    }      
    
    while(i &lt; 7){   // 违规 - 循环中无自增
        // ...
    }
     
    for(i = 10; i &lt;= 7; i--){ // 违规 - 循环中无自减
    }

    while(i &gt; 7){   // 违规 - 循环中无自减
        // ...
    }
     
    for(i = 10; i &gt;= 7; i++){ // 违规 - 循环中无自增
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(const int p){
    int i = 0;
    while(i &lt; 5){             // OK
        i = i + 2;
    }  

    while(i &lt; p){             // OK  
        i++;
    }    

    while(i &lt; 7){             // OK
        i++;
    }
     
    for(i = 10; i &lt;= 7; i++){ // OK
    }

    while(i &gt; 7){             // OK
        --i;
    }
     
    for(i = 10; i &gt;= 7; i--){ // OK
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

The Power of Ten - Rules for Developing Safety Critical Code.
Rule 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-85</key>
<configkey>CODSTA-85</configkey>
<name><![CDATA[ 避免在无限循环中有退出点 [CODSTA-85] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在无限循环中有退出点 [CODSTA-85-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"该规则用于有意无退出点的循环
(例如，进程调度器)。 应该提供
不能终止循环的证明。"
如果一个循环语句（while, do while, for）
中有退出点，该规则将报告一个违规。 只有
空循环或者简单常量条件的循环被检查。
该规则假定循环能被终止，如果包含如下：
- break
- return
- goto语句跳到循环外边的标签
- 抛出的异常没有被循环内的try/catch截获
- 访问标准函数： exit, abort 或 _Exit



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则不检查被调用的函数 - 如果循环 
内部的被调函数中存在一个用于终止循环的退出点
该规则部报告违规



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范防止不当地终止了不能被终止的循环。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(){
    for(;;){
        // code
        break;     // 违规
    }

    while(1){
        // code
        return;    // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(){
    for(;;){      // OK
        // code
    }

    while(1){     // OK
        // code
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

The Power of Ten - Rules for Developing Safety Critical Code.
Rule 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-86</key>
<configkey>CODSTA-86</configkey>
<name><![CDATA[ 参数的有效性必须在每个函数中被检查 [CODSTA-86] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
参数的有效性必须在每个函数中被检查 [CODSTA-86-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在每个函数内检查参数有效性。"
如果一个函数的参数在函数内第一次使用前没 
有检查其有效性，该规则将报告一个违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果参数在一个条件语句：if, switch 或三元操作 
符中使用过，则该规则假定该参数已经被验证有效性。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止使用不当的参数值。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo3(int p, int q){   // 违规
    p++;
    q++;
    return p + q;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo4(int p, int q){   // OK
    if(p == 0 || q == 0){
        return 0;
    }
    p++;
    q++;
    return p + q;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

The Power of Ten - Rules for Developing Safety Critical Code.
Rule 7

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-87</key>
<configkey>CODSTA-87</configkey>
<name><![CDATA[ 使用不超过一级的解引用 [CODSTA-87] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用不超过一级的解引用 [CODSTA-87-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"应该严格限制指针的使用。特别是不应该使用
多级指针。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"指针极易被误用，即便是对有丰富经验的程
序员。 同时这种多级指针使用难于跟踪和分
析代码执行逻辑，尤其对于静态分析工具。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(){
    int** p;
    int** q;
    int i;

    **p = 1; // 违规
    i = **q; // 违规
}




</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用超过一级的指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

The Power of Ten - Rules for Developing Safety Critical Code.
Rule 9

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-88</key>
<configkey>CODSTA-88</configkey>
<name><![CDATA[ 不允许函数指针 [CODSTA-88] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许函数指针 [CODSTA-88-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"应该严格使用指针。 不允许使用函数指针。
指针极易被误用，即便是对经验丰富的程序员。
函数指针的使用难于跟踪和程序逻辑的分析，
尤其是对基于静态分析的工具更难分析"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则增强代码可读性并使得代码更容
易被静态分析工具检查。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef void (*FP)();
extern FP x[];             /* 违规 - 变量 x */
void foo1(FP * y) {        /* 违规 - 参数 y */
    int (*z)(void) = 0;    /* 违规 - 变量 z */
    foo1(y);               /* OK - usage is ignored */
}
void foo2(FP) {}    /* OK - 无名参数被忽略 */
void foo3(FP p);    /* OK - 函数声明被忽略 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明函数指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 9

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-89</key>
<configkey>CODSTA-89</configkey>
<name><![CDATA[ 声明不得包含超过一级的间接指针 [CODSTA-89] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
声明不得包含超过一级的间接指针 [CODSTA-89-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用多于一级的间接指针会严
重影响对代码行为的理解，因此
应该避免使用。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int** INTPTR;  /* 违规 */
int** ptr;             /* 违规 */
int* a[];              /* 违规 */
struct S{
    int** s;           /* 违规 */
};

struct S** ps;         /* 违规 */

int** foo();           /* 违规 */
int(**pfunc1)();       /* 违规 */
int**(*pfunc2)();      /* 违规 */
void fun( int** par,   /* 违规 */
          INTPTR par_t /* 违规 */
        )
{
	int* a[10];        /* 违规 */
    int ** ptr;        /* 违规 */
    INTPTR ptr_t = 0;  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明包含超过一级的间接指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 9

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-90</key>
<configkey>CODSTA-90</configkey>
<name><![CDATA[ 逻辑 '&&' 或 '||' 的每个操作数应该为后缀表达式 [CODSTA-90] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑 '&amp;&amp;' 或 '||' 的每个操作数应该为后缀表达式 [CODSTA-90-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当单标签、常量或者函数调用没有加上
括号，该规则将报告一个违规。
"加括号对于代码的可读性和确保代码
按照程序员所设计逻辑运行非常重要。"
See also: MISRA2004-12_1_e, MISRA2004-12_5


例外：

"如果表达式仅由逻辑操作符 '&amp;&amp;' 或仅由逻
辑操作符 '||' 组成, 则不需括号。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"这个规则的效果是需要有适当的括号运算。" 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || y &amp;&amp; z );         // 违规
    if ( x &amp;&amp; !y );             // 违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || ( y &amp;&amp; z ) );         // OK
    if ( x &amp;&amp; ( !y ) );             // OK
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 5, Rule 5-2-1

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.21 Operators, AV Rule 158

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-91</key>
<configkey>CODSTA-91</configkey>
<name><![CDATA[ 函数应该最多有一个退出(exit)点 [CODSTA-91] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数应该最多有一个退出(exit)点 [CODSTA-91-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个函数应该最多一个退出点。
访问来自标准库 stdlib.h 的函数 exit, abort, and _Exit 
被视为退出点。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int i)
{
    if (i == 0) {
        return 0;        /* 违规 */
    } else if (i == 1) {
        return 1;        /* 违规 */
    } else {
        return 2;        /* 违规 */
    }
}

void foo2(int* a)
{
    if (a == 0) {
        return;  /* 违规 - 函数末尾存在第二个退出点 */
    }
    *a = 10; 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int i)
{
    int result = 0;
    if (i == 0) {
        result = 0;
    } else if (i == 1) {
    	result = 1;
    } else {
    	result = 2;
    }
    return result;   /* OK */
}

void foo2(int* a)
{
    if (a != 0) {
        *a = 10;    /* OK */
    } 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. HIS Source Code Metriken, version 1.3.1
   Metrik "RETURN"

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-92</key>
<configkey>CODSTA-92</configkey>
<name><![CDATA[ 标准库宏和对象的名称不得被重用 [CODSTA-92] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标准库宏和对象的名称不得被重用 [CODSTA-92-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"程序员使用新版本的标准库的宏或者对象
的地方(例如 增强功能或者添加检查输入值)，这些
修改过的宏或者对象需要有一个新的命名。
这样做是为了避免这样的混淆：是标准宏或者
对象正在被调用，还是修改过的正在被调用。"
本规则检查下面的保留名称是否被使用：
- 来自C标准库头文件的宏和typedef名称: assert.h,
  complex.h, ctype.h, errno.h, float.h, iso646.h, limits.h, locale.h, math.h,
  setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h, string.h, time.h,
  wchar.h, wctype.h, stdint.h, inttypes.h, fenv.h, stdbool.h, tgmath.h
- 以下划线字符开头的标示符
参见: NAMING-33, MISRA2004-20_2, CODSTA-93



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define NULL ( a &gt; b )     // 违规
#define _NULL ( a &gt; b )    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MY_NULL ( a &gt; b ) // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++ 语言在关键系统中的使用指南
   第 6 章，第 17 节， 规则 17-0-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-93</key>
<configkey>CODSTA-93</configkey>
<name><![CDATA[ 标准库函数的名称不得被覆盖 [CODSTA-93] ]]></name>
<tag>codsta</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标准库函数的名称不得被覆盖 [CODSTA-93-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"程序员使用新版本的标准库的函数的地方
(例如 增强功能或者添加检查输入值)，这些
修改过的函数需要有一个新的命名。 然而，
如果这个功能和原始的一致，它允许重载名称
来添加新的参数类型。 这样确保和名称相关的行为
保持一致。 因此，比如，新版本的开平方根函数
被写入用来检查输入是否为负值，那么这个函数不能
被命名为'sqrt'，而是需要给定一个新的名字。它允许
为在函数库中不存在的类型添加一个新的开平方根函数"
本规则检查下面的保留名字是否被使用：
- 来自C标准库头文件的函数名称： assert.h,
  complex.h, ctype.h, errno.h, float.h, iso646.h, limits.h, locale.h, math.h,
  setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h, string.h, time.h,
  wchar.h, wctype.h, stdint.h, inttypes.h, fenv.h, stdbool.h, tgmath.h
- function names that begin with the underscore character
参见: NAMING-33, MISRA2004-20_2, CODSTA-92



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可预防未定义的行为。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

在静态分析中检查该功能和原始的是否一致是
不可能的。所以， 规则在所有声明的具有保留名称
的函数上报告违规。 用户应该自己检查修改的函数
是否具有相同的功能并且可以重载来自于标准库的函数。
规则同样也不具有例外来允许重载包含在标准库中不存在
类型的函数。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int printf ( int a, int b )        // 违规
{
    return ( ( a &gt; b ) ? a : b );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int my_printf ( int a, int b )     // OK
{
    return ( ( a &gt; b ) ? a : b );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++ 语言在关键系统中的使用指南
   第 6 章， 第 17 节， 规则 17-0-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-94</key>
<configkey>CODSTA-94</configkey>
<name><![CDATA[ 不应该声明指针或数组类型 [CODSTA-94] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应该声明指针或数组类型 [CODSTA-94-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

通过指针你可以直接访问内存，但如果不能
正确使用指针，很有可能会使你的程序崩溃。
因为指针动态处理内存，它们必然都会具有
一定的危险性和缺点。

规则在任何使用指针或数组的函数或变量
的声明时报告违规。它不允许函数具有如下情况的声明：
返回值 为指向任何类型指针的函数，或参数为指针或数组的函数， 
也不要声明指针或数组类型的全局或局部变量。 
也同样不允许函数指针。
参见: CODSTA-95



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v9.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可以防止内存泄漏，解引用空指针，
缓冲区溢出，内存损坏和未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* INT_P; /* OK - no violation on typedef */
INT_P x;            /* 违规 */
int* foo();         /* 违规 */
void (*FP)();       /* 违规 */
void bar(int*)      /* 违规 */
{
  int tab[10];      /* 违规 */
  int *tab1[10];    /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不应该使用指针和数组。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>CODSTA-95</key>
<configkey>CODSTA-95</configkey>
<name><![CDATA[ 不应该声明指针类型 [CODSTA-95] ]]></name>
<tag>codsta</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应该声明指针类型 [CODSTA-95-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

通过指针你可以直接访问内存，但如果不能
正确使用指针，很有可能会使你的程序崩溃。
因为指针动态处理内存，它们必然都会具有
一定的危险性和缺点。

规则在任何使用指针的函数或变量的声明时
报告违规。它不允许函数具有如下情况的声明：
返回值为指向任何类型指针的函数，或参数为指针的函数， 
也不要声明指针类型的全局或局部变量。 
也同样不允许函数指针。
参见: CODSTA-94



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v9.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可以防止内存泄漏，解引用空指针，
缓冲区溢出，内存损坏和未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* INT_P; /* OK - no violation on typedef */
INT_P x;            /* 违规  */
int* foo();         /* 违规 */
void (*FP)();       /* 违规 */
void bar(int*)      /* 违规 */
{
  int tab[10];      /* OK - no violation on simple array */
  int *tab1[10];    /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不应该使用指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-01</key>
<configkey>COMMENT-01</configkey>
<name><![CDATA[ 推荐使用 C++ 风格的注释 [COMMENT-01] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
推荐使用 C++ 风格的注释 [COMMENT-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用 // 来处理注解. 不要使用 /* 和 */. 
"C++, 其实并不允许注解以 /* */ 来嵌套。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改进了可读性和维护性. 如果以 // 持 
续编写注解, 则 /* */ 的组合可以在开发和
调试阶段用来将整段代码做注解的动作
.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rec. 9

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 126

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-02</key>
<configkey>COMMENT-02</configkey>
<name><![CDATA[ 提供版权信息 [COMMENT-02] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
提供版权信息 [COMMENT-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"所有文件需包含版权信息, 以: // Copyright 
为一行的方式显示"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高了可读性和维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规 - 没有版权信息



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// Copyright



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rule 5

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 133

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-03</key>
<configkey>COMMENT-03</configkey>
<name><![CDATA[ 对每一个文件进行注释 [COMMENT-03] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对每一个文件进行注释 [COMMENT-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每个包含源码的文件必须以注解的方式提供
文件名和其内容介绍来记录."


记事:

C 和 C++ 的注解方式是认同的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改进可读性和维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// No comment "File:"           // 违规 - 没有介绍的注解



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// File: &lt;short description of the file&gt;   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rule 4

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 133

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-04</key>
<configkey>COMMENT-04</configkey>
<name><![CDATA[ 注释每个函数 [COMMENT-04] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
注释每个函数 [COMMENT-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在每个函数前编写描述性注解。"
规范将在底下状况报告违例:

1) 函数原型 如果没有函数定义且原
   型前没有提供注解, 

2) 假设函数定义:
-  没有原型且函数定义前没有提供
   注解
-  有原型但无论原型或函数定义都
   没有提供注解



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改进了可读性和维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1();     // 违规

int foo2(int x){ // 违规
    return x++;
}

int foo3(int x);
int foo3(int x){ // 违规
    return x++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// 函数的说明注解.
void foo1(); 

// 函数的说明注解.
int foo2(int x){ 
    return x++;
}

// 函数的说明注解.
int foo3(int x);

int foo3(int x){ 
    return x++;
}

int foo4(int x);

// 函数的说明注解.
int foo4(int x){
    return x++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rec. 8

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 134

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-05</key>
<configkey>COMMENT-05</configkey>
<name><![CDATA[ 每一个变量声明都应该进行注释 [COMMENT-05] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个变量声明都应该进行注释 [COMMENT-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个变量声明应该被注解.
如果没有在变量声明后或前
一行添加注解, 规范会报告违例。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这规范只检测局部和全局变量的声明.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int var1;
    // 违规

    int var2;
    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int var1; // comment - OK

    // comment - OK
    int var2;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.14 章节 Comments, AV Rule 132

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-06</key>
<configkey>COMMENT-06</configkey>
<name><![CDATA[ 每一个类型定义(typedef)都应该进行注释 [COMMENT-06] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个类型定义(typedef)都应该进行注释 [COMMENT-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每一个 typedef 应被注解.
如果没有在 typedef 声明后或前
一行添加注解, 规范会报告违例。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32;
// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int32; // OK - comment



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.14 章节 Comments, AV Rule 132

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-07</key>
<configkey>COMMENT-07</configkey>
<name><![CDATA[ 每一个枚举值都应该进行注释 [COMMENT-07] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个枚举值都应该进行注释 [COMMENT-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个枚举值应该被注解.
如果没有在枚举值声明后和前
一行添加注解, 规范会报告违例。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum {
    ENUM1 = 2,
    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum {
    ENUM1 = 2, // OK - comment
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.14 章节 Comments, AV Rule 132

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-08</key>
<configkey>COMMENT-08</configkey>
<name><![CDATA[ 每一个结构成员变量都应该进行注释 [COMMENT-08] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个结构成员变量都应该进行注释 [COMMENT-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个结构成员变量应被注解.
如果没有在结构成员变量声明后和
前一行添加注解, 规范会报告违例。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S
{
    char* c;
    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S
{
    char* c; // comment - OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.14 章节 Comments, AV Rule 132

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-09</key>
<configkey>COMMENT-09</configkey>
<name><![CDATA[ 所有汇编程序的使用应该被注释说明 [COMMENT-09] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有汇编程序的使用应该被注释说明 [COMMENT-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“所有汇编程序的使用应该注释说明。 汇编语言代码
是实现定义的，因此是不可移植的。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果在 'asm' 指令的同一行或其直接的前一行
有注释，那么此规则认为汇编程序的使用已经
注释说明。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规在含有 'asm' 指令的行
void foo( void )
{
   asm ( "NOP" );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( void )
{
   // OK - 在 'asm' 指令之前的注释 
   asm ( "NOP" );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-4-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>COMMENT-10</key>
<configkey>COMMENT-10</configkey>
<name><![CDATA[ 使用浮点运算应该被注释说明 [COMMENT-10] ]]></name>
<tag>comment</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用浮点运算应该被注释说明 [COMMENT-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果使用浮点数，那么下面的问题需要作为误差过程的
一部分加以覆盖:
- 一个解释为什么浮点数是合适的或唯一的 
  解决方法的理由。
- 证明适当的技巧是可用的。
- 证明应用了适当的处理过程。
- 说明浮点的执行。”
此规则检查是否在浮点运算表达式的
前一行或同一行有注释。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“安全地使用浮点运算需要有高水平的数值分析技巧，
以及对编译器和目标硬件深入的知识。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 在如下行有违规: double d = d1 + d2;
double add(double d1, double d2)
{
    double d = d1 + d2;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

double add(double d1, double d2)
{
	double d = d1 + d2; // OK - 浮点运算
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 0 节, 规则 0-4-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-01</key>
<configkey>EXCEPT-01</configkey>
<name><![CDATA[ 绝不要从析构、释放分配以及 swap 函数抛出异常 [EXCEPT-01] ]]></name>
<tag>except</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
绝不要从析构、释放分配以及 swap 函数抛出异常 [EXCEPT-01-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Never allow an error to be reported from a destructor, a resource deallocation
function (e.g., operator delete), or a swap function. These are key functions
that must not fail because they are necessary for the two key operations
in transactional programming: to back out work if problems are encountered
during processing, and to commit work if no problems occur."
The rule reports a violation if from a destructor, an operator delete
or a swap function is thrown an exception or is called a function
that can throw exceptions.
参见: EXCEPT-03



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

Function can not throw any exceptions if has external 'C' linkage
or in a declaration uses an empty exception specification throw().



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents propagation of exceptions out of the destructor,
operator delete and swap function.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Exceptions{};

class A{
    A();
    ~A();
    void operator delete(void*);
};

A::~A(){
    throw Exceptions();            // 违规
}

void A::operator delete(void*){
    throw Exceptions();            // 违规
}

class B {
public:
    B();
    ~B();
    void operator delete(void*);
    void foo();        // can throw exceptions
    static void soo(); // can throw exceptions
};

B::~B(){
    foo();                         // Violation
}

void B::operator delete(void*){
    soo();                         // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A{
    A();
    ~A();
    void operator delete(void*);
    void foo() throw();        // can not throw exceptions
    static void soo() throw(); // can not throw exceptions
};

A::~A(){
    foo();                         // OK
}

void A::operator delete(void*){
    soo();                         // OK
}

class B {
public:
    B();
    ~B();
    void operator delete(void*);
    void foo();        // can throw exceptions
    static void soo(); // can throw exceptions
};

B::~B(){
    try{
        foo();                     // OK
    } catch (...){
    }
}

void B::operator delete(void*){
    try{
        soo();                     // OK
    } catch (...){
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Construction, Destruction, and Copying", Rule 51

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 2, Item 8

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-02</key>
<configkey>EXCEPT-02</configkey>
<name><![CDATA[ 异常抛出值，捕获异常 [EXCEPT-02] ]]></name>
<tag>except</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
异常抛出值，捕获异常 [EXCEPT-02-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

异常应该抛出值（而不是指针）并且捕获引用
(通常使用 const 修饰)。 这是一个良好的方式，
防止发生一些与异常内存管理相关的错误。
在重新抛出异常时，推荐选择 'throw;' 而不用 'throw except;'。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止重新抛出对象的内存管理我俄航天和异常
类型多样。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Exception {
public:
	Exception( char* );
};

bool sanityObserved();
void restoreSanity();

void foo_Violation() {
    Exception *exp = new Exception("error message");
    if (!sanityObserved()) {
       throw exp;                      // 违规 - 抛出指针
    }
    try {
       restoreSanity();
    }
    catch(Exception* newException) {   // 违规- 捕获指针 
        throw newException;            // 违规- 参数重新抛出 
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception {
public:
	Exception( char* );
};

bool sanityObserved();
void restoreSanity();

void foo_OK() {
    Exception exp("error message");
    if (!sanityObserved()) {
       throw exp;                     // OK
    }
    try {
       restoreSanity();
    }
    catch(Exception&amp; newException)    // OK 
    {  
        throw;                        // OK 
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Error Handling and Exceptions", Rule 73

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-03</key>
<configkey>EXCEPT-03</configkey>
<name><![CDATA[ 不得从析构函数中抛出异常 [EXCEPT-03] ]]></name>
<tag>except</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得从析构函数中抛出异常 [EXCEPT-03-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否从一个析构函数中抛出异常。 
这条规则只是针对 C++ 编程语言。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止从一个析构函数中抛出异常。它可能会导致内存泄漏
和不当的对象析构。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Foo {
public:
    Foo( ) { }
    ~Foo( ) {
        throw;  // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception {};

class Foo {
public:
    Foo( ) { }
    ~Foo( ) {
        try {       // OK 
        } catch (Exception&amp; e) {
            // 捕获所有的异常
        }
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 2 章, 第 8 项

2. <A HREF="http://www.cs.helsinki.fi/u/vihavain/s03/cpp/items/CppStyleRules2.html">http://www.cs.helsinki.fi/u/vihavain/s03/cpp/items/CppStyleRules2.html</A>

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-5-1

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-04</key>
<configkey>EXCEPT-04</configkey>
<name><![CDATA[ 所有的异常应该重新抛出，或者用标准的日志记录器进行记录 [EXCEPT-04] ]]></name>
<tag>except</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的异常应该重新抛出，或者用标准的日志记录器进行记录 [EXCEPT-04-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则会查找代码异常处理机制有没有正确的
错误记录过程. 正确的错误记录过程应该是如:
- 函数调用应使用 'log' 或 'warning' 或
- 使用 std::cout, std::cerr, std::clog 来生成 log信息。


例外:

如果异常在其他地方捕获或记录, 则这条规则
不会报告违规.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在程序的运行阶段，异常可用来判断不正常的条件产生 
. 如果从安全的观点来调试不正常的条件, 
拥有正确的 log 来记录可疑的事件是相当必要的. 
实施这条规则可以确定正确的记录在每个异常处都有执行.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// example of incorrect code

class Exception { };
void x();

void foo1() {
    try {
        x(); // might throw Exception
    }
    catch (const Exception&amp; e) { // 违规 - 没有记录
        return;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// examples of correct code

#include &lt;iostream&gt;

class Exception{};
void x();
void log(char* msg); // error logging procedure

void foo1() {
    try {
        x(); // might throw Exception
    }
    catch (const Exception&amp; e) { // OK
        std::cerr &lt;&lt; "Error";
        return;
    }
    catch (int * e) { // OK
        std::cout &lt;&lt; "Error";
        return;
    }
    catch (float e) { // OK
        std::clog &lt;&lt; "Error";
        return;
    }
}

void foo2() {
    try {
        x(); // might throw Exception
    }
    catch (const Exception&amp; e) { // OK
         log("Error");
    }
}

void foo3() {
    try {
        x(); // might throw Exception
    }
    catch (const Exception&amp; e) { // OK
         throw;
    }
}

class MyException { };
void foo4() {
    try {
        x(); // might throw Exception
    }
    catch (const Exception&amp; e) { // OK
         throw MyException();
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://cwe.mitre.org/data/definitions/391.html">http://cwe.mitre.org/data/definitions/391.html</A>

2. <A HREF="http://freshsources.com/HTML/12.07/ALLISON/ALLISON.HTM">http://freshsources.com/HTML/12.07/ALLISON/ALLISON.HTM</A>

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-05</key>
<configkey>EXCEPT-05</configkey>
<name><![CDATA[ 在程序中不要运用 C++ 异常处理函数(例如,throw, catch 和 try 等) [EXCEPT-05] ]]></name>
<tag>except</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在程序中不要运用 C++ 异常处理函数(例如,throw, catch 和 try 等) [EXCEPT-05-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用 C++ 的异常处理。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这规范提高了代码的可移植性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;

using namespace std;
int main()
{
    char *buf;
    try                                          // 违规
    {
        buf = new char[512];
        if( buf == 0 )
            throw "Memory allocation failure!";  // 违规
    }
    catch( char * str )                          // 违规
    {
        cout &lt;&lt; "Exception raised: " &lt;&lt; str &lt;&lt; '\n';
    }
    // ...
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;

using namespace std;
int main()                                   // OK
{
	char *buf;
	buf = new char[512];
	if( buf == 0 )
		cout&lt;&lt; "Memory allocation failure!";

	return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ 编程规范
第 4.27 章节 Fault Handling, AV Rule 208

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-06</key>
<configkey>EXCEPT-06</configkey>
<name><![CDATA[ 应该至少有一个异常处理程序来捕获所有其他未处理的异常 [EXCEPT-06] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该至少有一个异常处理程序来捕获所有其他未处理的异常 [EXCEPT-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个程序抛出一个未处理的异常，
那么它以实现定义的方式终止。特别的，
在终止之前调用栈是否已经展开是实现定义的，
所以任何自动对象的析构函数可能会也可能不会被执行。
通过实施一个“最后的防线捕获所有(last-ditch catch-all)”的规定，
开发人员能够确保程序以一致的方式终止。”
此规则检查 'main' 函数最外面的语句是否包含
捕获所有(catch-all)处理函数的 try 语句。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则检查是否包含捕获所有(catch-all)处理函数的
try 语句直接在 'main' 函数中执行。
无法检测到那些从 'main' 函数调用并实现在函数中的语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Exception{};
int main( )
{
    try  // 违规
    { 
        // ...
    }
    catch ( Exception e )
    {
        // ...
    }
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception{};
int main( )
{
    try  // OK
    { 
        // ...
    }
    catch ( Exception e )
    {
        // ...
    }
    catch ( ... )
    {
        // ...
    }
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 15 节, 规则 15-3-2

2. <A HREF="http://cwe.mitre.org/data/definitions/391.html">http://cwe.mitre.org/data/definitions/391.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-07</key>
<configkey>EXCEPT-07</configkey>
<name><![CDATA[ 空的抛出 (throw;) 应该只用于 catch 处理程序的复合语句中 [EXCEPT-07] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空的抛出 (throw;) 应该只用于 catch 处理程序的复合语句中 [EXCEPT-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“空的抛出重新抛出代表一个异常的对象。
它的使用目的是能够处理跨越两个或多个
处理程序的异常。
然而，语法上，没有任何防止抛出的可能；正在 catch 处理程序
之外被使用，这里没有异常对象重新抛出。这可能导致
执行定义的程序终止。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止实现定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Exception{};
void foo(int a) 
{
    Exception E;
    if(a)
    {
        throw;   // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception{};
void foo(int a) 
{
    Exception E;
    if(a)
    {
        throw E;       // OK
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-1-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-08</key>
<configkey>EXCEPT-08</configkey>
<name><![CDATA[ 应该只能在程序启动之后和终止之前抛出异常 [EXCEPT-08] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该只能在程序启动之后和终止之前抛出异常 [EXCEPT-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在程序开始执行 main 函数体之前，它是在启动
阶段，构造和初始化静态对象。同样，在 main 函数
返回之后，它是在静态对象被销毁的终止阶段。
如果在这两个阶段抛出一个异常，那么它会导致
程序按照一个实现定义的方式终止。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则只检查一层的嵌套函数调用。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“按照实现定义的方式抛出一个在程序启动
或程序结果终止期间的异常。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C
{
public:
    C ( )
    {
        throw ( 0 ); // 违规– 在 main 开始之前抛出
    }
    ~C ( )
    {
        throw ( 0 ); // 违规– 在 main 退出之后抛出
    }
};
C c;

int main( ... )
{ 
	// ...
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

异常不应该在程序启动或终止阶段抛出。  



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-09</key>
<configkey>EXCEPT-09</configkey>
<name><![CDATA[ 异常对象不应该有指针类型 [EXCEPT-09] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
异常对象不应该有指针类型 [EXCEPT-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果抛出指针类型的异常对象，并且该指针指向
了一个动态创建的对象，那么可能会不清楚哪一个
函数是负责销毁它的，同时也不清楚在什么时候。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止内存管理问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef short int16_t;
class A
{
    // Implementation
};
void fn ( int16_t i )
{
    static A a1;
    A* a2 = new A;
    if ( i &gt; 10 )
    {
        throw ( &amp;a1 ); // 违规– 指针类型抛出
    }
    else
    {
        throw ( a2 ); // 违规– 指针类型抛出
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef short int16_t;
class A
{
    // Implementation
};

void fn ( int16_t i )
{
    static A a1;
    A* a2 = new A;
    if ( i &gt; 10 )
    {
        throw ( a1 );  // OK
    }
    else
    {
        throw ( *a2 ); // OK
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 15 节, 规则 15-0-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-10</key>
<configkey>EXCEPT-10</configkey>
<name><![CDATA[ 不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中 [EXCEPT-10] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中 [EXCEPT-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果程序使用 goto 或 switch 开关语句将控制传递
到 try 或 catch 块中，那么程序是不规范的；然而，
并非所有的编译器会发布一个诊断消息。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则检测不是所有的编译器都会报告的错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* The code is compilable with MSVC 6.0 */
class Exception{};
void f ( int i )
{
    if ( 10 == i )
    {
        goto Label_10;
    }
    switch ( i )
    {
        case 1:
            try
            {
                Label_10: // 违规
                case 2:   // 违规
                    break;
            }
            catch ( Exception e )
            {
            }
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* The example of correct code */
class Exception{};
void f ( int i )
{
    if ( 10 == i )
    {
        goto Label_10;
    }
    switch ( i )
    {
        case 1:   // OK
            try
            {
                  // ... 
            }
            catch ( Exception e )
            {
            }
        case 2:   // OK
            break;
    }
    Label_10:     // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-0-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-11</key>
<configkey>EXCEPT-11</configkey>
<name><![CDATA[ throw 语句的赋值表达式不得自身引起一个异常抛出 [EXCEPT-11] ]]></name>
<tag>except</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
throw 语句的赋值表达式不得自身引起一个异常抛出 [EXCEPT-11-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果当构造异常对象，或者当初始化此异常对象的
赋值表达式求值的时候抛出一个异常，
那么这就是一个异常，并且优先于
正要被抛出的异常。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class E
{
public:
    E ( )
    {
        throw 10;
    }
};
int foo1()
{
    try
    {
        if ( 0 )
        {
            throw E ( ); // 违规
        }
    }
    catch(...)
    {
    	
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class E
{
public:
    E ( ){ }
};

int foo()
{
    try
    {
        if ( 0 )
        {
            throw E ( ); // OK
        }
    }
    catch(...)
    {
    	
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-1-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-12</key>
<configkey>EXCEPT-12</configkey>
<name><![CDATA[ NULL 不得被显式地抛出 [EXCEPT-12] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
NULL 不得被显式地抛出 [EXCEPT-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“抛出空 throw(NULL) (相当于 throw(0)) 绝不是空指针常数 
(null-pointer-constant) 的抛出，所以只能被一个整数处理程序捕获。
这可能是不符合开发人员的期望，尤其是如果
该项目只具有指针类型(pointer-to-type)异常的处理程序”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define NULL 0
void foo()
{
    try
    {
        throw ( NULL ); // 违规
    }
    catch ( int i )     // NULL exception handled here
    {
        // ...
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define NULL 0
void foo()
{
    try
    {
        throw ( 0 ); // OK
    }

    catch ( int i ) // NULL exception handled here
    {
        // ...
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-1-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-13</key>
<configkey>EXCEPT-13</configkey>
<name><![CDATA[ 代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [EXCEPT-13] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [EXCEPT-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个程序抛出未处理的异常，那么它会以实现定义
的方式终止。特别是，它是实现定义是否调用栈
在终止之前展开，所以任何自动对象的析构函数
可能会或不会被调用。 如果抛出一个异常
作为一个派生类的对象，那么“兼容类型(compatible type)”
可以是该派生类或者其任何基类。”
如果从 'main' 函数体，或者从没有任何
在异常规范列表上记录异常的函数体中 
抛出一个未处理的异常，那么规则报告违规。
参见: EXCEPT-18



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只检查一层嵌套函数的调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此规则的目的是程序应该捕获
所有预期抛出的异常。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
class B {};

void main ( int i ) throw ( )
{
    try
    {
        if ( i &gt; 10 )
        {
            throw A ( );
        }
        else
        {
            throw B ( ); // 违规
        }
    }
    catch ( A const &amp; )
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {};
class B {};

void main ( int i ) throw ( )
{
    try
    {
        if ( i &gt; 10 )
        {
            throw A ( );
        }
        else
        {
            throw B ( ); // OK
        }
    }
    catch ( A const &amp; )
    {
    }
    catch ( B const &amp; )
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-4

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-14</key>
<configkey>EXCEPT-14</configkey>
<name><![CDATA[ 如果一个函数的声明包括一个异常规范，这个函数应该只能抛出所指明类型的异常 [EXCEPT-14] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个函数的声明包括一个异常规范，这个函数应该只能抛出所指明类型的异常 [EXCEPT-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果具有一个异常规范声明的函数抛出一个
没有包括在规范中的异常类型，那么 unexpected() 函数
就会被调用。此函数的行为能够被覆盖在整个项目中，
但是默认情况下会导致抛出 std::bad_exception 的异常。
如果 std::bad_exception 没有被列在异常规范中，
那么 terminate() 将会被调用，从而导致 
程序的实现定义终止。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则只检查两层的嵌套函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Exception{};
void foo ( )
{
    throw ( 21 );
}
void goo ( ) throw ( Exception )  // 违规
{
    foo ( );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception{};
void foo ( )
{
    throw ( 21 );
}
void goo ( ) throw ( Exception, int ) // OK
{
    foo ( );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-5-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-15</key>
<configkey>EXCEPT-15</configkey>
<name><![CDATA[ 类(class)类型的异常应该始终按照引用方式捕获 [EXCEPT-15] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类(class)类型的异常应该始终按照引用方式捕获 [EXCEPT-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个类类型的异常按照值方式捕获，会发生切断（派生关系）。
也就是说，如果是一个派生类的异常对象并且作为基类捕获，
那么只有此基类的函数（包括虚函数）可以被调用。 
此外，任何在派生类中的其他成员数据不能被访问。”
此规则检测按照值方式捕获类或结构类型的异常对象。 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果异常按照引用方式被捕获，不会发生切断（派生关系）。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class ExpBase
{
};
class ExpD1: public ExpBase
{
};
void foo()
{
    try
    {
        throw ExpD1 ( );
        throw ExpBase ( );
    }
    catch ( ExpBase b ) // 违规 - derived type objects will be
    // caught as the base type
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class ExpBase
{
};
class ExpD1: public ExpBase
{
};
void foo()
{
    try
    {
        throw ExpD1 ( );
        throw ExpBase ( );
    }
    catch ( ExpBase &amp;b ) // OK - exceptions caught by reference
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-5

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-16</key>
<configkey>EXCEPT-16</configkey>
<name><![CDATA[ 类的构造函数或析构函数中执行 try 功能模块的处理程序不得引用来自此类或其基础类的非静态成员 [EXCEPT-16] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类的构造函数或析构函数中执行 try 功能模块的处理程序不得引用来自此类或其基础类的非静态成员 [EXCEPT-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在类的构造函数或析构函数中的 try 功能模块的
处理程序中(例如，catch 部分)访问一个类或基类的
非静态(non-static)成员是不允许的。 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“在类的构造函数或析构函数中的 try 功能模块的
处理程序中(例如，catch 部分)访问一个类或基类的
非静态成员是不确定的。例如，如果在创建对象的过程中
抛出一个内存分配异常，那么当处理程序试图去
访问其成员时该对象不存在。 相反，在析构函数中，
该对象可能在异常被处理之前已经成功销毁，
因此不会对处理程序可用。相比之下，静态成员的生命期
大于对象本身的生命期，所以静态成员能够保证
在处理程序访问它时存在。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32_t;
class C
{
    public:
        int32_t x;
        C( )
    try
    {
        // Action that may raise an exception
    }
    catch ( ... )  // Violation
    {
        if ( 0 == x ) // Non-compliant – x may not exist at this point
        {
            // Action dependent on value of x
        }
    }
    ~C ( )
    try
    {
        // Action that may raise an exception
    }
    catch ( ... )  // 违规
    {
	    if ( 0 == x ) // Non-compliant – x may not exist at this point
        {
            // Action dependent on value of x
        }
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在类的构造函数或析构函数中的 try 功能模块的处理程序中
使用类或基类非静态成员。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-17</key>
<configkey>EXCEPT-17</configkey>
<name><![CDATA[ 如果在单独的 try-catch 语句或 try 功能模块中提供多个处理程序给派生类和部分或全部的基类时，这些处理程序应该遵循从最底层的派生类到基类的顺序 [EXCEPT-17] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果在单独的 try-catch 语句或 try 功能模块中提供多个处理程序给派生类和部分或全部的基类时，这些处理程序应该遵循从最底层的派生类到基类的顺序 [EXCEPT-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在单独的 try-catch 语句或 try 功能模块中 
提供多个处理程序给派生类和部分或全部的基类时，
这些处理程序应该遵循从最底层的派生类到基类的顺序。
当测试来看是否异常的类型匹配一个处理程序的类型，
一个派生类的异常会匹配其基类的处理程序。
如果基类的处理程序在派生类的处理程序之前被找到，
那么就会使用基类的处理程序。派生类的处理程序是不可达的代码
并且不会被执行。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可阻止写入不可达的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B { };
class D: public B { };

void foo()
{

	try
	{
		// ...
	}
	catch ( B &amp;b )
	{
		// ...
	}
	catch ( D &amp;d ) // 违规
	{
		// ...
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B { };
class D: public B { };

void foo()
{
	try
	{
		// ...
	}
	catch ( D &amp;d ) // OK - Derived class caught before base class
	{
		// ...
	}
	catch ( B &amp;b ) // OK - Base class caught after derived class
	{
		// ...
	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-6

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>EXCEPT-18</key>
<configkey>EXCEPT-18</configkey>
<name><![CDATA[ 代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [EXCEPT-18] ]]></name>
<tag>except</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [EXCEPT-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个程序抛出未处理的异常，那么它会以实现定义
的方式终止。特别是，它是实现定义是否调用栈
在终止之前展开，所以任何自动对象的析构函数
可能会或不会被调用。 如果抛出一个异常 
作为一个派生类的对象，那么“兼容类型(compatible type)”
可以是该派生类或者其任何基类。”
如果当一个非本地对象被声明或初始化时 
抛出一个未处理的异常，那么规则报告违规。
参见: EXCEPT-13



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只检查一层嵌套函数的调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此规则的目的是程序应该捕获
所有预期抛出的异常。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B{};
class A {
    int i;
    A ( ) : i(1)
    {
        try
        {
            if ( i &gt; 10 )
            {
                throw A ( );
            }
            else
            {
                throw B ( ); 
            }
        }
        catch ( A const &amp; )
        {
        }
    }
};
A a; // 违规 - unhandled exception of class B



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B{};
class A {
    int i;
    A ( ) : i(1)
    {
        try
        {
            if ( i &gt; 10 )
            {
                throw A ( );
            }
            else
            {
                throw B ( ); 
            }
        }
        catch ( A const &amp; )
        {
        }
        catch ( B const &amp; )
        {
        }
    }
};
A a; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 15 节, 规则 15-3-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-01</key>
<configkey>FORMAT-01</configkey>
<name><![CDATA[ 禁止使用未用 ASCII 空格的 Tab 字符 [FORMAT-01] ]]></name>
<tag>format</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用未用 ASCII 空格的 Tab 字符 [FORMAT-01-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检查您是否使用ASCII的空格为制表符. 
不同的操作系统, 显示设备, 和编辑器在处理制表符
有着不同的方式. 代码所包含的制表符会因移植到不同的
环境而有缩进不正确的情况。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这规范预防了包含制表符的代码在不同的环境
有不一致的缩进显示.




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
	int i; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int j; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 43

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-02</key>
<configkey>FORMAT-02</configkey>
<name><![CDATA[ 左边大括号 '{' 应该单独显示在一行上 [FORMAT-02] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
左边大括号 '{' 应该单独显示在一行上 [FORMAT-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查左边的大括号显示在一行上. 
参见: FORMAT-03, FORMAT-34


例外:

规则不遵守枚举，初始化和空的块。
enum E {EN1 = 2, EN2 = 1};  // OK
int array[] = {1,2,3,4,5};  // OK
class FooBar{};             // OK



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了可阅读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A1
{ int a;                      // 违规
};

struct S1 {                   // 违规
    int a;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A1
{
    int a;                    // OK
};

struct S1
{                             // OK
    int a;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>


1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 6 Style Classes - 6.3 Compound Statements- Rec. 24

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.9 Style, AV Rule 61

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-03</key>
<configkey>FORMAT-03</configkey>
<name><![CDATA[ 右边大括号 '{' 应该单独显示在一行上 [FORMAT-03] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
右边大括号 '{' 应该单独显示在一行上 [FORMAT-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测大括号 "}" 独自显示在一行。
参见: FORMAT-02, FORMAT-34


例外:

规范对于枚举, 初始化和空区块排除检查.
它允许在以下的情况时同一行在 '}' 之后放置标识符：
- '}' 结束 'do-while' 构造
- '}' 结束 class/structure/union/enum 的声明



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高可读性及维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo(int i)
{
    if (i == 0) { return i; }   // 违规
    do { i++; } while (i &lt; 10); // 违规
}

struct S{ int i; float f; }ss;  // 违规      



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo(int i)
{
    if (i == 0)
    {
    	return i;
    }   // OK
    do
    {
    	i++;
    } while (i &lt; 10); // OK - Exception
}

struct S
{
    int i;
    float f;
}ss;                   // OK - Exception

enum E {EN1 = 2, EN2 = 1};  // OK - Exception
int array[] = {1,2,3,4,5};  // OK - Exception
class FooBar{};             // OK - Exception



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 6 Style Classes - 6.3 Compound Statements- Rec. 24

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.9 Style, AV Rule 61

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-04</key>
<configkey>FORMAT-04</configkey>
<name><![CDATA[ 单行字符应该不超过 80 个 [FORMAT-04] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
单行字符应该不超过 80 个 [FORMAT-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查单行应该少于80个字符。
本规则适用于各种编辑器. 另外,一些打印机将不能打印超过80的列。
Tab 算作一个字符.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则提高了代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

const int MAXIMUM_LIMIT = 100;

void foo()
{
   int someLocalVariableHoldingTheLimit = (MAXIMUM_LIMIT * 10) - (MAXIMUM_LIMIT/2); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int MAXIMUM_LIMIT = 100;

void foo()
{
   int someLocalVariableHoldingTheLimit = (MAXIMUM_LIMIT * 10) -
                                          (MAXIMUM_LIMIT/2); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-05</key>
<configkey>FORMAT-05</configkey>
<name><![CDATA[ 宏的长度不能超过 10 行 [FORMAT-05] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
宏的长度不能超过 10 行 [FORMAT-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查是否宏的长度超过 10 行。 
宏超过 10 行难以阅读。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规
#define SUM(\
    PARAMETER_1,\
    PARAMETER_2,\
    PARAMETER_3,\
    PARAMETER_4)\
    (\
    PARAMETER_1+\
    PARAMETER_2+\
    PARAMETER_3+\
    PARAMETER_4\
    )

void main()
{
   int val = SUM(1,1,1,1);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// OK
#define SUM( PARAMETER_1, PARAMETER_2, PARAMETER_3, PARAMETER_4)\
    (\
    PARAMETER_1 + PARAMETER_2 + PARAMETER_3 + PARAMETER_4\
    )

void main()
{
   int val = SUM(1,1,1,1);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-06</key>
<configkey>FORMAT-06</configkey>
<name><![CDATA[ 每行只允许有一条语句 [FORMAT-06] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每行只允许有一条语句 [FORMAT-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测每个代码行是否只有一个语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这规范由降低代码的复杂度来提升可读性和维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
   int i; char c; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int ii; // OK
    char cc; 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 42

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-07</key>
<configkey>FORMAT-07</configkey>
<name><![CDATA[ 在赋值运算符之前应该有且仅有一个 ASCII 空格字符 [FORMAT-07] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在赋值运算符之前应该有且仅有一个 ASCII 空格字符 [FORMAT-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查在关系和相等运算符前是否有
一个单一的ASCII 的空格字符。
参见: FORMAT-08



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯有助于
提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int y  =  1; // 违规
int z=1;      // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int x = 1; // OK


参考:

Parasoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-08</key>
<configkey>FORMAT-08</configkey>
<name><![CDATA[ 在赋值运算符之后应该有且仅有一个 ASCII 空格字符 [FORMAT-08] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在赋值运算符之后应该有且仅有一个 ASCII 空格字符 [FORMAT-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则用于检查在复制运算符之后是否存在一个
单一的ASCII空格字符。
参见: FORMAT-07



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯有助于
提高可阅读性..



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int y  =  1; // 违规
int z=1;   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int x = 1; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-09</key>
<configkey>FORMAT-09</configkey>
<name><![CDATA[ 在位运算符之前应该有且仅有一个 ASCII 空格字符 [FORMAT-09] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在位运算符之前应该有且仅有一个 ASCII 空格字符 [FORMAT-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则用于检查在位运算符之前是否有一个
单一的ASCII 空格字符。
参见: FORMAT-10, FORMAT-11



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯
有助于提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   int z = 73;
   int y=0;
   y=z|0x0f; // 违规
   y=z  |  0x0f; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   int z = 73;
   int y=0;
   y=z | 0x0f; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-10</key>
<configkey>FORMAT-10</configkey>
<name><![CDATA[ 在位运算符之后应该有且仅有一个 ASCII 空格字符 [FORMAT-10] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在位运算符之后应该有且仅有一个 ASCII 空格字符 [FORMAT-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则用于检查在位运算符之后是否有一个单一的ASCII 空格字符。
参见: FORMAT-09, FORMAT-11



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯有助于提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   int z = 73;
   int y=0;
   y=z|0x0f; // 违规
   y=z  |  0x0f; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   int z = 73;
   int y=0;
   y=z | 0x0f; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-11</key>
<configkey>FORMAT-11</configkey>
<name><![CDATA[ 在位运算符 '&'前后应该有且仅有一个 ASCII 空格字符 [FORMAT-11] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在位运算符 '&amp;'前后应该有且仅有一个 ASCII 空格字符 [FORMAT-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则用于检查在位运算符 '&amp;'前后
是否有一个单一的ASCII 空格字符。
参见: FORMAT-09, FORMAT-10



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯
有助于提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Space( ) {
   int z = 73;
   int y = 0;

   y = z &amp;  y;   // 违规
   y = z  &amp; y;   // 违规
   y = z&amp; y;     // 违规
   y = z &amp;y;     // 违规
   y = z&amp;y;      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Space( ) {
   int z = 73;
   int y = 0;

   y = z &amp; y;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-12</key>
<configkey>FORMAT-12</configkey>
<name><![CDATA[ 在条件语句的关键字和开括号之间应该有且仅有一个 ASCII 空格字符 [FORMAT-12] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在条件语句的关键字和开括号之间应该有且仅有一个 ASCII 空格字符 [FORMAT-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则会报告违规，如果条件语句关键字和左括号之间：
- 没有空格
- 有多个空格
- 有标签或注释
或者条件语句关键字和左括号不在同一行。
能识别的条件语句关键字有: if, for, switch, while
参见: FORMAT-13



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规范可以改善代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int x, int y)
{
   if(x &lt; y){}                 /* 违规 - 没有空格 */
   if  (x &gt; y){}               /* 违规 - 两个空格 */
   for	(;;);                  /* 违规 - 使用标签 */
   while
       (x &lt; 10)                /* 违规 */
       x++;
   do{ /* .. */ }while(y &gt; 1); /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int x, int y)
{
   if (x &lt; y){}                 /* OK */
   if (x &gt; y){}                 /* OK */
   for (;;);                    /* OK */
   while (x &lt; 10)               /* OK */
       x++;
   do{ /* .. */ }while (y &gt; 1); /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-13</key>
<configkey>FORMAT-13</configkey>
<name><![CDATA[ 在条件语句的开括号之后最多只能有一个 ASCII 的空格字符 [FORMAT-13] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在条件语句的开括号之后最多只能有一个 ASCII 的空格字符 [FORMAT-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查在条件语句; for, if, switch, while
的开括号后是否有最多一个ASCII的
空格字符。
参见: FORMAT-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在开括号后有最多一个ASCII空格字符可
提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
   int x=1;
   int y=1;

   if(  x == y  ) // 违规
   {
   }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
   int x=1;
   int y=1;

   if (x == y) // OK
   {
   }

   if ( x == y ) // OK
   {
   }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-14</key>
<configkey>FORMAT-14</configkey>
<name><![CDATA[ 在三元条件操作符之前只能有一个 ASCII 的空格字符 [FORMAT-14] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在三元条件操作符之前只能有一个 ASCII 的空格字符 [FORMAT-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查在三元条件操作符之前是否有一个单一的
ASCII空格字符.
参见: FORMAT-15



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯
有助于提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int j=10;
    int i=1;
    j = ( i &lt; 0 )  ?  ( -i ) : ( i );  // 违规
    j = ( i &lt; 0 )?( -i ) : ( i );      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int j=10;
    int i=1;
    j = ( i &lt; 0 ) ? ( -i ) : ( i );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-15</key>
<configkey>FORMAT-15</configkey>
<name><![CDATA[ 在三元条件操作符之后只能有一个 ASCII 的空格字符 [FORMAT-15] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在三元条件操作符之后只能有一个 ASCII 的空格字符 [FORMAT-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查在三元条件操作符之后是否
有一个单一的ASCII 的空格字符.
参见: FORMAT-14



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯有助于
提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int j=10;
    int i=1;
    j = ( i &lt; 0 )  ?  ( -i ) : ( i );  // 违规
    j = ( i &lt; 0 )?( -i ) : ( i );      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int j=10;
    int i=1;
    j = ( i &lt; 0 ) ? ( -i ) : ( i );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-16</key>
<configkey>FORMAT-16</configkey>
<name><![CDATA[ 在关系和相等运算符前后只能有一个 ASCII 的空格字符 [FORMAT-16] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在关系和相等运算符前后只能有一个 ASCII 的空格字符 [FORMAT-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查在关系和相等运算符前后是否有一个
单一的 ASCII 的空格字符。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯有助于
提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int x)
{
   if(x==1)     // 违规
   {
   }

   if(x  &gt;  1)  // 违规
   {
   }

   if(x &lt;=1)    // 违规
   {
   }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int x)
{
   if(x == 1)   // OK
   {
   }

   if(x &gt; 1)    // OK
   {
   }

   if(x &lt;= 1)   // OK
   {
   }
}


说明:

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-17</key>
<configkey>FORMAT-17</configkey>
<name><![CDATA[ 在 '.' 或 '->' 操作符之后不能有空白格 [FORMAT-17] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 '.' 或 '-&gt;' 操作符之后不能有空白格 [FORMAT-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测在 '.' 或 '-&gt;' 操作符后是否存在空格.
参见: FORMAT-18



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这促进了操作符和成员/对象之
间关系的连续性. 这些操作符是
为了访问成员/对象使用而不能分开考虑.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct MyStruct {
   int x;
};

void foo(struct MyStruct* myObjPtr) {
    struct MyStruct myObj;
    myObj. x;     /* 违规 */
    myObjPtr-&gt; x; /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct MyStruct {
   int x;
};

void foo(struct MyStruct* myObjPtr) {
    struct MyStruct myObj;
    myObj.x;     /* OK */
    myObjPtr-&gt;x; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel 编程规范 
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
  出自: 6 Style - 6.7 Miscellaneous - Rec. 27

2.联合攻击战斗机, 飞行器, C++ 编程规范
  第 4.9 章节 Style, AV Rule 63

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-18</key>
<configkey>FORMAT-18</configkey>
<name><![CDATA[ 在 '.' 或 '->' 操作符之前不能有空白格 [FORMAT-18] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 '.' 或 '-&gt;' 操作符之前不能有空白格 [FORMAT-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测在特定行的 '.' 或 '-&gt;' 操作符前是否存在空格.
参见: FORMAT-17



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这促进了操作符和成员/对象之
间关系的连续性. 这些操作符是
为了访问成员/对象使用而不能分开考虑.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct MyStruct {
   int x;
};

void foo(struct MyStruct* myObjPtr) {
    struct MyStruct myObj;
    myObj .x;     /* 违规 */
    myObjPtr -&gt;x; /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct MyStruct {
   int x;
};

void foo(struct MyStruct* myObjPtr) {
    struct MyStruct myObj;
    myObj.x;     /* OK */
    myObjPtr-&gt;x; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel 编程规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
  出自: 6 Style - 6.7 Miscellaneous - Rec. 27

2.联合攻击战斗机, 飞行器, C++ 编程规范
  第 4.9 章节 Style, AV Rule 63

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-19</key>
<configkey>FORMAT-19</configkey>
<name><![CDATA[ 在所有逗号后应该有且仅有一个 ASCII 的空格字符 [FORMAT-19] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在所有逗号后应该有且仅有一个 ASCII 的空格字符 [FORMAT-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查在所有逗号后是否有且仅有
一个 ASCII 的空格字符。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

因为逗号用于划分独立的语句，应该使用一个空格来
明确这个用法。这会大大提高 'C'语言的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   int xx,yy;       // 违规
   int xxx,  yyy; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   int x, y; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-20</key>
<configkey>FORMAT-20</configkey>
<name><![CDATA[ 在所有分号后应该有且仅有一个 ASCII 的空格字符 [FORMAT-20] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在所有分号后应该有且仅有一个 ASCII 的空格字符 [FORMAT-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查在所有分号的后面是否有ASCII码的空格符号 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

因为分号代表一个单独的语句，所以要用空格来强调这个情况。
这将极大的增强C代码的可读性。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   int i;

   for ( i = 0;i &lt;= 10;i++) // 违规
   {
   }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   int i;

   for ( i = 0; i &lt;= 10; i++) // OK
   {
   }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft建议

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-21</key>
<configkey>FORMAT-21</configkey>
<name><![CDATA[ 在前缀一元运算符及其操作之间不能有空格 [FORMAT-21] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在前缀一元运算符及其操作之间不能有空格 [FORMAT-21-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测在前缀一元运算符和操作数
间没有存在空格. 这促进了操作符和其
操作数之间关系的连续性. 这些操作符
只在他们的操作数上运作而不能分开考虑.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int i=0;
    -- i;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int i=0;
    --i;   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 63

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-22</key>
<configkey>FORMAT-22</configkey>
<name><![CDATA[ 在后缀一元运算符及其操作之间不能有空格 [FORMAT-22] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在后缀一元运算符及其操作之间不能有空格 [FORMAT-22-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测在后缀一元运算符和操作数
间没有存在空格. 这促进了操作符和其
操作数之间关系的连续性. 这些操作符
只在他们的操作数上运作而不能分开考虑.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   int y = 0;
   y ++;       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   int y = 0;
   y++;        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 63

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-23</key>
<configkey>FORMAT-23</configkey>
<name><![CDATA[ 在 "return" 或 "sizeof " 语句和其开括号间不能有空格 [FORMAT-23] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 "return" 或 "sizeof " 语句和其开括号间不能有空格 [FORMAT-23-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查在 "return" 或 "sizeof " 语句和其开括号间的空白格.
See also: FORMAT-24, FORMAT-25



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   sizeof (int); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   sizeof(int); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-24</key>
<configkey>FORMAT-24</configkey>
<name><![CDATA[ 在 "return" 或  "sizeof " 语句括号里面的参数或表达式不能有空格 [FORMAT-24] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 "return" 或  "sizeof " 语句括号里面的参数或表达式不能有空格 [FORMAT-24-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查在 "return" 或  "sizeof " 语句括号
里面的参数或表达式是否有空白格.
参见: FORMAT-23, FORMAT-25



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   sizeof( int ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   sizeof(int); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-25</key>
<configkey>FORMAT-25</configkey>
<name><![CDATA[ "return" 和 "sizeof" 语句应该使用括号 [FORMAT-25] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
"return" 和 "sizeof" 语句应该使用括号 [FORMAT-25-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则用于检查 "return" 和 "sizeof" 语句
是否使用括号.
参见: FORMAT-23, FORMAT-24



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码可阅读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define true 1
#define false 0
int foo() 
{
   return true; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define true 1
#define false 0
int goo() 
{
   return(true); // OK
}

void xoo() 
{
   return;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-26</key>
<configkey>FORMAT-26</configkey>
<name><![CDATA[ 在逻辑运算符的前后应该有且仅有一个 ASCII 空格字符 [FORMAT-26] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在逻辑运算符的前后应该有且仅有一个 ASCII 空格字符 [FORMAT-26-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则用于检查在逻辑运算符的前后是否有且
仅有一个 ASCII 空格字符.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在操作符和操作数之间清晰分割的习惯有助于
提高可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   int x = 1;
   int y = 1;

   if(x||y)       // 违规
   {
   }

   if(x   ||   y) // 违规
   {
   }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   int x = 1;
   int y = 1;

   if(x || y) // OK
   {
   }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-27</key>
<configkey>FORMAT-27</configkey>
<name><![CDATA[ 代码行以每一级四个空格缩进 [FORMAT-27] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
代码行以每一级四个空格缩进 [FORMAT-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每一行代码应当以每一级四个空格缩进.
参见: FORMAT-34, FORMAT-36, FORMAT-37



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
- 规则对Tab字符作为正确的列缩进.
- 规则不会检查含有"()"或者"[]"代码行以
  及以预处理指令直接开始的代码行.
- 规则将会被下列变量的脚本参数化改变:
  - 变量 "IndentSize" 包含空格缩进的大小. 
  - 变量 "TabSize" 包含tab字符空格缩进的大小.
  - 所有变量设置为4.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可阅读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
 };            // 违规

 void foo(){   // 违规
   }           // 违规
class B {
   int a;      // 违规
     int b;    // 违规
};

 /** 违规 - 不正确的缩进
 * ...
 */
void koo( int x){
    if (x == 0 ||
      x == 1){    // OK - in context of "()"
       x = 1;     // 违规
         x = 2;   // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
};             // OK

void foo(){    // OK
}              // OK
class B {
    int a;     // OK
    int b;     // OK
};

/** OK - 正确的缩进
 * ...
 */
void koo( int x){
    if (x == 0 || 
      x == 1){    // OK - in context of "()"
        x = 1;    // OK
        x = 2;    // OK
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-28</key>
<configkey>FORMAT-28</configkey>
<name><![CDATA[ 在函数的定义中，函数返回类型应该直接写在函数名称前面的单独一行上 [FORMAT-28] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数的定义中，函数返回类型应该直接写在函数名称前面的单独一行上 [FORMAT-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在函数定义时候, 返回值类型应该直
接写在函数名称前面单独一行上."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可阅读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo() {       // 违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int 
foo() {          // OK
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码标准 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 6 Style - 6.2 Functions - Rec. 22

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-29</key>
<configkey>FORMAT-29</configkey>
<name><![CDATA[ 不允许在同一行声明多个变量 [FORMAT-29] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许在同一行声明多个变量 [FORMAT-29-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范会在一行里定义多个变量而触发。
参见: FORMAT-33



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这规范提高了可读性并避免混肴.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a, b;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int a;      // OK
    int b;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.19 章节 变量, AV Rule 152

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-30</key>
<configkey>FORMAT-30</configkey>
<name><![CDATA[ 在函数名后直接写左括号 [FORMAT-30] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数名后直接写左括号 [FORMAT-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在函数名的后面直接写左括号."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可阅读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void 
foo () {	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void
foo() {		// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel编码标准
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 6 Style - 6.2 Functions - Rec. 23

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-31</key>
<configkey>FORMAT-31</configkey>
<name><![CDATA[ 条件表达式中单独进行逻辑判断 [FORMAT-31] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
条件表达式中单独进行逻辑判断 [FORMAT-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

为了帮助阅读,条件表达式
中应当单独逻辑判断。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使代码更具可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int j, int i) {
    if (i != j &gt; 0) {}       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int j, int i) {
    if (i != j &amp;&amp; j &gt; 0) {}  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola编码标准 G-12

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-32</key>
<configkey>FORMAT-32</configkey>
<name><![CDATA[ 解引用操作符 '*' 和地址操作符 `&' 应直接与类型名连接在一起 [FORMAT-32] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
解引用操作符 '*' 和地址操作符 `&amp;' 应直接与类型名连接在一起 [FORMAT-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"解引用操作符 * 和地址运算符 &amp; 应该
直接连接在声明和定义的类型名."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范使代码的可读性更好。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int k=42;
    int *p1;	// 违规
    int &amp;r1 = k;// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int k=42;
    int* p2;	// OK
    int&amp; r2 = k;// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel 编程规范 
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#6.5">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#6.5</A>
  出自: 6 Style - 6.4 Pointers and References - Rec. 26

2.联合攻击战斗机, 飞行器, C++ 编程规范
  第 4.9 章节 Style, AV Rule 62

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-33</key>
<configkey>FORMAT-33</configkey>
<name><![CDATA[ 每个变量都要在单独的声明语句中被声明 [FORMAT-33] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每个变量都要在单独的声明语句中被声明 [FORMAT-33-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“每个变量都要在单独的声明语句中被声明”
当指针和访问指示符在同一个语句中用于多个声明时，
确定变量的类型变得很混乱。 
参见: FORMAT-29



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止混乱和增强源代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
    int* a, b;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) 
{
    int* a;      // OK
    int b;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
   出自: 11 Variables - 规则 39, 6 Style - 6.5 Pointers and References - Rec. 26

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 8 节, 规则 8-0-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-34</key>
<configkey>FORMAT-34</configkey>
<name><![CDATA[ 包含一个区域的括号 "{}" 应该放置在同一列 [FORMAT-34] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
包含一个区域的括号 "{}" 应该放置在同一列 [FORMAT-34-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则用于检查做大括号和右大括号是否在同一列.
参见: FORMAT-02, FORMAT-03


例外:

本规则不适用于枚举,舒适化或者空的块.
enum E {EN1 = 2, EN2 = 1};  // OK
int array[] = {1,2,3,4,5};  // OK
class FooBar{};             // OK
本规则如果行中使用'tab'将不会报出违规.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则可以提高代码的可阅读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Foobar {   // 违规
   int a;
};

struct S1 {      // 违规
    int a;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Foobar 
{                // OK
    int a;
};

struct S1
{                // OK
    int a;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 6 Style Classes - 6.3 Compound Statements- Rec. 24

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.9 Style, AV Rule 60

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-35</key>
<configkey>FORMAT-35</configkey>
<name><![CDATA[ 在函数声明的时候，前括号和第一个形参应该和函数名写在同一行上 [FORMAT-35] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数声明的时候，前括号和第一个形参应该和函数名写在同一行上 [FORMAT-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当声明函数的时候，前括号和第一个参数
(如果有的话)应该和函数名写在同一行上。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可阅读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo
( );            // 违规

void goo(       // 违规
int a );



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( );        // OK

void goo( int a );  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel编码标准
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
from: 6 Style - 6.2 Functions - Rec. 21

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-36</key>
<configkey>FORMAT-36</configkey>
<name><![CDATA[ 同级语句行应该缩进到相同的水平 [FORMAT-36] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
同级语句行应该缩进到相同的水平 [FORMAT-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在相同代码块中的一个接一个的两个语句应当有
相同的所进度。
参见: FORMAT-27, FORMAT-37



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

- 规则识tab字符为正确的列缩进.
- 在"()"或者"[]"中的行内容,或者直接预编译开始的行，本规则无效.
- 在Python脚本中改变"TabSize"的变量值可以参数化
  规则(默认将被设置4个空格).



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可阅读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x ) {
    if (x == 0) {
    }
     x = 2;
    x = 2;          // 违规
   x = 2;           // 违规
    x = 2;          // 违规
   x = 2;           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x ) {
    if (x == 0) {
    }
    x = 2;          // OK
    x = 2;          // OK
    x = 2;          // OK
    x = 2;          // OK
    x = 2;          // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-37</key>
<configkey>FORMAT-37</configkey>
<name><![CDATA[ 控制语句块的第一行应该比控制语句关键字缩进更多 [FORMAT-37] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
控制语句块的第一行应该比控制语句关键字缩进更多 [FORMAT-37-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

控制语句的首行应当比控制语句的关键字缩进的多(if, else, 
while, do while, for, switch, try, catch, case, default)
控制语句的关键字.
参见: FORMAT-27, FORMAT-36



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

- 规则对于直接预编译开始的行无效.
-  Python脚本出现下列可变更的数值将
   参数化规则:
  "MinIndentSize" - 最小允许的空格缩进度
  "MaxIndentSize" - 最大允许的空格缩进度
  "TabSize"       - tab 字符的空格大小
  所有变量默认值为4.

  例如: MinIndentSize = 2, MaxIndentSize = 4:
  
  while (x == 0)
    x = 1;       // OK - 缩进度为 2 

  while (x == 0)
     x = 1;      // OK - 缩进度为 3

  while (x == 0)
      x = 1;     // OK - 缩进度为 4
  


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可提高代码的可阅读性与可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x ) {
    while (x == 0)
      x = 1;       // 违规
    if (x == 0) {
    x++;           // 违规
    x++;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x ) {
    while (x == 0)
        x = 1;     // OK
    if (x == 0) {
        x++;       // OK
        x++;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-38</key>
<configkey>FORMAT-38</configkey>
<name><![CDATA[ 当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个 [FORMAT-38] ]]></name>
<tag>format</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个 [FORMAT-38-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当声明和定义多于两个参数的函数时,
前括号和第一个参数应该和函数名一
起位于同行. 每个增加的参数应分别
写在不同的代码行 (结束括号直接跟
在最后一个参数).



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可读性及风格佳。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b, int c);// 违规

void zoo(                     // 违规    
         int a, int b,        // 违规
         int c
         )                    // 违规
{

}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a,
         int b,
         int c);        // OK

void zoo( int a, 
          int b,
          int c)        // OK
{
}

void goo(int a, int b); // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 58

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-39</key>
<configkey>FORMAT-39</configkey>
<name><![CDATA[ 按字母顺序排序 #include 指令 [FORMAT-39] ]]></name>
<tag>format</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
按字母顺序排序 #include 指令 [FORMAT-39-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则检查是否排序了 #include 指令。如果在前一行的 #include 
指令的名称应该排序在当前行的 #include 之后则将会报告一个 
违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v9.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

&lt;header&gt; 形式的包括不会和 "header" 形式的包括相比较。
只在当两个包括出现在相邻的行中时才做比较。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "zheader2.h"
#include "zheader1.h" // 违规
// this line have no #include
#include "zheader0.h" // ok - previous include not in previous line
#include &lt;iostream&gt; // ok - &lt;header&gt; not compared with "header" 
#include &lt;algorithm&gt; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "zheader0.h"
#include "zheader1.h"
#include "zheader2.h"
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-40</key>
<configkey>FORMAT-40</configkey>
<name><![CDATA[ 空格在开始方括号 '[' 之后和结束方括号 ']' 之前的使用方式应该保持一致 [FORMAT-40] ]]></name>
<tag>format</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空格在开始方括号 '[' 之后和结束方括号 ']' 之前的使用方式应该保持一致 [FORMAT-40-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则检查是否在开始方括号 '[' 之后和结束方括号 ']' 
之前的空格使用方式一致。

参见: FORMAT-39



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

有可能将这条规则改为标准的允许或禁止在 '[' 之后
和 ']'之前使用空格。 这样的修改可以在 python
方法 'formatRule'中完成。 可以通过分配包含首选格式
的字符串来自定义 'format' 变量。  

有三种可能性:

1. format = "[ 1 ] or [1]" (默认)
   在这种情况下，正确的模式有两种:
   - 至少有一个空格既存在于开始方括号 '[' 之后也
      存在于结束方括号 ']'之前
   - 既没有空格在开始方括号 '[' 之后也
      没有在结束方括号 ']'之前。 例如:
   int a1[1];   // OK
   int a2[ 1];  // 违规
   int a3[1 ];  // 违规
   int a4[ 1 ]; // OK

2. format = "[1]"
   在这种情况下应该既没有空格在开始方括号 '[' 之后也
   没有在结束方括号 ']'之前。 例如:
   int a1[1];   // OK
   int a2[ 1];  // 违规
   int a3[1 ];  // 违规
   int a4[ 1 ]; // 违规

3. format = "[ 1 ]"
   在这种情况下应该至少有一个空格既存在于开始方括号
   '[' 之后也存在于结束方括号 ']'之前。 例如:
   int a1[1];   // 违规
   int a2[ 1];  // 违规
   int a3[1 ];  // 违规
   int a4[ 1 ]; // OK



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 默认格式:
int tab[ 10];  /* 违规 */
void foo() {
  tab[0 ] = 0; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// 默认格式:
int tab[10];    /* OK - space removed */
void foo() {
  tab[ 0 ] = 0; /* OK - space added */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by Parasoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>FORMAT-41</key>
<configkey>FORMAT-41</configkey>
<name><![CDATA[ 在开始方括号 '[' 和前面的标识符之间不应该有空格 [FORMAT-41] ]]></name>
<tag>format</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在开始方括号 '[' 和前面的标识符之间不应该有空格 [FORMAT-41-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果有一个空格，Tab 键，注释位于开始方括号 ('[') 的前面
或它是在行的第一个标识符，本条规则将报告一个违规。
这条规则的目的是让括号和前面的标识符 "粘" 
在一起。

参见: FORMAT-17, FORMAT-18, FORMAT-40


例外:

对于以下代码不会报告违规:
   const char special[256] = {
      [0] = 1, ['?'] = 1,
      ['x'] = 1 };



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v9.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int tab [10];  /* 违规 */
void foo(int param []) { /* 违规 */
  char* arr = new char [10]; /* 违规 */
  tab/*comment*/[0] = 0; /* 违规 */
  tab
[0] = 0; /* 违规 */
  delete [] arr; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int tab[10];
void foo(int param[]) {
  char* arr = new char[10];
  tab[0] = 0;
  delete[] arr;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by Parasoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_10_1_1</key>
<configkey>GJB5369-4_10_1_1</configkey>
<name><![CDATA[ 禁止使用嵌套的注释 [GJB5369-4_10_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用嵌套的注释 [GJB5369-4_10_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

C语言不支持注释嵌套即使
有些编译器支持它作为一个语言扩展功能。
注释开始于/*直到遇到第一个*/。
任何出现在一个注释内部的/*都是违反这个规则的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C语言不支持注释嵌套因为它容易导致混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* some comment, end comment marker accidentally omitted

&lt;&lt;New Page&gt;&gt;
Perform_Critical_Safety_Function(X);
/* this comment is not compliant - Violation */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* some comment, end comment marker accidentally omitted */

&lt;&lt;New Page&gt;&gt;
Perform_Critical_Safety_Function(X);
/* this comment is compliant - OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 2 节

2. 起源： Misra 指南 - 第 9 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章，第 2 节，第 2-7-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_10_2_2</key>
<configkey>GJB5369-4_10_2_2</configkey>
<name><![CDATA[ 建议不使用单行注释“∥” [GJB5369-4_10_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
建议不使用单行注释“∥” [GJB5369-4_10_2_2-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则用于检测代码中是否有用单行注释，
如果有会报告违规。单行注释并非在所有编译器中
都是有效的，所以建议不使用单行注释“∥”。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/*********************************
* 建议不使用单行注释符“//”
*********************************/
void static_p(void){
    //这是单行注释	//违规
    /*……*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
void static_p(void){
    /*注释*/	//ok
    /*……*/
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.10.2.2  建议不使用单行注释“∥”

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_11_1_1</key>
<configkey>GJB5369-4_11_1_1</configkey>
<name><![CDATA[ 禁止使用不合适的循环变量类型 [GJB5369-4_11_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用不合适的循环变量类型 [GJB5369-4_11_1_1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"for"语句的三个表达式只能用作如下目的:
-第一个表达式用来初始化循环的计数变量（下例中的i）.
-第二个表达式应该包含测试循环的计数变量（i）,也可选择包含其他循环控制变量（标记）.
-第三个表达式作用是循环计数变量增一或者减一.
这个规则分析for语句,查找初始化的变量以及后面更新的地方,但是并不关心循环控制.
通常,变量是在for语句内部初始化,即使它们与循环的终止条件无关.在极端情况下,整个条件
块可能移到了for语句内,这样就使代码既易出错又难读.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

按照此规则,代码会更安全,可读性较好.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( float max )  {
    float y;
    for (y = 0; y &lt; max; y++);  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int max )  {
    int y;
    for (y = 0; y &lt; max; y++);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

 MISRA-C:2004 C语言在关键系统中的使用指南
 第六部分,第13部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_11_1_2</key>
<configkey>GJB5369-4_11_1_2</configkey>
<name><![CDATA[ 循环变量必须是局部声明的 [GJB5369-4_11_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
循环变量必须是局部声明的 [GJB5369-4_11_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

循环变量应该定义在最小的范围内，
即循环变量的作用域应最小，
所以循环变量必须是局部声明的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned int global_f=0u;
/*******************************
* 循环变量必须是局部声明的 
********************************/
int loop_standards(int p_1)
{
    int j=10;
   /*...*/
    for(global_f=0; global_f&lt;10; global_f=global_f+1){ // 违规
        j--;
    }
    return j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/*******************************
* 循环变量必须是局部声明的 
********************************/
int loop_standards(int p_1)
{
    int j=10;
    int i=0;
   /*...*/
    for(i=0; i&lt;10; i=i+1){ // 违规
        j--;
    }
    return j;
}




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.11.1.2  循环变量必须是局部声明的

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_11_2_1</key>
<configkey>GJB5369-4_11_2_1</configkey>
<name><![CDATA[ 谨慎使用无限循环语句 [GJB5369-4_11_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用无限循环语句 [GJB5369-4_11_2_1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测可能引起无限循环的情况。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免代码死循环。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

for(;;)	// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

for (i=0;i&lt;5;i++)	// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.11.2.1  谨慎使用无限循环语句

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_11_2_2</key>
<configkey>GJB5369-4_11_2_2</configkey>
<name><![CDATA[ 避免在循环中使用 break 语句 [GJB5369-4_11_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在循环中使用 break 语句 [GJB5369-4_11_2_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可使用 break 语句
(除了终止 switch 语句的 cases 以外)。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用 'break' 可能导致错误和混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define true 1
void foo(int i)
{
  while (true) 
  {
    if (i==10) 
    {
      break; /* 违规 */
    }        
  }
    
  switch( i ) 
  {
    case -1:
    while (true) 
    {
      if (i==10) 
      {
        break; /* 违规 */
      }        
    }        
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define true 1
void foo(int i)
{
  switch( i ) 
  {
    case -1 :
    break; /* OK */
                
    case 0 :
    break; /* OK */
                
    default:
    break; /* OK */
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 58 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.24 章 Flow Control Structures， AV 第 191 条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_11_2_3</key>
<configkey>GJB5369-4_11_2_3</configkey>
<name><![CDATA[ 谨慎使用无法控制的循环条件 [GJB5369-4_11_2_3] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用无法控制的循环条件 [GJB5369-4_11_2_3-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

用来做为循环的条件如果是一个常数值，可能导致无限循环。




</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免死循环。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void static_p(void)
{
    while (0)
    {/*.....*/}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免在while条件中放常数值。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.11.2.3  谨慎使用无法控制的循环条件

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_12_1_1</key>
<configkey>GJB5369-4_12_1_1</configkey>
<name><![CDATA[ 禁止对指针变量使用强制类型转换赋值 [GJB5369-4_12_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对指针变量使用强制类型转换赋值 [GJB5369-4_12_1_1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

整数类型不能强制转换成指针。
当一个任意的整型转换成指针时可能出现问题。


例外：

规则允许整型常量0强制转换成指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义或由实现方式定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int* pi;
    int i;
    pi = (int*)i;    // 违规
}


修复 ：

不能把非指针强制转换成指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源：Misra指南45规则

2. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

3. 联合攻击战斗机，飞行器，C++编码规范
    4.24章节流量控制结构，飞行器第182条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_12_2_1</key>
<configkey>GJB5369-4_12_2_1</configkey>
<name><![CDATA[ 谨慎使用其它类型变量给指针赋值 [GJB5369-4_12_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用其它类型变量给指针赋值 [GJB5369-4_12_2_1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测代码里对指针类型变量的赋值是否遵循以地址运算方式处理。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可预防危险的指针操作。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void static_p(unsigned int p_1, unsigned short p_2)
{
	int y=0;
	int *ptr3;
	*ptr3=y;	// 违规
	/*.....*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void static_p(unsigned int p_1, unsigned short p_2)
{
	int y=0;
	int *ptr3;
	*ptr3=&amp;y;	// OK
	/*.....*/;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.12.2.1  谨慎使用其他类型变量给指针赋值

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_12_2_2</key>
<configkey>GJB5369-4_12_2_2</configkey>
<name><![CDATA[ 避免使用不必要的类型转换 [GJB5369-4_12_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用不必要的类型转换 [GJB5369-4_12_2_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Explicit casting between identical types is unnecessary and clutters code.
Furthermore it can mask problems if changes are made to the code (e.g. one of 
the types changes and a conversion with possible loss of information occurs)"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"The use of casting should be sufficient to cause the calculations required 
to occur with the desired precision. Unnecessary casting adds the possibility
of confusion, and may be such that its interaction with the rules of promotion
leads to results other than those expected. Unnecessary casting may also lead
to code which is harder to maintain, should the types of variables change."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int INT;

int someFunction1();
INT someFunction2();

void foo(int p)
{
    /* ... */
    p = (int)someFunction1();  // 违规
    p = (int)someFunction2();  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int INT;

int someFunction1();
INT someFunction2();

void foo(int p)
{
    /* ... */
    p = someFunction1();  // OK
    p = someFunction2();  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines - Rule 44

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.5 Libraries, AV Rule 181

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_13_1_1</key>
<configkey>GJB5369-4_13_1_1</configkey>
<name><![CDATA[ 枚举元素的初始化必须完整 [GJB5369-4_13_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
枚举元素的初始化必须完整 [GJB5369-4_13_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在枚举数列表里，“=”不应该被用来
明确地初始化第一个成员之外的其他成员，
除非所有的元素都被明确地初始化。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

帮助避免错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum TEST { /* Violation */
    X = 1,
    Y,
    Z = 3,
};

enum TEST2 { /* Violation */
    X2,
    Y2 = 2,
    Z2,
};

enum TEST3 { /* Violation */
    X3,
    Y3,
    Z3 = 3,
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum TEST { /* OK */
    X,
    Y,
    Z,
};

enum TEST2 { /* OK */
    X2 = 1,
    Y2,
    Z2,
};

enum TEST3 { /* OK */
    X3 = 1,
    Y3 = 2,
    Z3 = 3,
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 9 节

2. 来源: Misra 指南 - 第 32 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 8 节， 第 8-5-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_13_1_2</key>
<configkey>GJB5369-4_13_1_2</configkey>
<name><![CDATA[ 结构体变量初始化的类型必须一致 [GJB5369-4_13_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构体变量初始化的类型必须一致 [GJB5369-4_13_1_2-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

结构体变量的初始值类型与结构体变量的定义类型一致。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高了代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct s_type_a{int xs; float fs;};
/**********************************************
* 结构体变量初始化的类型必须一致
**********************************************/
void static_p(void)
{
    struct s_type_a sta={3.14f, 0.0f};    // 违规
    /*...*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct s_type_a{int xs; float fs;};
/**********************************************
* 结构体变量初始化的类型必须一致
**********************************************/
void static_p(void)
{
    struct s_type_a sta={3, 0.0f};    // OK
    /*...*/
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.13.1.2  结构体变量初始化的类型必须一致

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_13_1_3</key>
<configkey>GJB5369-4_13_1_3</configkey>
<name><![CDATA[ 结构体变量初始化的嵌套结构必须与定义的相一致 [GJB5369-4_13_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构体变量初始化的嵌套结构必须与定义的相一致 [GJB5369-4_13_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ISO C要求有数组的初始化列表，结构体和共用体类型要被
包括在唯一的一对大括号里（虽然不这么做的后果并不明确）。
这里给出的规则进一步要求使用
额外的大括号来指示结构体嵌套。
数组或者结构体的零初始化只允许在顶层进行。
数组或者结构体的非零初始化
要求对每一个元素有一个明确地初始化程序。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则只检查多达三层括号嵌套初始化。


例外：

“数组或者结构体的所有元素可以通过仅给第一个元素一个
明确的初始化量而被初始化（为0或者空）。如果选择了
这个初始化方法那么第一个元素应该被初始化
为0（或者空），而且不需要使用大括号嵌套。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“该规则强制要求程序员明确地考虑并证实复杂数据类型
的元素被初始化的顺序。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int y[3][2] = { 1, 2, 3, 4, 5, 6 }; // Violation

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, 2}; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int y[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // OK

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, { 2 }}; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 9 节

2. 来源: Misra 指南 - 第 31 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.16 章 初始化，第 AV 144 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 8 节， 第 8-5-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_13_1_4</key>
<configkey>GJB5369-4_13_1_4</configkey>
<name><![CDATA[ 变量使用前必须被赋过值 [GJB5369-4_13_1_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
变量使用前必须被赋过值 [GJB5369-4_13_1_4-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
该规则检测变量在使用之前是否进行初始化。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.0


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
'当未初始化变量作为常量参数传递给一个没有源代码的函数
时报违规'复选框允许你指定是否允许一个未初始化的变量
作为一个常量参数传递给函数。以防参数为 struct 或 class 类型，
只针对完全为初始化的对象报告违规提醒。举例，若 struct 的
某个域以const参数的形式传递给第三方库函数，若该struct类型
只有部分未初始化，则不报告违规。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
该规则检测多种错误情况。
下面只是其中一个会触发违规的例子。

1.
static void useParameter(int *pi)
{
	int j = *pi;
}

static void usageOfUninializedVariablePassedToMethodByAddress()
{
	int i;
	useParameter(&amp;i); // VIOLATION
}

2.
static void pointerDerefInLhsOfDefinition()
{
    int* notInitializedPointer;
    *notInitializedPointer = 0; // VIOLATION
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
使用之前一定要初始化。


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
N/A

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_14_1_1</key>
<configkey>GJB5369-4_14_1_1</configkey>
<name><![CDATA[ 禁止对实数类型的量做是否相等的比较 [GJB5369-4_14_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对实数类型的量做是否相等的比较 [GJB5369-4_14_1_1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可以测试浮点数等值或不等值.浮点数比较推荐的方法是写一个库函数,
用来执行比较操作.库函数应该考虑到浮点粒度（FLT_EPSILON）和被比较值的数量级.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

等值和不等值的间接测试同样是问题,在Misra标准中是不允许的,但此规则不能检查出:
if ( ( x &lt;= y ) &amp;&amp; ( x &gt;= y ) )
{
  /* ... */ 
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

浮点类型的内在属性是等值比较一般都不为真,即便预期为真.
此外,在运行前无法预测比较的结果,甚至每次执行的结果会不一样.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    float x, y;

    if (x == y);      // Violation
    if (x == 0.0f);   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( float epsilon ) {
    float x, y;

    if (x - epsilon &lt;= y &amp;&amp; y &lt;= x + epsilon);  // OK
    if (-epsilon &lt;= x &amp;&amp; x &lt;= epsilon);         // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2. Misra 指南 - 第50条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.25 公式章节, AV 第202条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第六部分,第6-2-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_14_1_2</key>
<configkey>GJB5369-4_14_1_2</configkey>
<name><![CDATA[ 禁止逻辑判别的表达式不是逻辑表达式 [GJB5369-4_14_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止逻辑判别的表达式不是逻辑表达式 [GJB5369-4_14_1_2-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于一个数据值是否为零的测试必须是显式的,除非数据是布尔值.
"布尔有效"的表达式要么是"创建为布尔",要么是"强制为布尔",定义如下:
下列操作符将生成"创建为布尔"的值:
-相等运算符 (== 和 !=)
-逻辑运算符(!, &amp;&amp; 和 ||)
-关系运算符 (&lt;, &gt;, &lt;= 和 &gt;=)
使用工具执行特定类型的强制机制,产生强制为布尔的值.
布尔类型可能和特定的typedef相联系,用于任何布尔型的对象.

使用逻辑运算符的操作数,不会造成违规:
-创建为布尔值
-布尔常量
-定义为“0”或者“1”的整型或者enum常量
-变量，参数或者以下类型的表达式
   -布尔
   -typedef为布尔
   -名称以"bool"（忽略大小写）开头的enum,
      在主体中包含2个enum常量
   -typedef为char/short/int/enum，并且名称以"bool"开头（忽略大小写）
   -参考以上类型



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对于常量表达式此规则不会报告违规.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

清楚地区分整型和逻辑值.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo()
{
    return 1;
}

void foo( int x, int y )
{
  if (goo()) {}	// Violation
  if (y) {}     // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo()
{
    return 1;
}

void foo( int x, int y )
{
  if (goo() != 0) {}	// OK
  if (y != 0) {}        // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第23部分

2. Misra 指南 - 第49条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_14_1_3</key>
<configkey>GJB5369-4_14_1_3</configkey>
<name><![CDATA[ switch 语句中的表达式禁止是逻辑表达式 [GJB5369-4_14_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句中的表达式禁止是逻辑表达式 [GJB5369-4_14_1_3-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

switch条件中不能出现有效的布尔类型值。
本规则禁止使用以下产生布尔类型值的运算符：
a) 等号运算符 (== and !=)
b) 逻辑运算符 (!, &amp;&amp; and ||)
c) 关系运算符 (&lt;, &gt;, &lt;= and &gt;=)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则可以阻止在switch条件中使用布尔数值.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i)
{
    switch(i == 0)           // 违规
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(int i) 
{
    switch(i)                   //通过
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章，第15部分

2. 来源: Misra 指南—第63条规则

3. 联合攻击战斗机, 飞行器
   第4.24章Chapter 4.24 Flow Control Structures, AV 第195条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_14_2_1</key>
<configkey>GJB5369-4_14_2_1</configkey>
<name><![CDATA[ 建议逻辑表达式采用显式的表达 [GJB5369-4_14_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
建议逻辑表达式采用显式的表达 [GJB5369-4_14_2_1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

从清晰可读的角度出发，建议逻辑表达式采用显式的表达。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

if((!(trcsta&lt;=ISTRAC))&amp;&amp;(!(FDIRECT&lt;=it))) // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

if((trcsta&gt;ISTRAC)&amp;&amp;(fdirect&gt;IT)) // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.14.2.1  建议逻辑表达式采用显式的表达

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_15_1_1</key>
<configkey>GJB5369-4_15_1_1</configkey>
<name><![CDATA[ 禁止枚举类型中的元素名与已有的变量名同名 [GJB5369-4_15_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止枚举类型中的元素名与已有的变量名同名 [GJB5369-4_15_1_1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

枚举类型中的元素名应保持唯一性。
该准则的违背通常表现在，枚举中
元素名与已有的全局变量名同名。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免代码死循环。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned int duplicate1=0u;
/*********************************************
* 禁止枚举类型中的元素名与已有的变量名同名
*********************************************/
void static_p(void)
{
    enum Name_Type{e1,duplicate}EnumVar;// 违规
    EnumVar=e1;
    /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned int duplicate1=0u;
/*********************************************
* 禁止枚举类型中的元素名与已有的变量名同名
*********************************************/
void static_p(void)
{
    enum Name_Type{e2,duplicate}EnumVar;// OK
    EnumVar=e1;
    /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.15.1.1  禁止枚举类型中的元素名与已有的变量名同名

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_15_1_2</key>
<configkey>GJB5369-4_15_1_2</configkey>
<name><![CDATA[ 禁止局部变量与全局变量同名 [GJB5369-4_15_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止局部变量与全局变量同名 [GJB5369-4_15_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏全局变量和全局参数的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

隐藏全局变量或者全局参数的名字
会导致错误或者混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int x;
void foo( ) {
    int x;     /* Violation */ 
    x = 3;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免使用全局变量和全局参数的名字隐藏。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. ISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_15_1_3</key>
<configkey>GJB5369-4_15_1_3</configkey>
<name><![CDATA[ 禁止形参名与全局变量名同名 [GJB5369-4_15_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止形参名与全局变量名同名 [GJB5369-4_15_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏全局变量和全局参数的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

隐藏全局变量或者全局参数的名字
会导致错误或者混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int x;
void foo( ) {
    int x;     /* Violation */ 
    x = 3;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免使用全局变量和全局参数的名字隐藏。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. ISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_15_1_4</key>
<configkey>GJB5369-4_15_1_4</configkey>
<name><![CDATA[ 禁止形参名与类型或标识符同名 [GJB5369-4_15_1_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止形参名与类型或标识符同名 [GJB5369-4_15_1_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类型定义得到的名字不允许被重用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

重用类型定义得到的名字会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int MyInt;
void foo() 
{
  double MyInt;  /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int MyInt;
void foo() 
{
  double MyVar;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 17 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_15_1_5</key>
<configkey>GJB5369-4_15_1_5</configkey>
<name><![CDATA[ 禁止在内部块中重定义已有的变量名 [GJB5369-4_15_1_5] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在内部块中重定义已有的变量名 [GJB5369-4_15_1_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏局部变量的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

局部变量的名字隐藏会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( ) {
    int a;
    {
        int a;    /* Violation */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免隐藏局部变量的名字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_15_1_6</key>
<configkey>GJB5369-4_15_1_6</configkey>
<name><![CDATA[ 禁止复杂表达式中使用 volatile 类型的变量 [GJB5369-4_15_1_6] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止复杂表达式中使用 volatile 类型的变量 [GJB5369-4_15_1_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用 volatile 关键字。
参见: misra2004-12_2_f



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则防止表达式的求值依赖于编译器版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1() {
  volatile int v;  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 volatile 关键字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 46 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.25 章 Expressions， AV 第 205 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_15_2_1</key>
<configkey>GJB5369-4_15_2_1</configkey>
<name><![CDATA[ 在源程序中谨慎使用非标准字符 [GJB5369-4_15_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在源程序中谨慎使用非标准字符 [GJB5369-4_15_2_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只能使用定义在 ISO C 标准里的那些 
字符和转义序列。

第 5.2.1 章节的 ISO C 标准定义了 91 个字符，
这个是所有编译器最低的源字符集
这些是唯一应使用的字符，
即使编译器支持一个更大的字符集，
或支持其他的字符集。

这些字符是:
- 拉丁字母里的 26 个大写字母
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z

- 拉丁字母里的 26 个小写字母
a b c d e f g h i j k l m
n o p q r s t u v w x y z

- 10 个十进位数字
0 1 2 3 4 5 6 7 8 9

- 以下的 29 图形字符
!"#%&amp;' ()*+,-./:
;&lt;=&gt;?[\]^_{|}~
空格字符和控制字符代表 
水平制表符，垂直制表符， 换页。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

只需要最少的字符集



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    char c1 = '$';  /* 违规 */
    char c2 = '`';  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用没有定义在 ISO C 标准里的字符。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 5 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.4 章 Environment， AV 第 9 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_15_2_2</key>
<configkey>GJB5369-4_15_2_2</configkey>
<name><![CDATA[ 禁止使用预处理操作符 # 和 ## [GJB5369-4_15_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用预处理操作符 # 和 ## [GJB5369-4_15_2_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有关#和##预处理操作符，赋值的顺序一直有争议。
编译器在这些操作符的实现中是不一致的，
因此问了避免这些问题不要使用他们。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来阻止 # 和 ##操作符的不一致的实现。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define stringer( x ) printf( #x "\n" ) /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用# 和 ## 预处理操作符。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-3-2条规则

3. 国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.3.1.1  禁止在同一个宏中使用多个"#"或者"##"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_1</key>
<configkey>GJB5369-4_1_1_1</configkey>
<name><![CDATA[ 过程名禁止被重用 [GJB5369-4_1_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
过程名禁止被重用 [GJB5369-4_1_1_1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一个过程名禁止被重用于其它之处。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(void)
{
}

void static_p(void)
{
int foo=1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.1.1  过程名禁止被重用

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_10</key>
<configkey>GJB5369-4_1_1_10</configkey>
<name><![CDATA[ 禁止过程或函数中的参数表为空 [GJB5369-4_1_1_10] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止过程或函数中的参数表为空 [GJB5369-4_1_1_10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果函数没有参数，参数列表应该被声明为 void。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo();  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(void); /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源： Misra指南 - 第76条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_11</key>
<configkey>GJB5369-4_1_1_11</configkey>
<name><![CDATA[ 禁止在同一个宏中使用多个 # 或 ## [GJB5369-4_1_1_11] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在同一个宏中使用多个 # 或 ## [GJB5369-4_1_1_11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有关#和##预处理操作符，赋值的顺序一直有争议。
为了避免这类问题，两个操作符仅仅只有一个
可以出现在单个的宏定义中。
(i.e. 一个#, 或者一个## 或者都没有).



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define TEST1(A,B,C) A # B # C      // 违规 
#define TEST2(A,B,C) A ## B # C      //违规 
#define TEST3(A,B,C) A ## B ## C    // 违规 



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define TESTa(A,B) A # B            // OK
#define TESTb(A,B) A ## B            // OK 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. 来源： Misra 指南 - 第98条规则

3. MISRA C++2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-3-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_12</key>
<configkey>GJB5369-4_1_1_12</configkey>
<name><![CDATA[ 禁止定义不象函数的宏 [GJB5369-4_1_1_12] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止定义不象函数的宏 [GJB5369-4_1_1_12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在定义一个如函数的宏时， 整个定义
应该括在括号内。
参见: MISRA2004-19_10



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升代码的可读性并确保操作顺序。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define abs( x ) (x)&gt;=0 ? c: -(x)           /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define abs2( x ) ((x)&gt;=0 ? c: -(x))        /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 96 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_13</key>
<configkey>GJB5369-4_1_1_13</configkey>
<name><![CDATA[ 禁止在宏中包含不允许的项 [GJB5369-4_1_1_13] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在宏中包含不允许的项 [GJB5369-4_1_1_13-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

C 语言宏应该仅仅扩展到一个使用括号初始化的语句，
一个常量，一串字符，一个插入语，一种类型的修饰，
一种存储类别的指定，或者一个do-while-0的结构。
这些是仅允许的宏的使用。在特别的宏里，
不应该使用它来定义语句或者除了使用do-while结构部分语句。
宏也不会重定义语言的句法规则。在宏替换列表中，
无论哪种括号类型( ) { } [ ]，括号应该匹配。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

存储类别的说明和类型修饰包含这样的关键字：
typedef, extern, static, auto, register, const, volatile, restrict.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止语言句法规则的重定义。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PI 3.14159F      /* 正常 */
#define DOUBLE_PI  2*PI  /* 违规 */
#define int64_t    long  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define PI 3.14159F       /* 正常 */
#define DOUBLE_PI (2*PI)  /* 正常 */
typedef long int64_t;     /* 正常 */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2.来源: Misra 指南 - 第90条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_14_a</key>
<configkey>GJB5369-4_1_1_14_a</configkey>
<name><![CDATA[ 禁止重新定义保留字 [GJB5369-4_1_1_14_a] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止重新定义保留字 [GJB5369-4_1_1_14_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ #undef 一个来自在标准库定义的宏通常是一种错误的习惯。
同样， #define一个C保留字符或者标准库中的任何一个宏、
对象或者函数的C关键字的宏名，也是一种错误的习惯。
例如, 有一些特殊的保留字个函数名，如果它们被重新定义
或者没有定义，他们被用来指定一些未定义的行为，包括
定义 _ _LINE_ _, _ _FILE_ _, _ _DATE_ _, _ _TIME_ _, 
_ _STDC_ _, errno and assert。一般来说， 所有的标识
符开头的下划线字符保留。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则防止未定义行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define __A 1	    // 违规
#define assert 1   // 违规
#undef __AA         //违规
#undef assert       // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要 #define 和 #undef 保留字符



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第20部分

2. 来源: Misra 指南 - 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
  第6章，第17部分，第17-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_14_b</key>
<configkey>GJB5369-4_1_1_14_b</configkey>
<name><![CDATA[ 禁止重新定义保留字 [GJB5369-4_1_1_14_b] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止重新定义保留字 [GJB5369-4_1_1_14_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“#undef 或者#define C保留字是不正确的。”


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

从定义保留字将带来错误和混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define break 1     // 违规
#define continue 1  // 违规
#undef while        // 违规
#undef return       // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要#define or #undef 跟保留字



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第20部分

2. 来源: Misra 指南 - 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南,第6章，第17部分，第17-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_15</key>
<configkey>GJB5369-4_1_1_15</configkey>
<name><![CDATA[ 字符型变量必须明确定义是有符号还是无符号 [GJB5369-4_1_1_15] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符型变量必须明确定义是有符号还是无符号 [GJB5369-4_1_1_15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

'char' 的类型可以被编译器自动定义成有符号或是 
无符号的类型。开发人员一定要在定义 'char' 
类型时指定是否要有符号， 而不是假设所使用 
的编译器，让编译器自动定义 'char' 类型的符号。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果一个变量的类型是一个 typedef 为 char 的，那么将会在
typedef 声明上报告一个违规。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守这一规则可以提升代码安全性和可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef char CHAR; // 违规

char foo(char)     // 违规 x 2
{
   char var1;      // 违规
   CHAR var2;      // OK - Violation is reported on a typedef declaration
}

char (*fptr1)();      // 违规
void (*fptr2)(char);  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char UC; // OK
void foo()
{
   signed char b;         // OK
}
void bar1(signed char d); // OK
unsigned char bar5();     // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 14 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_16</key>
<configkey>GJB5369-4_1_1_16</configkey>
<name><![CDATA[ 禁止对一个名字重新定义 [GJB5369-4_1_1_16] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对一个名字重新定义 [GJB5369-4_1_1_16-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在一段程序中任何标签的名称都不允许被重用做其它目的。
ISO 9899:1990并没有定义这种行为：一个聚集声明
使用一个不同形式的类型说明符的标签。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

标签的名称的重用会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct stag { int a; };      

void stag(void){}        // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct stag { int a; }; 

void foo(void){}         // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-4 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_17</key>
<configkey>GJB5369-4_1_1_17</configkey>
<name><![CDATA[ 用 typedef 自定义的类型禁止被重新定义 [GJB5369-4_1_1_17] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
用 typedef 自定义的类型禁止被重新定义 [GJB5369-4_1_1_17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类型定义得到的名字不允许被重用为另一个类型定义的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

重用类型定义得到的名字会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned char uint8_t;

void foo()
{
   typedef signed char uint8_t; /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char uint8_t;

void foo()
{
   typedef signed char int8_t; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 17 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_18</key>
<configkey>GJB5369-4_1_1_18</configkey>
<name><![CDATA[ 禁止在同一个文件中有 #if 而没有 #endif [GJB5369-4_1_1_18] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在同一个文件中有 #if 而没有 #endif [GJB5369-4_1_1_18-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当语句块的包含和不包含由一系列预处理指令控制时，
如果所有相关的指令不在一个文件里面的话，
可能会引起混淆。此规则要求预处理指令 #if/ifdef/ifndef 的
个数必须与文件中 #endi f的个数相匹配。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提升了良好的代码结构，阻止了一些问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 违规 */
#define A
#ifdef A
#include "file1.h"
#endif
#if 1
#include "file2.h"



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* OK*/
#define A
#ifdef A
#include "file1.h"
#endif
#if 1
#include "file2.h"
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
    第6章，第16部分，第16-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_19</key>
<configkey>GJB5369-4_1_1_19</configkey>
<name><![CDATA[ 禁止数组没有边界限定 [GJB5369-4_1_1_19] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止数组没有边界限定 [GJB5369-4_1_1_19-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则用于检测数组定义时是否有边界限定，如果没有则报告违规。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/*********************************
* 禁止数组没有边界限定
*********************************/
void static_p
{
    unsigned int u_array[]={1,2,3}; //违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void static_p
{
    unsigned int u_array[4]={1,2,3}; //OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.1.19  禁止数组没有边界限定

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_2</key>
<configkey>GJB5369-4_1_1_2</configkey>
<name><![CDATA[ 标号名禁止被重用 [GJB5369-4_1_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标号名禁止被重用 [GJB5369-4_1_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ISO C 定义了数个不同的命名空间。
从技术上来说在各自的命名空间里使用同一个名字来代表
完全不同的项是可以的。然而这种做法是不允许的原因是
它会带来混淆，因此名字不可以重用，
即使是在不同的命名空间里。”
C语言里有4个命名空间
1. 标签名字
2. 结构体，共用体和枚举类型的关键字
3. 结构体和共用体的成员；每个结构体或者共同体作为一个独立的命名空间
4. 所以其他标识符；例如枚举常量，变量，函数，类型定义



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

输出消息仅仅展示了第一个（行）在其它命名空间里
被重用的名字的位置。


例外：

该规则的一个例外是结构体成员的命名，
不同结构体的成员名字可以重用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef struct MyStruct  // tags name space
{
  int Member;            // members name space
} MyStruct;              // Violation - identifiers name space



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef struct MyStruct  // tags name space
{
  int Member;             // members name space
} MyStructObj;            // OK - identifiers name space



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 12 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-6 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_20</key>
<configkey>GJB5369-4_1_1_20</configkey>
<name><![CDATA[ 禁止在#include<......>中使用绝对路径名 [GJB5369-4_1_1_20] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在#include&lt;......&gt;中使用绝对路径名 [GJB5369-4_1_1_20-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>


头文件路径应该在编译器的选项中予以设置说明，
禁止在#include&lt;......&gt;中使用绝对路径名。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>
/**************************************
* 禁止在#include&lt;......&gt;中使用绝对路径名
**************************************/
#include &lt;C:\VC\include\stdio.h&gt;  // 违规
void Dummy(void)
{
  /*...*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/**************************************
* 禁止在#include&lt;......&gt;中使用绝对路径名
**************************************/
#include &lt;stdio.h&gt;  // OK
void Dummy(void)
{
  /*...*/
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.1.20  禁止在#include&lt;......&gt;中使用绝对路径名

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_21</key>
<configkey>GJB5369-4_1_1_21</configkey>
<name><![CDATA[ 禁止结构体声明不完整 [GJB5369-4_1_1_21] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止结构体声明不完整 [GJB5369-4_1_1_21-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
此规则用于检测结构体声明不完整，结构体的声明必须要完整地声明，否则报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
增强代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/********************************
* 禁止结构体声明不完整
********************************/
struct static_p;
void dummy(void)
{
    /*...*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct static_p{
　int iNum;
　long lLength; 
};
void dummy(void)
{
    /*...*/
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.1.21  禁止结构体声明不完整

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_3</key>
<configkey>GJB5369-4_1_1_3</configkey>
<name><![CDATA[ 禁止在结构体定义中含有空域 [GJB5369-4_1_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在结构体定义中含有空域 [GJB5369-4_1_1_3-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

通常出现在类似于如下的情形中：
struct atag { struct anothertag{...};...};



</PRE>
<STRONG>
示例
</STRONG>
<PRE>
#include "c_standards.h"  
/*************************************************
 * 准则16：禁止在结构体定义中含有空域。
 *************************************************/
struct s_p {UINT_32 xs; struct {UCHAR ac, ab;};};
void static_p(void)
{ 
   struct s_p sb;
   sb.xs = 1;
   /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.1.3  禁止在结构体定义中含有空域

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_4</key>
<configkey>GJB5369-4_1_1_4</configkey>
<name><![CDATA[ 禁止声明多重标号 [GJB5369-4_1_1_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止声明多重标号 [GJB5369-4_1_1_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用多重标号是多余的，多重标号完全可以用一个标号来替代。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/*********************************************************
 *  禁止声明多重标号
 *********************************************************/
static void static_p(void)
{
    start: begin:
    /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/*********************************************************
 *  禁止声明多重标号
 *********************************************************/
static void static_p(void)
{
    start:
    /* ... */
    begin:
    /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.1.4  禁止声明多重标号

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_6</key>
<configkey>GJB5369-4_1_1_6</configkey>
<name><![CDATA[ 在过程声明中必须对参数说明 [GJB5369-4_1_1_6] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在过程声明中必须对参数说明 [GJB5369-4_1_1_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

In many compiler implementations, functions which do not declare return
type are automatically assigned int return type. This will conflict with
semantics of function implementation.
The empty parameter list in a function declarator that is not part of
a definition of that function specifies that no information about
the number or types of the parameters is supplied. The special case
of an unnamed parameter of type void as the only item in the list
specifies that the function has no parameters.
Explicitly specifying parameter and return types as void clearly conveys
the function intent.

The rule reports a violation if:
- a function is declared or defined with an empty parameter list or
- a function does not have an explicit return type and does not contain
  return statement with a value
The rule is enabled only for C language.

See also: MISRA2004-8_2_a, MISRA2004-16_5



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1();         /* Violation - there is no 'void' in parameter list */
void foo1() {}       /* Violation - there is no 'void' in parameter list */

foo2(void);          /* Violation - there is no 'void' in return type */
foo2(void) {}        /* Violation - there is no 'void' in return type */
foo3(void) {return;} /* Violation - there is no 'void' in return type */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(void);          /* OK */
void foo1(void) {}        /* OK */

void foo3(void) {return;} /* OK */

foo4(void){ return 0;} /* OK - the 'return' statement with a value in function */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 16

2. Origin: Misra Guidelines - Rule 76

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_7</key>
<configkey>GJB5369-4_1_1_7</configkey>
<name><![CDATA[ 禁止过程参数只有类型没有标识符 [GJB5369-4_1_1_7] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止过程参数只有类型没有标识符 [GJB5369-4_1_1_7-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一些编译器允许过程参数的说明只有类型而
没有标识符，但这样的参数并不能真正地被
使用，因此禁止过程参数只有类型没有标识符。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct s_type_b{unsigned int xs;};
/*******************************
* 禁止过程参数只有类型没有标识符     
********************************/
void static_p_a(unsigned int p_1, struct s_type_b *); // 违规
void static_p_a(unsigned int p_1, struct s_type_b *)  // 违规
{
    /*...*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct s_type_b{unsigned int xs;};
/*******************************
* 禁止过程参数只有类型没有标识符     
********************************/
void static_p_a(unsigned int p_1, struct s_type_b * p_2); // OK
void static_p_a(unsigned int p_1, struct s_type_b * p_2)  // OK
{
    /*...*/
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.1.7  禁止过程参数只有类型没有标识符

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_8</key>
<configkey>GJB5369-4_1_1_8</configkey>
<name><![CDATA[ 禁止在过程参数表中使用省略号 [GJB5369-4_1_1_8] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在过程参数表中使用省略号 [GJB5369-4_1_1_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不要使用可变数量的参数来定义函数，否则将带来许多潜在的问题。
用户不能使用一些可变数量的参数来书写增加的函数。
将阻止使用stdarg.h, va_arg, va_start and va_end。”
本条规则将在下列地方报出违规信息：
-包含&lt;stdarg.h&gt; or &lt;cstdarg&gt;的头文件
-使用va_arg/va_start/va_end的函数
-使用可变数量的参数来定义的函数（没有声明）



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则阻止不确定的行为.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdarg.h&gt;                     /* 违规 */
int average( int first, ... );          /* OK - Violation on definition */

int average( int first, ... ) {         /* 违规 */
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start( marker, first );          /* 违规 */
    while( i != -1 ) {
        sum += i;
        count++;
        i = va_arg( marker, int );      /* 违规 */
    }
    va_end( marker );                   /* 违规 */
    return( sum ? (sum / count) : 0 );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用可变参数的函数.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第6章，第16部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_1_9</key>
<configkey>GJB5369-4_1_1_9</configkey>
<name><![CDATA[ 禁止重新定义使用 C 或 C++ 的关键字 [GJB5369-4_1_1_9] ]]></name>
<tag>gjb5369</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止重新定义使用 C 或 C++ 的关键字 [GJB5369-4_1_1_9-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

重新定义使用 C 和 C++ 的关键字，破坏了程序的可读性，因此禁止重新定义使用 C 或 C++ 的关键字。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/********************************************
*  禁止重新定义使用 C 或 C++ 关键字
********************************************/
void static_p(void)
{
      unsigned int public      = 0;
      unsigned int private     = 0;
      unsigned int protected = 0;
      unsigned int operator   = 0;
      unsigned int new         = 0;
      unsigned int template  = 0;
      unsigned int virtual      = 0;
      unsigned int delete     = 0;
      unsigned int friend      = 0;
      unsigned int cout       = 0;
      unsigned int cin         = 0;
      unsigned int endl       = 0;
     /*...*/
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要重新定义使用 C 或 C++ 关键字


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.1.9  禁止重新定义使用 C 或 C++ 的关键字

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_2_1</key>
<configkey>GJB5369-4_1_2_1</configkey>
<name><![CDATA[ 建议使用typedef在统一的变量声明头文件中对基本变量类型重新定义 [GJB5369-4_1_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
建议使用typedef在统一的变量声明头文件中对基本变量类型重新定义 [GJB5369-4_1_2_1-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在不同的编译程序中基本类型的长度是大不相同的，因此鼓励在统一
的一个变量声明头文件中使用typedef定义软件使用的变量类型，而在
除此之外的程序中禁止使用基本类型的声明。（注：该规则在使用时，
请根据实际情况调整头文件名词。）



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条准则是为了使代码易于移植。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>
不在统一的变量声明头文件中定义。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

例如，在头文件c_standards.h中定义：

typedef unsigned int	UINT_32;
typedef int		SINT_32;
typedef unsigned short	UINT_16;
typedef unsigned char	UCHAR;
typedef float		FLOAT_32;
typedef double		FLOAT_64;

#include "c_standards.h"  
void p(void)
{
   UINT_32 i = 0u;
   FLOAT_32 x = 0.0f;
   ……
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.2.1  建议使用typedef在统一的变量声明头文件中对基本变量类型重新定义

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_2_2</key>
<configkey>GJB5369-4_1_2_2</configkey>
<name><![CDATA[ 避免将过程定义为参数 [GJB5369-4_1_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免将过程定义为参数 [GJB5369-4_1_2_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

将过程定义为参数可以用来生成代码，
但也会使程序的控制流变得不清晰，
因此避免将过程定义为参数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void test_p(int p_1)
{/*...*/}
/*********************************************************
 *  避免将过程定义为参数
 *********************************************************/
void static_p(void(*p_proc_pointer)(int parameter_1))
{
    p_proc_pointer=test_p;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不允许通过参数调用过程/函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.2.2  避免将过程定义为参数

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_2_3</key>
<configkey>GJB5369-4_1_2_3</configkey>
<name><![CDATA[ 过程中避免使用过多的参数，建议不要超过20 个 [GJB5369-4_1_2_3] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
过程中避免使用过多的参数，建议不要超过20 个 [GJB5369-4_1_2_3-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用全局变量与使用参数传递之间的权衡是一个复杂的问题。
通过实参与形参传递数据确实会消耗一些时间，而使用全局
变量会快一些。但过多地使用全局变量也会带来许多副作用。
减少参数个数的方法之一是可以将相关参数定义在结构体中，
这样使过程看起来更简洁。一般建议通过实参与形参传递数据
的参数个数不要超过îð 个。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,
            int l, int m, int n, int o, int p, int q, int r, int s, int t,
            int u, int v, int w, int x)  // 违规
{ 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// 限制参数的数量
void foo(int a, int b, int c, int d, int e, int f, int g)  // OK
{ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.2.3  过程中避免使用过多的参数，建议不要超过20 个

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_2_4</key>
<configkey>GJB5369-4_1_2_4</configkey>
<name><![CDATA[ 在结构体定义中谨慎使用位域 [GJB5369-4_1_2_4] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在结构体定义中谨慎使用位域 [GJB5369-4_1_2_4-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

位域是C中的一个难点，因为对它的使用必须特别谨慎。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/************************************************************
 * 禁止在结构体定义中使用位域。
 ************************************************************/
struct bitfield1{unsigned int x:1;};     // 违规
/*-- Function prototypes --*/
void dummy(void)
{
   /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在结构体定义中使用位域。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.2.4 在结构体定义中谨慎使用位域

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_2_6</key>
<configkey>GJB5369-4_1_2_6</configkey>
<name><![CDATA[ 禁止在块中使用 #define 或 #undef [GJB5369-4_1_2_6] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在块中使用 #define 或 #undef [GJB5369-4_1_2_6-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

尽管在一个代码文件的任何地方放置 #define 或者
#undef 是合法的，但是把他们放在程序块中是一个误导，
因为这样意味着给那段程序块一个范围限制，
但是本意却不是那样的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int* x ) {
#define CHECKPARAM(p) (p != 0)  // 违规
    if (CHECKPARAM(x)) {
	/* ... */
    }
#undef CHECKPARAM               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define CHECKPARAM(p) (p != 0) // OK- 宏在任何块的外面定义
void foo( int* x ) {
    if (CHECKPARAM(x)) {
        /* ... */
    }
}
#undef CHECKPARAM              // OK- 宏在任何块的外面撤销定义



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6,章 第19部分

2. 来源: Misra指南-第91条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-2条规则

4.  国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.2.5  避免在一个程序块中单独使用"#define"

4.  国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.2.6 避免在一个程序块中单独使用"#undef"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_2_7</key>
<configkey>GJB5369-4_1_2_7</configkey>
<name><![CDATA[ 谨慎使用 #pragma [GJB5369-4_1_2_7] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 #pragma [GJB5369-4_1_2_7-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#pragma 可以用来掩盖所有类型的问题，因此应谨慎使用 #pragma



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#pragma TEST            /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.2.7  谨慎使用 #pragma

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_2_8</key>
<configkey>GJB5369-4_1_2_8</configkey>
<name><![CDATA[ 谨慎使用联合(union)的声明 [GJB5369-4_1_2_8] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用联合(union)的声明 [GJB5369-4_1_2_8-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

即使内存因为某些原因被重新使用，
这种操作还是存在数据可能被误解危险。
因此，这个规则禁止任何原因的结构体类型的使用。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则在每一个共同体声明的时候报告一个违规的消息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未定义的行为和错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

union U {        违规 
    int _i;
    char _buf[ sizeof( int ) ];
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用共同体。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第18部分

2. Herb Sutter, Andrei Alexandrescu, C++编码标准, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   类型安全章节，第97条规则

3. 来源： Misra 指南 - 第109条规则

4. J联合攻击战斗机, 飞行器, C++ 编码标准
   第4.20章 共同体和位域, AV 第153条规则
   
5. MISRA C++2008 C++语言在关键系统中的使用指南，第6章，第9部分，第9-5-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_1_2_9</key>
<configkey>GJB5369-4_1_2_9</configkey>
<name><![CDATA[ 在结构体中谨慎使用无名位域 [GJB5369-4_1_2_9] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在结构体中谨慎使用无名位域 [GJB5369-4_1_2_9-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

无名位域的使用可能确实是编程者的意图，
也可能是编程者的失误，因此在结构体中
谨慎使用无名位域。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/*********************************************************
 * 准则134： 禁止在结构体中使用无名位域。
 *********************************************************/
struct static_p{unsigned int x:2, :2;};
void dummy(void)
{
   /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.1.2.9  禁止枚举类型中的元素名与已有的变量名同名

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_10</key>
<configkey>GJB5369-4_2_1_10</configkey>
<name><![CDATA[ main 必须定义为 int main(void) 或 int main(int,char*[]) 的形式 [GJB5369-4_2_1_10] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
main 必须定义为 int main(void) 或 int main(int,char*[]) 的形式 [GJB5369-4_2_1_10-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

main 必须定义为 int main(void) 或
int main(int,char*[]) 的形式，
这有助于错误的确定和参数的输入。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

有助于错误的确定和参数的输入。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/**************************************
* main 必须定义为 int main(void) 或
* int main(int,char*[]) 的形式
**************************************/
void main(void) // 违规
{
  /*...*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/**************************************
* main 必须定义为 int main(void) 或
* int main(int,char*[]) 的形式
**************************************/
int main(void) // OK
{
  /*...*/
}

或者:

int main(int,char*[]) // OK
{
  /*...*/
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.2.1.10  main 必须定义为 int main(void) 或 int main(int,char*[]) 的形式

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_2</key>
<configkey>GJB5369-4_2_1_2</configkey>
<name><![CDATA[ 循环体必须用大括号括起来 [GJB5369-4_2_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
循环体必须用大括号括起来 [GJB5369-4_2_1_2-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

基于加强代码可读性、避免人为失误的目的，
循环体必须用大括号括起来。循环体包括 while, 
do ... while 和 for 循环， 应该在其后接复合语句
 (用大括号括起来),即使这个复合语句是只包含单个语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/*************************************
* 循环体必须用大括号括起来
**************************************/
int static_p(int p_1)
{
    int j=10;
    int k=0;
    /*...*/
    for (k=0; k&lt;10; k=k+1) j--;     // 违规
    return j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int static_p(int p_1)
{
    int j=10;
    int k=0;
    /*...*/
    for (k=0; k&lt;10; k=k+1) 
    {
        j--;     // OK
    }
    return j;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.2.1.2  循环体必须用大括号括起来

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_3</key>
<configkey>GJB5369-4_2_1_3</configkey>
<name><![CDATA[ then/else 中的语句必须用大括号括起来 [GJB5369-4_2_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
then/else 中的语句必须用大括号括起来 [GJB5369-4_2_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

if语句结构应该是一个复杂语句.
else关键字后面应该是一个复杂语句或者是另外一个if语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高了代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x, int y )
{
    int i, j;
    if(x &gt; 0)      // Violation
        x = i;
    else if(y &gt; 0) // Violation
        y = i;
    else
        y = j;     // Violation
        x = j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x, int y )
{
    int i, j;
    if(x &gt; 0)      // OK
    {
        x = i;
    }
    else if(y &gt; 0) // OK
    {
        y = i;
    }
    else
    {
        y = j;     // OK
        x = j;
    }
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Misra 指南-第59条规则

3. Ellemtel 编码规范
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    from: 6 Style - 6.4 Flow Control Statements - Rec. 25

4.联合攻击战斗机, 飞行器 C++ 编码规范
   第4.9设计章节,AV第59条规则

5. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第六部分,第6-4-1规则示例

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_4</key>
<configkey>GJB5369-4_2_1_4</configkey>
<name><![CDATA[ 逻辑表达式的连接必须使用括号 [GJB5369-4_2_1_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑表达式的连接必须使用括号 [GJB5369-4_2_1_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在ISO 9899:1990，第 6.3.1部分中定义了"基本表达式"。
本质上它们可以是独立的标识符、常量或一个带圆括号的表达式。本规则要求
一个操作数如果不是一个独立的操作符或常数必须使用圆括号括起来，
这里的表达式如果仅仅只包括逻辑&amp;&amp;或逻辑
||就不需要外加圆括号
参见：MISRA2004-12_1_e, CODSTA-90



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“圆括号在提高代码的可读性和确保程序行为按程序员预期执行方面起着很重要作用。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || y &amp;&amp; z );         // 违规
    if ( x &amp;&amp; !y );             // 违规
    if ( foo( x, y, z ) &amp;&amp; x ); //违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || ( y &amp;&amp; z ) );         // OK
    if ( x &amp;&amp; ( !y ) );             // OK
    if ( ( foo( x, y, z ) ) &amp;&amp; x ); // OK
    return 0;
}


参考文献：

1. MISRA-C:2004 C语言在关键系统中的使用指南 
   第6章，第12节

2. Misra指南-第34条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_5</key>
<configkey>GJB5369-4_2_1_5</configkey>
<name><![CDATA[ 禁止在头文件前有可执行代码 [GJB5369-4_2_1_5] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在头文件前有可执行代码 [GJB5369-4_2_1_5-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止在头文件前有可执行代码。（强制）
头文件应该放在文件一开始的地方，应在任何可执行代码前。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/**********************************************************
 * 准则73：禁止在头文件前有可执行代码。
 **********************************************************/
void static_p(void)
{
#include "c_standards.h"
   /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "c_standards.h"
void static_p(void)
{
   /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.2.1.5  禁止在头文件前有可执行代码

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_6</key>
<configkey>GJB5369-4_2_1_6</configkey>
<name><![CDATA[ 宏参数必须用括号括起来 [GJB5369-4_2_1_6] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
宏参数必须用括号括起来 [GJB5369-4_2_1_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在定义一个如函数的宏时， 整个定义
应该括在括号内。
参见: MISRA2004-19_10



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升代码的可读性并确保操作顺序。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define abs( x ) (x)&gt;=0 ? c: -(x)           /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define abs2( x ) ((x)&gt;=0 ? c: -(x))        /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 96 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_7</key>
<configkey>GJB5369-4_2_1_7</configkey>
<name><![CDATA[ 嵌入汇编程序的过程必须是纯汇编程序 [GJB5369-4_2_1_7] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
嵌入汇编程序的过程必须是纯汇编程序 [GJB5369-4_2_1_7-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果需要汇编语言指令建议把它们用
如下方式封装和隔离(a)汇编语言函数
(b)C语言函数或者(c)宏。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* compilable by cl.exe g++*/
void asmCall( ) {      /* Violation */
    int g = 0;

    #ifdef _MSC_VER
        __asm {
            mov eax, 01h
            int 10h
        }
    #elif __GNUC__
        __asm (
            "mov %eax, 0x01\n\t"
            "int $0x10"
        );
    #endif
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void asmCall( ) {       /* OK */
    #ifdef _MSC_VER
        __asm {
            mov eax, 01h
            int 10h
        }
    #elif __GNUC__
         __asm (
            "mov %eax, 0x01\n\t"
            "int $0x10"
        );
    #endif
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 2 节

2. Misra 使用指南 - 第 3 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南,
   第 6 章，第 7 节， 第7-4-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_8</key>
<configkey>GJB5369-4_2_1_8</configkey>
<name><![CDATA[ 头文件名禁止使用 "‘"、"\"和"/#" 等字符 [GJB5369-4_2_1_8] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
头文件名禁止使用 "‘"、"\"和"/#" 等字符 [GJB5369-4_2_1_8-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在头文件的名称预处理标记中 ', ", /* 或 // 字符
用于 &lt; 和 &gt; 分隔符之间或者 ', /* 或 // 字符用于 " 分隔符之间，
那么这是不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "fi'le.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "file.h"  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 16 节, 规则 16-2-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_1_9</key>
<configkey>GJB5369-4_2_1_9</configkey>
<name><![CDATA[ 禁止字符串中单独使用“\”，字符串的终止必须使用“\0” [GJB5369-4_2_1_9] ]]></name>
<tag>gjb5369</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止字符串中单独使用“\”，字符串的终止必须使用“\0” [GJB5369-4_2_1_9-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只用“\”并不能控制字符串的终止，应该用“\0”控制字符串的终止。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S {
    char pc[10];
}* ps = 0;
void foo( ) {
    char pc[10];
    
    ps-&gt;pc[0] = "\0";           // 违规
    pc[0] = "\0";               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S {
    char pc[10];
}* ps = 0;
void foo( ) {
    char pc[10];
    
    ps-&gt;pc[0] = '\0';           // OK
    pc[0] = '\0';               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.2.1.9  禁止字符串中单独使用“\”，字符串的终止必须使用“\0”

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_2_1</key>
<configkey>GJB5369-4_2_2_1</configkey>
<name><![CDATA[ 建议一个文件中的程序总行不超过2000 行 [GJB5369-4_2_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
建议一个文件中的程序总行不超过2000 行 [GJB5369-4_2_2_1-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
此规则用于检测文件总行数是否超过2000行，如果超过则报告违规。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
过长的程序文件不利于管理和维护。
建议一个文件中的程序总行不超过2000 行。
这样可以增强文件的可维护性。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.2.2.1  建议一个文件中的程序总行不超过2000 行

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_2_2_2</key>
<configkey>GJB5369-4_2_2_2</configkey>
<name><![CDATA[ 建议一个过程或函数中的程序总行不超过 200 行 [GJB5369-4_2_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
建议一个过程或函数中的程序总行不超过 200 行 [GJB5369-4_2_2_2-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC)



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

逻辑代码行即为组成代码片断的各行。这些行以分号结尾。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止函数变长，变复杂，从而变的难以组合并测试。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void sample_function() // 违规
{
    int x, y;
    
    // ...

    if (x&lt;10)
    {
        y = x + 1;   // L-SLOCs number = 201
    } 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void sample_function() // OK
{
    int x, y;
    
    // ...

    if (x&lt;10)
    {
        y = x + 1;   // L-SLOCs number = 150
    } 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 3.2 Code Size and Complexity, AV Rule 1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_3_1_1</key>
<configkey>GJB5369-4_3_1_1</configkey>
<name><![CDATA[ 禁止条件判别成立时相应分支无可执行语句 [GJB5369-4_3_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止条件判别成立时相应分支无可执行语句 [GJB5369-4_3_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

条件判别成立时相应分支中无任何执行语句，可能是
由于疏忽而遗漏掉了，或是有意避免布尔表达式不成立
时的情况。为了防止由于疏忽造成的遗漏，因此禁止
条件判别成立时相应分支无执行语句。
该规则的违背通常为下面几种形式：
a) if(...)else
b) if(...){}else
c) if(...){;}else



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高了代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void static_p(void)
{
    unsigned int value_x=1u;
    /*...*/
    if(value_x == 0u);      // 违规
    /*...*/
    if(value_x == 0u){     // 违规
    }
    /*...*/
    if(value_x == 0u){;}    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void static_p(void)
{
    unsigned int value_x=1u;
    /*...*/
    if(value_x == 0u){          // OK
        value_x = value_x + 1; 
    }
    /*...*/
    if(value_x == 0u){          // OK
        value_x = value_x + 1;
    }
    /*...*/
    if(value_x == 0u){value_x = value_x + 1;}    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.3.1.1  禁止条件判别成立时相应分支无可执行语句

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_3_1_2</key>
<configkey>GJB5369-4_3_1_2</configkey>
<name><![CDATA[ 在 if … else if 语句中必须使用 else 分支 [GJB5369-4_3_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 if … else if 语句中必须使用 else 分支 [GJB5369-4_3_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则适用于任何一个 'if' 语句是否都由一个或多个
'else-if' 语句结尾； 最后的 'else-if' 应该紧跟着一个 'else'
语句。 在一个简单的 'if' 语句中，那么应该包括 'else' 
语句。
对最后 'else' 语句的需求是防御性的编程。 
其中 'else' 语句应该要么有合适的操作或包含
一个为什么没有操作合理的注释。"
参见: CODSTA-23



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

确保合适的数据流、提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a)
{
    if(a &gt; 0)
    {
    }
    else if (a &gt; 10)   // Violation
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a)
{
    if(a &gt; 0)
    {
    }
    else if (a &gt; 10)   // OK
    {
    }
    else
    {
        // comment or action
    }
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南 - 第 60条规则

3.联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构章节, AV 第 192条规范

4.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第6部分,第6-4-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_3_1_3</key>
<configkey>GJB5369-4_3_1_3</configkey>
<name><![CDATA[ 禁止条件判别的 else 分支无可执行语句 [GJB5369-4_3_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止条件判别的 else 分支无可执行语句 [GJB5369-4_3_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

else 分支中无可执行语句是由于代码不完整造成的，或是有意
表明 else 对应的可能性已经考虑到了。为了防止残留不完整的
代码，因此禁止条件判别的 else 分支无可执行语句。
该规则的违背通常为下面的几种形式：
a) else;
b) else{}
c) else{;}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高了代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void static_p(void)
{
    unsigned int name_x=1u;
    /*...*/
    if(name_x == 0u)
    {/*...*/}
   else;                        // 违规
    /*...*/
    if(name_x == 0u)
    {/*...*/}
    else{                     // 违规
    }
    /*...*/
    if(name_x == 0u)
    {/*...*/}
    else                     // 违规
    {;}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void static_p(void)
{
    unsigned int name_x=1u;
    /*...*/
    if(name_x == 0u)
    /*...*/
   else name_x = name_x + 1;       // OK
    /*...*/
    if(name_x == 0u)
    {/*...*/}
    else{                   // OK
        name_x = name_x + 1;
    }
    /*...*/
    if(name_x == 0u)
    {/*...*/}
    else                     // OK
    {name_x = name_x + 1;}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.3.1.3  禁止条件判别的 else 分支无可执行语句

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_3_1_4</key>
<configkey>GJB5369-4_3_1_4</configkey>
<name><![CDATA[ 在 switch 语句中必须有 default 语句 [GJB5369-4_3_1_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 switch 语句中必须有 default 语句 [GJB5369-4_3_1_4-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“为 switch 语句提供 default 分支 
用于处理异常情况。”
该规则检测是否为 switch 语句提供默认
分支。 如果所有预期的情况在其他分支中
处理，则 default 分支能用于错误检查。
参见： MISRA2004-15_3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防错误发生的可能性。


事例：

void foo( ) {
    int tag;
    switch ( tag ) {	// 违规
    case 0: {
        break;
            }
    case 1: {
        foo( );
        break;
            }
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int tag;
    switch ( tag ) {	// OK
    case 0: {
        break;
            }
    case 1: {
        foo( );
        break;
            }
    default: break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rule 48

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.24 Flow Control Structures, AV Rule 194

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_3_1_5</key>
<configkey>GJB5369-4_3_1_5</configkey>
<name><![CDATA[ 禁止使用空 switch 语句 [GJB5369-4_3_1_5] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用空 switch 语句 [GJB5369-4_3_1_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个switch语句应当至少含有一个case子句。
另见: OPT-21, OPT-22, CODSTA-54



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提供可维护性的switch语句.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* 违规 */ 
    {
        default:
            ;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* OK */ 
    {
      case 1:
      {
      }
      default:
            ;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6条长，第15部分

2. 来源: Misra 指南 - 第64条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-8条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_3_1_6</key>
<configkey>GJB5369-4_3_1_6</configkey>
<name><![CDATA[ 禁止 switch 语句中只包含 default 语句 [GJB5369-4_3_1_6] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止 switch 语句中只包含 default 语句 [GJB5369-4_3_1_6-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个switch语句应当至少含有一个case子句。
另见: OPT-21, OPT-22, CODSTA-54



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提供可维护性的switch语句.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* 违规 */ 
    {
        default:
            ;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* OK */ 
    {
      case 1:
      {
      }
      default:
            ;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6条长，第15部分

2. 来源: Misra 指南 - 第64条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-8条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_3_1_7</key>
<configkey>GJB5369-4_3_1_7</configkey>
<name><![CDATA[ 禁止 switch 的 case 语句不是由 break 终止 [GJB5369-4_3_1_7] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止 switch 的 case 语句不是由 break 终止 [GJB5369-4_3_1_7-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个switch分句的最后一句应该是break语句，
或者如果switch分句是复合语句，那么这个
复合语句的最后一句应该是break语句。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本条规则允许使用return替代break语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不可预测的程序行为.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 违规
            i = 4;
            break;
            i++;
        case 1 :         // 违规
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
        case 2 :         // 违规
            {
                i = 3;
            }
        default:         // 违规
            i = 8;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 通过
            i = 4;
            i++;
            break;
        case 1 :         // 通过
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
            break;
        case 2 :         // 通过
            {
                i = 3;
                break;
            }
        case 3 :         // 通过 - 空case语句
        default:         // 通过
            i = 8;
            break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第15部分

2. Misra 指南 - 第61条规则

3. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rule 47

4. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.24章流量控制结构， AV 第193条规则
   

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_3_1_8</key>
<configkey>GJB5369-4_3_1_8</configkey>
<name><![CDATA[ 禁止switch的case语句中无任何可执行语句 [GJB5369-4_3_1_8] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止switch的case语句中无任何可执行语句 [GJB5369-4_3_1_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果某个case语句中无任何可执行语句，则它将共享
后面case语句中的执行语句。这种情况或是由于代码
不完整造成的，或是编程者特意设计的。为了防止残留
不完整的代码，因此禁止switch的case语句中无任何可执行语句。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int i) {
    switch(i)      /* 违规 */
    {
        case 0:
            return 1;
        case 1:
        case 2:
        default:
            return 0;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int i) {
    switch(i)      /* OK */
    {
        case 0:
            return 1;
        default:
            return 0;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.3.1.8  禁止switch的case语句中无任何可执行语句

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_4_1_1</key>
<configkey>GJB5369-4_4_1_1</configkey>
<name><![CDATA[ 禁止将参数指针赋值给过程指针 [GJB5369-4_4_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止将参数指针赋值给过程指针 [GJB5369-4_4_1_1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止参数指针赋值给过程指针。
参数指针赋值给过程指针会导致不可预料的结果



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/****************************************************************
 * 禁止参数指针赋值给过程指针。
 ****************************************************************/
unsigned int *static_p(unsigned int *p1_ptr)
{
   static unsigned int w = 10u;
   /* ... */
   p1_ptr = &amp;w;
   /* ... */
   return &amp;w;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.4.1.1  禁止将参数指针赋值给过程指针

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_4_1_2</key>
<configkey>GJB5369-4_4_1_2</configkey>
<name><![CDATA[ 禁止指针的指针超过两级 [GJB5369-4_4_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止指针的指针超过两级 [GJB5369-4_4_1_2-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int * INTPTR;
struct s {
    int *** s3;                  /* 违规 */
};

struct s *** ps3;                /* 违规 */
int ** (***pfunc3)();            /* 违规 */
int *** ( **pfunc4)();           /* 违规 */
void function( int * par1,
    int *** par3,                /* 违规 */
    INTPTR * const * const par5  /* 违规 */
    )              
{
    int *** ptr3;                /* 违规 */
    INTPTR * const * const ptr5 = 0; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明超过两级的间接指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第170条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

4. 来源： Misra 指南 - 第102条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_4_1_3</key>
<configkey>GJB5369-4_4_1_3</configkey>
<name><![CDATA[ 禁止将过程声明为指针类型 [GJB5369-4_4_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止将过程声明为指针类型 [GJB5369-4_4_1_3-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用非常量指针指向函数。
参见: CODSTA-CPP-03, CODSTA-CPP-38, CODSTA-CPP-43, CODSTA-CPP-44, MISRA2004-16_7, OPT-21



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用非常量指针指向函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( );
typedef void (*PFUNC) (void);
const PFUNC pf = foo;

void bar( ) {
    PFUNC f1 = foo;         /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( );
typedef void (*PFUNC) (void);
const PFUNC pf = foo; 

void bar( ) {
    const PFUNC f1 = foo;   /* OK */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 第 104 条规则

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_4_2_1</key>
<configkey>GJB5369-4_4_2_1</configkey>
<name><![CDATA[ 谨慎使用指针的逻辑比较 [GJB5369-4_4_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用指针的逻辑比较 [GJB5369-4_4_2_1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

试图在指针之间做比较操作将会产生未定义的行为。


例外：

两个操作数都是相同类型并且指向同一数组。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对数组末尾的下一个元素的寻址是允许的，
但是访问这个元素是不允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此规则使得代码具有更高的可靠性，给人更少的困惑。”



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

在比较复杂的代码中，对指向同一数组的指针
使用比较操作，此规则可能不能正常工作。
因为在这样的情况下，此规则可能报告假错误。
例如：
void foo( ) {
    int a[10], i;
    int* p1,* p2,* p3,* p4,* p5;

    p1 = a; i = p1 &lt; a;    // 正常
    p2 = p1;i = p2 &lt; a;    // 正常
    p3 = p2;i = p3 &lt; a;    // 正常
    p4 = p3;i = p4 &lt; a;    // 违规 - 假错误
    p5 = p4;i = p5 &lt; a;    // 违规 - 假错误
}



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a[] ) {
    int* p1 = 0;
    int* p2;
    int* p3 = a;
    int i;

    i = p1 &lt; p2;   // 违规
    i = p2 &lt; a;    // 违规
    i = p3 &lt; a;    // 正常
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能对指向不同数组元素的指针做指针比较操作。




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第17部分

2. 来源: Misra 指南 - 第103条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.22章指针与引用, AV第171条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-18条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_4_2_2</key>
<configkey>GJB5369-4_4_2_2</configkey>
<name><![CDATA[ 谨慎对指针进行代数运算 [GJB5369-4_4_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎对指针进行代数运算 [GJB5369-4_4_2_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则用于检测代码中是否有指针进行代数运算，
如果有则报告违规。对指针进行代数运算是具
有较大风险的，应谨慎对指针进行代数运算。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/**********************************
* 谨慎对指针进行代数运算
**********************************/
void static_p(void){
    unsigned int w;
    unsigned int array[5];
    unsigned int *p1_ptr;
    p1_ptr=array;
    w=*(p1_ptr+8);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免使用指针代数运算。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.4.2.2  谨慎对指针进行代数运算

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_5_1_1</key>
<configkey>GJB5369-4_5_1_1</configkey>
<name><![CDATA[ 禁止直接从过程中跳出 [GJB5369-4_5_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止直接从过程中跳出 [GJB5369-4_5_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“setjmp 和 longjmp 允许普通的函数调用机制绕过和不能被使用”
当使用函数etjmp or longjmp且文件中出现任何一个头文件: 
setjmp.h, setjmp, or csetjmp，本规则将报出相关违例信息。.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则通过绕过而组织被调用



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;setjmp.h&gt;
jmp_buf mark;              /* Address for long jump to jump to */
int     fperr;             /* Global error number */

void foo( void ) {
    int jmpret;
    jmpret = setjmp( mark );        /* 违规 */
}

void fphandler( int sig, int num ) {
    longjmp( mark, -1 );            /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用宏setjmp 和longjmp函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第122条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第20条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第17部分，第17-0-5条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_5_1_2</key>
<configkey>GJB5369-4_5_1_2</configkey>
<name><![CDATA[ 禁止使用 goto 语句 [GJB5369-4_5_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 goto 语句 [GJB5369-4_5_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用goto语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

goto语句会导致错误和混乱.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int a ) {
    if (a &lt; 0) {     
        goto end;       /* 违规 */
    } 
    a = foo(a-1);
end:
    return a+1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int a ) {
    /* Code was changed and does not use goto anymore */
    if (a &gt;= 0) {
        a = foo(a-1);
    }
    return a+1;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   出自: 第14章节控制流结构  -第49规则 

3.Misra 指南 - 第 56条规则

4. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构, AV 第 189规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

6. HIS Source Code Metriken, version 1.3.1
   Metrik "GOTO"

7. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_5_2_1</key>
<configkey>GJB5369-4_5_2_1</configkey>
<name><![CDATA[ 避免使用 setjmp/longjmp [GJB5369-4_5_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用 setjmp/longjmp [GJB5369-4_5_2_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“setjmp 和 longjmp 允许普通的函数调用机制绕过和不能被使用”
当使用函数etjmp or longjmp且文件中出现任何一个头文件: 
setjmp.h, setjmp, or csetjmp，本规则将报出相关违例信息。.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则通过绕过而组织被调用



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;setjmp.h&gt;
jmp_buf mark;              /* Address for long jump to jump to */
int     fperr;             /* Global error number */

void foo( void ) {
    int jmpret;
    jmpret = setjmp( mark );        /* 违规 */
}

void fphandler( int sig, int num ) {
    longjmp( mark, -1 );            /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用宏setjmp 和longjmp函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第122条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第20条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第17部分，第17-0-5条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_1</key>
<configkey>GJB5369-4_6_1_1</configkey>
<name><![CDATA[ 禁止在非赋值表达式中出现赋值操作符 [GJB5369-4_6_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在非赋值表达式中出现赋值操作符 [GJB5369-4_6_1_1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止给布尔表达式赋值.
阻止对布尔表达式的操作数使用简单或复合的赋值运算符.
但是，变量还是可以被赋以布尔值的.
如果需要对布尔表达式的操作数赋值，则必须单独在操作数外面赋值.
这样做可避免混淆"="和"==",并帮助错误的静态检测.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

表达式被认为是布尔表达式有两种原因,一
种是表达式所在的位置应该是布尔值,
另一种是它使用的操作符会产生布尔值.布尔值在下面情况下出现:
—If 语言的控制表达式
—迭代语句的控制表达式
—条件运算符？的第一个操作数


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止混淆 "=" 和 "==".


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x = y);                // Violation
    if ((x &gt; y) &amp;&amp; (x = 4));  // Violation
    if (!(x = y));                // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x == y);               // OK
    if ((x &gt; y) &amp;&amp; (x == 4)); // OK
    if (!(x == y));               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Misra 指南 -第35条规则

2. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第13部分

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.21操作章节, AV 第160条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南l
    第六章节,第六部分,第6-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_11</key>
<configkey>GJB5369-4_6_1_11</configkey>
<name><![CDATA[ 禁止对常数值做逻辑非的运算 [GJB5369-4_6_1_11] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对常数值做逻辑非的运算 [GJB5369-4_6_1_11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这些操作符使用布尔以外的其他类型作为操作数是
没有多大意义（或者目的）。这条规则用于检测这种使用情况，
这往往是因为逻辑运算符 (&amp;&amp;, || 和 !)
很容易地与位运算符 (&amp;, | 和 ~)相混淆。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。
规则可防止逻辑运算符和位运算符之间的混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* examples of incorrect code */
void foo(int a, int b, int c, int d, int* ptr)
{
    if ( 1 &amp;&amp; ( c &lt; d ) ) {}        // 违规
    if ( ( a &lt; b ) &amp;&amp; ( c + d ) ){} // 违规
    if ( a || ( c + d ) ) {}        // 违规
    if ( !ptr ) {}                  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* examples of correct code */
void foo(int a, int b, int c, int d)
{
    if ( ( a &lt; b ) &amp;&amp; ( c &lt; d ) ){}   // OK
    if ( ( a == b ) || ( c != d ) ){} // OK
    if ( !false ) {}                  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
Chapter 6, Section 5, Rule 5-3-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_12</key>
<configkey>GJB5369-4_6_1_12</configkey>
<name><![CDATA[ 禁止对有符号类型使用位运算 [GJB5369-4_6_1_12] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对有符号类型使用位运算 [GJB5369-4_6_1_12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对有符号数进行位运算(~, &lt;&lt;, &gt;&gt;, &amp;, ^ 和 |)通常是没有 
意义的。 比如，会出现这样的问题，对有符号数进行右移运算会将 
符号位移入数据位，左移运算会将数据位
移入符号位。
术语 underlying type（基本类型）是用来描述通过对
无整形提升的表达式运算后得到的一种基础
类型。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和理解性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int x, int y )
{
    x = y &gt;&gt; 2;       // 违规
    x = y &amp; 0x0F;     // 违规
    return x | 5;     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int x, int y )
{
    /* 调用程序必须保证x和y是非负数 */
    x = (unsigned int)y &gt;&gt; 2u;       /* OK */
    x = (unsigned int)y &amp; 0x0Fu;     /* OK */
    return (unsigned int)x | 5u;     /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra指南-第37条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_13</key>
<configkey>GJB5369-4_6_1_13</configkey>
<name><![CDATA[ 禁止对枚举类型的越限使用 [GJB5369-4_6_1_13] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对枚举类型的越限使用 [GJB5369-4_6_1_13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在:
* 枚举和非枚举类型
* 枚举和不同的枚举类型
做隐式类型转换是不允许的.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可以防止改变取决于枚举常量的值



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum ABC0{A0, B0, C0};

void foo1(int arg1){}

int foo(int p)
{
    ABC0 x;
    int i = x; // 违规
    foo1(x);   // 违规
    return x;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum ABC0{A0, B0, C0};

void foo1(int arg1){}

int foo(int p)
{
    ABC0 x;
    int i = (int)x; // OK
    foo1((int)x);   // OK
    return (int)x;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_15</key>
<configkey>GJB5369-4_6_1_15</configkey>
<name><![CDATA[ 禁止在逻辑表达式中使用赋值操作符 [GJB5369-4_6_1_15] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在逻辑表达式中使用赋值操作符 [GJB5369-4_6_1_15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止给布尔表达式赋值.
阻止对布尔表达式的操作数使用简单或复合的赋值运算符.
但是，变量还是可以被赋以布尔值的.
如果需要对布尔表达式的操作数赋值，则必须单独在操作数外面赋值.
这样做可避免混淆"="和"==",并帮助错误的静态检测.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

表达式被认为是布尔表达式有两种原因,一
种是表达式所在的位置应该是布尔值,
另一种是它使用的操作符会产生布尔值.布尔值在下面情况下出现:
—If 语言的控制表达式
—迭代语句的控制表达式
—条件运算符？的第一个操作数


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止混淆 "=" 和 "==".


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x = y);                // Violation
    if ((x &gt; y) &amp;&amp; (x = 4));  // Violation
    if (!(x = y));                // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x == y);               // OK
    if ((x &gt; y) &amp;&amp; (x == 4)); // OK
    if (!(x == y));               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Misra 指南 -第35条规则

2. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第13部分

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.21操作章节, AV 第160条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南l
    第六章节,第六部分,第6-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_16</key>
<configkey>GJB5369-4_6_1_16</configkey>
<name><![CDATA[ 禁止赋值操作符与“&&”或“||”连用 [GJB5369-4_6_1_16] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止赋值操作符与“&amp;&amp;”或“||”连用 [GJB5369-4_6_1_16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止赋值操作符与“&amp;&amp;”或“||”连用.
这样的用法是一种不好的习惯，因为赋值将被条件化。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/**********************************************************
 * 准则129： 禁止赋值操作符与“&amp;&amp;”或“||”连用。
 **********************************************************/
void static_p(void)
{
   bool flag = false;
   unsigned int y = 0u, x = 0u;
   /* ... */
   if (flag &amp;&amp; ((x = y) == 0)) {
      /* ... */
   }
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void static_p(void)
{
   bool flag = false;
   unsigned int y = 0u, x = 0u;

   /* ... */
   x = y
   if (flag &amp;&amp; (x == 0)) {
      /* ... */
   }
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.6.1.16  禁止赋值操作符与“&amp;&amp;”或“||”连用

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_17</key>
<configkey>GJB5369-4_6_1_17</configkey>
<name><![CDATA[ 禁止位操作符带有布尔型的操作数 [GJB5369-4_6_1_17] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止位操作符带有布尔型的操作数 [GJB5369-4_6_1_17-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这种情况的出现通常是用错了操作符号，
例如把 "‖" 误写为 "∣"。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

有助于错误的确定和参数的输入。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/**************************************
* 禁止位操作符带有布尔型的操作数
**************************************/
void static_p(void)
{
    unsigned int x=1u;
    bool flag=false;
    /*...*/
    if((flag | (x!=0))==false){
        /*...*/
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/**************************************
* 禁止位操作符带有布尔型的操作数
**************************************/
void static_p(void)
{
    unsigned int x=1u;
    bool flag=false;
    /*...*/
    if((flag || (x!=0))==false){
        /*...*/
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.6.1.17  禁止位操作符带有布尔型的操作数

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_18</key>
<configkey>GJB5369-4_6_1_18</configkey>
<name><![CDATA[ 禁止位操作符作用于布尔值 [GJB5369-4_6_1_18] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止位操作符作用于布尔值 [GJB5369-4_6_1_18-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
此规则用于检测代码中是否有在布尔值件使用了位操作符，如果有则会报告违规。这种情况的出现通常是用错了操作符号，例如把“&amp;&amp;”误写为“&amp;”。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
/*********************************
* 禁止位操作符作用于布尔值
*********************************/
void static_p(void){
    unsigned int y=2u;
    bool flag=false;
    flag=flag &amp; (y==2u);	//违规
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
void static_p(void){
    unsigned int y=2u;
    bool flag=false;
    flag=flag &amp;&amp; (y==2u);	//OK
}

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_2</key>
<configkey>GJB5369-4_6_1_2</configkey>
<name><![CDATA[ 数组的使用必须保证不会出现越界 [GJB5369-4_6_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
数组的使用必须保证不会出现越界 [GJB5369-4_6_1_2-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
该规则检测可能导致数组越界的数组访问。
尤其是当明显的越界发生时，将报告违规。
当数组下标值为负，零或者大于数组个数时，将发生数组越界。


</PRE>
<STRONG>
始于
</STRONG>
<PRE>
v7.0.22


</PRE>
<STRONG>
注意
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
安全相关性
</STRONG>
<PRE>
数组越界将造成严重的安全性隐患。
若应用程序包含此漏洞，它可能被人通过执行恶意代码获取整个程序的控制权。


</PRE>
<STRONG>
参数
</STRONG>
<PRE>
"积极报告关于索引在循环内部更改的违规" 模式提示 BugDetective 
在任何时候当它怀疑会有问题存在于使用一个会在循环内部更改的变量作为
访问数组的索引时，就报告一个违规 -- 即使可能存在很高概率这个情况
会是一个误报。 使用这个模式可能将导致更多的错误被报告出来，但是也
可以增加假报警的数量。

"报告未验证的违规" 参数对很多 BugDetective 规则来说是常见的。它被
描述在 Parasoft C++test 用户手册的 "BugDetective 的数据流静态分析
-&gt; 自定义 BugDetective 静态分析 -&gt; 配置规则参数" 章节。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
不足
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
示例
</STRONG>
<PRE>
下面是一个会触发违规的例子：

void fillArray(int array[], int size)
{
	int i;
	for (i = 0; i &lt;= size; i++) { // iterate from 0 to 100
		array[i] = 0; // VIOLATION (accessing array out of bounds: "array[i]" where (i == 100))
	}
}

void example()
{
	int array[100];
	fillArray(array, 100);
	// ...
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
下面的代码将不会触发一个违规：

void fillArray(int array[], int size)
{
	int i;
	for (i = 0; i &lt; size; i++) { // iterate from 0 to 99
		array[i] = 0; // NO VIOLATION
	}
}

void example()
{
	int array[100];
	fillArray(array, 100);
	// ...
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.owasp.org/index.php/Buffer_Overflow">http://www.owasp.org/index.php/Buffer_Overflow</A> (security relevance)

CWE/SANS Top 25 Most Dangerous Software Errors: CWE-131
<A HREF="http://cwe.mitre.org/top25/#CWE-131">http://cwe.mitre.org/top25/#CWE-131</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_3</key>
<configkey>GJB5369-4_6_1_3</configkey>
<name><![CDATA[ 禁止对有符号类型进行移位运算 [GJB5369-4_6_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对有符号类型进行移位运算 [GJB5369-4_6_1_3-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对有符号类型进行移位运算(&lt;&lt;, &gt;&gt;)会导致不可预料的后果。
比如，会出现这样的问题，对有符号数进行右移运算会将 
符号位移入数据位，左移运算会将数据位移入符号位。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和理解性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/*****************************************
* 禁止对有符号类型进行移位运算
*****************************************/
void static_p( void)
{
    int b=1;
    /*...*/
    b&gt;&gt;1;     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void static_p( void)
{
    unsigned int b=1;
    /*...*/
    b&gt;&gt;1u;     // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.6.1.3  禁止对有符号类型进行移位运算

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_4</key>
<configkey>GJB5369-4_6_1_4</configkey>
<name><![CDATA[ 对变量进行移位运算必须保证不会产生溢出 [GJB5369-4_6_1_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对变量进行移位运算必须保证不会产生溢出 [GJB5369-4_6_1_4-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

移位运算符的右边操作数应当介于零
和一个小于左边操作数宽度位的之间（包含) 。
这条规则假设类型的大小: char 有 8 位， short 有 16 位，
int 有 32 位， long 有 64 位。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以让提升代码的可读性，减少困惑。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifndef uint8_t
    typedef unsigned char   uint8_t;
#endif
#ifndef uint16_t
    typedef unsigned short  uint16_t;
#endif
#ifndef uint32_t
    typedef unsigned int    uint32_t;
#endif

void foo( ) {
    uint8_t  it8;
    uint16_t it16;
    uint32_t it32;

    it8  &lt;&lt; 8;  // 违规
    it16 &lt;&lt; 16; // 违规
    it32 &gt;&gt; 32; // 违规
    it16 &gt;&gt; it8;// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef uint8_t
    typedef unsigned char   uint8_t;
#endif
#ifndef uint16_t
    typedef unsigned short  uint16_t;
#endif
#ifndef uint32_t
    typedef unsigned int    uint32_t;
#endif

void foo( ) {
    uint8_t  it8;
    uint16_t it16;
    uint32_t it32;

    it8  &lt;&lt; 7;  // OK
    it16 &lt;&lt; 15; // OK
    it32 &gt;&gt; 31; // OK
    if (it8 &gt; 0 &amp;&amp; it8 &lt; sizeof( it8 ))
        it16 &gt;&gt; it8; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 38 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_5</key>
<configkey>GJB5369-4_6_1_5</configkey>
<name><![CDATA[ 禁止给无符号变量赋负值 [GJB5369-4_6_1_5] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止给无符号变量赋负值 [GJB5369-4_6_1_5-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对无符号整型或者无符号长整型表达式
进行一元减法运算是没有意义的。
有时对一个小的无符号整型操作数进行一元
减法运算整形提升后会得到一个有意义的
整型值，但这并不是好的编程习惯。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止整型提升时产生不可预期的结果。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    unsigned char  ui1;
    signed short si2;
    si2 = -ui1;                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    unsigned char  ui1;
    signed short si2;
    si2 = -(signed short) ui1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C：2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra 指南 - 第39条规则

3. 联合攻击战斗机，飞行器，C++编码规范，
   第4.21章，飞行器第165条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，第5-3-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_6</key>
<configkey>GJB5369-4_6_1_6</configkey>
<name><![CDATA[ 有符号类型的位长度必须大于等于两位 [GJB5369-4_6_1_6] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
有符号类型的位长度必须大于等于两位 [GJB5369-4_6_1_6-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有符号类型只给一位的长度是没有意义的，
因此有符号类型的位长度必须大于等于两位。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止潜在缺陷和错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct MyStruct {
    signed int si01:1;    /* 违规 */
    signed int si02:1;    /* 违规 */
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct MyStruct {
    signed int si01:2;    /* OK */
    unsigned int si02:1;  /* OK */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.6.1.6  有符号类型的位长度必须大于等于两位

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_7</key>
<configkey>GJB5369-4_6_1_7</configkey>
<name><![CDATA[ 位的定义必须是有符号整数或无符号整数 [GJB5369-4_6_1_7] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
位的定义必须是有符号整数或无符号整数 [GJB5369-4_6_1_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“位域只能定义成无符号整型或者有符号整型。
整形的使用是由实现环境决定的，因为整形的位域
可以是有符号也可是无符号的。枚举，短整型或者字符类型的位域
的使用是不允许的，因为其行为是不可确定的。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止这种随实现环境不同而不同的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Enum { E1, E2};
struct Struct 
{
    unsigned char  f1:2;  /* Violation */
    unsigned short f2:2;  /* Violation */
    unsigned long  f3:2;  /* Violation */
    enum Enum      f4:2;  /* Violation */
    int            f5:2;  /* Violation */
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct Struct
{
    unsigned int f1:2;  /* OK */
    unsigned int f2:2;  /* OK */
    unsigned int f3:2;  /* OK */
    signed int   f4:2;  /* OK */
    signed int   f5:2;  /* OK */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. 来源: Misra 指南 - 第 111 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.20 章 共用体和位段，第 AV 154 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_8</key>
<configkey>GJB5369-4_6_1_8</configkey>
<name><![CDATA[ 禁止给变量赋的值与变量的类型不一致 [GJB5369-4_6_1_8] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止给变量赋的值与变量的类型不一致 [GJB5369-4_6_1_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型的表达式的值不应当被隐式转换
为一个不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = f32a;                // 违规
    s32b = f32a;                // 违规
    f32a = f64a;                // 违规
    f64a = f32b + f32a + f64b;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = (unsigned int)f32a;  // OK
    s32b = (signed int)f32a;    // OK
    f32a = (float)f64b;         // OK
    f64a = f64b + f32b + f32a;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004 C语言在关键系统中的使用指南

2. 联合攻击战斗机，飞行器，C++编码规范 
    4.23章节 类型转换， 飞行器第184条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-5条规则

4.MISRA-C++:  2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_1_9</key>
<configkey>GJB5369-4_6_1_9</configkey>
<name><![CDATA[ 赋值类型必须匹配 [GJB5369-4_6_1_9] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
赋值类型必须匹配 [GJB5369-4_6_1_9-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"C performs many type conversions implicitly and silently, so as to harmonize
types within an expression before evaluating it. Some of these conversions can
result in loss of information. Such implicit conversions shall not be used,
but explicit casts should be used instead."
The rule reports a violation if a parameter/variable/expression of integral
or floating type is implicitly cast to a narrower type.
参见: MISRA2004-10_1_b, MISRA2004-10_2, PORT-27, PORT-28



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule assumes the following order of sizes:
char &lt; short &lt; int &lt; long &lt; long long
float &lt; double &lt; long double
The rule assumes that the size of enumeration type is the same as int type.


例外:

The rule does not report violation if a conversion is used:
- on a constant expression
- between integral and floating type
- between signed and unsigned type
- on a bit field



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"Explicit casts should normally only be used in the case where a conversion 
which could result in a loss of information is specifically required by the 
programmer. If the static checking of implicit conversions is overridden by
the use of explicit casts in this way, then the programmer should be aware
of the issues of truncation and lost of precision associated with the operation,
and should provide appropriate checking of values in the code"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void bar(unsigned char c);

void foo(unsigned int ui, double d)
{
    float f;
    unsigned short us1;
    unsigned short us2 = ui; /* 违规 */
    us1 = us2 + us2;         /* 违规 - due to integral promotion */
    f = d;                   /* 违规 */
    bar(ui);                 /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>


void bar(unsigned char c);

void foo(unsigned int ui, double d)
{
    float f;
    unsigned short us = (unsigned short)ui; /* OK */
    f = (float)d;                           /* OK */
    bar((unsigned char)ui);                 /* OK */
}

/* exceptions */

void except(unsigned int ui){
    unsigned char uc = 300;   /* OK - constant expression */
    int i = ui;               /* OK - only signed/unsigned conversion */
    float f = ui;             /* OK - integral/floating conversion */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines rule 43

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 180

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_2_1</key>
<configkey>GJB5369-4_6_2_1</configkey>
<name><![CDATA[ 避免使用逗号操作符 [GJB5369-4_6_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用逗号操作符 [GJB5369-4_6_2_1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了在循环的控制表达式中使用逗号运算符，
在其他的地方使用逗号运算符会不利于代码的可读性。
同样的效果可以通过其他的方式来实现。”
参见: misra2004-12_10



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

广泛的使用逗号运算符会降低代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1( int x, int y )
{
    int i;
    i = (x = 1, y = 0);            // 违规
    x++, y++;                      // 违规
    for (i = 0; i &lt; 10; i++){
        foo1( (x--, y + 2), y );   // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo2( int x, int y ) {
    int i;
    x++;
    y++;                                       // OK
    for (i = 0; i &gt;=0, i &lt; 10; i++)	{     // OK 
    }
    x--;
    foo2( y + 2, y );                      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 42 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 168 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_2_2</key>
<configkey>GJB5369-4_6_2_2</configkey>
<name><![CDATA[ 谨防长度操作符 sizeof 的副作用 [GJB5369-4_6_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨防长度操作符 sizeof 的副作用 [GJB5369-4_6_2_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在C语言编程中的一个可能错误是评估一个表达式和预期表达式 
的时候申请使用sizeof 操作符。 可是表达式
却无法被评估: sizeof只能作用于表达式类型。 
为了避免这类错误， sizeof 不能用于包含副作用的表达式。"
"这个操作引起的副作用是访问了不稳定的对象,
如修改一个对象, 修改一个文件, 或者调用一个函数这些
会导致调用函数执行环境变化的操作方法。"



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只能检测三层函数调用。


例外:

操作数形如 sizeof(i)  i 变量是允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止由 sizeof 引起的错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int glob;

int fun_with_se(){
    glob++; // side-effect
    return glob;
}

void foo1(int i){
    int j, k, l, m;
    j = sizeof(k = 2);         // 违规 - k is not set to 2
    l = sizeof(i++);           // 违规 - i is not incremented
    m = sizeof(fun_with_se()); // 违规 - glob is not incremented
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int fun_without_se(){
    // no side-effect
    return 1;
}

void foo1(int i){
    int j, k, l, m, n, o;
    volatile int vol;
    k = 2;
    j = sizeof(k);                // OK
    i++;
    l = sizeof(i);                // OK
    // examples of correct code
    m = sizeof(fun_without_se()); // OK
    n = sizeof(int);              // OK
    o = sizeof(vol);              // OK - volatile objects are permitted
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
    Chapter 6, Section 12

2. Origin: Misra Guidelines - Rule 40

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.21 Operators, AV Rule 166

4. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 5, Rule 5-3-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_2_3</key>
<configkey>GJB5369-4_6_2_3</configkey>
<name><![CDATA[ 谨慎使用不同类型变量的混合运算 [GJB5369-4_6_2_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用不同类型变量的混合运算 [GJB5369-4_6_2_3-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"C performs many type conversions implicitly and silently, so as to harmonize
types within an expression before evaluating it. Some of these conversions can
result in loss of information. Such implicit conversions shall not be used,
but explicit casts should be used instead."
The rule reports a violation if a parameter/variable/expression of integral
or floating type is implicitly cast to a narrower type.
参见: MISRA2004-10_1_b, MISRA2004-10_2, PORT-27, PORT-28



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule assumes the following order of sizes:
char &lt; short &lt; int &lt; long &lt; long long
float &lt; double &lt; long double
The rule assumes that the size of enumeration type is the same as int type.


例外:

The rule does not report violation if a conversion is used:
- on a constant expression
- between integral and floating type
- between signed and unsigned type
- on a bit field



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"Explicit casts should normally only be used in the case where a conversion 
which could result in a loss of information is specifically required by the 
programmer. If the static checking of implicit conversions is overridden by
the use of explicit casts in this way, then the programmer should be aware
of the issues of truncation and lost of precision associated with the operation,
and should provide appropriate checking of values in the code"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void bar(unsigned char c);

void foo(unsigned int ui, double d)
{
    float f;
    unsigned short us1;
    unsigned short us2 = ui; /* 违规 */
    us1 = us2 + us2;         /* 违规 - due to integral promotion */
    f = d;                   /* 违规 */
    bar(ui);                 /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>


void bar(unsigned char c);

void foo(unsigned int ui, double d)
{
    float f;
    unsigned short us = (unsigned short)ui; /* OK */
    f = (float)d;                           /* OK */
    bar((unsigned char)ui);                 /* OK */
}

/* exceptions */

void except(unsigned int ui){
    unsigned char uc = 300;   /* OK - constant expression */
    int i = ui;               /* OK - only signed/unsigned conversion */
    float f = ui;             /* OK - integral/floating conversion */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines rule 43

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 180

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_6_2_4</key>
<configkey>GJB5369-4_6_2_4</configkey>
<name><![CDATA[ 避免由于设计的原因导致某些代码不能执行 [GJB5369-4_6_2_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免由于设计的原因导致某些代码不能执行 [GJB5369-4_6_2_4-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在if/while/for/else块中如果一个条件值不变而出现无用代码.
参见:MISRA2004-14_1组规则 and MISRA2004-13_7组规则



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

vo7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助防止无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int unreachable_code = 1;
    if(0)                         // Violation
    { 
        unreachable_code = 2; 
    }                 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不得有不可达代码



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分
   
2. 来源: Misra 指南- 第52条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制结构章节,AV第186条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节, 第0部分,第 0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_1_2</key>
<configkey>GJB5369-4_7_1_2</configkey>
<name><![CDATA[ 主过程所在文件中禁止有未被该文件中任何过程调用的子过程 [GJB5369-4_7_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
主过程所在文件中禁止有未被该文件中任何过程调用的子过程 [GJB5369-4_7_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

主过程所在文件中禁止有未被该文件中任何过程调用的子过程。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int p_1)	// 违规
{
    int x=p_1;
}

int main(void)
{
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int p_1)	// OK
{
    int x=p_1;
}

int main(void)
{
    foo(int x);
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.7.1.2  主过程所在文件中禁止有未被该文件中任何过程调用的子过程

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_1_3</key>
<configkey>GJB5369-4_7_1_3</configkey>
<name><![CDATA[ static类型的过程在所在文件中必须被调用 [GJB5369-4_7_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
static类型的过程在所在文件中必须被调用 [GJB5369-4_7_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"任何定义的函数都必须至少被调用一次."
如果定义函数未被使用规则会报告违规



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则检测以下函数:
- 在 C语言中: 
  - 静态函数,
- 在 C++中: 
  - 非模板全局静态函数, 
  - 在匿名命名空间中的非模板全局静态函数,
  - 非模板 非静态 非运算符 私有成员函数



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"函数或者过程没有被调用是一个很严重的问题,
例如缺少路径."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static void foo() // 违规
{
   /* ... */
}

int main()
{
  return (0);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static void foo() // OK
{
   /* ... */
}

int main()
{
  foo(); 
  return (0);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
第 6 章, 第 0 节, 规则 0-1-10

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_1_4</key>
<configkey>GJB5369-4_7_1_4</configkey>
<name><![CDATA[ 禁止使用被禁用的过程、函数、文件或名称 [GJB5369-4_7_1_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用被禁用的过程、函数、文件或名称 [GJB5369-4_7_1_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"程序员使用新版本的标准库的宏、对象或者函数
的地方(例如 增强功能或者检查输入值)，这些
修改过的宏、对象或者函数需要有一个新的命名。
这样做是为了避免这样的混淆：是标准宏、
对象或者函数正在被调用，还是修改过的正在
被调用。因此，比如，新版本的开平方根函数
被写入用来检查输入是否为负值，那么这个函数
不能被命名为'sqrt'，而是需要给定一个新的名字。"
本规则检查下面的保留名字是否被使用：
-来自C标准库头文件的宏、函数、和typedef名称：assert.h,
  complex.h, ctype.h, errno.h, float.h, iso646.h, limits.h, locale.h, math.h,
  setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h, string.h, time.h,
  wchar.h, wctype.h, stdint.h, inttypes.h, fenv.h, stdbool.h, tgmath.h
- 以下划线字符开头的标示符
另见: NAMING-33, CODSTA-92, CODSTA-93



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可预防未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int memset();    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int my_memset(); // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章， 第 20 节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_1_6</key>
<configkey>GJB5369-4_7_1_6</configkey>
<name><![CDATA[ 禁止同一个表达式中调用多个相关函数 [GJB5369-4_7_1_6] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止同一个表达式中调用多个相关函数 [GJB5369-4_7_1_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了少数运算符（特别是函数调用运算符 (), &amp;&amp;, ||, ?: 
和, (逗号)）中的子表达式被赋值的顺序是未指定并可能变化的。
这意味着子表达式的赋值顺序是不可靠的，尤其不能信赖
副作用发生的顺序。
函数当他们被调用的时候可能有额外的影响（例如修改一些
全局数据）。在表达式使用它之前先调用函数，
生成一个临时变量来赋值，可以避免对赋值优先级的依赖。” 

如果一个表达式被两个函数调用，
其中第一个函数将参数作为一个指针或一个引用，
用于一个非const变量并修改该变量，
而第二个函数使用了与第一个函数相同的变量作为参数，
该规则会报告一个违规。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果一个变量在函数中通过赋值直接地修改
或函数体没有定义在当前的编译单元，规则假设这个变量被修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止表达式的赋值依赖于编译器版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int* ptr)
{
    (*ptr)++;
    return 0;
}
int bar(int local_param)
{
    return local_param;
}

void foo_t(int i, int j)
{
    i = foo(&amp;j) + bar(j);    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int* ptr)
{
    (*ptr)++;
    return 0;
}
int bar(int local_param)
{
    return local_param;
}

void foo_t(int i, int j)
{
    int temp = foo(&amp;j);
    i = temp + bar(j);    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_1_8</key>
<configkey>GJB5369-4_7_1_8</configkey>
<name><![CDATA[ 禁止 void 类型的变量作为参数进行传递 [GJB5369-4_7_1_8] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止 void 类型的变量作为参数进行传递 [GJB5369-4_7_1_8-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范禁止 void 类型的变量作为参数进行传递.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void static_p(int p_1)
{
	void *v_ptr=&amp;y;
	para_func(v_ptr); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在函数的参数传递 void 类型的变量.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.7.1.8  禁止 void 类型的变量作为参数进行传递

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_1_9</key>
<configkey>GJB5369-4_7_1_9</configkey>
<name><![CDATA[ 禁止实参和形参类型不一致 [GJB5369-4_7_1_9] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止实参和形参类型不一致 [GJB5369-4_7_1_9-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

传入函数的参数类型必须与
函数定义中的参数类型相一致。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
 
该规则提高代码的可读性与可维护性，减少错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{

}

void goo(float a, float b)
{
  foo(a, b);   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{

}

void goo(int a, int b)
{
  foo(a, b);   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_2_1</key>
<configkey>GJB5369-4_7_2_1</configkey>
<name><![CDATA[ 避免过程参数在过程调用中未被使用 [GJB5369-4_7_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免过程参数在过程调用中未被使用 [GJB5369-4_7_2_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不得在非虚函数中有未使用的参数（有名或无名）."


例外:

"在一个被当作回调的函数中定义无名参数
不违反此规则."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"未使用函数往往由于设计变更和导致会造成
参数列表不匹配."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int Foo(int i, int k)   // 违规
{
    i = 5;
    return i;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int Foo(int i)          // OK
{
    i = 5;
    return i;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
第 6 章, 第 0 节, 规则 0-1-11

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_2_2</key>
<configkey>GJB5369-4_7_2_2</configkey>
<name><![CDATA[ 避免以非调用方式使用函数 [GJB5369-4_7_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免以非调用方式使用函数 [GJB5369-4_7_2_2-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在表达式中使用一个过程标识符有可能
无法执行函数的调用或函数地址的分配。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

bool test_p(void)
{
    bool retval=ture;
    /*...*/
    return retval;
}

/*********************************************
* 避免以非调用方式使用函数
***********************************************/
void static_p(void)
{
     if(test_p){
      /*...*/
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.7.2.2  避免以非调用方式使用函数

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_7_2_3</key>
<configkey>GJB5369-4_7_2_3</configkey>
<name><![CDATA[ 谨慎使用 abort, exit 等函数 [GJB5369-4_7_2_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 abort, exit 等函数 [GJB5369-4_7_2_3-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许使用来自库stdlib.h，cstdlib或者库stdlib_iso.h
中的 'abort', 'exit', 'getenv' 和 'system' 函数.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用那些没有在嵌入式系统需要的函数



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include  &lt;stdlib.h&gt;
void foo( void ) {
    char *libvar;
    libvar = getenv( "LIB" );  /* 违规 */
    system( "dir" );           /* 违规 */
    abort( );                  /* 违规 */
    exit( 0 );                /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用abort, exit, getenv 和系统函数.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. 来源: Misra 指南 - 第126条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5 章库，, AV 第24条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-0-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_1_1</key>
<configkey>GJB5369-4_8_1_1</configkey>
<name><![CDATA[ 禁止单独使用小写字母“l”或大写字母“O”作为变量名 [GJB5369-4_8_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止单独使用小写字母“l”或大写字母“O”作为变量名 [GJB5369-4_8_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

小写字母“l”很容易与数字“1”混淆，
大写字母“O”很容易与数字“0”混淆，
因此禁止单独使用小写字母“1”或大写字母“0”作为变量名。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void static_p(void)
{
     int l=1,O=0;
     /*...*/
     l=O;  //违规
     O=1; //违规
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.8.1.1  禁止单独使用小写字母“l”或大写字母“O”作为变量名

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_1_2</key>
<configkey>GJB5369-4_8_1_2</configkey>
<name><![CDATA[ 禁止三字母词的使用 [GJB5369-4_8_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止三字母词的使用 [GJB5369-4_8_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

三字母词的使用使得程序难于阅读，
容易出现编程失误。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.11.2.1  谨慎使用无限循环语句

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_1_3</key>
<configkey>GJB5369-4_8_1_3</configkey>
<name><![CDATA[ 使用的八进制数必须加以注释 [GJB5369-4_8_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用的八进制数必须加以注释 [GJB5369-4_8_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

由于八进制数是以O开始的，容易与十进制的数混淆，
所以使用的八进制数必须加以注释。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int code1;
    int code2;
    int code3;

    code1 = 052;    /* 违规 */
    code2 = 071;    /* 违规 */
    code3 = '\100'; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1() 
{
    int code1;
    int code2;
    int code3;

    code1 = 42;  /* OK */
    code2 = 57;  /* OK */
    code3 = 64;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.8.1.3  使用的八进制数必须加以注释

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_2_1</key>
<configkey>GJB5369-4_8_2_1</configkey>
<name><![CDATA[ 避免使用"+="或"-="操作符 [GJB5369-4_8_2_1] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用"+="或"-="操作符 [GJB5369-4_8_2_1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则用于检测代码中是否使用了“+=”或“ -=”，
如果有则报告违规。“+=”或“ -=”操作符的使用具有简洁的特点，
但也影响了可读性，容易出现编程失误。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

增强代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/*****************************************
* 避免使用“+=”或“-=”操作符
*****************************************/
void static_p(void){
    unsigned int x=1u;
    unsigned int y=2u;
    unsigned int z=3u;
    bool flag=false;
    /*……*/
    x+=1;	//违规
    z-=y;	//违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void static_p(void){
    unsigned int x=1u;
    unsigned int y=2u;
    unsigned int z=3u;
    bool flag=false;
    /*……*/
    x=1+x;	//ok
    z=z-y;	//ok
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.8.2.1  避免使用“+=”或“-=”操作符

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_2_2</key>
<configkey>GJB5369-4_8_2_2</configkey>
<name><![CDATA[ 谨慎使用 "++" 或 "--" 操作符 [GJB5369-4_8_2_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 "++" 或 "--" 操作符 [GJB5369-4_8_2_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“此规则的目的是说明，当使用递增或递减运算
符时，递增或递减操作应该是语句完成的唯一附加功能.
此规则建议在使用++和--运算符时不要与其他 
数学运算符混合起来使用因为：
 - 影响代码的可读性
 - 对在声明中没有明确定义的函数行为产生额外
   的影响
I建议单独使用++和--运算符比较
安全。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性。 
降低由于额外影响导致函数潜在的
不确定行为的危险



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = --y + x++;  /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int x, y;
    --y;            /* OK */
    x = y + x;
    x++;            /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 联合攻击战斗机，飞行器，C++编码规范，
    第4.25章，飞行器第204条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南，
    第6章，第12节，第5-2-10条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_2_3</key>
<configkey>GJB5369-4_8_2_3</configkey>
<name><![CDATA[ 避免使用 continue 语句 [GJB5369-4_8_2_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用 continue 语句 [GJB5369-4_8_2_3-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免使用continue.continue用来跳出循环.
但是，如果用其他语句代替（continue）代码更容易读懂.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用continue导致错误和混乱.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int bar( int );
void foo( int i ) {
    while (i--) {
        if (bar( i )) {
            continue;     /* Violation */
        }
        i /= 2;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int bar( int );
void foo( int i ) {
    while (i--) {
        if (bar( i )) {
            /* OK - code was changed and does not use continue anymore */
        } else {
            i /= 2;
        }
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rec. 53

3. 来源: Misra 指南- 第57条规则

4. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24控制流结构,AV 第190条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_2_4</key>
<configkey>GJB5369-4_8_2_4</configkey>
<name><![CDATA[ 谨慎使用三重表达式 [GJB5369-4_8_2_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用三重表达式 [GJB5369-4_8_2_4-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测是否使用 '?:' 三重表达式。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性. 三重表达式 '?:' 不容易了解
且容易造成混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int main( ) 
{
    return (1 ? 1 : 0); // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int main( ) 
{
    if (1)             // OK
        return 1;
    else
        return 0;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Parasoft 推荐

2. 国军军用标准 航天型号软件 C 语言安全子集
4.8.2.4  谨慎使用三重表达式

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_2_5</key>
<configkey>GJB5369-4_8_2_5</configkey>
<name><![CDATA[ 避免使用不起作用的语句 [GJB5369-4_8_2_5] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用不起作用的语句 [GJB5369-4_8_2_5-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"任何 (除了空语句以外) 没有副作用而且不会
对导致控制流变化的语句通常表示一个编程错误，
因此对这类语句应该执行静态检查。" 

ISO/IEC 9899:1999标准中,副作用是这样定义的:访问某个可变对象,
修改某个对象,修改某个文件或者调用包含上述任一操作的函数都是副
作用.副作用即是那些在执行中的发生的变化.

Null语句定义为:只含有一个分号的语句.
如果检测到不带副作用的非空语句,就会报告违规.
比如,某个表达式的估算结果未被使用,原因是程序员忘记使用赋值
符来保存该值,或者他不小心把"="写成了"==".此语句会被认
为没有副作用.这样的编程错误具有潜在的危害性。

如果检测到空的块语句,也会报告违规,因为这样的语句也不会带有副作用.
空函数体并不违反此条规则,因为本规则把所有函数调用看作是带有副作用的,即使
函数调用没有改变任何变量的值.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
 
空的函数体并不被这条规则视为违规。 
就这条规则的目的而言，任何函数调用都被认为 
有副作用，即使作为这个函数调用的结果， 
没有任何变量被修改
这条规则不对空块报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

符合此规则会使代码更安全和可读.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct tagStruct {
    int _iField;
    char * _p;
};

int bar( );

void foo( ) {
    int i = 0;
    struct tagStruct s, *ps;
    /* Examples of incorrect code - no side effects: */
    i + 3;                    /* Violation - result not used */
    3;                        /* Violation - result not used */
    i;                        /* Violation - result not used */
    i + bar();                /* Violation - result not used */
    ps-&gt;_p + s._iField;       /* Violation - result not used */
    ps-&gt;_iField &lt;&lt; s._iField; /* Violation - result not used */
    *(ps-&gt;_p);                /* Violation - result not used */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct tagStruct{
    int _iField;
    char * _p;
};

volatile struct tagStruct volStr;

int bar( );

void foo( ) {
    int i = 0;
    volatile int j = 0;
    struct tagStruct s, *ps;

    /* Examples of correct code - with side effects: */
    i = i + 3;               /* OK - assignment */
    i &lt;&lt;= 3;                 /* OK - assignment */
    bar();                   /* OK - function call */
    j;                       /* OK - volatile variable */
    volStr._p;               /* OK - volatile variable */
    if(ps-&gt;_iField){}        /* OK - cause control flow to change */

    ;                        /* OK - null statement */
    {}                       /* OK - empty block */
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南-第53条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.24 章节控制流结构, AV第 187条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_2_6</key>
<configkey>GJB5369-4_8_2_6</configkey>
<name><![CDATA[ 避免使用空语句 [GJB5369-4_8_2_6] ]]></name>
<tag>gjb5369</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用空语句 [GJB5369-4_8_2_6-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

C 语言允许使用空语句， 但有些编译器是不能处理空语句的，
所以建议避免使用空语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void static_p(void)
{
    unsigned int Timing_Loop=100u;
    /*...*/
    Timing_Loop--;;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void static_p(void)
{
    unsigned int Timing_Loop=100u;
    /*...*/
    Timing_Loop--;      //OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.8.2.6  避免使用空语句

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_2_7</key>
<configkey>GJB5369-4_8_2_7</configkey>
<name><![CDATA[ 谨慎使用寄存器变量 [GJB5369-4_8_2_7] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用寄存器变量 [GJB5369-4_8_2_7-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可使用寄存器存储类别关键字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止依赖于编译器。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    register int a;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 'register' 存储类别关键字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源:  Misra 指南 - 第 28 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 140 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_8_2_8</key>
<configkey>GJB5369-4_8_2_8</configkey>
<name><![CDATA[ 避免使用老的参数表的定义形式 [GJB5369-4_8_2_8] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用老的参数表的定义形式 [GJB5369-4_8_2_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

建议使用新的(ANSI)参数表的定义形式。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int test1(a,b)
int a;
int b;
{
	
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int test1(int a, int b)
{
         // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
国家军用标准GJB 5369－2005 航天型号软件 C 语言安全子集
4.8.2.8  避免使用老的参数表的定义形式

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_9_1_1</key>
<configkey>GJB5369-4_9_1_1</configkey>
<name><![CDATA[ 函数必须有返回语句 [GJB5369-4_9_1_1] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数必须有返回语句 [GJB5369-4_9_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对于返回值是非空类型的函数，它的所有退出
路径都应该有一个表达式明确地给出返回值。
缺了这个表达式，将会导致未定义的行为
（并且编译器可能不能指出这个错误）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

"goto" 语句被认为是一个退出点。
该规则不跟踪数据流。它假定在条件语句中
每条路径应该根据条件可独立访问的。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则阻止了不可预测的函数行为。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

此规则将跳出"while", "for", 和"catch"语句段。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1(int x){ // 违规 
                 //在第二重if语句，没有返回
    if (x==0) {
        if (x==0) {
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // 违规 
                 // 在switch语句中，没有default语句的返回值
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
    }
}

int foo3(int x){ // 违规 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1(int x){ // OK
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // OK
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
        default: return 1;
    }
}

int foo3(int x){ // OK
    return 0;
}

int foo4(int x){ // OK
    if (x==0) {
        return 0;
    }
    return 0;
}

int foo5(int x){ // Ok
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        switch(x){
            case 0: return 1;
            case 1: return 1;
            case 2: return 1;
            default: return 1;
        }
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.13章函数，AV 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第8部分，第8-4-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_9_1_2</key>
<configkey>GJB5369-4_9_1_2</configkey>
<name><![CDATA[ 禁止 Void 类型的过程中的 return 语句带有返回值 [GJB5369-4_9_1_2] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止 Void 类型的过程中的 return 语句带有返回值 [GJB5369-4_9_1_2-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于返回值类型为 void 的函数，
返回语句不能有表达式。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不确定的行为 （编译器可能不会提供错误）。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* compilable by 'c' compiler */
void foo2() {
  return 1;  /* 违规 */
}

void foo3() {
  int a=0;
  return a;  /* 违规 */
}

void foo4(int a) {
  return a;  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* compilable by 'c' compiler */

void foo1() {
  return;    /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 84 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_9_1_3</key>
<configkey>GJB5369-4_9_1_3</configkey>
<name><![CDATA[ 有返回值的函数中 return 必须带有返回值 [GJB5369-4_9_1_3] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
有返回值的函数中 return 必须带有返回值 [GJB5369-4_9_1_3-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对于返回值是非空类型的函数，它的所有退出
路径都应该有一个表达式明确地给出返回值。
缺了这个表达式，将会导致未定义的行为
（并且编译器可能不能指出这个错误）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

"goto" 语句被认为是一个退出点。
该规则不跟踪数据流。它假定在条件语句中
每条路径应该根据条件可独立访问的。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则阻止了不可预测的函数行为。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

此规则将跳出"while", "for", 和"catch"语句段。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1(int x){ // 违规 
                 //在第二重if语句，没有返回
    if (x==0) {
        if (x==0) {
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // 违规 
                 // 在switch语句中，没有default语句的返回值
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
    }
}

int foo3(int x){ // 违规 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1(int x){ // OK
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // OK
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
        default: return 1;
    }
}

int foo3(int x){ // OK
    return 0;
}

int foo4(int x){ // OK
    if (x==0) {
        return 0;
    }
    return 0;
}

int foo5(int x){ // Ok
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        switch(x){
            case 0: return 1;
            case 1: return 1;
            case 2: return 1;
            default: return 1;
        }
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.13章函数，AV 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第8部分，第8-4-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>GJB5369-4_9_1_4</key>
<configkey>GJB5369-4_9_1_4</configkey>
<name><![CDATA[ 函数返回类型必须一致 [GJB5369-4_9_1_4] ]]></name>
<tag>gjb5369</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数返回类型必须一致 [GJB5369-4_9_1_4-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则在返回值类型与声明的函数返回值类型
不一致的情况下报告一个违规。
如果一个函数的返回类型属于以下情况，将不会报告违规：
- 一个 typedef 或返回类型的引用
- 一个只有通过来自返回类型 const 或 volatie 修饰符不同的类型
- 一个非空对象或函数的指针
- 一个返回类型的基类的引用
参见： MISRA-043, PORT-14, MISRA2004-10_1 (组), PB-06, PB-11



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在 C 语言中单独的字符常量的类型是 'int'， 但是本规则
假设其为 'char' (类似于在 C++ 中的定义) 以防止混乱。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防有可能导致信息丢失的隐式转换，n提高代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

float foo1( int i ) {
    return i;            // 违规
}

void* foo3(int* ptr ) {
    return ptr;          // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int_t;

float foo1( int i ) {
    return (float)i;            // OK
}

void* foo2(int* ptr ) {
    return (void*)ptr;          // OK
}

int foo3(const volatile int_t cvi ) {
    return cvi;            // OK
}

int foo4(int&amp; ref ) {
    return ref;            // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-01</key>
<configkey>INIT-01</configkey>
<name><![CDATA[ 头文件中不能包含任何初始化 [INIT-01] ]]></name>
<tag>init</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
头文件中不能包含任何初始化 [INIT-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

头文件中不能包含任何初始化。 将初始化放到头文件中使得
该数据”属于“哪个函数不清晰。多个源文件包含该头文件
可能导致”重定义“错误。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则主要用于检测 C 代码。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防”重定义“问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// header file 
int i = 0;	// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// header file 
int i;	// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-02</key>
<configkey>INIT-02</configkey>
<name><![CDATA[ 不能用有符号常量初始化无符号整形变量 [INIT-02] ]]></name>
<tag>init</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能用有符号常量初始化无符号整形变量 [INIT-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if unsigned integer variable is initialized
by numeric constant with a negative value.
See also: PB-08,  MISRA2004_10_1_h



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents undesirable implicit conversions.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S {
    unsigned int m_i;
};

void foo()
{
   unsigned int y = -21;    // Violation
   S s = {-10};             // Violation
}

class A {
public:
    A();
private:
    unsigned int ai;
};

A::A() : ai(-10){           // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S {
    unsigned int m_i;
    signed int n_i;
};

void foo()
{
   unsigned int y = 21;    // OK
   signed int x = -21;     // OK
   S s = { 10, -10};       // OK
}

class A {
public:
    A();
private:
    unsigned int ai;
    signed int si;
};

A::A() : ai(10), si(-10){  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-03</key>
<configkey>INIT-03</configkey>
<name><![CDATA[ 初始化所有变量 [INIT-03] ]]></name>
<tag>init</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
初始化所有变量 [INIT-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“变量必须在使用前进行初始化。 一般而言，如果变量未定义， 
编译器将给出警告信息。 那对于这样的情况已经足够了。 
类的事例经常通过无参数初始化，如果在声明时没有提供参数 
供参数 （空的构造函数被调用）。 为声明已经在另一个文件中 
初始化的变量,总是使用关键字 extern。
初始化变量，而不是在首次使用前给该变量赋值，代码变得更有效率 
,这样也不会有临时的对象被创建用于初始化 
对于有大量数据的对象，这能有效的提高代码执行速度。” 


例外：

对于 'volatile' 类型, 非基本类型以及数组例外。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止读取未初始化的代码。


事例：

int a;             // 违规

void foo( ) {
    int b;         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int a = 0;        // OK

void foo( ) {
    int b = 0;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
    From: 11 Variables - Rule 41

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Coding Style", Rule 19

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.16 Initialization, AV Rule 142

4. <A HREF="http://cwe.mitre.org/data/definitions/457.html">http://cwe.mitre.org/data/definitions/457.html</A>

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

6. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-04</key>
<configkey>INIT-04</configkey>
<name><![CDATA[ 初始化所有指针变量 [INIT-04] ]]></name>
<tag>init</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
初始化所有指针变量 [INIT-04-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测所有指针变量是否被初始化。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这规范实施一个良好的编码练习: 总是初始化指针变 
量, 即便你想做一次性修改或赋值到这变量.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

初始化指针变量可避免未初始化指针的解引用而引发的问题.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int y, int * p)
{
   int *i;  // 违规
   int *j;  // 违规
   if (y) {
      j = 0;
   } else {
      j = p;
   }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int y, int * p)
{
   int *i = 0;            // OK
   int *j = y ? 0 : p;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Coding Style", 规则 19

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-05</key>
<configkey>INIT-05</configkey>
<name><![CDATA[ 如果引用所指向的对象地址能够改变，不要初始化该引用 [INIT-05] ]]></name>
<tag>init</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果引用所指向的对象地址能够改变，不要初始化该引用 [INIT-05-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果引用所指向的对象地址能够改变，不要初始化 
该引用。 若引用指向的对象能被释放，则导致该 
引用能通过一个指针删除, 结果导致该引用指向NULL 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止非法访问已经被释放的变量。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
   int *ptr = 0;
   int &amp;rptr = *ptr; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
   int ptr = 0;
   int &amp;rptr = ptr; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-06</key>
<configkey>INIT-06</configkey>
<name><![CDATA[ 在构造函数中初始化所有成员变量 [INIT-06] ]]></name>
<tag>init</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在构造函数中初始化所有成员变量 [INIT-06-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

构造函数应该初始化所有成员变量。
该规则检测成员变量是否初始化：
- 构造函数中初始化链表
- 构造函数函数体
- 从构造函数中访问函数体 (三层嵌套
  被检查).
参见: INIT-10, INIT-14, MISRA-030


说明:

该规则假定成员变量可能通过传递非常量类型指针到
一个外部函数，用以被初始化成员变量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止读取未初始化的变量。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C
{
public:
    C( );

private:
    int mem_a;
    int mem_b;
    int mem_c;
    int mem_d;
    int mem_e;
};

C::C( ) // Violation - mem_a, mem_b, mem_c, mem_d, mem_e - not initialized
{
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C
{
public:
    C( );
    void init();
    void init2();
    void getPtr(int *);
private:
    int mem_a;  // initialized in constructor initialization list
    int mem_b;  // initialized inside constructor body
    int mem_c;  // initialized inside function 'init' called from constructor
    int mem_d;  // initialized inside function 'init2' called from 'init'
    int mem_e;  // its non-const pointer is passed to an external function.
};

void C::init()
{
    mem_c = 2;
    init2();
}

void C::init2()
{
    mem_d = 2;
}


C::C( ) : mem_a( 0 ) // OK - all members are initialized
{
    mem_b = 1;
    init();
    getPtr(&amp;mem_e);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 4

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-07</key>
<configkey>INIT-07</configkey>
<name><![CDATA[ 通过用户自定义的构造函数显式初始化类成员 [INIT-07] ]]></name>
<tag>init</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
通过用户自定义的构造函数显式初始化类成员 [INIT-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查是否提供用户自定义构造函数来决定 
类类型变量是否已正确初始化. 如果你在类里未写 
任何一个构造函数, 则编译器会为用户生成一个默 
认的公共构造函数。
这条规则检查你未定义任何一个构造函数.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

只有静态成员或没有成员的类会被省略而不被 
这条规则报告.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果遵循这条规则, 你可以明确地使类初始化和 
避免编译器不正确的初始化成员, 尤其是那些指 
针成员.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B
{
    public:
        static int s;
        int b;
        int a;
};
int main() 
{
    B bb;     // 违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
    public:
        A(){}
    private:
        static int w;
        int b;
        int a;
};

class C // OK
{
    public:
        int foo();
        void qwe(int x);
};

class D  // OK
{
    public:
        static int s;
        static int b;
        static int a;
};

int main() 
{
    C cc; // OK
    A a;   // OK
    D dd; // OK
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-08</key>
<configkey>INIT-08</configkey>
<name><![CDATA[ 用户自定义的构造函数必须初始化动态分配的类对象 [INIT-08] ]]></name>
<tag>init</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
用户自定义的构造函数必须初始化动态分配的类对象 [INIT-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查是否提供用户自定义构造函数来决定 
动态分配的类对象是否已正确初始化. 如果你在类里未写 
任何一个构造函数, 则编译器会为用户生成一个默 
认的公共构造函数. 
这条规则检查你未定义任何一个构造函数.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

只有静态成员或没有成员的类会被省略而不被 
这条规则报告.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果遵循这条规则, 你可以明确地使类初始化和 
避免编译器不正确的初始化成员, 尤其是那些指 
针成员.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B
{
    public:
        static int s;
        int b;
        int a;
};
B* foo(B* b)
{
    B* a=new B(); // 违规
    return new B(); // 违规
}

int main() 
{
    foo(new B()); // 违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
    public:
        A(){}
        static int w;
        int b;
        int a;
};

A* foo2()
{
    A* a=new A(); // OK
    return new A(); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-09</key>
<configkey>INIT-09</configkey>
<name><![CDATA[ 初始化类的静态成员变量 [INIT-09] ]]></name>
<tag>init</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
初始化类的静态成员变量 [INIT-09-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有静态成员变量应该被初始化。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止读取未初始化的变量。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C{
       const static int a; // 违规
       static int b;
};

int C::b; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C{
       const static int a = 0;  // OK
       static int b;
};

const int C::a;

int C::b = 0;      // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-10</key>
<configkey>INIT-10</configkey>
<name><![CDATA[ 初始化列表的初始化顺序应该与其声明的顺序一致 [INIT-10] ]]></name>
<tag>init</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
初始化列表的初始化顺序应该与其声明的顺序一致 [INIT-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“析构函数对于成员变量的析构顺序总是与构造函数 
中相反的顺序。 这样，如果成员变量的初始化顺序 
与声明时保持一致，则编译器将跟踪每个对象的成 
员变量，以确保析构函数按正确的顺序进行析构, 
这是较为昂贵的提议，为避免这样的开销，对于 
指定类型的对象，构造函数和析构函数的顺序是 
一样的，并且在初始化列表中的成员变量的顺序被忽略。”
事例代码中来自类 A 的成员变量 b 没有按我们假定的 
顺序初始化 (用相同值初始化)。
参见: INIT-06, INIT-14, MISRA-030



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防访问空指针。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( int x ) : a( x ), b( a ) {}    // 违规 - b 声明在 a 之前
private:
    int b;
    int a;
};

class B : public A {
public:
    B( int );
private:
    int a;
    float b;
};

B::B( int y ) : b( 5 ), A( 1 ), a( y ) {}   // 违规 - a 声明在 b 之前



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A( int x ) : a( x ), b( a ) {}   // OK - a 声明在 b 之前
private:
    int a;
    int b;
};

class B : public A {
public:
    B( int );
private:
    float b;
    int a;
};

B::B( int y ) : b( 5 ), A( 1 ), a( y ) {}   // OK - b 声明在 a 之前



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 4

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   Chapter: "Constructors, Destructors, and Assignment Operators", Item 13

3, JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.10 Classes, AV Rule 75

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-11</key>
<configkey>INIT-11</configkey>
<name><![CDATA[ 使用 = 操作符来赋值所有数据成员 [INIT-11] ]]></name>
<tag>init</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 = 操作符来赋值所有数据成员 [INIT-11-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果你使用 = 操作符，这条规则确保你赋值给对象里的每个
数据成员.
这条规则检查如果成员变量初始化在:
- 赋值操作符的语句里
- 赋值操作符所调用的函数体里
  (检查3层嵌套的函数调用).
参见: MRM-43



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这条规则假设那些成员变量透过传递其非常量指针到外部函数 
来初始化.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在 = 赋值运算符的函数里对所有成员变量赋值可以避免
数据损坏.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C
{
public:
    C&amp; operator=(const C&amp;);
private:
    int mem_a;
    int mem_b;
    int mem_c;
    int mem_d;
};

C&amp; C::operator=(const C&amp;) // 违规 - mem_a, mem_b, mem_c, mem_d - not assigned
{
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C
{
public:
    C&amp; operator=(const C&amp;);
    void init();
    void init2();
    void getPtr(int *);
private:
    int mem_a;  // assigned inside operator= body
    int mem_b;  // assigned inside function 'init' called from operator=
    int mem_c;  // assigned inside function 'init2' called from 'init'
    int mem_d;  // its non-const pointer is passed to an external function.
};

void C::init()
{
    mem_b = 2;
    init2();
}

void C::init2()
{
    mem_c = 2;
}

C&amp; C::operator=(const C&amp;) // OK - all members are assigned
{
    mem_a = 1;
    init();
    getPtr(&amp;mem_d);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 章节 2, 第 12 项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Constructors, Destructors, and Assignment Operators", 第 16 项

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-12</key>
<configkey>INIT-12</configkey>
<name><![CDATA[ 避免在编译单元中出现初始化顺序问题 [INIT-12] ]]></name>
<tag>init</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在编译单元中出现初始化顺序问题 [INIT-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在一个编译单元内的非局部静态对象的初始化 
值为在另一个不同编译单元内的非静态局部对象，
则该对象可能没有初始化，因为 C++ 对定义于不同 
编译单元的非局部静态对象的初始化顺序并无明确定义。
幸运的是, 一种小的设计能够完全消除该问题。
所要做的只是将每个非静态局部对象放到该变
量所属的函数（声明该变量的函数）内即可。 
这些函数返回指向所包含对象的引用。
客户端可以调用这个函数而不是 
这个对象的引用。 换句话说，非局部 
静态对象被局部静态对象替代。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"This approach is founded on C++'s guarantee that local 
static objects are initialized when the object's definition
is first encountered during a call to that function. So if
you replace direct accesses to non-local static objects 
with calls to functions that return references to local 
static objects, you're guaranteed that the references you
get back will refer to initialized objects. As a bonus, if you
never call a function emulating a non-local static object, 
you never incur the cost of constructing and destructing 
the object, something that can't be said for true non-local
static objects."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class FileSystem { 
public:
    size_t numDisks( ) const; 
};
extern FileSystem tfs;                              // 违规 
class Directory { 
public:
    Directory( );
};
Directory::Directory( ) {
    size_t disks_tfs = tfs.numDisks( ); 
}
Directory tempDir( );



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class FileSystem { 
public:
    size_t numDisks( ) const; 
};
FileSystem&amp; tfs_one( ) { 
    static FileSystem fs;                            // OK
    return fs; 
}
class Directory { 
public:
    Directory( );
};
Directory::Directory( ) {
   size_t disks_one = tfs_one().numDisks( );
}
Directory tempDir( ); 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 4

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.28 Portable Code, AV Rule 214

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-13</key>
<configkey>INIT-13</configkey>
<name><![CDATA[ 不能假设构造函数中成员的初始化顺序 [INIT-13] ]]></name>
<tag>init</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能假设构造函数中成员的初始化顺序 [INIT-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不能假设构造函数中成员的初始化顺序
不能依靠在构造函数中成员的初始化顺序."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守这条规则可以让代码更安全，可读性更好.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class X {
public:
    X( int y );
private:
    int i;
    int j;
};

inline X::X( int y ) : j( y ), i( j ) {}    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class X {
public:
    X( int x, int y );
private:
    int i;
    int j;
};

inline X::X( int x, int y ) : j( y ), i( x ) {}    // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 18 Portable Code - 18.6 Order of Execution - Port. Rec. 14

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>INIT-14</key>
<configkey>INIT-14</configkey>
<name><![CDATA[ 在构造函数中推荐使用初始化列表而非赋值 [INIT-14] ]]></name>
<tag>init</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在构造函数中推荐使用初始化列表而非赋值 [INIT-14-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检测构造函数中是否通过赋 
值进行初始化。赋值操作可能造成 
首先调用默认构造函数，然后再执 
行赋值操作。初始化能够消除这种 
问题。 注意常量和引用只能初始 
化而不能赋值。 
参见： INIT-06, INIT-10, MISRA-030



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

改善代码一致性和运行时性能 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

class A {
public:
    A( const char* file, const char* path ) {  
        myFile = file;     // 违规
        myPath = path;     // 违规
    }
private:
    string myFile;
    string myPath;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

class A {
public:
    A( const char* file, const char* path ) : 
        myFile(file), myPath(path) {}    // OK
private:
    string myFile;
    string myPath;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Design Style", Rule 09,
   Chapter: "Construction, Destruction, and Copying", Rule 48

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   Chapter: "Constructors, Destructors, and Assignment Operators", Item 12

3. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 4

4. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.10 Classes, AV Rule 74

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-1</key>
<configkey>JSF-1</configkey>
<name><![CDATA[ 任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC) [JSF-1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC) [JSF-1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC)



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

逻辑代码行即为组成代码片断的各行。这些行以分号结尾。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止函数变长，变复杂，从而变的难以组合并测试。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void sample_function() // 违规
{
    int x, y;
    
    // ...

    if (x&lt;10)
    {
        y = x + 1;   // L-SLOCs number = 201
    } 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void sample_function() // OK
{
    int x, y;
    
    // ...

    if (x&lt;10)
    {
        y = x + 1;   // L-SLOCs number = 150
    } 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 3.2 Code Size and Complexity, AV Rule 1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-10</key>
<configkey>JSF-10</configkey>
<name><![CDATA[ 字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集 [JSF-10] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集 [JSF-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“所选择的C 的执行应该符合10646-1标准的子集，
而选定的子集应作记录。”
明确指定数值的字符可能不符合 
所选择的ISO 10646-1标准的子集。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

字符类型值的定义和记录是 ISO 10646-1 的子集。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    const char * s[] = {"a",
                        "\012" /* 违规 */
    };
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

定义字符的类型是 ISO 10646-1 的子集。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 006 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规则
   第 4.4 章 Environment， AV 第 10 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-107</key>
<configkey>JSF-107</configkey>
<name><![CDATA[ 在文件的范围内声明函数 [JSF-107] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在文件的范围内声明函数 [JSF-107-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数应该被声明在文件范围内。
在区块范围内声明函数可能会使人混淆，
并且会导致不明确的行为。




</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止产生不确定的行为并提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1( ) {
    void foo2( );  /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo2( );      /* OK */
void foo1( ) {
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. 来源: Misra 指南 - 第 112 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.13 章 函数，第 AV 107 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 3 节， 第 3-1-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-108</key>
<configkey>JSF-108</configkey>
<name><![CDATA[ 避免使用有可变数量参数的函数 [JSF-108] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用有可变数量参数的函数 [JSF-108-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用有可变数量参数的函数



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以防止很多潜在的问题



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int x, ...)   // 违规
{  
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用有可变数量参数的函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 第 69 条规则

2. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   从: 9 Functions - 9.1 Function Arguments - 第 31 条规则 

3. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   "Type Safety" 章， 第 98 条规则

4. Scott Meyers and Martin Klaus, "Examining C++ Program Analyzers", 
   Dr. Dobbs' Journal, the February 1997, 
   "Implementation" 章， 第 23 项
   <A HREF="http://www.aristeia.com/ddjpaper1_frames.html">http://www.aristeia.com/ddjpaper1_frames.html</A>

5. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.13 章 Function， AV 第 108 条规则

6. MISRA C++:2008 C++ 语言在关键系统中的使用指南，
   第 6 章， 第 8 节， 第 8-4-1 条规则 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-109</key>
<configkey>JSF-109</configkey>
<name><![CDATA[ 非模板类的定义中不能定义成员函数 [JSF-109] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非模板类的定义中不能定义成员函数 [JSF-109-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在类定义内定义函数是隐式内联的；然而，
在类定义内定义成员函数同样使得类
的定义不紧凑并且很难读。这条规则会检测是否你的
成员函数定义实在类的定以内。
参见: CODSTA-CPP-33



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则通过分离接口和实现确保更好的数据隐藏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    int foo( ) {};      // 违规
    inline int bar( );
};

inline int A::bar( ) {
    return 0;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    int foo( );         // OK
    inline int bar( );
};

int A::foo( ) {};
inline int A::bar( ) {
    return 0;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 6 Style  - 6.1 Classes - Rule 21

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.13章节 Functions, 第109条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-11</key>
<configkey>JSF-11</configkey>
<name><![CDATA[ 禁止使用三字母词 [JSF-11] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用三字母词 [JSF-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则遇到使用三字母词的时候会报告一个违规信息。
所有在源文件里出现的下列三个字符的序列（称为三字母词序列）将被相应的
单个字符替换：
??= #
??( [
??/ \
??) ]
??' ^
??&lt; {
??! |
??&gt; }
??- ~

如果编译器用开关来忽略三字母词时
需要使用该选项，或者能够确保在
代码中绝不使用两个问号相联。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

三字母词能引起与其它使用两个问号相联的情形的意外的混淆
并导致不可预期的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

??=define TEST 1	/* Violation */
void foo() {
    const char * s = "(Date should be in the form ??-??-??)";	           /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define TEST 1	/* OK */
void foo() {
    const char * s = "(Date should be in the form " "??" "-??" "-??" ")";  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 4 节

2. 来源: Misra 指南 - 第 7 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.4 章 环境，第 AV 11 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-3-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-110</key>
<configkey>JSF-110</configkey>
<name><![CDATA[ 不要使用多于 7 个参数的函数 [JSF-110] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用多于 7 个参数的函数 [JSF-110-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有长参数列表的函数是难以阅读，使用和维护的。
同时也表明，没有很好的使用抽象和对象的概念。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则帮助改进代码的可维护性和可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b, int c, int d, int e, int f, int g, int h)  // 违规
{ 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// 限制函数的参数在7个之内.

void foo(int a, int b, int c, int d, int e, int f, int g)  // OK
{ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
4.13 Function, AV Rule 110

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-111</key>
<configkey>JSF-111</configkey>
<name><![CDATA[ 禁止返回对局部对象的引用 [JSF-111] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止返回对局部对象的引用 [JSF-111-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“禁止函数返回局部变量的指针或引用。如果函数返回了
局部变量的引用或指针，那么当使用该引用或指针时，其
引用的内存块已经被释放掉了。不同的编译器可能会也可
能不会给出相应的警告。
”参见：MRM-23, PB-40, MISRA2004-17_6



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

返回对局部对象的引用或由被调函数中的new运算符初始化
的解引用指针可能会导致内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* foo( ) {
    int i;
    return &amp;i; // Violation
}
int&amp; bar( ) {
    int i;
    return i;  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( ) {
    int i = 0;
    return i;  // OK
}
int bar( ) {
    int i = 0;
    return i;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#9.4">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#9.4</A>
  论坛：9 函数 - 9.4返回类型以及值 -第34条规则

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“类与函数：实现”，第31项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.13章 函数，AV规则第111条

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-112</key>
<configkey>JSF-112</configkey>
<name><![CDATA[ 禁止返回函数范围内的new运算符初始化的解引用本地指针 [JSF-112] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止返回函数范围内的new运算符初始化的解引用本地指针 [JSF-112-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止函数返回对局部对象的引用或者由函数中的new运算符初始
化的解引用指针。本规则能检查到函数返回了对局部对象的引用
或解引用指针。
参见：MRM-24



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

返回对局部对象的引用或由被调函数中的new运算符初始化的解
引用指针可能会导致内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A(int xval, int yval) : _x(xval), _y(yval) {}
    friend A&amp; operator+(const A&amp; p1, const A&amp; p2);
private:
    int _x, _y;
};

A&amp; operator+(const A&amp; p1, const A&amp; p2) {
    A *result = new A(p1._x + p2._x, p1._y + p2._y);
    return *result;             // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A(int xval, int yval) : _x(xval), _y(yval) {}
    friend A operator+(const A&amp; p1, const A&amp; p2);
private:
    int _x, _y;
};

A operator+(const A&amp; p1, const A&amp; p2) {
    A result = A(p1._x + p2._x, p1._y + p2._y);
    	
    return result;              // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scoot Meyers，《高效C++：改善程序及设计的50种特定方法》，
  第二版，Addison-Wesley，
  (C)2005 Pearson Education, Inc., 
  章节：“类与函数：实现”，第31项

2.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.13章节 函数，AV规则第112条

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-113</key>
<configkey>JSF-113</configkey>
<name><![CDATA[ 函数应该在其最后有单一的出口 [JSF-113] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数应该在其最后有单一的出口 [JSF-113-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数应该有单一的出口.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则包括函数调用出口、终止,标准库的出口.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

帮助编写安全、易读的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int i)
{
    if (i == 0) {
        return 0;        // Violation	
    } else if (i == 1) {
        return 1;        // Violation
    } else {
        return 2;        // Violation
    }
}

int foo2(int a) {  
    int result;
    if (a &gt; 0) {
        return result;  // Violation
    } 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int i)
{
	int result = 0;
    if (i == 0) {
        result = 0;
    } else if (i == 1) {
    	result = 1;
    } else {
    	result = 2;
    }
    return result;   // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分

2. 来源: Misra 指南-第82条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
  第4-13功能章节,AV第113条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-114</key>
<configkey>JSF-114</configkey>
<name><![CDATA[ 非 void 函数中每一个 return 语句必须有返回值 [JSF-114] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非 void 函数中每一个 return 语句必须有返回值 [JSF-114-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对于返回值是非空类型的函数，它的所有退出
路径都应该有一个表达式明确地给出返回值。
缺了这个表达式，将会导致未定义的行为
（并且编译器可能不能指出这个错误）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

"goto" 语句被认为是一个退出点。
该规则不跟踪数据流。它假定在条件语句中
每条路径应该根据条件可独立访问的。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则阻止了不可预测的函数行为。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

此规则将跳出"while", "for", 和"catch"语句段。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1(int x){ // 违规 
                 //在第二重if语句，没有返回
    if (x==0) {
        if (x==0) {
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // 违规 
                 // 在switch语句中，没有default语句的返回值
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
    }
}

int foo3(int x){ // 违规 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1(int x){ // OK
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // OK
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
        default: return 1;
    }
}

int foo3(int x){ // OK
    return 0;
}

int foo4(int x){ // OK
    if (x==0) {
        return 0;
    }
    return 0;
}

int foo5(int x){ // Ok
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        switch(x){
            case 0: return 1;
            case 1: return 1;
            case 2: return 1;
            default: return 1;
        }
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.13章函数，AV 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第8部分，第8-4-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-115</key>
<configkey>JSF-115</configkey>
<name><![CDATA[ 如果函数返回错误信息，该错误信息必须经过测试 [JSF-115] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数返回错误信息，该错误信息必须经过测试 [JSF-115-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不管函数是来自标准库，还是第三方的库，或者是用户定义的函数，
它可能提供一些方式来标志一个错误的发生。这种方式可能是通过设
置一个错误标志，一些特别的返回值或者其它的方式。
无论何种方式，调用这个函数的程序应该在函数返回时，检查错误标志。
但是，注意对函数输入参数进行检查是一种比试图在函数完成之后检查
错误的更稳健的一种方式（参见MISRA2004-20_3）。  
同样也要注意对errno（用来从函数返回错误信息）的使用是笨拙的，
要小心使用（参见MISRA2004-20_5）。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
函数调用可能返回char, short int, int, enum类型或者这些类型的引用的值，
此规则用来检查返回这些类型值的函数调用并在这个值没有被赋值，
检查或者强制转换成了void类型时报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来帮助书写安全性高的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int SomeFunctionReturningError( );
void foo( )
{
    SomeFunctionReturningError( );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int SomeFunctionReturningError( );
int foo( ) 
{
    int x;
    x = SomeFunctionReturningError( );       // OK
    (void)SomeFunctionReturningError( );    //OK
    if (SomeFunctionReturningError( ));       // OK
    switch (SomeFunctionReturningError( )) {  //  OK
    }
    return SomeFunctionReturningError( );     //  OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源:Misra 使用指南 - 第 86 条规则

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Function, AV Rule 115

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第0部分，第0-3-2条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 7

6. <A HREF="http://cwe.mitre.org/data/definitions/391.html">http://cwe.mitre.org/data/definitions/391.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-116</key>
<configkey>JSF-116</configkey>
<name><![CDATA[ 通过值传递内建类型，除非你打算修改该参数 [JSF-116] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
通过值传递内建类型，除非你打算修改该参数 [JSF-116-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检查参数是否通过内建的类型进行值传递,
除非需要在函数里修改该参数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

值传递能提高代码效率。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int Foo(int i, int &amp;j)  // 违规
{    
    return i + j;
}
int Bar(int &amp;i, int j)  // 违规
{    
    j += i;
    return j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int Foo(int i, int j)  // OK
{      
    return i + j;
}
int Bar(int i, int j)  // OK
{    
    j += i;
    return j;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc. Chapter: "Take Parameters Appropriately
   by Value, (Smart) Pointer, or Reference", Rule 25

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Functions (Value, Pointer or Reference), AV Rule 116

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-117.1</key>
<configkey>JSF-117.1</configkey>
<name><![CDATA[ 尽可能声明引用参数为 const 引用 [JSF-117.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽可能声明引用参数为 const 引用 [JSF-117.1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否用户声明引用参数为 const 引用。
当用户的函数不会修改其所引用的参数时，用户 
应该使用 const 来防止当函数返回时变量意外 
的修改。
参见: CODSTA-CPP-03, CODSTA-CPP-38, CODSTA-CPP-44, 
          MISRA-104, MISRA2004-16_7, OPT-21



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

声明不会被修改的参数为 const 引用而不是引用 
提高了可读性。它也防止将来修订会意外的 
改变调用函数的数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct Foo {
    int x;
    int y;
};

int Bar( Foo &amp;f ) {  // 违规
    return f.x;
}

int FooBar( Foo &amp;f ) { // OK
    return f.x++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct Foo {
    int x;
    int y;
};

int Bar( const Foo &amp;f ) {  // OK
    return f.x;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章, 第3项

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第7节, 规则 7-1-2

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-117_a</key>
<configkey>JSF-117_a</configkey>
<name><![CDATA[ 避免函数参数或返回值导致的切片问题 [JSF-117_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免函数参数或返回值导致的切片问题 [JSF-117_a-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测如果有虚拟函数的类对象以值来 
传递或返回而不是用引用. 用引用来传递 / 
返回比用值来传递更有效率. 因为不会创建
新的对象而且可避免 "切断问题."
参见: OPT-14, PB-23



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范预防切断问题, 增加代码一贯性
和运行效能.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    virtual void someFun();
    const A violation( A a ) {       // 违规 - 以值传递参数
        return a;                    
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    virtual void someFun();
    const A&amp; valid( const A &amp;a ) {   // OK
        return a;                    
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编程规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Design Style", 第 09 规则

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 4 章, 第 20 项

3. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc.,
   章节: "Classes and Functions: Design and Declaration", 第 22 项

4. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 1 章, 第 3 项

5. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 9 Function - 9.1 Function Arguments - Rec. 43

6. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 117 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-117_b</key>
<configkey>JSF-117_b</configkey>
<name><![CDATA[ 如果类中含有非静态指针并且没有声明过拷贝构造函数，就应使用引用传递类对象 [JSF-117_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果类中含有非静态指针并且没有声明过拷贝构造函数，就应使用引用传递类对象 [JSF-117_b-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测含有指针成员的对象使用编
译器生成的拷贝构造函数来以值传递. 以
引用来传递对象可避免可能的拷贝成员指
针逐位拷贝的问题.
当类 / 结构体有非静态指针成员栏位, 没有
定义的拷贝构造函数, 且类 / 结构体对象以
值传递时则规范会报告违例.
参见: OPT-14, PB-20


例外:

该规则不包括检查名字以 'iterator' 结尾的类型为类/结构体
的对象 (例如 'iterator', 'const_iterator', 'normal_iterator',...)



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范协助避免可能的成员指针逐位拷贝问题 .



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A;
void foo1(A a);

class A
{
    int *x;
};

void foo(void)
{
    A a;
    foo1(a);     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A;
void foo1(A &amp;a);


class A
{
    int *x;
};

void foo(void)
{
    A a;
    foo1(a);     // OK - 以引用传递
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 117 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-118</key>
<configkey>JSF-118</configkey>
<name><![CDATA[ 如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [JSF-118] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [JSF-118-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在函数原型中的指针参数，如果不用来修改地址参数就应该被声明为指向常量的指针。
既然被保护的是对象，这个常量的限制应该应用于指针指向的对象而不是指针本身。”
参见: CODSTA-14, CODSTA-CPP-43, CODSTA-CPP-53, MISRA-104, 



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

可能已经是参数声明为指向常量的指针的重载函数。
然后改变参数的类型为指向常量的指针会使得
代码不可编译。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
此规则可用来阻止无意的修改数据，并在函数接口定义上，提高准确性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int function(int* ptr)       // 违规
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int function(const int* ptr) // OK
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55种提高程序设计的特殊的途径 ", 
   第三版, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章，第3项

2. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

3.  联合攻击战斗机, 飞行器, C++ 编码标准
   第4.13章函数， AV 第118条规则

4. 来源: Misra 指南- 第81条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-118_b</key>
<configkey>JSF-118_b</configkey>
<name><![CDATA[ 如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [JSF-118_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [JSF-118_b-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if a parameter in a function prototype is declared
as typedef to pointer to non-const object and the pointer is not used to modify
the addressed object. Then the type of parameter could be changed to typedef
to pointer to const object.
参见: CODSTA-14, CODSTA-CPP-43, CODSTA-CPP-53, MISRA-104



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

It is not sufficient to add 'const' identifier before typedef's
name in a function declaration, because it is applied to pointer
not to pointed object.
There can already be overloaded function with parameter declared as typedef
to pointer to const. Then changing the type of parameter to typedef to pointer
to const will make the code non-compilable.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents unintentional change of data and improves precision in the
definition of the function interface.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* PINT;
typedef const int* CINT;

int function1(PINT ptr)        // 违规
{
    return (*ptr) + 1;
}

int function2(const PINT ptr)  // 违规
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int* PINT;
typedef const int* CINT;

int function1(CINT ptr)        // OK
{
    return (*ptr) + 1;
}

int function2(const CINT ptr)  // OK
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 3

2. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 16

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Function, AV Rule 118

4. Origin: Misra Guidelines - Rule 81

5. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 7, Rule 7-1-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-119</key>
<configkey>JSF-119</configkey>
<name><![CDATA[ 函数不应该直接或者间接地调用自己 [JSF-119] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不应该直接或者间接地调用自己 [JSF-119-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数不应该直接或者间接地调用自己。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这个规则用来检测直接递归调用或者简单地
间接地递归调用（多达三层嵌套函数调用）。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止使用递归函数调用.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int l ) {
    int x = l;

    if (l &gt; 0) {
        foo( x - 1 );   /* 违规 */
    }
}

void foo3( int );

void foo4( int i ) {
    if (i &gt; 0) {
        foo3( (int) i / 2 );  /* 违规 */
    }
}

void foo3( int i ) {
    int x = i;

    if (i &gt; 0) {
        foo4( x - i );  /* 违规 */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1( ) {          /* Ok */
    /* 空的 */
}

void foo2( );           /* Ok */

void foo3( ) {
    foo2( );            /* Ok */
}

void foo7( int );

void foo4( int i ) {
    foo7( i );    /* Ok - 不能检测复杂地间接地递归调用 */
}

void foo5( int i ) {
    foo4( i );    /* Ok -不能检测复杂地间接地递归调用*/
}

void foo6( int i ) {
    foo5( i );    /* Ok - 不能检测复杂地间接地递归调用 */
}

void foo7( int i ) {
    if (i &gt; 0) {
        foo6( i - 5 );  /* Ok - 不能检测复杂地间接地递归调用 */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源：Misra 指南 - 第70条规则

3. 联合攻击战斗机，飞行器，C++ 编码标准
   第4.13章函数，AV 第119条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-5-4条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

6. HIS Source Code Metriken, version 1.3.1
Metrik "ap_cg_cycle"

7. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-12</key>
<configkey>JSF-12</configkey>
<name><![CDATA[ 不要使用下列合体字母<%, %>, <:, :>, %:, %:%: [JSF-12] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用下列合体字母&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%: [JSF-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用下列合体字母&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:
该规则中的合体字母使得简单结构体含义不清。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则增强代码的可读性。


源自：

v7.1


事例：

int a &lt;: 2 :&gt; &lt;: 2 :&gt; = &lt;%&lt;%0,1%&gt;,&lt;%2,3%&gt;%&gt;; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int a[2][2] = { {0,1}, {2,3} };              // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.4 Environment, AV Rule 12

2. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 2, Rule 2-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-121</key>
<configkey>JSF-121</configkey>
<name><![CDATA[ 如果函数中仅包含了 1 或 2 条语句，应该考虑成为内联函数 [JSF-121] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数中仅包含了 1 或 2 条语句，应该考虑成为内联函数 [JSF-121-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当函数仅有 1 或 2 个语句时才考虑为需要
内联的函数对象.
此规范会在内联函数拥有2个以上的语句时
报告违例.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

内联复杂的函数可能导致明显的代码膨胀
而会增加代码调试的复杂度.



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

每个声明的变量被视为不同的语句.

int a, b, c;  // 会被计算出3个语句



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

inline int foo(int a)   // 违规
{
  int b = 0;
  b = (b-a)/a;
  return b;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int a)          // OK
{
  int b = 0;
  b = (b-a)/a;
  return b;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   Chapter 4.13 Functions, AV Rule 121

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-122</key>
<configkey>JSF-122</configkey>
<name><![CDATA[ 短小而且简单的 accessor/mutator 语句应该为内联函数 [JSF-122] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
短小而且简单的 accessor/mutator 语句应该为内联函数 [JSF-122-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

较小的访问器和修改器 (accessor and mutator) 函数应被内联.
规范会在访问器/修改器 (accessor/mutator) 没有底下条件时报违例:
- loop 语句
- 虚函数调用
- 递归
- 超过 5 个语句

且没内联.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

内联简单和小的函数可以节省时间和空间.



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

此规范认为 getter/setter (访问器/修改器) 是拥有以
 get/Get 和 set/Set 开头命名或以下划线和大写字
母开头及:
- get 方法返回成员变量或引用
- set 方法设定数值到成员变量


例外:

模板和虚函数.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
 	int m_var;
 
 public:
 	 int get_m_var();
 	 void set_m_var();
};


int A::get_m_var()    // 违规
{
   return m_var;
}

void A::set_m_var()   // 违规
{
   m_var = 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
 	int m_var;
 
 public:
 	inline int get_m_var();
 	inline void set_m_var();
};


inline int A::get_m_var()   // OK
{
   return m_var;
}

inline void A::set_m_var()  // OK
{
   m_var = 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 122 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-123</key>
<configkey>JSF-123</configkey>
<name><![CDATA[ 应尽量减少 accessor/mutator 函数的数目 [JSF-123] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应尽量减少 accessor/mutator 函数的数目 [JSF-123-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

访问器和修改器 (accessor and mutator) 函数的数量
应控制与成员变量的数量相同. 此规范会在 setter
 或 getter 方法的数量超出成员变量的数量时
报告违例.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规范假设 setter/getter (修改器/访问器) 方法是从
 get/Get 或 set/Set 开头命名的且以下划线
或大写字母紧跟着.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

许多的访问器和修改器 (accessors and mutators) 可能说明一个类只是
简单的处理数据收集的合计而不是体现一个
明确的状态抽象或不变式. 这种情况而言, 
拥有公共数据的结构体将是较好的选择.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Sample // 违规
{
 private:
	int m_var;
 public:
    int get_m_var();
    void set_m_var();
    void set_m_var(int a);
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Sample // OK
{
 private:
	int m_var;
 public:
    int get_m_var();
    void set_m_var(int a = 0);
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.10 章节 Classes, AV 第 123 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-124</key>
<configkey>JSF-124</configkey>
<name><![CDATA[ 较小的转调函数应被内联 [JSF-124] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
较小的转调函数应被内联 [JSF-124-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

较小的转调函数应被内联.
此规范会在函数仅运行单个动作如
调用的函数未被内联时报告违例.


例外:

构造函数, 解构造函数, 模板及虚函数.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

内联简单和小的函数可以节省时间和空间.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo(int a, int b)
{
 /* code */
 return 1;
}

int foo(int a, int b)        // 违规
{
  return(goo(a,b));
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo(int a, int b)
{
 /* code */
 return 1;
}

inline int foo(int a, int b) // OK
{
  return(goo(a,b));
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 124 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-125_a</key>
<configkey>JSF-125_a</configkey>
<name><![CDATA[ 使用引用而非数值传递对象 [JSF-125_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用引用而非数值传递对象 [JSF-125_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测如果有虚拟函数的类对象以值来
传递或返回而不是用引用. 用引用来传递 / 
返回比用值来传递更有效率. 因为不会创建
新的对象而且可避免 "切断问题."
参见: PB-20, PB-23, OPT-33


例外:

有种情况是对象是比较小，所以 
传值比传引用更有效率.
由于 C++ 的类型系统和 QString, RWCString and CString 等  
都是隐式共享, 它们可能被当作整数或其它基本类型.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范增加代码一贯性和运行效能.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    const A violation( A a ) {       // 违规 - 以值传递参数
        return a;                    // 违规 - 以值返回
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    const A&amp; valid( const A &amp;a ) {   // OK
        return a;                    // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编程规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Design Style", 第 09 规则

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 4 章, 第 20 项

3. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Design and Declaration", 第 22 项

4. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 1 章, 第 3 项

5. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 9 Function - 9.1 Function Arguments - Rec. 43

6. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 125 规则

7. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-125_b</key>
<configkey>JSF-125_b</configkey>
<name><![CDATA[ 使用 op= 而非单独的操作符 [JSF-125_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 op= 而非单独的操作符 [JSF-125_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当你声明独立的操作符:
+ , - , * , / ,  ^, % , | , &amp; , &gt;&gt; , &lt;&lt; (如, 操作符+), 操作符 
的赋值符 (如, 操作符+=) 也应定义.
"提供赋值符版本的操作符以及独立版本, 
让类的成员会难以在效率和便利中作出 
权衡."
"用户应该考虑以赋值符版本的操作符替代
独立版本每当性能是独特的因素."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"赋值符版本的操作符比独立版本的更有效率, 
因为独立版本通常需要返回新对象, 而那会 
需要暂时构造和解构造的动作. 赋值符版本的 
操作符直接写到左手边参数, 所以是没有必要
生成暂时的对象来存放操作符的返回值."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
};

A&amp; operator+( A&amp; a, A&amp; b );      // 违规
A&amp; operator-( A&amp; a, A&amp; b );      // 违规

class B {
public:
    B&amp; operator+=( B&amp; b );
};
B&amp; operator+( B&amp; a, B&amp; b );
void foo( ) {
    B ba, bb ,bc, bd;
    bb = ba + bc + bd;          // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A&amp; operator+=( A&amp; a );
    A&amp; operator-=( A&amp; a );
};

A&amp; operator+( A&amp; a, A&amp; b );      // OK
A&amp; operator-( A&amp; a, A&amp; b );      // OK
class B {
public:
    B&amp; operator+=( B&amp; b );
};
B&amp; operator+( B&amp; a, B&amp; b );
void foo( ) {
    B ba, bb ,bc, bd;
    bb = ba;                    // OK
    bb += bc;                   // OK
    bb += bd;                   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: "Efficiency", 第 22 项

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 125 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-126</key>
<configkey>JSF-126</configkey>
<name><![CDATA[ 推荐使用 C++ 风格的注释 [JSF-126] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
推荐使用 C++ 风格的注释 [JSF-126-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用 // 来处理注解. 不要使用 /* 和 */. 
"C++, 其实并不允许注解以 /* */ 来嵌套。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改进了可读性和维护性. 如果以 // 持 
续编写注解, 则 /* */ 的组合可以在开发和
调试阶段用来将整段代码做注解的动作
.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rec. 9

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 126

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-127</key>
<configkey>JSF-127</configkey>
<name><![CDATA[ 无法被编译的代码段落不能被“注释掉” [JSF-127] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
无法被编译的代码段落不能被“注释掉” [JSF-127-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一段代码要求不能被编译时
就通过使用条件编译来实现（例如使用#if
或者#ifdef结构并附加一段注释）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在某些情况下规则会报告错误肯定或者错误否定。
这种情况是由于源代码和注释文本的相似性而引起的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用注释的开始和结束标识符来达到此目的是危险的
因为C语言不支持注释嵌套，任何已经存在于这段代码
中的注释会改变这种效果。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int x = 5;
    /*  Section of code     // Violation
        commented out
    if (x==0){
        x++;
    }
    */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int x = 5;
/* Comment without          // OK
   code within */
#if 0                       
    if (x==0){
        x++;
    }
#endif
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第 6 章，第 2 节

2. 来源: Misra 使用指南 - 第 10 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.14 章注释， 第 AV 127 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-7-2 条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-7-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-13</key>
<configkey>JSF-13</configkey>
<name><![CDATA[ 不得使用宽字符串字面量 [JSF-13] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用宽字符串字面量 [JSF-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不得使用宽字符串字面量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止各种与他们相关的不确定和实施明确的行为。
他们不可以被使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
void foo() {
  wchar_t* x = L"Fred";	/* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
void foo() {
  char* x = "Fred";	/* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 8 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.4 章 Environment， AV 第 13 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-132_a</key>
<configkey>JSF-132_a</configkey>
<name><![CDATA[ 每一个变量声明都应该进行注释 [JSF-132_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个变量声明都应该进行注释 [JSF-132_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个变量声明应该被注解.
如果没有在变量声明后或前
一行添加注解, 规范会报告违例。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这规范只检测局部和全局变量的声明.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int var1;
    // 违规

    int var2;
    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int var1; // comment - OK

    // comment - OK
    int var2;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.14 章节 Comments, AV Rule 132

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-132_b</key>
<configkey>JSF-132_b</configkey>
<name><![CDATA[ 每一个类型定义(typedef)都应该进行注释 [JSF-132_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个类型定义(typedef)都应该进行注释 [JSF-132_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每一个 typedef 应被注解.
如果没有在 typedef 声明后或前
一行添加注解, 规范会报告违例。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32;
// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int32; // OK - comment



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.14 章节 Comments, AV Rule 132

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-132_c</key>
<configkey>JSF-132_c</configkey>
<name><![CDATA[ 每一个枚举值都应该进行注释 [JSF-132_c] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个枚举值都应该进行注释 [JSF-132_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个枚举值应该被注解.
如果没有在枚举值声明后和前
一行添加注解, 规范会报告违例。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum {
    ENUM1 = 2,
    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum {
    ENUM1 = 2, // OK - comment
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.14 章节 Comments, AV Rule 132

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-132_d</key>
<configkey>JSF-132_d</configkey>
<name><![CDATA[ 每一个结构成员变量都应该进行注释 [JSF-132_d] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个结构成员变量都应该进行注释 [JSF-132_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个结构成员变量应被注解.
如果没有在结构成员变量声明后和
前一行添加注解, 规范会报告违例。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S
{
    char* c;
    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S
{
    char* c; // comment - OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.14 章节 Comments, AV Rule 132

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-133_a</key>
<configkey>JSF-133_a</configkey>
<name><![CDATA[ 对每一个文件进行注释 [JSF-133_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对每一个文件进行注释 [JSF-133_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每个包含源码的文件必须以注解的方式提供
文件名和其内容介绍来记录."


记事:

C 和 C++ 的注解方式是认同的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改进可读性和维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// No comment "File:"           // 违规 - 没有介绍的注解



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// File: &lt;short description of the file&gt;   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rule 4

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 133

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-133_b</key>
<configkey>JSF-133_b</configkey>
<name><![CDATA[ 提供版权信息 [JSF-133_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
提供版权信息 [JSF-133_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"所有文件需包含版权信息, 以: // Copyright 
为一行的方式显示"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高了可读性和维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规 - 没有版权信息



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// Copyright



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rule 5

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 133

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-134</key>
<configkey>JSF-134</configkey>
<name><![CDATA[ 注释每个函数 [JSF-134] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
注释每个函数 [JSF-134-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在每个函数前编写描述性注解。"
规范将在底下状况报告违例:

1) 函数原型 如果没有函数定义且原
   型前没有提供注解, 

2) 假设函数定义:
-  没有原型且函数定义前没有提供
   注解
-  有原型但无论原型或函数定义都
   没有提供注解



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改进了可读性和维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1();     // 违规

int foo2(int x){ // 违规
    return x++;
}

int foo3(int x);
int foo3(int x){ // 违规
    return x++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// 函数的说明注解.
void foo1(); 

// 函数的说明注解.
int foo2(int x){ 
    return x++;
}

// 函数的说明注解.
int foo3(int x);

int foo3(int x){ 
    return x++;
}

int foo4(int x);

// 函数的说明注解.
int foo4(int x){
    return x++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rec. 8

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 134

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-135_a</key>
<configkey>JSF-135_a</configkey>
<name><![CDATA[ 在内部范围的标识符不能和外部的标识符用同样的名字，因为会隐藏那个标识符 [JSF-135_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在内部范围的标识符不能和外部的标识符用同样的名字，因为会隐藏那个标识符 [JSF-135_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏全局变量和全局参数的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

隐藏全局变量或者全局参数的名字
会导致错误或者混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int x;
void foo( ) {
    int x;     /* Violation */ 
    x = 3;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免使用全局变量和全局参数的名字隐藏。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. ISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-135_b</key>
<configkey>JSF-135_b</configkey>
<name><![CDATA[ 在内部范围的标识符不能和外部的标识符用同样的名字，因为会隐藏那个标识符 [JSF-135_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在内部范围的标识符不能和外部的标识符用同样的名字，因为会隐藏那个标识符 [JSF-135_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏局部变量的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

局部变量的名字隐藏会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( ) {
    int a;
    {
        int a;    /* Violation */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免隐藏局部变量的名字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-136</key>
<configkey>JSF-136</configkey>
<name><![CDATA[ 在函数范围内声明对象 [JSF-136] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数范围内声明对象 [JSF-136-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

声明的对象应该在函数范围
除非有必要在更大范围。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用全局变量



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int globalVar;  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int localVar;   // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 第 22 条规则

2. Ellemtel 编码规范 
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    出自: 16 Memory Allocation - Rec. 57

3. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 136 条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-137</key>
<configkey>JSF-137</configkey>
<name><![CDATA[ 尽可能在文件范围中的声明都是静态 static 的 [JSF-137] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽可能在文件范围中的声明都是静态 static 的 [JSF-137-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在可能的情況，所有在文件范围中的声明应该是静态 static 的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止意外覆盖的函数或者变量。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int g1; /* 违规 */
void foo1() {}; /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static int g2; /* OK */
static void foo2(){}; /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 23 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.15 章 Declarations and Definitions， AV 第 137 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-138_a</key>
<configkey>JSF-138_a</configkey>
<name><![CDATA[ 对标识符使用一致的连接 [JSF-138_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对标识符使用一致的连接 [JSF-138_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在同一个转换单位标识符不得同时
有内部和外部连接。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以阻止变量名隐藏，应为这样会造成困惑



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static unsigned short x;
static unsigned short y;

void foo( ) {
    extern unsigned short x;     // 违规
    extern unsigned short y;     // 违规
    {
        extern unsigned short y; // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

在同一个转换单位不要同时声明变量
在内部和外部连接。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源:  Misra 指南 - 第 24 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 138 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-138_b</key>
<configkey>JSF-138_b</configkey>
<name><![CDATA[ 带有内部链接的对象和函数应使用静态关键字进行定义和声明 [JSF-138_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
带有内部链接的对象和函数应使用静态关键字进行定义和声明 [JSF-138_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“将关键字“static”应用到所有的有内在连结的
对象和函数的声明中是一个良好的习惯做法。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则促成好的编码风格并提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* file.h */
static int x;

/* file.c */
#include "file.h"
extern int x;        /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* file.h */
static int x;

/* file.c */
#include "file.h"
static int x;         /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 138 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-139</key>
<configkey>JSF-139</configkey>
<name><![CDATA[ 外部对象不得声明在多个文件中 [JSF-139] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
外部对象不得声明在多个文件中 [JSF-139-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

外部对象应在头文件中声明，然后由包含在所有
这些的源文件使用这些对象。此规则将通知关于多
声明符号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则提升代码的可读性，让代码更清晰，防止错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* misra_027.h */
/* 不得在多个文件中声明外部对象。 */
extern int a;           /* 违规 */

/* misra_027.c */
#include "misra_027.h"
extern int a;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* misra_027.h */
extern int a;           /* OK */

/* misra_027.c */
#include "misra_027.h"
int a;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 27 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 139 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-14</key>
<configkey>JSF-14</configkey>
<name><![CDATA[ 字面量后缀将使用大写字母而不是小写字母 [JSF-14] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字面量后缀将使用大写字母而不是小写字母 [JSF-14-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

字面量后缀将使用大写字母而不是小写字母。
参见: CODSTA-50



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(long param = 64l)  // 违规
{
	const long a = 64l; // 违规
	
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(long param = 64L)  // OK
{
	const long a = 64L;     // OK
}


参考文献:

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.4 章 Environment, AV 规则 14

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 2 节, 规则 2-13-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-140</key>
<configkey>JSF-140</configkey>
<name><![CDATA[ 不要用寄存器式存储类别 [JSF-140] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要用寄存器式存储类别 [JSF-140-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可使用寄存器存储类别关键字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止依赖于编译器。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    register int a;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 'register' 存储类别关键字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源:  Misra 指南 - 第 28 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 140 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-141</key>
<configkey>JSF-141</configkey>
<name><![CDATA[ 类，结构体或枚举不应该在定义时作为变量类型声明变量 [JSF-141] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类，结构体或枚举不应该在定义时作为变量类型声明变量 [JSF-141-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类，结构体或枚举不应该在定义时作为变量类
型声明变量。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增加易读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum
{
  up,
  down
} direction;             //违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum direction_e
{
  up,
  down
};

direction_e direction; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编码规范
第4.15章 Declarations and Definitions, AV 第141条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-142_a</key>
<configkey>JSF-142_a</configkey>
<name><![CDATA[ 所有自动变量在使用之前必须被赋值 [JSF-142_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有自动变量在使用之前必须被赋值 [JSF-142_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这个规则的意图是在变量读取之前，所有的变量
要先被赋值。 变量并不一定需要在初始化声明时
被赋值。 理想的静态检查应该检查任何有可能被
利用又没有被赋值的自动变量。”
参见: INIT-06, INIT-10, INIT-14, BD-PB-NOTINIT



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这条规则假设通过传递的一个常量定指到外部函数，
局部变量有可能会被初始化。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止从未初始化的变量中读取。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int b;          // 违规      
    b++; 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int b = 0;     // OK 
    b++;        
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 1 章, 第 4 项

2. Misra 指南 - 第 30 条规则

3. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
   出自: 第 11 Variables - 第 40 条规则

4. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.16 章 Initialization， AV 第 142 条规则

5. MISRA C++:2008 C++ 语言在关键系统中的使用指南，
   第 6 章， 第 8 节， 第 8-5-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-142_b</key>
<configkey>JSF-142_b</configkey>
<name><![CDATA[ 初始化所有变量 [JSF-142_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
初始化所有变量 [JSF-142_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“变量必须在使用前进行初始化。 一般而言，如果变量未定义， 
编译器将给出警告信息。 那对于这样的情况已经足够了。 
类的事例经常通过无参数初始化，如果在声明时没有提供参数 
供参数 （空的构造函数被调用）。 为声明已经在另一个文件中 
初始化的变量,总是使用关键字 extern。
初始化变量，而不是在首次使用前给该变量赋值，代码变得更有效率 
,这样也不会有临时的对象被创建用于初始化 
对于有大量数据的对象，这能有效的提高代码执行速度。” 


例外：

对于 'volatile' 类型, 非基本类型以及数组例外。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止读取未初始化的代码。


事例：

int a;             // 违规

void foo( ) {
    int b;         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int a = 0;        // OK

void foo( ) {
    int b = 0;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
    From: 11 Variables - Rule 41

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Coding Style", Rule 19

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.16 Initialization, AV Rule 142

4. <A HREF="http://cwe.mitre.org/data/definitions/457.html">http://cwe.mitre.org/data/definitions/457.html</A>

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

6. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-143</key>
<configkey>JSF-143</configkey>
<name><![CDATA[ 如果变量不能被初始化为有意义的值就不应引入 [JSF-143] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果变量不能被初始化为有意义的值就不应引入 [JSF-143-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果变量不能被初始化为有意义的值就不应引入.
此规则会在以下情况报告违例:
- 局部变量在初始化时赋值却未使用 (例如在
  初始化语句后和赋予新值前未被使用)
- 局部变量太早声明且只在 for 迴圈使用时



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规范只对 C++ 代码有效.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免变量未被赋予有意义的数值而去存取.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int f(int);

void fun_1(int x)
{
   int i;             // 违规: i 太早声明 
                      // (目的只在 for 迴圈里使用i)

   int max=0;         // 违规: max 被伪值初始化

   max = f(x);
   for (i=0 ; i&lt;max ; ++i)
   {
   }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int f(int);

void fun_2(int x)
{

   int max = f(x);   // OK: max not introduced until meaningful
                     // value is available

   for(int i = 0; i &lt; max; i++) // OK
   {
   }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.16 章节 Initialization, AV 第 143 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-144</key>
<configkey>JSF-144</configkey>
<name><![CDATA[ 在数组和结构体的非 0 初始化中，使用大括号进行标识和匹配 [JSF-144] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在数组和结构体的非 0 初始化中，使用大括号进行标识和匹配 [JSF-144-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ISO C要求有数组的初始化列表，结构体和共用体类型要被
包括在唯一的一对大括号里（虽然不这么做的后果并不明确）。
这里给出的规则进一步要求使用
额外的大括号来指示结构体嵌套。
数组或者结构体的零初始化只允许在顶层进行。
数组或者结构体的非零初始化
要求对每一个元素有一个明确地初始化程序。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则只检查多达三层括号嵌套初始化。


例外：

“数组或者结构体的所有元素可以通过仅给第一个元素一个
明确的初始化量而被初始化（为0或者空）。如果选择了
这个初始化方法那么第一个元素应该被初始化
为0（或者空），而且不需要使用大括号嵌套。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“该规则强制要求程序员明确地考虑并证实复杂数据类型
的元素被初始化的顺序。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int y[3][2] = { 1, 2, 3, 4, 5, 6 }; // Violation

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, 2}; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int y[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // OK

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, { 2 }}; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 9 节

2. 来源: Misra 指南 - 第 31 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.16 章 初始化，第 AV 144 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 8 节， 第 8-5-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-145</key>
<configkey>JSF-145</configkey>
<name><![CDATA[ 在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化 [JSF-145] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化 [JSF-145-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在枚举数列表里，“=”不应该被用来
明确地初始化第一个成员之外的其他成员，
除非所有的元素都被明确地初始化。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

帮助避免错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum TEST { /* Violation */
    X = 1,
    Y,
    Z = 3,
};

enum TEST2 { /* Violation */
    X2,
    Y2 = 2,
    Z2,
};

enum TEST3 { /* Violation */
    X3,
    Y3,
    Z3 = 3,
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum TEST { /* OK */
    X,
    Y,
    Z,
};

enum TEST2 { /* OK */
    X2 = 1,
    Y2,
    Z2,
};

enum TEST3 { /* OK */
    X3 = 1,
    Y3 = 2,
    Z3 = 3,
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 9 节

2. 来源: Misra 指南 - 第 32 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 8 节， 第 8-5-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-147</key>
<configkey>JSF-147</configkey>
<name><![CDATA[ 不得使用浮点型数向下转换表示 [JSF-147] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用浮点型数向下转换表示 [JSF-147-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
	
程序员不得以任何方式使用
浮点型数向下转换表示。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止转换时可能会丟失数据



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int* pi;
    float* pf;
    double* pd;
    short int* ps;
    long * pl;

    pi = (int*)pf;    /* 违规 */
    pi = (int*)pd;    /* 违规 */
    ps = (short*)pf;  /* 违规 */
    pl = (long*)pf;   /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int* pi;
    float* pf;
    double* pd;
    short int* ps;
	
    pf = (float*)pd;  /* OK */ 
    ps = (short*)pi;  /* OK */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 16 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.17 章 Types， AV 第 147 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-148</key>
<configkey>JSF-148</configkey>
<name><![CDATA[ Case 语句的标签应该使用枚举(enum)类型而不是直接使用整数或常数 [JSF-148] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Case 语句的标签应该使用枚举(enum)类型而不是直接使用整数或常数 [JSF-148-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果需要从有限的数据中做选择，使用枚举类型替代
整数类型（以及常量）。 当整形（常量）被作为
 case 的条件时，规则将报告一个违规信息。


例外：

该规则不会排除字符串 (例如 'A', 'B' 等等)
作为 case 的条件。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

增强代码调试，可读性以及可维护性。 
注意编译器标签（如果可用）应该被设置生
成一个警告，如果有些枚举类型没有出现在 switch 语句中。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int color)
{
	switch(color)
	{

 	case 1:        // 违规
 			break;
 	case 2:        // 违规
 			break;
 	case 3:        // 违规
 			break;
 	default:
			break;
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum color 
{
    RED = 1,
    BLUE = 2,
    GREEN = 3
};

void foo(int color)
{
	switch(color)
	{

 	case RED:      // OK 
 			break;
 	case BLUE:     // OK
 			break ;
 	case GREEN:    // OK
 			break;
 	default: 
			break;
	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.18 Constants, AV Rule 148

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-149</key>
<configkey>JSF-149</configkey>
<name><![CDATA[ 不应使用非零八进制常量和八进制转义序列 [JSF-149] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应使用非零八进制常量和八进制转义序列 [JSF-149-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“任何以 '0' (零)开头的整形常量被视为八进制。
这就存在着危险，例如，在写固定长度的常量的时候。
八进制的换码序列会产生问题，因为一个不经意引入
的十进制数字会中止这个换码顺序并引入
另外一个字符。最好不要使用八进制常量或者换码序列
并且静态地检查是否出现这种情况。
整形常量0（写作一个单个的数字），严格
来说，是一个八进制常量，但是可以视为这个规则的一个特例。
此外\0是唯一允许的八进制换码序列。”


例外：

该规则忽略任何pragma parasoft / codewizard 指令。
该规则忽略任何asm blocks里的数值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码的可读性与可维护性。
该规则防止使用随实现环境不同而不同的数值。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int code1;
    int code2;
    int code3;

    code1 = 052;    /* Violation */
    code2 = 071;    /* Violation */
    code3 = '\100'; /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1() 
{
    int code1;
    int code2;
    int code3;

    code1 = 42;  /* OK */
    code2 = 57;  /* OK */
    code3 = 64;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 7 节

2. 来源: Misra 指南 - 第 19 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.18 章 常量，第 AV 149 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-13-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-150</key>
<configkey>JSF-150</configkey>
<name><![CDATA[ 十六进制常量应该使用大写字母表示 [JSF-150] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
十六进制常量应该使用大写字母表示 [JSF-150-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

十六进制常量应该使用大写字母表示。
参见： CODSTA-51



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

int i = 0x3fff;   // 违规



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

改善可读性和可维护性。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int i = 0x3FFF;   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.18 Constants, AV Rule 150

2. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 2, Rule 2-13-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-151</key>
<configkey>JSF-151</configkey>
<name><![CDATA[ 避免使用幻数 [JSF-151] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用幻数 [JSF-151-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

代码中避免出现数字常量。 这些数字不具备自我解释的能力。
使用有意义的字符替代。
参见： CODSTA-29



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

初始化的数字常量不在检查之列。
0 和 1 同样被排除因为其值为true或者false。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改善可读性和可维护性。


事例：

void boo(int);

int foo( int a[], int b ) {
    int e;
    int f = 0;  
    a[5] = 56; // 违规
    e= 8;      // 违规
    boo(56);   // 违规
    return 8;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int MAX = 8;       // OK

void boo(int);

int foo( float a[], float b ) {
    int e;
    int f = 0;        // OK  
    int i = 5;        // OK
    a[i] = MAX;       // OK
    e = MAX;          // OK
    boo(a[5]);        // OK
    return  MAX;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Coding Style", Rule 17

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.18 Constants, AV Rule 151

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-151.1</key>
<configkey>JSF-151.1</configkey>
<name><![CDATA[ 不能修改字符串内的字符 [JSF-151.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能修改字符串内的字符 [JSF-151.1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

字符串文字不该被修改. 规范会在字符串
文字被赋予非常量的变量, 参数或表达式时报违例.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

试图修改一个字符串的影响是不可预知.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void moo(char * p)
{
}

void foo()
{
	char* c1 = "Hello";    // 违规
	char c2[] = "Hello";   // 违规
	char c3[6] = "Hello";  // 违规
	char* c12;
	c12 = "Hello";         // 违规
	moo("Hello");          // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void moo(const char * p)
{
}

void foo()
{
	const char* c1 = "Hello";    // OK
	const char c2[] = "Hello";   // OK
	const char c3[6] = "Hello";  // OK
	const char* c12;
	c12 = "Hello";               // OK
	moo("Hello");                // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.18 章节 Constants, AV 第 151.1 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-152</key>
<configkey>JSF-152</configkey>
<name><![CDATA[ 不允许在同一行声明多个变量 [JSF-152] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许在同一行声明多个变量 [JSF-152-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范会在一行里定义多个变量而触发。
参见: FORMAT-33



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这规范提高了可读性并避免混肴.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a, b;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int a;      // OK
    int b;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.19 章节 变量, AV Rule 152

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-153</key>
<configkey>JSF-153</configkey>
<name><![CDATA[ 禁止使用联合体 [JSF-153] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用联合体 [JSF-153-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

即使内存因为某些原因被重新使用，
这种操作还是存在数据可能被误解危险。
因此，这个规则禁止任何原因的结构体类型的使用。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则在每一个共同体声明的时候报告一个违规的消息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未定义的行为和错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

union U {        违规 
    int _i;
    char _buf[ sizeof( int ) ];
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用共同体。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第18部分

2. Herb Sutter, Andrei Alexandrescu, C++编码标准, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   类型安全章节，第97条规则

3. 来源： Misra 指南 - 第109条规则

4. J联合攻击战斗机, 飞行器, C++ 编码标准
   第4.20章 共同体和位域, AV 第153条规则
   
5. MISRA C++2008 C++语言在关键系统中的使用指南，第6章，第9部分，第9-5-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-154</key>
<configkey>JSF-154</configkey>
<name><![CDATA[ 只能将位域定义为有符号的整型或无符号的整型 [JSF-154] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只能将位域定义为有符号的整型或无符号的整型 [JSF-154-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“位域只能定义成无符号整型或者有符号整型。
整形的使用是由实现环境决定的，因为整形的位域
可以是有符号也可是无符号的。枚举，短整型或者字符类型的位域
的使用是不允许的，因为其行为是不可确定的。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止这种随实现环境不同而不同的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Enum { E1, E2};
struct Struct 
{
    unsigned char  f1:2;  /* Violation */
    unsigned short f2:2;  /* Violation */
    unsigned long  f3:2;  /* Violation */
    enum Enum      f4:2;  /* Violation */
    int            f5:2;  /* Violation */
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct Struct
{
    unsigned int f1:2;  /* OK */
    unsigned int f2:2;  /* OK */
    unsigned int f3:2;  /* OK */
    signed int   f4:2;  /* OK */
    signed int   f5:2;  /* OK */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. 来源: Misra 指南 - 第 111 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.20 章 共用体和位段，第 AV 154 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-156</key>
<configkey>JSF-156</configkey>
<name><![CDATA[ 结构体或联合体的所有成员变量必须被命名 [JSF-156] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构体或联合体的所有成员变量必须被命名 [JSF-156-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

命名所有结构体(structure) 或 联合体(union)的成员。

在 C 语言中 "位域" 设施是其中的一个最不好定义
的部分。位域有两个主要的用途，他们可以用在:

1) 访问单个位，或是一组位，在更大的数据类型，
与联合会一道 (见规则 110).
2) 让标记或是其他短长度数据能够被包装，以节省存储空间

使用位域包装短长度的数据以节省存储空间是本
文档认为唯一的合理使用。

提供了只通过他们的名称访问结构体的元素，
程序员不能做任何有关于位域是如何
存储在结构体里的假设。

这条规则检查所有声明位域的名称。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用不可访问的数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int t;
typedef int plain;
struct tag {
    unsigned t:4;
    const t:5;   /* 违规 */
    plain r:5;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

提名所有 structure 或 union 的成员。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源:  Misra 指南  - 第 113 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 156 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-157</key>
<configkey>JSF-157</configkey>
<name><![CDATA[ 逻辑 && 或者 || 运算符的右边操作数不应该包含副作用 [JSF-157] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑 &amp;&amp; 或者 || 运算符的右边操作数不应该包含副作用 [JSF-157-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

含副作用，而且这些副作用
依赖于其他子表达式的值，有可能发生也有可能
不发生。可能导致这一问题的运算符包括&amp;&amp;和||，
在这两种运算符中，对右边操作数的赋值要受到
左边操作数值的条件限制。有可能引起副
作用的操作包括：访问volatile类型
对象，修改某个对象，修改某个文件，或调用某个
执行了上述某个操作的函数等。这些操作可能改
变调用函数的运行环境状态。”
参见：MISRA2004-12_2_a, MISRA2004-12_4_b



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则只能检查三层嵌套级别的函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果开发者信赖一个副作用的发生，
使用本规则可以避免对右操作数进行有条件赋值造成的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int i;
    int j;
    if ((j == i) || (0 == i++)) ; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int i;
    int j;
    if ((j == i) || (0 == i)) i++; // OK
}


参考文献：

1. MISRA-C:2004 C语言在关键系统的使用指南 
   第6章，第12部分

2. 来源：Misra指南-第33条规则

3. 联合攻击战斗机，飞行器，C++编程规范
   4.21章节操作符，飞行器第157条规则

4. MISRA C++:2008-C++语言在关键系统中的使用指南，
   第6章，第5部分，第5-14-1条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-158</key>
<configkey>JSF-158</configkey>
<name><![CDATA[ 逻辑 '&&' 或 '||' 的每个操作数应该为后缀表达式 [JSF-158] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑 '&amp;&amp;' 或 '||' 的每个操作数应该为后缀表达式 [JSF-158-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当单标签、常量或者函数调用没有加上
括号，该规则将报告一个违规。
"加括号对于代码的可读性和确保代码
按照程序员所设计逻辑运行非常重要。"
See also: MISRA2004-12_1_e, MISRA2004-12_5


例外：

"如果表达式仅由逻辑操作符 '&amp;&amp;' 或仅由逻
辑操作符 '||' 组成, 则不需括号。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"这个规则的效果是需要有适当的括号运算。" 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || y &amp;&amp; z );         // 违规
    if ( x &amp;&amp; !y );             // 违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || ( y &amp;&amp; z ) );         // OK
    if ( x &amp;&amp; ( !y ) );             // OK
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 5, Rule 5-2-1

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.21 Operators, AV Rule 158

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-159</key>
<configkey>JSF-159</configkey>
<name><![CDATA[ 避免重载 &&, || 或者 , （逗号） [JSF-159] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免重载 &amp;&amp;, || 或者 , （逗号） [JSF-159-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“内建的 &amp;&amp;, || 或者, （逗号） 会受到编译器的特殊处理。
如果用户重载它们，他们会变成具有特殊语义的普通功能，
并且这是一个肯定会引入隐蔽的缺陷和脆弱性的方式。"
此规则用于检测用户重载运算符 &amp;&amp;, || 或者 ,（逗号）时。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

重载这些操作符将改变编译器读取表达式语义 
的方式，造成不可预知的程序行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( int i ) : _i( i ) {}
    ~A( );

    int value( ) { return _i; }
private:
    int _i;
};

int operator&amp;&amp;( A&amp; lhs, A&amp; rhs ) {              // 违规
    return lhs.value( ) &amp;&amp; rhs.value( );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要重载运算符 &amp;&amp;, || 或者 ,（逗号）。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范” Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Functions and Operators", 第30条规则

2. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: “操作符”， 第7项

3. 联合攻击战斗机， 飞行器， C++ 编码规范
   章节 4.21 操作符, AV 第159条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第5节, 规则5-2-11

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-160</key>
<configkey>JSF-160</configkey>
<name><![CDATA[ 禁止在产生布尔值的表达式中使用赋值运算符 [JSF-160] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在产生布尔值的表达式中使用赋值运算符 [JSF-160-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止给布尔表达式赋值.
阻止对布尔表达式的操作数使用简单或复合的赋值运算符.
但是，变量还是可以被赋以布尔值的.
如果需要对布尔表达式的操作数赋值，则必须单独在操作数外面赋值.
这样做可避免混淆"="和"==",并帮助错误的静态检测.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

表达式被认为是布尔表达式有两种原因,一
种是表达式所在的位置应该是布尔值,
另一种是它使用的操作符会产生布尔值.布尔值在下面情况下出现:
—If 语言的控制表达式
—迭代语句的控制表达式
—条件运算符？的第一个操作数


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止混淆 "=" 和 "==".


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x = y);                // Violation
    if ((x &gt; y) &amp;&amp; (x = 4));  // Violation
    if (!(x = y));                // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x == y);               // OK
    if ((x &gt; y) &amp;&amp; (x == 4)); // OK
    if (!(x == y));               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Misra 指南 -第35条规则

2. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第13部分

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.21操作章节, AV 第160条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南l
    第六章节,第六部分,第6-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-162_a</key>
<configkey>JSF-162_a</configkey>
<name><![CDATA[ 避免隐式的无符号整型和有符号整型的转换 [JSF-162_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的无符号整型和有符号整型的转换 [JSF-162_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
该规则检查是否使用了有符号和无符号类型之间的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned int u32a, u32b;
    signed int s32a, s32b;

    s32a = u32a;            /* Violation */
    s32b = s32a + u32a;     /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned int u32a, u32b;
    signed int s32a, s32b;

    s32a = (signed int)u32a;        /* OK */
    s32b = s32a + (signed int)u32b; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-4条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-162_b</key>
<configkey>JSF-162_b</configkey>
<name><![CDATA[ 避免隐式的无符号整型和有符号整型的转换 [JSF-162_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的无符号整型和有符号整型的转换 [JSF-162_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值不应当隐式
转换为不同的基础类型。
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。”
规则检查变量初始化时是否使用了有符号数和无符号数
之间的隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned int u32a;
    signed int s32a = u32a;                 /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned int u32a;
    signed int s32a = (signed int)u32a;     /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004C语言在关键系统中的使用指南	
    第6章，第10节

2. MISRA-C++: 2008C++语言在关键系统中的使用指南	
    第6章，第5节，第5-0-4条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-162_c</key>
<configkey>JSF-162_c</configkey>
<name><![CDATA[ 有符号和无符号值的运算中必须使用显式的类型转换 [JSF-162_c] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
有符号和无符号值的运算中必须使用显式的类型转换 [JSF-162_c-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有符号和无符号值的运算中必须使用显式的类型转换



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守这一条规则得到更安全，更可读的代码



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(signed char a)
{
    signed char b = 'b';
    unsigned char c = 'c';
    a = b + c;                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(signed char a)
{
    signed char b = 'b';
    unsigned char c = 'c';
    a = (unsigned char)b + c;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范 
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    来自: 18 Portable Code - 18.3 Type Conversions - Port. Rec. 8

2. Misra 指南 - 第 48 条规则

3. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 162 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-163</key>
<configkey>JSF-163</configkey>
<name><![CDATA[ 不应在算术运算中使用无符号类型的数据 [JSF-163] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应在算术运算中使用无符号类型的数据 [JSF-163-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不该使用无符号算术.
规范会在找到算术表达式的 
操作数是无符号类型时报违例.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

长久以来, 无符号数值和有符号数值混合都
有错误倾向因为它主要操作有许多算术转换
和整体提升规则.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(unsigned p)
{
   unsigned int a = 0;
   int b = 0;
  
   b = p + a;         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(signed p)
{
   signed int a = 0;
   int b = 0;
  
   b = p + a;         // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.21 章节 Operators, AV 第 163 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-164</key>
<configkey>JSF-164</configkey>
<name><![CDATA[ 移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间 [JSF-164] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间 [JSF-164-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“例如，左移或右移运算符的左操作数是一个
16位整数， 那么移位数必须是一个
0~15之间的数字常量。

现在有很多方法可以遵循此规则，最简单的办法
就是保证右操作数是常量（它的值可以通过静态分析来
检查）。对于无符号整型必须保证操作数是 
非负数，此时只要检查上限值就可以（使用运行时检测
或通过代码检查）。否则上限值和下限值都必须被检查。”
此规则规定数据类型大小：字符型8bit，短整型16bit，
整型32bit，长整型64bit。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和易理解性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
void foo( uint16_t p ) 
{
   uint8_t u8a;

   u8a = (uint8_t) (u8a &lt;&lt; 9); /* 违规 */
   u8a = (uint8_t) (u8a &lt;&lt; p); /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
void foo( uint16_t p )
{
   uint8_t u8a;
   uint16_t u16a;
 
   u16a = (uint16_t) ((uint16_t) u8a &lt;&lt; 9); /* OK */

   if (p &gt;= 0 &amp;&amp; p &lt;= 8) {
     u8a = (uint8_t) (u8a &lt;&lt; p); /* OK - p range checked */
   }

   u8a = (uint8_t) (u8a &lt;&lt; 4); /* OK - constant value in range */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.  MISRA-C:2004 C语言在关键系统中的使用指南，
     第6章，第12节

2. 联合攻击战斗机，飞行器，C++编码规范，
    第4.21章，飞行器第164条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-8-1条规则 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-164.1</key>
<configkey>JSF-164.1</configkey>
<name><![CDATA[ 右移位操作符的左操作数不能是负数 [JSF-164.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
右移位操作符的左操作数不能是负数 [JSF-164.1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规范会在右移运算符的左操作数是使用 
以下一种格式时报违例.
- constant with a negative value
- unary operator '-' followed by parameter, variable or expression
- parameter or variable of signed type
- expression of signed type that contains parameter, variable, dereferenced
  pointer or function call of signed type



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如 e1 &gt;&gt; e2 这例子, 如果 e1 是带符号类型且是负值, 则
(e1 &gt;&gt; e2) 的值是实现定义.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(signed int signed_param)
{
    signed int signed_variable;
    int variable;
    signed int* ptr_signed_variable;

    signed_param &gt;&gt; 5;         // 违规
    signed_variable &gt;&gt; 5;      // 违规
    -variable &gt;&gt; 5;            // 违规
    -100 &gt;&gt; 5;                 // 违规
    -100u &gt;&gt; 5;                // 违规
    *ptr_signed_variable &gt;&gt; 5; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(unsigned int unsigned_param)
{
    unsigned int unsigned_variable;
    int variable;
    unsigned int* ptr_signed_variable;

    unsigned_param &gt;&gt; 5;         // OK
    unsigned_variable &gt;&gt; 5;      // OK
    (unsigned int)variable &gt;&gt; 5; // OK
    100 &gt;&gt; 5;                    // OK
    100u &gt;&gt; 5;                   // OK
    *ptr_signed_variable &gt;&gt; 5;   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.21 章节 Operators, AV 第 164.1 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-165</key>
<configkey>JSF-165</configkey>
<name><![CDATA[ 一元减法运算符不得适用于其原始类型是无符号型的表达式 [JSF-165] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一元减法运算符不得适用于其原始类型是无符号型的表达式 [JSF-165-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对无符号整型或者无符号长整型表达式
进行一元减法运算是没有意义的。
有时对一个小的无符号整型操作数进行一元
减法运算整形提升后会得到一个有意义的
整型值，但这并不是好的编程习惯。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止整型提升时产生不可预期的结果。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    unsigned char  ui1;
    signed short si2;
    si2 = -ui1;                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    unsigned char  ui1;
    signed short si2;
    si2 = -(signed short) ui1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C：2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra 指南 - 第39条规则

3. 联合攻击战斗机，飞行器，C++编码规范，
   第4.21章，飞行器第165条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，第5-3-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-166</key>
<configkey>JSF-166</configkey>
<name><![CDATA[ sizeof 操作符的参数不应该是含副作用的表达式 [JSF-166] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
sizeof 操作符的参数不应该是含副作用的表达式 [JSF-166-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在C语言编程中的一个可能错误是评估一个表达式和预期表达式 
的时候申请使用sizeof 操作符。 可是表达式
却无法被评估: sizeof只能作用于表达式类型。 
为了避免这类错误， sizeof 不能用于包含副作用的表达式。"
"这个操作引起的副作用是访问了不稳定的对象,
如修改一个对象, 修改一个文件, 或者调用一个函数这些
会导致调用函数执行环境变化的操作方法。"



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只能检测三层函数调用。


例外:

操作数形如 sizeof(i)  i 变量是允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止由 sizeof 引起的错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int glob;

int fun_with_se(){
    glob++; // side-effect
    return glob;
}

void foo1(int i){
    int j, k, l, m;
    j = sizeof(k = 2);         // 违规 - k is not set to 2
    l = sizeof(i++);           // 违规 - i is not incremented
    m = sizeof(fun_with_se()); // 违规 - glob is not incremented
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int fun_without_se(){
    // no side-effect
    return 1;
}

void foo1(int i){
    int j, k, l, m, n, o;
    volatile int vol;
    k = 2;
    j = sizeof(k);                // OK
    i++;
    l = sizeof(i);                // OK
    // examples of correct code
    m = sizeof(fun_without_se()); // OK
    n = sizeof(int);              // OK
    o = sizeof(vol);              // OK - volatile objects are permitted
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
    Chapter 6, Section 12

2. Origin: Misra Guidelines - Rule 40

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.21 Operators, AV Rule 166

4. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 5, Rule 5-3-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-167</key>
<configkey>JSF-167</configkey>
<name><![CDATA[ 整数除法操作语句之前必须有注释 [JSF-167] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整数除法操作语句之前必须有注释 [JSF-167-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在选定的编译器中
执行整数除法应该
明确地记录和考虑。
这条规则检查，在代码中凡是有一个
整数除法，那么代码的前一行必须要有注释。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防不预期的数据和准确度的流失 。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int i=2;
    int j=3;
    int k;

    k=j/i;  /* 违规 - 除法之前没有注释*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void boo() 
{
    int i=2;
    int j=3;
    int k;

/*  OK - 整数除法之前的注释 */    
    k=i/j;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 41 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 167 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-168_a</key>
<configkey>JSF-168_a</configkey>
<name><![CDATA[ 除了在 FOR 循环的控制表达式之外，不得使用逗号运算符 [JSF-168_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
除了在 FOR 循环的控制表达式之外，不得使用逗号运算符 [JSF-168_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了在循环的控制表达式中使用逗号运算符，
在其他的地方使用逗号运算符会不利于代码的可读性。
同样的效果可以通过其他的方式来实现。”
参见: misra2004-12_10



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

广泛的使用逗号运算符会降低代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1( int x, int y )
{
    int i;
    i = (x = 1, y = 0);            // 违规
    x++, y++;                      // 违规
    for (i = 0; i &lt; 10; i++){
        foo1( (x--, y + 2), y );   // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo2( int x, int y ) {
    int i;
    x++;
    y++;                                       // OK
    for (i = 0; i &gt;=0, i &lt; 10; i++)	{     // OK 
    }
    x--;
    foo2( y + 2, y );                      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 42 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 168 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-168_b</key>
<configkey>JSF-168_b</configkey>
<name><![CDATA[ 禁止使用逗号运算符 [JSF-168_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用逗号运算符 [JSF-168_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用逗号运算符会降低代码的可读性, 
可以通过其他方法实现逗号运算符的功能。”
参见 misra-042



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高代码的可读性和可维护性.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = 0, y = 0;           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = 0;
    y = 0;                 // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
   第6章，第12节

2. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，规则5-18-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-169</key>
<configkey>JSF-169</configkey>
<name><![CDATA[ 任何时候都应该避免使用指向指针的指针 [JSF-169] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
任何时候都应该避免使用指向指针的指针 [JSF-169-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则用于检测代码中是否存在指向指针的指针。
“任何时候都应该避免使用指向指针的指针。
通过提升代码的可读性，从而降低错误率。”


例外：

“该规则例外的情况是对于提供其他语言（如C语言）的接口的函数。 
这类接口函数的参数常常是预定义数据类型，这种情况下指向指针的指针
是需要用到的。另外一个例外是 main 函数的第二个参数，其类型一般为
 char*[]。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性，并提倡数据抽象。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int** a;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

相反， 声明一个有指针类型
成员变量的类。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#12">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#12</A>
   From: 12 Pointers and References - Rec. 48

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 169

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-17</key>
<configkey>JSF-17</configkey>
<name><![CDATA[ 禁止使用 errno 错误标识符 [JSF-17] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 errno 错误标识符 [JSF-17-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"errno是才的一部分，理论上是有用的，但是实际上
没有通过标准给予明确的定义的。非零值可能会或
不会表明一个出现了问题，因此它不得使用。即使
是那些该errno的行为明确界定的职能，最好先检查
调用函数，而不是依靠使用errno来捕获错误的投入的价值
如果errno指示符被用，文件含有以下头文件：errno.h, errno, cerrno.
本规则报出一个违规信息



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则防止不确定行为



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;errno.h&gt;

int err_check( ) {
    errno = 1;       /* 违规 */
    return (errno);  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用errno.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第119条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第17条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第19部分，第19-3-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-170_a</key>
<configkey>JSF-170_a</configkey>
<name><![CDATA[ 对象的声明中最多包含 2 级指针 [JSF-170_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明中最多包含 2 级指针 [JSF-170_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int * INTPTR;
struct s {
    int *** s3;                  /* 违规 */
};

struct s *** ps3;                /* 违规 */
int ** (***pfunc3)();            /* 违规 */
int *** ( **pfunc4)();           /* 违规 */
void function( int * par1,
    int *** par3,                /* 违规 */
    INTPTR * const * const par5  /* 违规 */
    )              
{
    int *** ptr3;                /* 违规 */
    INTPTR * const * const ptr5 = 0; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明超过两级的间接指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第170条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

4. 来源： Misra 指南 - 第102条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-170_b</key>
<configkey>JSF-170_b</configkey>
<name><![CDATA[ 对象的声明中最多包含 2 级指针 [JSF-170_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明中最多包含 2 级指针 [JSF-170_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* apInt[] ;
apInt* rule12;         /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明操过两级的间接指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第170条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

4. 来源： Misra 指南 - 第102条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-171</key>
<configkey>JSF-171</configkey>
<name><![CDATA[ 仅当指针指向同一个数组时才能使用 >, >=, <, <= [JSF-171] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
仅当指针指向同一个数组时才能使用 &gt;, &gt;=, &lt;, &lt;= [JSF-171-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

试图在指针之间做比较操作将会产生未定义的行为。


例外：

两个操作数都是相同类型并且指向同一数组。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对数组末尾的下一个元素的寻址是允许的，
但是访问这个元素是不允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此规则使得代码具有更高的可靠性，给人更少的困惑。”



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

在比较复杂的代码中，对指向同一数组的指针
使用比较操作，此规则可能不能正常工作。
因为在这样的情况下，此规则可能报告假错误。
例如：
void foo( ) {
    int a[10], i;
    int* p1,* p2,* p3,* p4,* p5;

    p1 = a; i = p1 &lt; a;    // 正常
    p2 = p1;i = p2 &lt; a;    // 正常
    p3 = p2;i = p3 &lt; a;    // 正常
    p4 = p3;i = p4 &lt; a;    // 违规 - 假错误
    p5 = p4;i = p5 &lt; a;    // 违规 - 假错误
}



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a[] ) {
    int* p1 = 0;
    int* p2;
    int* p3 = a;
    int i;

    i = p1 &lt; p2;   // 违规
    i = p2 &lt; a;    // 违规
    i = p3 &lt; a;    // 正常
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能对指向不同数组元素的指针做指针比较操作。




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第17部分

2. 来源: Misra 指南 - 第103条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.22章指针与引用, AV第171条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-18条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-173</key>
<configkey>JSF-173</configkey>
<name><![CDATA[ 带有自动存储空间的对象地址不能被分配给另一个对象，该对象销毁后，另一个对象仍然存在，但指针成为野指针 [JSF-173] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
带有自动存储空间的对象地址不能被分配给另一个对象，该对象销毁后，另一个对象仍然存在，但指针成为野指针 [JSF-173-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个局部变量的地址被赋值给另外一个大范围的
局部变量，或者一个静态变量，或者从一个函数中返回，
然后包含这个地址的变量的生存周期可能超过最初变量的
生存周期（它的地址变得无效）。
例如:
int * foo( void ) {
    int local_auto;
    return (&amp;local_auto);
}”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止数据的丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* global;
int* foo() {
    int iLocal;
    static int* siLocal;

    siLocal = &amp;iLocal;       // 违规
    global = &amp;iLocal;        // 违规
    return &amp;iLocal;          // 违规
}
void goo() {
    int* piLocal;
    {
        int iiLocal;
        piLocal = &amp;iiLocal;  // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要将局部变量的地址赋值给全局变量、静态变量或者函数的返回值。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第17部分

2. 来源: Misra 指南 - 第106条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第173条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-5-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-174_a</key>
<configkey>JSF-174_a</configkey>
<name><![CDATA[ 空指针不得解除引用 [JSF-174_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空指针不得解除引用 [JSF-174_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Where a function returns a pointer and that pointer is subsequently 
de-referenced, the program should first check that the pointer is not NULL."
If a control statement contains in condition non-dereferenced pointer, then 
the rule assumes that this pointer is checked. In such cases rule does not
report violations in spite of it does not check if a control statement is
really used to prevent null pointer dereference. 
参见: MISRA-107_b, BD-PB-NP



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Complying with this rule leads to safer code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* ret_ptr(int* p){
    return p;
}

void func(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    /* here pointer 'ptr' should be checked */
    i = *ptr;    /* Violation - pointer 'ptr' may be null */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int* ret_ptr(int* p){
    return p;
}

int check(int* p){
    if(p == 0)
        return 0;
    if(p &gt; 0)
        return 1;
}

void func1(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    if(ptr){
    	i = *ptr;    /* OK - pointer 'ptr' was checked in 'if' condition */
    }

}

void func2(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    if(!ptr){
        return;
    }
    i = *ptr;       /* OK - pointer 'ptr' was checked in 'if' condition */

}

void func3(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    if(check(ptr)){
    	i = *ptr;   /* OK - pointer 'ptr' was checked in 'check' function */
    }
}

void func4(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    if(ptr == 0){
        i = *ptr;    /* OK - pointer 'ptr' was checked in 'if' condition.
                        The 'if' condition is not correct, but the rule
                        does not check such cases. To detect this issue
                        could be used Bug Detectiv rule - BD-PB-NP */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines - Rule 107

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 174

3. <A HREF="http://cwe.mitre.org/data/definitions/476.html">http://cwe.mitre.org/data/definitions/476.html</A>

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-174_b</key>
<configkey>JSF-174_b</configkey>
<name><![CDATA[ 空指针不得解除引用 [JSF-174_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空指针不得解除引用 [JSF-174_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Where a function returns a pointer and that pointer is subsequently 
de-referenced, the program should first check that the pointer is not NULL."
If a control statement contains in condition non-dereferenced pointer, then 
the rule assumes that this pointer is checked. In such cases rule does not
report violations in spite of it does not check if a control statement is
really used to prevent null pointer dereference. 
参见: MISRA-107_a, BD-PB-NP



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Complying with this rule leads to safer code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S{
    int si;
};

struct S* ret_ptr(struct S* p){
    return p;
}

void func(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    /* here pointer 's' should be checked */
    s-&gt;si = i;    /* Violation - pointer 's' may be null */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S{
    int si;
};

struct S* ret_ptr(struct S* p){
    return p;
}

int check(struct S* p){
    if(p == 0)
        return 0;
    if(p &gt; 0)
        return 1;
}

void func1(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    if(s){
        s-&gt;si = i;    /* OK - pointer 's' was checked in 'if' condition */
    }

}

void func2(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    if(!s){
        return;
    }
    s-&gt;si = i;       /* OK - pointer 's' was checked in 'if' condition */

}

void func3(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    if(check(s)){
        s-&gt;si = i;   /* OK - pointer 's' was checked in 'check' function */
    }
}

void func4(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    if(s == 0){
        s-&gt;si = i;    /* OK - pointer 's' was checked in 'if' condition.
                         The 'if' condition is not correct, but the rule
                         does not check such cases. To detect this issue
                         could be used Bug Detectiv rule - BD-PB-NP */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines - Rule 107

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 174

3. <A HREF="http://cwe.mitre.org/data/definitions/476.html">http://cwe.mitre.org/data/definitions/476.html</A>

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-175</key>
<configkey>JSF-175</configkey>
<name><![CDATA[ 不允许指针与 NULL 比较或者将 NULL 赋值给指针； 请使用0替代 [JSF-175] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许指针与 NULL 比较或者将 NULL 赋值给指针； 请使用0替代 [JSF-175-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检查代码中是否存在指针与NULL比较或者将NULL赋值给指针的情况
“不允许指针与 NULL 比较或者将 NULL 赋值给指针； 请使用0替代”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

按照 ANSI-C 标准, NULL 定义为 (void*)0 或者 0.
若该定义在 ANSI-C++，则可能出现问题。
如果 NULL 被定义为类型 void*, 则没有显示类型转
换的情况下,不能赋给任意其他类型的指针。


事例：

#include &lt;stddef.h&gt;
void foo( ) {
    int *lp = NULL; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
void foo( ) {
    int *lp = 0; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 12 Pointers and References - Rule 42

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 175

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-176</key>
<configkey>JSF-176</configkey>
<name><![CDATA[ 使用typedef定义函数指针以使其更简洁 [JSF-176] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用typedef定义函数指针以使其更简洁 [JSF-176-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

”使用typedef定义函数指针以使其更简洁“



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

”使用typedef的另一个原因是增强代码可读性。
如果使用指向函数的指针， 易造成代码可读性差。
通过给函数指定类型声明可以避免此类情况。“


事例：

void (*p)();                 // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef void (*PTF)();

PTF p;              // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 12 Pointers and References - Rec. 49

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 176

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-177</key>
<configkey>JSF-177</configkey>
<name><![CDATA[ 不要使用用户自定义的转换函数 [JSF-177] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用用户自定义的转换函数 [JSF-177-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

小心使用用户自定义的转换函数。 如果找到用户自定义转换函数，该规则
将给出警告。这样的访问即便在最好的情况下也可能导致创建
和销毁临时对象， 影响运行， 同时最糟糕的情况是
运行无意义的代码被编译。 而后者，编译时能被检
测的问题被引入到运行时的测试阶段方能检测。
参见: CODSTA-CPP-04



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

一般而言该规则能改善运行时效率和可预见的程序
行为。编译器可能检测到严重的代码缺陷。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    operator const char*( ) const;  // 违规
};

void foo(){
	A a;
	const char* ch_ptr = a; // 隐式转换
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    const char* asPointerToConstChar( ) const; // OK
};

void foo(){
	A a;
	const char* ch_ptr = a.asPointerToConstChar(); // 显式转换
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   Chapter: "Operators", Item 5

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Class Design and Inheritance", Rule 40

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 177

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-178</key>
<configkey>JSF-178</configkey>
<name><![CDATA[ 避免继承层次结构向下的类型转换 [JSF-178] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免继承层次结构向下的类型转换 [JSF-178-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免对继承的层次结构进行向下类型转换。
本规则检查出从基类型指针到子类型指针的类型转换。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

允许继承的层次结构向下的类型转换会造成维护性方面
的问题，并且对基类型进行的下向类型转化是非法的。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {};
class Derived: public Base {};
class Derived2: public Derived {};

void foo() {
    Base *pb;
    Derived *pd = (Derived *) pb;       // Violation

    Base *pb2;
    Derived *pd2 = (Derived2 *) pb2;    // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {};
void foo() {
    Base *pb0;
    Base *pd0 = (Base *) pb0;           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
   章节：“继承与面向对象的设计”，第39项

2.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.23章 类型转换，AV规则第178条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-179</key>
<configkey>JSF-179</configkey>
<name><![CDATA[ 指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针 [JSF-179] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针 [JSF-179-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“由于继承的虚拟性不属于其基类型，
因此其衍生类对象的规划，通过虚拟基
类型的指针，在编译时是未知的。”
“采用除dynamic_cast外的其它方式进
行从虚拟基类型到衍生类的类型转换会
引起未定义的行为。”
参见：OOP-29，OOP-49



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止未定义行为的发生。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// The code is not compilable with all compilers
class B { 
public:
	virtual int foo();
};
class D: public virtual B {
public:
	virtual int foo(){}
};
void fun(){
    D d;
    B *pB = &amp;d;
    D *pD = static_cast&lt;D*&gt;(pB);  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B { 
public:
	virtual int foo();
};
class D: public virtual B {
public:
	virtual int foo(){}
};
void fun(){
    D d;
    B *pB = &amp;d;
    D *pD = dynamic_cast&lt;D*&gt;(pB);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.23章 类型转换，AV规则第179条

2.MISRA C++:2008 - 在关键系统中使用C++语言的准则
  第6章，第5节，第5-2-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-18</key>
<configkey>JSF-18</configkey>
<name><![CDATA[ 禁止使用库文件 stddef.h 中的宏 offsetof [JSF-18] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用库文件 stddef.h 中的宏 offsetof [JSF-18-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当操作数类型不兼容或位字段时使用的时候，
使用这个宏可能导致一些难以确定的行为，”
当宏offsetof被使用或者文件中包含以下任何一个头文件：
stddef.h, stddef, or cstddef.
本规则将会报出违规信息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则预防不确定行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规- The macro offsetof shall not be used. Macro is in line: [10]
#include &lt;stddef.h&gt;

struct S {
    int x, y, z;
    char buffer[ 128 ];
};

int main( ) {
    int i = offsetof( struct S, buffer );
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 offsetof.


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第120条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第18条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-180_a</key>
<configkey>JSF-180_a</configkey>
<name><![CDATA[ 不得使用会导致信息丢失的隐式类型转换 [JSF-180_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用会导致信息丢失的隐式类型转换 [JSF-180_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"C performs many type conversions implicitly and silently, so as to harmonize
types within an expression before evaluating it. Some of these conversions can
result in loss of information. Such implicit conversions shall not be used,
but explicit casts should be used instead."
The rule reports a violation if a parameter/variable/expression of integral
or floating type is implicitly cast to a narrower type.
参见: MISRA2004-10_1_b, MISRA2004-10_2, PORT-27, PORT-28



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule assumes the following order of sizes:
char &lt; short &lt; int &lt; long &lt; long long
float &lt; double &lt; long double
The rule assumes that the size of enumeration type is the same as int type.


例外:

The rule does not report violation if a conversion is used:
- on a constant expression
- between integral and floating type
- between signed and unsigned type
- on a bit field



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"Explicit casts should normally only be used in the case where a conversion 
which could result in a loss of information is specifically required by the 
programmer. If the static checking of implicit conversions is overridden by
the use of explicit casts in this way, then the programmer should be aware
of the issues of truncation and lost of precision associated with the operation,
and should provide appropriate checking of values in the code"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void bar(unsigned char c);

void foo(unsigned int ui, double d)
{
    float f;
    unsigned short us1;
    unsigned short us2 = ui; /* 违规 */
    us1 = us2 + us2;         /* 违规 - due to integral promotion */
    f = d;                   /* 违规 */
    bar(ui);                 /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>


void bar(unsigned char c);

void foo(unsigned int ui, double d)
{
    float f;
    unsigned short us = (unsigned short)ui; /* OK */
    f = (float)d;                           /* OK */
    bar((unsigned char)ui);                 /* OK */
}

/* exceptions */

void except(unsigned int ui){
    unsigned char uc = 300;   /* OK - constant expression */
    int i = ui;               /* OK - only signed/unsigned conversion */
    float f = ui;             /* OK - integral/floating conversion */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines rule 43

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 180

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-180_c</key>
<configkey>JSF-180_c</configkey>
<name><![CDATA[ 避免隐式的整型和浮点类型的转换 [JSF-180_c] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的整型和浮点类型的转换 [JSF-180_c-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
该规则检查是否使用了整型和浮点类型之间的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    float f32a;
    unsigned int u32a;

    f32a = u32a;                /* Violation */
    f32a = f32a + u32a;         /* Violation */
    f32a = u32a + 2.5f;         /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    float f32a;
    unsigned int u32a;

    f32a = (float)u32a;         /* OK */
    f32a = f32a + (float)u32a;  /* OK */
    f32a = (float)u32a + 2.5f;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-5条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-180_d</key>
<configkey>JSF-180_d</configkey>
<name><![CDATA[ 避免隐式的复合表达式的数据类型转换 [JSF-180_d] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的复合表达式的数据类型转换 [JSF-180_d-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
“限制复杂表达式的隐性转换的目的
是要求在一个表达式里的一系列算术运算里，
所有的运算需要按照相同的算术类型来执行。
注意这并不意味着该表达式里所有的操作数都是
相同的数据类型。
表达式u32a + u16b + u16c是合乎要求的-两个加法运算将理论上
按照U32类型来执行。
表达式u16a + u16b + u32c是不合乎要求的-第一次加法运算
理论上是按照U16类型执行的而第二次运算则是U32类型。
这里使用措辞“理论上的”是因为，算术运算执行时所使用的类型
依赖于该系统中整型类型的实际长度。
该规则检查是否使用了复杂表达式的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = u16b + u16a + u32b;          /* Violation */
    u32a = u32b + (u16a + u16b);        /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = u32b + u16b + u16a;          /* OK */
    u32a = u16b + (u16a + u32b);        /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-3条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-180_e</key>
<configkey>JSF-180_e</configkey>
<name><![CDATA[ 避免隐式的从宽类型到窄类型的转换 [JSF-180_e] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的从宽类型到窄类型的转换 [JSF-180_e-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值不能隐式转换
为不同的基本类型。
术语underlying type（基本类型）是指可以从表达式
的运算中获得的运算类型，并且是该表达式
不经过整型提升。
整型提升描述了一个依靠算术运算对（有符号或无符号）
int或long整型操作数进行操作的过程。
其他整型操作数（如：char, short, bit-field 和 enum）
通常在算术运算前转换为int或无符号int类型。
整数常量表达式的基础类型
会根据它的大小和正负决定。”
规则检测是否存在长宽类型向窄类型隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果所有的操作都由一致的潜在类型
执行，可以避免程序员的困惑
和关于整型提升的危险。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned char u8a;
    unsigned short u16a;
    unsigned int u32a;

    u16a = u32a;        /* 违规*/
    u8a  = u32a;        /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned char u8a;
    unsigned short u16a;
    unsigned int u32a;

    u16a = (unsigned short)u32a;       /* OK */
    u8a  = (unsigned char)u32a;        /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004C语言在关键系统的使用指南 
    第 6 章，第 10 节

2. MISRA-C++: 2008C++语言在关键系统的使用指南 
    第 6 章，第 5 节，第 5-0-6 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-180_f</key>
<configkey>JSF-180_f</configkey>
<name><![CDATA[ 避免隐式的函数返回表达式类型转换 [JSF-180_f] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的函数返回表达式类型转换 [JSF-180_f-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果一个整型表达式不是constant型，
并且是一个返回表达式，
这个整型表达式的值不能隐式转换成不同的基础类型。
基本类型是指可以
从表达式的运算中获得的运算类型，并且是该表达式
不经过整形提升。
整型提升描述了一个
常常依靠算术运算对（无符号或有符号）int或long整型操作数进行操作的过程。
其他整型操作数（如：char, short, bit-field 和 enum）
通常在算术运算前转换为int或无符号int类型。
规则检测函数返回表达式中是否使用了隐式转换。




</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned int Conv_ret1( signed char a )
{
    return a;                            /*  违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned int Conv_ret1( signed char a )
{
    return (unsigned int)a;              /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004 C语言在关键系统中的使用指南 
   第6章，第10节

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-180_h</key>
<configkey>JSF-180_h</configkey>
<name><![CDATA[ 避免隐式的函数实参类型转换 [JSF-180_h] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的函数实参类型转换 [JSF-180_h-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值在该表达式不是常数
并且是一个函数参数时，不应该被隐式转换为
不同的基础类型。
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不
经过整形提升。
整型提升描述了一个常常
依靠算术运算对（无符号或有符号）int或long整型操作数进行操作的过程。
其他整型操作数（如：char, short, bit-field 和 enum）
通常在算术运算前转换为int或无符号int类型。”
规则检测是否存在函数参数的隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

    void takes_signed_double(double);
    void takes_unsigned_int(unsigned int);
    void takes_signed_int(signed int);

    void foo(signed int si, unsigned int ui) {
        unsigned char uc;
        takes_signed_double(si);    /*  违规*/ 
        takes_unsigned_int(uc);     /*违规*/
        takes_signed_int(ui);       /* 违规*/
    }



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

    void takes_signed_double(double);
    void takes_unsigned_int(unsigned int);
    void takes_signed_int(signed int);

    void foo(signed int si, unsigned int ui) {
        unsigned char uc;
        takes_signed_double((double) si);       /* OK */
        takes_unsigned_int(ui);                 /* OK */
        takes_signed_int((int) ui);             /* OK */
    }



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004C语言在关键系统中的使用指南  
    第6章，第10节

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-181_a</key>
<configkey>JSF-181_a</configkey>
<name><![CDATA[ 不允许冗余显式转换为同一类型 [JSF-181_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许冗余显式转换为同一类型 [JSF-181_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Explicit casting between identical types is unnecessary and clutters code.
Furthermore it can mask problems if changes are made to the code (e.g. one of 
the types changes and a conversion with possible loss of information occurs)"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"The use of casting should be sufficient to cause the calculations required 
to occur with the desired precision. Unnecessary casting adds the possibility
of confusion, and may be such that its interaction with the rules of promotion
leads to results other than those expected. Unnecessary casting may also lead
to code which is harder to maintain, should the types of variables change."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int INT;

int someFunction1();
INT someFunction2();

void foo(int p)
{
    /* ... */
    p = (int)someFunction1();  // 违规
    p = (int)someFunction2();  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int INT;

int someFunction1();
INT someFunction2();

void foo(int p)
{
    /* ... */
    p = someFunction1();  // OK
    p = someFunction2();  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines - Rule 44

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.5 Libraries, AV Rule 181

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-181_b</key>
<configkey>JSF-181_b</configkey>
<name><![CDATA[ 避免不不必要的从继承类到基类的显式类型转换 [JSF-181_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免不不必要的从继承类到基类的显式类型转换 [JSF-181_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免不不必要的从继承类到基类的显式类型转换。
本规则将检查你的代码是否有不必要的类型转换。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

显式地进行到基类型的类型的向上强制转换是不必
要的。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base { /* ... */ };
class Derived : public Base { /* ... */ };
void Func() {
   Derived *d = new Derived();
   Base *b = (Base *)d;		// Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base { /* ... */ };
class Derived : public Base { /* ... */ };
void Func() {
   Derived *d = new Derived();
   Base *b = d;			// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
第4.23章 类型转换，AV规则第181条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-182_a</key>
<configkey>JSF-182_a</configkey>
<name><![CDATA[ 不允许指针类型和整数类型之间进行类型转换 [JSF-182_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许指针类型和整数类型之间进行类型转换 [JSF-182_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“将指针转换成指向整形的指针时，需要定义整型大小，此数值由实现方式决定。
指针和整数类型之间的强制转换应尽可能避免，
但有时寻址内存映射寄存器或其他硬件特定性能可能不可避免。”


例外：

规则允许强制转换成UINT_PTR或者INT_PTR类型。
这些类型是整数类型，分别给32位和64位Windows指针扩展大小。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止未定义或由实现方式定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int* pi;
    int i;
    i = (int) pi;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能把指针强制转换成非指针。




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

2. Misra指南第45条规则

3. Ellemtel编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3</A>
   出自：18可移植代码-18.3类型转换- Port. Rec. 7

4. <A HREF="http://msdn2.microsoft.com/en-gb/library/aa489560.aspx">http://msdn2.microsoft.com/en-gb/library/aa489560.aspx</A>

5. <A HREF="http://www.codeproject.com/system/64BitOSAndPortingIssues.asp">http://www.codeproject.com/system/64BitOSAndPortingIssues.asp</A>

6. 联合攻击战斗机，飞行器，C++编码规范
    4.24章节流量控制结构，飞行器第128条规则

7. MISRA C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-2-9条规则

8. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-182_b</key>
<configkey>JSF-182_b</configkey>
<name><![CDATA[ 禁止将其它类型变量强制转换成指针变量 [JSF-182_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止将其它类型变量强制转换成指针变量 [JSF-182_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

整数类型不能强制转换成指针。
当一个任意的整型转换成指针时可能出现问题。


例外：

规则允许整型常量0强制转换成指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义或由实现方式定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int* pi;
    int i;
    pi = (int*)i;    // 违规
}


修复 ：

不能把非指针强制转换成指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源：Misra指南45规则

2. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

3. 联合攻击战斗机，飞行器，C++编码规范
    4.24章节流量控制结构，飞行器第182条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-183</key>
<configkey>JSF-183</configkey>
<name><![CDATA[ 不要使用显示类型转换（强制） [JSF-183] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用显示类型转换（强制） [JSF-183-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

”不要使用显示类型转换（强制）。“



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则只针对基本类型。


例外：

显示类型转换可能被用于将指针转化为一个指向
继承类的基类指针。
将匿名比特流(bit-stream)转化为一个对象时，必须使用
显示类型转换。
一般地，当读取一个外部的对象时需要用到
显示类型转换。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范使得代码更清晰，增强代码可维护性。


事例：

void foo( ) {
    const int ci = 0;
    int i;
    i = (int) ci;    // 违规
    i = (int) &amp;i;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不使用强制类型转换



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 13 Type Conversions - Rule 43

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 183

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-184_a</key>
<configkey>JSF-184_a</configkey>
<name><![CDATA[ 避免隐式的浮点类型转换，防止数据丢失 [JSF-184_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的浮点类型转换，防止数据丢失 [JSF-184_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型表达式的值不应当隐式转换
为不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef float float32_t;

void goo_float( ) {
    double f64a;
    float f32a;

    float32_t f32bt = f64a;      // 违规
    unsigned int u32a = f32a;    // 违规
    unsigned short u16a = 1.0;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef float float32_t;

void goo_float( ) {
    double f64a;
    float f32a;

    float32_t f32bt = (float)f64a;             // OK
    unsigned int u32a = (unsigned int)f32a;    // OK
    unsigned short u16a = (unsigned short)1.0; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1．MISRA-C:2004 C语言在关键系统中的使用指南

2．联合攻击战斗机，飞行器，C++编码规范 
     4.23章节 类型转换， 飞行器第184条规则

3．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-5条规则

4．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-184_b</key>
<configkey>JSF-184_b</configkey>
<name><![CDATA[ 避免隐式的浮点类型转换，防止数据丢失 [JSF-184_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的浮点类型转换，防止数据丢失 [JSF-184_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型的表达式的值不应当被隐式转换
为一个不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = f32a;                // 违规
    s32b = f32a;                // 违规
    f32a = f64a;                // 违规
    f64a = f32b + f32a + f64b;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = (unsigned int)f32a;  // OK
    s32b = (signed int)f32a;    // OK
    f32a = (float)f64b;         // OK
    f64a = f64b + f32b + f32a;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004 C语言在关键系统中的使用指南

2. 联合攻击战斗机，飞行器，C++编码规范 
    4.23章节 类型转换， 飞行器第184条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-5条规则

4.MISRA-C++:  2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-185</key>
<configkey>JSF-185</configkey>
<name><![CDATA[ 倾向于使用 C++ 风格的转换 [JSF-185] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
倾向于使用 C++ 风格的转换 [JSF-185-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查代码中的c风格转换.
"c风格转换的语义依赖于上下文, 
隐藏在单一的符号之后。" 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

c++风格转换比c风格转换更加明确 
并且更加易于定位和阅读.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {
public:
    Base( );
    virtual ~Base( );
};

class Derived : public Base {
public:
    Derived( );
    ~Derived( );
};

void foo( ) {
    Base *pB;
    Derived *pD2 = (Derived *) pB;     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    Base( );
    virtual ~Base( );
};

class Derived : public Base {
public:
    Derived( );
    ~Derived( );
};

void foo( ) {
    Base *pB;
    Derived *pD1 = dynamic_cast&lt;Derived*&gt;( pB );   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   Chapter: "Basics", Item 2

2. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Type Safety", Rule 95

3. 联合攻击战斗机, 飞行器, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 185

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-186_a</key>
<configkey>JSF-186_a</configkey>
<name><![CDATA[ 在 "else" 语句块中不应存在不可达代码 [JSF-186_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 "else" 语句块中不应存在不可达代码 [JSF-186_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在else语句中不应该有覆盖不到的语句。
“这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的。”
参考：
MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_d, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
    if(a == a){
        a = a + b;
    }
    else{               // Violation
        a = a - b;
    }                     
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
    if(a == 3){
        a = a + b;
    }
    else{               // OK
        a = a - b;
    }                     
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南 - 第 52条规则

3.联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构章节, AV 第 186条规范

4.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第0-1-1规则
 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-186_b</key>
<configkey>JSF-186_b</configkey>
<name><![CDATA[ 在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在不可达代码 [JSF-186_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在不可达代码 [JSF-186_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。能够覆盖到但是从不执行的代码
将从这条规则中排出（例如，防御性编程代码）
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在return','break', 'continue'和 'goto' 语句后有覆盖不到的语句.
参见:MISRA2004-14_1_a, MISRA2004-14_1_c, MISRA2004-14_1_d, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo();
int myFunction(int i, int j)
{
    switch(i)
    {
        case 1:
            j = 5;
            break;    // Violation
            foo();
        case 2:
            j = 3;
            return j; // Violation
            foo();
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo();
int myFunction(int i, int j)
{
    switch(i)
    {
        case 1:
            j = 5;
            break;    // OK
        case 2:
            j = 3;
            return j; // OK
    }
    foo();
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6,章节, 第 14部分

2. 来源: Misra 指南 - 第 52条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV 第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章节, 第0部分, 第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-186_c</key>
<configkey>JSF-186_c</configkey>
<name><![CDATA[ 在 "if/else/while/for" 语句块中不应存在不可达代码 [JSF-186_c] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 "if/else/while/for" 语句块中不应存在不可达代码 [JSF-186_c-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在if/while/for/else块中如果一个条件值不变而出现无用代码.
参见:MISRA2004-14_1组规则 and MISRA2004-13_7组规则



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

vo7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助防止无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int unreachable_code = 1;
    if(0)                         // Violation
    { 
        unreachable_code = 2; 
    }                 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不得有不可达代码



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分
   
2. 来源: Misra 指南- 第52条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制结构章节,AV第186条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节, 第0部分,第 0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-186_d</key>
<configkey>JSF-186_d</configkey>
<name><![CDATA[ 在 Switch 语句中不应存在不可达代码 [JSF-186_d] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 Switch 语句中不应存在不可达代码 [JSF-186_d-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在"switch"语句中不应该有覆盖不到的代码.
这条规则预防语句、表达式被放置在case和default块外面.
"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在if/while/for/else块中如果一个条件值不变而出现无用代码.
参见:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i ) {
    switch (i) {    // Violation
        i = 0;
    case 1:
        i = 1;
        break;
    default:
        i = 2;
        break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i ) {
    switch (i) {    // OK
    case 0:
        i = 0;
        break;
    case 1:
        i = 1;
        break;
    default:
     	i = 2;
        break;
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-186_e</key>
<configkey>JSF-186_e</configkey>
<name><![CDATA[ 在 'for' 循环中不应存在不可达代码 [JSF-186_e] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'for' 循环中不应存在不可达代码 [JSF-186_e-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。能够覆盖到但是从不执行的代码
将从这条规则中排出（例如，防御性编程代码）。一部分代码
如果没有控制流路径从相关的输入点进入是覆盖不到的。"
如果一个 'for' 循环在条件中包含单关系表达式
'VAR &lt; FB',  'VAR &lt;= FB', 'FB  &gt; VAR', 'FB &gt;= VAR'
并且其结果始终是 false 时，报告一个违规， 这里 FB 是
一个常量或一个 const 变量，而 VAR 是一个在 for 初始化语句中复制的变量。
如果一个 for 条件的结果始终是 false 那么循环体将不会被执行。
参见:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c,
MISRA2004-14_1_d, MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i, int j ) 
{
    for ( i = 0; i &lt; 0; i++ )  // Violation
    {
      j = 1; 
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i, int j ) 
{
    for ( i = 0; i &lt; 5; i++ )  // OK
    {
      j = 1; 
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分
  
2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-186_f</key>
<configkey>JSF-186_f</configkey>
<name><![CDATA[ 在 'if' 或 'switch' 语句之后不应存在不可达代码 [JSF-186_f] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'if' 或 'switch' 语句之后不应存在不可达代码 [JSF-186_f-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码.
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
如果出现下面的情况这条规则就会报错：
-'if/else' 结构中每条分支都没有'return'语句
-'switch'结构中每个'case'分支和'default'中都没有'return'语句
参考：MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_d,
MISRA2004-14_1_e, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1( int c ) {
    if ( c &gt; 2 ) {    // Violation
        return 0;
    } else {
        return 1;
    }
    return c;         // 不可达代码
}

int foo2( int i ) {
    switch(i){        // 违规
    case 1:
        i++;
        return 0;
    case 2:
        i = i + 2;
        return 1;
    default:
        return 2;
    }
    return i;         // 不可达代码
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1( int c ) {
    if ( c &gt; 2 ) {    // OK
        return 0;
    } else {
        return c;
    }
}

int foo2( int i ) {
    switch(i){        // OK
    case 1:
        i++;
        return 0;
    case 2:
        i = i + 2;
        return 1;
    default:
        return i;
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
     第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24 控制流结构章节, AV 第186条规则

3. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-186_g</key>
<configkey>JSF-186_g</configkey>
<name><![CDATA[ 在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在不可达代码 [JSF-186_g] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在不可达代码 [JSF-186_g-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码.
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
如果出现下面的情况这条规则就会报错:
-在'if/else'结构中每条分支都没有'break', 'continue' or 'return'
-switch结构中每条'case'和'default'中都没有 'return' 
参考:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c,
          MISRA2004-14_1_d, MISRA2004-14_1_e, MISRA2004-14_1_f



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int c ) {
    while ( c &gt; 1 ) {
        if ( c &gt; 2 ) {    // Violation
            continue;
        } else {
            break;
        }
        c++;              // 不可达代码
    }

    for (int i = 0; i &gt; 1; i++ ) {
        switch(i){        // 违规
        case 1:
            i++;
            return i;
        case 2:
            i = i + 2;
            return i;
        default:
            return i;
        }
        c++;              // 不可达代码
    }
    return c;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int c ) {
    while ( c &gt; 1 ) {
        c++;
        if ( c &gt; 2 ) {    // OK
            continue;
        } else {
            break;
        }
    }

    for (int i = 0; i &gt; 1; i++ ) {
        c++;
        switch(i){        // OK
        case 1:
            i++;
            return i;
        case 2:
            i = i + 2;
            return i;
        default:
            return i;
        }
    }
    return c;
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24 控制流结构章节, AV 第186条规则

3. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-187</key>
<configkey>JSF-187</configkey>
<name><![CDATA[ 所有非 null 语句应该至少有一个执行或者导致控制流变化的副作用 [JSF-187] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有非 null 语句应该至少有一个执行或者导致控制流变化的副作用 [JSF-187-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"任何 (除了空语句以外) 没有副作用而且不会
对导致控制流变化的语句通常表示一个编程错误，
因此对这类语句应该执行静态检查。" 

ISO/IEC 9899:1999标准中,副作用是这样定义的:访问某个可变对象,
修改某个对象,修改某个文件或者调用包含上述任一操作的函数都是副
作用.副作用即是那些在执行中的发生的变化.

Null语句定义为:只含有一个分号的语句.
如果检测到不带副作用的非空语句,就会报告违规.
比如,某个表达式的估算结果未被使用,原因是程序员忘记使用赋值
符来保存该值,或者他不小心把"="写成了"==".此语句会被认
为没有副作用.这样的编程错误具有潜在的危害性。

如果检测到空的块语句,也会报告违规,因为这样的语句也不会带有副作用.
空函数体并不违反此条规则,因为本规则把所有函数调用看作是带有副作用的,即使
函数调用没有改变任何变量的值.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
 
空的函数体并不被这条规则视为违规。 
就这条规则的目的而言，任何函数调用都被认为 
有副作用，即使作为这个函数调用的结果， 
没有任何变量被修改
这条规则不对空块报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

符合此规则会使代码更安全和可读.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct tagStruct {
    int _iField;
    char * _p;
};

int bar( );

void foo( ) {
    int i = 0;
    struct tagStruct s, *ps;
    /* Examples of incorrect code - no side effects: */
    i + 3;                    /* Violation - result not used */
    3;                        /* Violation - result not used */
    i;                        /* Violation - result not used */
    i + bar();                /* Violation - result not used */
    ps-&gt;_p + s._iField;       /* Violation - result not used */
    ps-&gt;_iField &lt;&lt; s._iField; /* Violation - result not used */
    *(ps-&gt;_p);                /* Violation - result not used */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct tagStruct{
    int _iField;
    char * _p;
};

volatile struct tagStruct volStr;

int bar( );

void foo( ) {
    int i = 0;
    volatile int j = 0;
    struct tagStruct s, *ps;

    /* Examples of correct code - with side effects: */
    i = i + 3;               /* OK - assignment */
    i &lt;&lt;= 3;                 /* OK - assignment */
    bar();                   /* OK - function call */
    j;                       /* OK - volatile variable */
    volStr._p;               /* OK - volatile variable */
    if(ps-&gt;_iField){}        /* OK - cause control flow to change */

    ;                        /* OK - null statement */
    {}                       /* OK - empty block */
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南-第53条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.24 章节控制流结构, AV第 187条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-188</key>
<configkey>JSF-188</configkey>
<name><![CDATA[ 避免使用标签 [JSF-188] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用标签 [JSF-188-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要在 switch 语句以外使用标签



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用标签可能会导致错误和混乱



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int count) 
{
    /* ... */
    goto stop_operation;
    /* ... */
    stop_operation: return; /* 违规 */
    /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在 switch 语句以外使用标签



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 55 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.24 章 Flow Control Structures， AV 第 188 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-189</key>
<configkey>JSF-189</configkey>
<name><![CDATA[ 不要使用 goto 语句 [JSF-189] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 goto 语句 [JSF-189-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用goto语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

goto语句会导致错误和混乱.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int a ) {
    if (a &lt; 0) {     
        goto end;       /* 违规 */
    } 
    a = foo(a-1);
end:
    return a+1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int a ) {
    /* Code was changed and does not use goto anymore */
    if (a &gt;= 0) {
        a = foo(a-1);
    }
    return a+1;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   出自: 第14章节控制流结构  -第49规则 

3.Misra 指南 - 第 56条规则

4. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构, AV 第 189规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

6. HIS Source Code Metriken, version 1.3.1
   Metrik "GOTO"

7. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-19</key>
<configkey>JSF-19</configkey>
<name><![CDATA[ 不要使用 locale.h 头文件和 setlocale 函数 [JSF-19] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 locale.h 头文件和 setlocale 函数 [JSF-19-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用 &lt;locale.h&gt; 和 setlocale 函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用者把标准 C locate 修改为 locate。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;locale.h&gt;
void foo(void)
{
  /* Set the locale back to the default environment */
  setlocale(LC_ALL, "C");  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 'setlocale' 函数。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 121 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.5 章 Libraries， AV 第 19 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-190</key>
<configkey>JSF-190</configkey>
<name><![CDATA[ 不要使用 continue 语句 [JSF-190] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 continue 语句 [JSF-190-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免使用continue.continue用来跳出循环.
但是，如果用其他语句代替（continue）代码更容易读懂.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用continue导致错误和混乱.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int bar( int );
void foo( int i ) {
    while (i--) {
        if (bar( i )) {
            continue;     /* Violation */
        }
        i /= 2;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int bar( int );
void foo( int i ) {
    while (i--) {
        if (bar( i )) {
            /* OK - code was changed and does not use continue anymore */
        } else {
            i /= 2;
        }
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rec. 53

3. 来源: Misra 指南- 第57条规则

4. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24控制流结构,AV 第190条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-191</key>
<configkey>JSF-191</configkey>
<name><![CDATA[ 避免在非 switch 中使用 break 语句 [JSF-191] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在非 switch 中使用 break 语句 [JSF-191-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可使用 break 语句
(除了终止 switch 语句的 cases 以外)。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用 'break' 可能导致错误和混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define true 1
void foo(int i)
{
  while (true) 
  {
    if (i==10) 
    {
      break; /* 违规 */
    }        
  }
    
  switch( i ) 
  {
    case -1:
    while (true) 
    {
      if (i==10) 
      {
        break; /* 违规 */
      }        
    }        
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define true 1
void foo(int i)
{
  switch( i ) 
  {
    case -1 :
    break; /* OK */
                
    case 0 :
    break; /* OK */
                
    default:
    break; /* OK */
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 58 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.24 章 Flow Control Structures， AV 第 191 条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-192</key>
<configkey>JSF-192</configkey>
<name><![CDATA[ 所有的 'if...else-if' 结构中应该由 'else' 分支结束 [JSF-192] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的 'if...else-if' 结构中应该由 'else' 分支结束 [JSF-192-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则适用于任何一个 'if' 语句是否都由一个或多个
'else-if' 语句结尾； 最后的 'else-if' 应该紧跟着一个 'else'
语句。 在一个简单的 'if' 语句中，那么应该包括 'else' 
语句。
对最后 'else' 语句的需求是防御性的编程。 
其中 'else' 语句应该要么有合适的操作或包含
一个为什么没有操作合理的注释。"
参见: CODSTA-23



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

确保合适的数据流、提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a)
{
    if(a &gt; 0)
    {
    }
    else if (a &gt; 10)   // Violation
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a)
{
    if(a &gt; 0)
    {
    }
    else if (a &gt; 10)   // OK
    {
    }
    else
    {
        // comment or action
    }
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南 - 第 60条规则

3.联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构章节, AV 第 192条规范

4.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第6部分,第6-4-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-193</key>
<configkey>JSF-193</configkey>
<name><![CDATA[ 必须以 break 作为 switch 每个子句的结束语句 [JSF-193] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
必须以 break 作为 switch 每个子句的结束语句 [JSF-193-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个switch分句的最后一句应该是break语句，
或者如果switch分句是复合语句，那么这个
复合语句的最后一句应该是break语句。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本条规则允许使用return替代break语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不可预测的程序行为.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 违规
            i = 4;
            break;
            i++;
        case 1 :         // 违规
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
        case 2 :         // 违规
            {
                i = 3;
            }
        default:         // 违规
            i = 8;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 通过
            i = 4;
            i++;
            break;
        case 1 :         // 通过
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
            break;
        case 2 :         // 通过
            {
                i = 3;
                break;
            }
        case 3 :         // 通过 - 空case语句
        default:         // 通过
            i = 8;
            break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第15部分

2. Misra 指南 - 第61条规则

3. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rule 47

4. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.24章流量控制结构， AV 第193条规则
   

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-194</key>
<configkey>JSF-194</configkey>
<name><![CDATA[ 为 switch 语句提供 default 分支 [JSF-194] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
为 switch 语句提供 default 分支 [JSF-194-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“为 switch 语句提供 default 分支 
用于处理异常情况。”
该规则检测是否为 switch 语句提供默认
分支。 如果所有预期的情况在其他分支中
处理，则 default 分支能用于错误检查。
参见： MISRA2004-15_3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防错误发生的可能性。


事例：

void foo( ) {
    int tag;
    switch ( tag ) {	// 违规
    case 0: {
        break;
            }
    case 1: {
        foo( );
        break;
            }
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int tag;
    switch ( tag ) {	// OK
    case 0: {
        break;
            }
    case 1: {
        foo( );
        break;
            }
    default: break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rule 48

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.24 Flow Control Structures, AV Rule 194

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-195</key>
<configkey>JSF-195</configkey>
<name><![CDATA[ switch 的表达式中不能出现有效的布尔类型值 [JSF-195] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 的表达式中不能出现有效的布尔类型值 [JSF-195-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

switch条件中不能出现有效的布尔类型值。
本规则禁止使用以下产生布尔类型值的运算符：
a) 等号运算符 (== and !=)
b) 逻辑运算符 (!, &amp;&amp; and ||)
c) 关系运算符 (&lt;, &gt;, &lt;= and &gt;=)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则可以阻止在switch条件中使用布尔数值.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i)
{
    switch(i == 0)           // 违规
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(int i) 
{
    switch(i)                   //通过
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章，第15部分

2. 来源: Misra 指南—第63条规则

3. 联合攻击战斗机, 飞行器
   第4.24章Chapter 4.24 Flow Control Structures, AV 第195条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-196</key>
<configkey>JSF-196</configkey>
<name><![CDATA[ 每个 switch 语句至少有两个 case 分支和一个 default 分支 [JSF-196] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每个 switch 语句至少有两个 case 分支和一个 default 分支 [JSF-196-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个 switch 语句至少有两个 case 分支和一个 default 分支。
参见： CODSTA-41, MISRA2004-15_5



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

void foo(int i) 
{
    switch(i)      // 违规
    {
        default:
            ;
    }
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

更自然表示法。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      // OK
    {
      case 1:
      	break;
      case 2:
      	break;
      default:
            ;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.24 Flow Control Structures, AV Rule 196

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-197</key>
<configkey>JSF-197</configkey>
<name><![CDATA[ 不得使用浮点变量作为循环计数器 [JSF-197] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用浮点变量作为循环计数器 [JSF-197-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

浮点变量不得用作循环计数器



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止变量判断时的意外的结果



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
  float i;
  for (i=0.;i&lt;10.;i++)  /* 违规 */
  { 
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
  int i;
  for (i=0;i&lt;10;i++) /* OK */
  {  
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 65 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.24 章 Flow Control Structures， AV 第 197 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-198</key>
<configkey>JSF-198</configkey>
<name><![CDATA[ 在 for 循环中的除了初始化参数值，不应该执行其他动作。 [JSF-198] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 for 循环中的除了初始化参数值，不应该执行其他动作。 [JSF-198-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在 for 循环中的除了初始化参数值，
不应该执行其他动作。
注意初始化表达式可能调用一个存储器，
该存储器将返回一个序列中的值用于初始化:
for (Iter_type p = c.begin() ; p != c.end() ; ++p) // Good
{
 // ...
}



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

void foo()
{
 	int k = 0;
	
        /* ... */
 	 	
	for(; k&gt;0; k--){}                // 违规
	for(int i=0, k=2; k&gt;0; k--){}    // 违规
	for(int i = k+2-10; k&gt;0; k--){}  // 违规
	for(k--; k&gt;0; k--){}             // 违规
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改进代码可读性。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
 public:
  int i;
  int moo();
};

void foo()
{
 	int k = 0;
 	A obj;
	
        /* ... */
 	 	
	for(k=2; k&gt;0; k--){}           // OK
	for(int i =0; i&gt;0; i--){}      // OK
	for(k = obj.i; k&gt;0; k--){}     // OK
	for(k = obj.moo(); k&gt;0; k--){} // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.24 Flow Control Structures, AV Rule 198

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-199</key>
<configkey>JSF-199</configkey>
<name><![CDATA[ For 循环的增量表达式除了改变循环参数外，不应该执行其他任何动作 [JSF-199] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
For 循环的增量表达式除了改变循环参数外，不应该执行其他任何动作 [JSF-199-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

for 循环的增量表达式除了改变循环参数外，
不应该执行其他任何动作



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

void foo()
{
    int k = 0;

    for(;k&gt;0; ){}                 // 违规
    for(int i=0; k&gt;0; k--, i++){} // 违规
    for(k--; k&gt;0; k+1){}          // 违规
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改善代码可读性。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void zoo(){}

class A
{
public:
    int i;
};

void foo()
{
    int k = 0;
    A obj;
    
    for(int i = k+2-10; k&gt;0; zoo()){} // OK
    for(k=2; k&gt;0; k--){}              // OK
    for(int i =0; i&gt;0; i=i-1){}       // OK
    for(k = obj.i; k&gt;0; k-=1){}       // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.24 Flow Control Structures, AV Rule 199

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-20</key>
<configkey>JSF-20</configkey>
<name><![CDATA[ 禁止使用 setjmp 宏和 longjmp 函数 [JSF-20] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 setjmp 宏和 longjmp 函数 [JSF-20-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“setjmp 和 longjmp 允许普通的函数调用机制绕过和不能被使用”
当使用函数etjmp or longjmp且文件中出现任何一个头文件: 
setjmp.h, setjmp, or csetjmp，本规则将报出相关违例信息。.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则通过绕过而组织被调用



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;setjmp.h&gt;
jmp_buf mark;              /* Address for long jump to jump to */
int     fperr;             /* Global error number */

void foo( void ) {
    int jmpret;
    jmpret = setjmp( mark );        /* 违规 */
}

void fphandler( int sig, int num ) {
    longjmp( mark, -1 );            /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用宏setjmp 和longjmp函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第122条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第20条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第17部分，第17-0-5条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-200</key>
<configkey>JSF-200</configkey>
<name><![CDATA[ 如果 'for' 语句中无初始化或者无自增运算符；建议采用while循环替代 [JSF-200] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果 'for' 语句中无初始化或者无自增运算符；建议采用while循环替代 [JSF-200-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果 'for' 语句中无初始化或者无自增运算符，
建议采用while循环替代。
该规则将报告违规提示，如果 'for' 语句
无初始化或无自增运算。 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1


事例：

void foo()
{
  for(int i=0; i&lt; 10;) // 违规
  {
     /* ... */
  }

  int j = 0;
  for(; j&lt; 10;)        // 违规
  {
     /* ... */  
  }
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

while循环是一种更自然表示法。



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
  int i = 0;

  while(i&lt; 10)     // OK
  {
     /* ... */  
  }
  
  int j = 0;

  while(j&lt; 10)     // OK
  {
     /* ... */  
  }

}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.24 Flow Control Structures, AV Rule 200

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-201</key>
<configkey>JSF-201</configkey>
<name><![CDATA[ 禁止在循环体中修改循环计数器 [JSF-201] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在循环体中修改循环计数器 [JSF-201-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数字变量作为for循环的循环计数不要在循环体内部被修改.
但是，循环中其它代表逻辑值的循环控制变量可以被改变,
比如,for循环中检查指明动作完成的标志变量,



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防循环体中循环计数改变导致的错误和混淆.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int i;
    for ( i = 0; i &lt; 5; i++ ) {
        i = i + 3;                  /* Violation */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {    
    int i;
    for ( i = 0; i &lt; 5; i = i + 3 ) {} /* OK */
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节、第13部分

2. 来源: Misra 指南

3. J联合攻击战斗机, 飞行器, C++ 编码标准
   第 4.24 控制流结构章节, AV 第 201条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第 六章节, 第 6部分, 第6-5-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-202</key>
<configkey>JSF-202</configkey>
<name><![CDATA[ 禁止对浮点数类型的变量或表达式做比较操作 [JSF-202] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对浮点数类型的变量或表达式做比较操作 [JSF-202-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可以测试浮点数等值或不等值.浮点数比较推荐的方法是写一个库函数,
用来执行比较操作.库函数应该考虑到浮点粒度（FLT_EPSILON）和被比较值的数量级.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

等值和不等值的间接测试同样是问题,在Misra标准中是不允许的,但此规则不能检查出:
if ( ( x &lt;= y ) &amp;&amp; ( x &gt;= y ) )
{
  /* ... */ 
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

浮点类型的内在属性是等值比较一般都不为真,即便预期为真.
此外,在运行前无法预测比较的结果,甚至每次执行的结果会不一样.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    float x, y;

    if (x == y);      // Violation
    if (x == 0.0f);   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( float epsilon ) {
    float x, y;

    if (x - epsilon &lt;= y &amp;&amp; y &lt;= x + epsilon);  // OK
    if (-epsilon &lt;= x &amp;&amp; x &lt;= epsilon);         // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2. Misra 指南 - 第50条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.25 公式章节, AV 第202条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第六部分,第6-2-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-203</key>
<configkey>JSF-203</configkey>
<name><![CDATA[ 对无符号型常量表达式的求值不应该导致循环 [JSF-203] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对无符号型常量表达式的求值不应该导致循环 [JSF-203-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>


“因为无符号整数表达式不会严格意义上溢出，而是
按照模块化的方式循环， 任何无符号常量整数表达式
在实际上 '溢出' 时不会被编译器检查到。”
如果两个常量整数减法的结果是小于零
这条规则会报告错误。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这条规则只能检查简单的符号常量整数的减法。
这条规则没有办法检查:
- 减法以外的表达式
- 复杂的表达式
- 使用宏定义或是十六进位值的表达式



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防无符号整数的回绕。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#if (1u - 2u) /* 违规 */
/* ... */
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免无符号整数的回绕。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 51 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.25 章 Expressions， AV 第 203 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-204_a</key>
<configkey>JSF-204_a</configkey>
<name><![CDATA[ 该规则检测断言是否记录内部假定和常量 [JSF-204_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
该规则检测断言是否记录内部假定和常量 [JSF-204_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检测断言是否记录内部假定和常量。
"使用断言或等价类判断记录内部假定 
不要在断言中写有副作用的表达式。
避免 assert(false) 而推荐使用 assert(!"informational message"). 
大多数编译器将在错误输出中打印这些字符串。“



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则改善代码效率同时预防错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;assert.h&gt;
void foo( ) {
   int i = 0;
   assert( i++ != 0 ); // 违规
   assert(i=5);        // 违规
   assert(false);      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;assert.h&gt;
void foo( ) {
   int i = 0;
   assert(i != 0);                   // OK
   assert(!"informational message"); // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Error Handling and Exceptions", Rule 68

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.25 Expressions &amp; References, AV Rule 204

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-204_b</key>
<configkey>JSF-204_b</configkey>
<name><![CDATA[ 禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符 [JSF-204_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符 [JSF-204_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“此规则的目的是说明，当使用递增或递减运算
符时，递增或递减操作应该是语句完成的唯一附加功能.
此规则建议在使用++和--运算符时不要与其他 
数学运算符混合起来使用因为：
 - 影响代码的可读性
 - 对在声明中没有明确定义的函数行为产生额外
   的影响
I建议单独使用++和--运算符比较
安全。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性。 
降低由于额外影响导致函数潜在的
不确定行为的危险



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = --y + x++;  /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int x, y;
    --y;            /* OK */
    x = y + x;
    x++;            /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 联合攻击战斗机，飞行器，C++编码规范，
    第4.25章，飞行器第204条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南，
    第6章，第12节，第5-2-10条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-204_c</key>
<configkey>JSF-204_c</configkey>
<name><![CDATA[ 表达式的值应该在任何标准允许的赋值顺序下是一样的 [JSF-204_c] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值应该在任何标准允许的赋值顺序下是一样的 [JSF-204_c-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了少数运算符（特别是函数调用运算符 (), &amp;&amp;, ||, ?: 
和，逗号）中的子表达式被赋值的顺序是未指定并可能变化的。
这意味着子表达式的赋值顺序是不可靠的，尤其不能信赖
副作用发生的顺序。这些在表达式赋值中
该点前面所有的副作用都可以被确定的点
被称作“顺序点”。顺序点和副作用
被描述在ISO 9899:1990[2]的节5.1.2.3,6.3和6.6中。
注意，赋值顺序不能通过使用括号得到解决，
因为这不是一个优先级的问题。
下面说明依赖于顺序的赋值是如何发生的，
并且有助于对该规则的理解。”
“这会得出不同的结果取决于是否b[i]在 i++之前被赋值，反之亦然。
在另一个单独的语句中放置增量语句可以避免该问题。”
参见:MISRA2004-12_4_a, MISRA2004-12_4_b



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止表达式的赋值依赖于编译器的版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) 
{
    int a, b[10];
    a = b[a] + a++; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( )
{
    int a, b[10];
    a = b[a] + a;  // OK
    a++;           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.联合攻击战斗机，飞行器，C++编码规范
  第4.25章节 可移植代码，飞行器 第204条规则

4.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-204_d</key>
<configkey>JSF-204_d</configkey>
<name><![CDATA[ 三元运算符 '?:' 的第二个或第三个操作数不得含有副作用 [JSF-204_d] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
三元运算符 '?:' 的第二个或第三个操作数不得含有副作用 [JSF-204_d-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“C或C++代码中包含某些表达式不能被赋值的情况。
如果这些子表达式包含副作用，而且这些副作用依赖
于其他子表达式的值，有可能发生也有可能不发生。
导致这种问题的运算符包括：&amp;&amp;, ||和?:。对于操作符’?:’来说，
只能对其第二或第三个操作数中的一个进行赋值而不是全部赋值。
有了‘?:’ 操作符就可以在两个子表达式之间进行选择了，
因此不太可能产生错误。”
参见：MISRA2004-12_2_a, MISRA2004-12_4_a



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则只能检查两层嵌套等级的函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果开发者信赖副作用的发生，使用本规则可以避免对三目运算符的
第二或第三个操作数有条件的赋值造成的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int i;
int j;
int foo( ) {
    return (i &gt; j) ? j++ : i++; // 违规 -开发人员期望第二和第三个
                                // 操作数被赋值
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int i;
int j;
int foo( ) {
    if (i &gt; j) {      // OK
        ++i;
        return j++;
    } else {
        ++j;
        return i++;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统的使用指南 
   第6章，第12部分

2. 联合攻击战斗机，飞行器，C++编程规范
   4.25章节公式，飞行器第204条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-204_e</key>
<configkey>JSF-204_e</configkey>
<name><![CDATA[ 不要编写需要依赖函数参数赋值顺序的代码 [JSF-204_e] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要编写需要依赖函数参数赋值顺序的代码 [JSF-204_e-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数参数的赋值顺序是不确定的。这就意味着
如果函数参数包含副作用那么其产生的影响也是不确定的。
一个函数调用可以给出不同的结果取决于
该函数的哪一个参数首先被赋值。
我们可以通过副作用，理解如何访问volatile对象，修改某个对象，
或者调用包含上述操作的某个函数。

该规则检查调用的函数至少有两个参数。
在函数参数赋值期间，如果出现以下情况
   * 读取或修改某易失对象
   * 修改某非易失对象
而该对象在函数的其他参数赋值时，亦被访问
或被修改，此时报告违规。


例外：

只有一层函数调用被检查。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止编写可能在不同编译器产生不同结果的源代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Transmogrify(int,int);
int Bump(int&amp; x) {return ++x;}
void foo()
{
    int count = 5;
    Transmogrify(Bump(count),Bump(count)); // 违规
    Transmogrify(count++,count);           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Transmogrify(int,int);
int Bump(int&amp; x) {return ++x;}
void foo()
{
    int count = 5;
    int temp1 = Bump(count);
    Transmogrify(temp1,Bump(count)); // OK
    Transmogrify(count,count);       // OK
    count++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.Herb Sutter，Andrei Alexandrescu，“C++编码规范”，Addison-Wesley，
     (C) 2005 Pearson教育公司
  章节：“函数和操作符”，第31条规则

4.联合攻击战斗机，飞行器，C++编码规范
   第4.25章节可移植代码，飞行器第204条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-205</key>
<configkey>JSF-205</configkey>
<name><![CDATA[ 不要使用 volatile 关键字 [JSF-205] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 volatile 关键字 [JSF-205-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用 volatile 关键字。
参见: misra2004-12_2_f



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则防止表达式的求值依赖于编译器版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1() {
  volatile int v;  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 volatile 关键字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 46 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.25 章 Expressions， AV 第 205 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-206</key>
<configkey>JSF-206</configkey>
<name><![CDATA[ 禁止使用动态内存分配 [JSF-206] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用动态内存分配 [JSF-206-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“动态内存的使用可能导致存储溢实时失败，
这是不可取的。内置新建和删除操作，除指定版本，
使用动态堆内存。函数 calloc,malloc, realloc 和
free 使用动态对内存。 ”


例外:

该规则允许使用一个新的位置



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“有一些没有指定，为定义的和实现定义的行为
动态内存分配有关联，当然也存在缺陷。
动态堆内存泄露，数据不一致，分配导致内存，
内存耗尽，或一些非确定行为。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
  int * p = new int[10]; // 违规
  /* ... */
  
  delete[] p;            // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用，既没有 'new' 和 'delete'操作符，也没有 'calloc', 'malloc',
'realloc' 和free'函数.
 


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. Misra 指南 -第118条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-4-1条规则

4. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.26章 内存应用, AV 第206条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-207</key>
<configkey>JSF-207</configkey>
<name><![CDATA[ 将全局变量，常量，枚举类型和自定义类型变量(typedefs)封装在一个类中 [JSF-207] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
将全局变量，常量，枚举类型和自定义类型变量(typedefs)封装在一个类中 [JSF-207-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在一个类中封装全局变量和常量，枚举类型，typedefs
类型。 类中的静态变量应该使用全局变量，常量，枚举
类型和typedefs等类型进行替代。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范增强代码可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Days {yesterday};  // 违规
typedef int myint;      // 违规
myint glob;             // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    enum Days {yesterday};  // OK
    typedef int MyInt;      // OK
    static MyInt glob;      // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 5 Assigning Names - Rec. 19

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   章节 4.26 Memory Allocation, AV 规则 207

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-208</key>
<configkey>JSF-208</configkey>
<name><![CDATA[ 在程序中不要运用 C++ 异常处理函数(例如,throw, catch 和 try 等) [JSF-208] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在程序中不要运用 C++ 异常处理函数(例如,throw, catch 和 try 等) [JSF-208-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用 C++ 的异常处理。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这规范提高了代码的可移植性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;

using namespace std;
int main()
{
    char *buf;
    try                                          // 违规
    {
        buf = new char[512];
        if( buf == 0 )
            throw "Memory allocation failure!";  // 违规
    }
    catch( char * str )                          // 违规
    {
        cout &lt;&lt; "Exception raised: " &lt;&lt; str &lt;&lt; '\n';
    }
    // ...
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;

using namespace std;
int main()                                   // OK
{
	char *buf;
	buf = new char[512];
	if( buf == 0 )
		cout&lt;&lt; "Memory allocation failure!";

	return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ 编程规范
第 4.27 章节 Fault Handling, AV Rule 208

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-209</key>
<configkey>JSF-209</configkey>
<name><![CDATA[ 用 typedef 定义基本数据类型 [JSF-209] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
用 typedef 定义基本数据类型 [JSF-209-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不应该使用基本的数值类型的有符号和无符号变量,比如char，
int，short，long，和float，double类型，只有特定长度的
类型定义才可以使用。”
如果使用了基本数字值类型（例如signed char）或者类型定义
名称不包括任何数字来指示类型的长度（例如 my_int;）
，该规则会报告一个违规信息。
另见： MISRA-013


例外：

该规则不对下列的情况报告一个违规：
- "main" 函数返回类型
- 外部变量声明
- 普通字符类型，布尔和枚举类型
- 位域类型
- 以 'bool' 作为前缀的typedef自定义类型，或者普通字符的typedef自定义类型
  (即使它不包含任何数字)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“该规则可以帮助阐明存储空间的大小，但是因为整型
提升的不对称行为该规则不保证可移植性。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int my_int; /* 违规 - no digits */
static signed char a;      /* 违规 - not typedef */

short int foo(             /* 违规 (for return type) */
        short* v_short,    /* 违规 */
        float&amp; r_float)    /* 违规 */
{
    double h;              /* 违规 */
    const int z = 1;       /* 违规 */
    return 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Exceptions: */
typedef char char_t;            /* OK (plain char) */
typedef unsigned char BOOL;     /* OK (typedef name starts with 'bool' prefix */
struct STRUCT {
        unsigned int i:2;       /* OK (bit-bield type) */
};
char ch;                        /* OK (plain char) */
bool b;                         /* OK (boolean type) */
enum ENUM { EV };               /* OK (enum type) */
extern signed char a;           /* OK (extern variable) */
int main() { return 0; }        /* OK ("main" return type) */

/* Correct use of typedef: */
typedef signed int my_int32;    /* OK */
typedef signed char int8_t;     /* OK */
typedef short int s16_t;        /* OK */
typedef float&amp; float32ref;      /* OK */
typedef double float64;         /* OK */
typedef const int cs32_t;       /* OK */
s16_t foo(                      /* OK */
        char_t* p_char,         /* OK */
        float32ref r_float)     /* OK */
{
    float64 h;                  /* OK */
    cs32_t z = 1;               /* OK */
    return 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 18 Portable Code - 18.1 Data Abstraction - Port. Rec. 1

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.4 章 环境，第 AV 11 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-21</key>
<configkey>JSF-21</configkey>
<name><![CDATA[ 禁止使用库文件 signal.h 中的处理函数 [JSF-21] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用库文件 signal.h 中的处理函数 [JSF-21-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“信号处理包含实现定义和不确定的行为。”
如果文件中含有以下任意一个头文件signal.h, or csignal.
本规则将报出违规信息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止在信号处理中出现实现定义和不确定的行为的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;signal.h&gt;  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用&lt;signal.h&gt; 头文件。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第123条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第21条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-7-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-210.1</key>
<configkey>JSF-210.1</configkey>
<name><![CDATA[ 算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序 [JSF-210.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序 [JSF-210.1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则是为了防止应用程序被假设
关于被标志符分隔的非静态成员的顺序
是有序的.
规则报告一个违规信息如果如果静态转换的类型指向一个类
具有被分隔符分隔的非静态数据成员.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

被标志符分隔的非静态成员的顺序
不确定.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
   protected: // a比b先被存储, 或者反过来也一样
      int a;
   private:
      int b;
};


class M: A
{
};

void foo(M* message_buffer_ptr)
{
   A* a_ptr = static_cast&lt;A*&gt;(message_buffer_ptr);     // 违规
                                                       // 应用程序架设对象的
                                                       //数据类型将总是先拥有属性a
                                                       // 被存储，先于属性b.
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct A
{
    int a;
    int b;
};

class M: A
{
};

void foo(M* message_buffer_ptr)
{
   A* a_ptr = static_cast&lt;A*&gt;(message_buffer_ptr);     // OK
                                                       // 属性B没有被标识符
                                                       // 分隔
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第4.28章节 Portable Code, AV Rule 210.1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-213_a</key>
<configkey>JSF-213_a</configkey>
<name><![CDATA[ 谨慎使用 C 语言中表达式的优先运算规则 [JSF-213_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 C 语言中表达式的优先运算规则 [JSF-213_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
当操作符的右操作数是赋值表达式时，通常需要使用括号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
	int a, b;
	b = a = 0;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
	int a, b;
	b = (a = 0);	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节 可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-213_b</key>
<configkey>JSF-213_b</configkey>
<name><![CDATA[ 谨慎使用 C 语言中表达式的优先运算规则 [JSF-213_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 C 语言中表达式的优先运算规则 [JSF-213_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。
在复杂的C语言运算规则中，很容易出错，
使用括号可以避免发生这种错误，也有助于我们理解代码。
但是不要使用太多的括号，这样会使代码变得零乱，
并且影响代码的可读性。”
“对于赋值运算符的右侧操作数不是必须使用括号，
除非它的右侧包含一个赋值语句。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

不检查宏的结构体。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
	int a, b;

	b = (a = 0);	// OK
	b = (a + 0);	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
	int a, b;

	b = (a = 0);	// OK
	b = a + 0;	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器 第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-213_c</key>
<configkey>JSF-213_c</configkey>
<name><![CDATA[ 一元运算符的操作数不需要括号 [JSF-213_c] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一元运算符的操作数不需要括号 [JSF-213_c-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
对于一元运算符的操作数，本规则要求其不使用圆括号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) 
{
    int a, b;
    b = a * (-1);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) 
{
    int a, b;
    b = a * -1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-213_d</key>
<configkey>JSF-213_d</configkey>
<name><![CDATA[ 谨慎使用 C 语言中表达式的优先运算规则 [JSF-213_d] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 C 语言中表达式的优先运算规则 [JSF-213_d-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
“如果所有的运算符优先级相同，可以使用括号来控制操作数的
运算顺序。部分运算符（例如加法和乘法）在代数上可以结合
但在C语言里并不一定能够结合。同样，整型运算
涉及很多混合类型（有些类型已被某些规则禁止使用），
可能会由于整型提升产生不同类型的运算结果。下面的例子中
对于16位数据加法的执行情况充分证明
加法是不能结合的，并且对于表达式的结构清晰非常重要：”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则在算术运算中增加了安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifdef _MSC_VER
typedef unsigned __int16 uint16;
typedef unsigned __int32 uint32;
#elif __GNUC__
#include &lt;sys/types.h&gt;
typedef u_int16_t uint16;
typedef u_int32_t uint32;
#endif

void fooPlus( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = (a + b) + c; /* 违规- d 等于 9; a + b 超出范围 65536 */ 
}

void fooMultiply( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = (a * b) * c; /* 违规- d 等于 65526; a * b 超出范围 65536 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifdef _MSC_VER
typedef unsigned __int16 uint16;
typedef unsigned __int32 uint32;
#elif __GNUC__
#include &lt;sys/types.h&gt;
typedef u_int16_t uint16;
typedef u_int32_t uint32;
#endif

void fooPlus( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = a + (b + c); /* 正确-d 的值是65545 */
}

void fooMultiply( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = a * (b * c); /* 正确- d的值是 655350 */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-213_e</key>
<configkey>JSF-213_e</configkey>
<name><![CDATA[ 除非表达式中的所有操作符都相同才使用括号 [JSF-213_e] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
除非表达式中的所有操作符都相同才使用括号 [JSF-213_e-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。
除非某表达式内仅使用一种操作符，否则应使用括号。”
参见: MISRA2004-12_5, CODSTA-90



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

逻辑 &amp;&amp; 和 || 的操作数由 MISRA2004-12_5 规则检查



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a, b;
    b = a * a + a;      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int a, b;
    b = (a * a) + a;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器 第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-214</key>
<configkey>JSF-214</configkey>
<name><![CDATA[ 避免在编译单元中出现初始化顺序问题 [JSF-214] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在编译单元中出现初始化顺序问题 [JSF-214-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在一个编译单元内的非局部静态对象的初始化 
值为在另一个不同编译单元内的非静态局部对象，
则该对象可能没有初始化，因为 C++ 对定义于不同 
编译单元的非局部静态对象的初始化顺序并无明确定义。
幸运的是, 一种小的设计能够完全消除该问题。
所要做的只是将每个非静态局部对象放到该变
量所属的函数（声明该变量的函数）内即可。 
这些函数返回指向所包含对象的引用。
客户端可以调用这个函数而不是 
这个对象的引用。 换句话说，非局部 
静态对象被局部静态对象替代。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"This approach is founded on C++'s guarantee that local 
static objects are initialized when the object's definition
is first encountered during a call to that function. So if
you replace direct accesses to non-local static objects 
with calls to functions that return references to local 
static objects, you're guaranteed that the references you
get back will refer to initialized objects. As a bonus, if you
never call a function emulating a non-local static object, 
you never incur the cost of constructing and destructing 
the object, something that can't be said for true non-local
static objects."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class FileSystem { 
public:
    size_t numDisks( ) const; 
};
extern FileSystem tfs;                              // 违规 
class Directory { 
public:
    Directory( );
};
Directory::Directory( ) {
    size_t disks_tfs = tfs.numDisks( ); 
}
Directory tempDir( );



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class FileSystem { 
public:
    size_t numDisks( ) const; 
};
FileSystem&amp; tfs_one( ) { 
    static FileSystem fs;                            // OK
    return fs; 
}
class Directory { 
public:
    Directory( );
};
Directory::Directory( ) {
   size_t disks_one = tfs_one().numDisks( );
}
Directory tempDir( ); 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 4

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.28 Portable Code, AV Rule 214

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-215</key>
<configkey>JSF-215</configkey>
<name><![CDATA[ 避免使用指针进行算术运算 [JSF-215] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用指针进行算术运算 [JSF-215-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用指针进行运算。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止访问意外或是无效的内存地址。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
  int* a;
  int* b;
  int tab[10];
  a=tab;  
  a++;        /* 违规 */
  --a;        /* 违规 */
  b = a+5;    /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用指针运算。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 101 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.28 章 Portable Code， AV 第 215 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-22</key>
<configkey>JSF-22</configkey>
<name><![CDATA[ 禁止使用库文件 stdio.h 中的输入/输出函数 [JSF-22] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用库文件 stdio.h 中的输入/输出函数 [JSF-22-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

" I/O流和 I/O文件有相当大的不确定因素，
未定义和实现定义和它们很大的关联。
据推测，他们将不会再嵌入式系统中被使用。
如果 stdio.h中任何一个被用来代码中，
那么与性能相关的问题毫无疑问需要解决的。"
本规则将阻止使用 &lt;stdio.h&gt;, and &lt;cstdio&gt;头文件



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防在使用I/O流和文件带来大量难以确定的问题，
以及I/O流和文件相关的未指定和未执行的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;  /* 违规*/



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用&lt;stdio.h&gt;库。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第124条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第22条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第27部分，第27-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-23</key>
<configkey>JSF-23</configkey>
<name><![CDATA[ 禁止使用 stdlib.h 中的库函数 atof, atoi 和 atol [JSF-23] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 stdlib.h 中的库函数 atof, atoi 和 atol [JSF-23-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

来自库&lt;stdlib.h&gt;中的函数 'atof', 'atoi' 和'atol' ，
当字符串不能通过它们来转换的时候，没有确定的行为。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用那些含有没有定义行为的函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
void foo( void ) {
    char *s; double x; int i; long l;
    s = "  -2309.12E-15";    
    x = atof( s );           /* 违规 */
    s = "  -9885 pigs";      
    i = atoi( s );           /* 违规*/
    s = "98854 dollars";     
    l = atol( s );           /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用atof, atoi 和atol 这些函数.


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第20部分

2. 来源: Misra 指南 - 第125条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5章库, AV 第23条规则

4. MISRA C++:2008 C语言在关键系统中的使用指南,第6章，第18部分，第18-0-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-24</key>
<configkey>JSF-24</configkey>
<name><![CDATA[ 禁止使用 stdlib.h 中的库函数 abort, exit, getenv 和 system [JSF-24] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 stdlib.h 中的库函数 abort, exit, getenv 和 system [JSF-24-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许使用来自库stdlib.h，cstdlib或者库stdlib_iso.h
中的 'abort', 'exit', 'getenv' 和 'system' 函数.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用那些没有在嵌入式系统需要的函数



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include  &lt;stdlib.h&gt;
void foo( void ) {
    char *libvar;
    libvar = getenv( "LIB" );  /* 违规 */
    system( "dir" );           /* 违规 */
    abort( );                  /* 违规 */
    exit( 0 );                /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用abort, exit, getenv 和系统函数.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. 来源: Misra 指南 - 第126条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5 章库，, AV 第24条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-0-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-25</key>
<configkey>JSF-25</configkey>
<name><![CDATA[ 禁止使用库文件 time.h 中的时间处理库函数 [JSF-25] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用库文件 time.h 中的时间处理库函数 [JSF-25-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这个库和时钟时间关联。各个方面和执行程序
相关或者不确定，比如时间的格式”。
规则防止列入 &lt;time.h&gt; and &lt;ctime&gt; 头文件。
参见: SECURITY-01



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止不确定行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;time.h&gt;  /* 违规*/



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用time.h 头文件.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. 来源: Misra 指南 - 第127条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5 章库，, AV 第25条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第18章，第7部分，第18-0-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-26</key>
<configkey>JSF-26</configkey>
<name><![CDATA[ 只有下列预处理器指令才能被使用: #ifndef, #define, #endif, #include [JSF-26] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只有下列预处理器指令才能被使用: #ifndef, #define, #endif, #include [JSF-26-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只有下列预处理器指令才应该被使用: #ifndef,
#define, #endif, #include



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

限制预处理器的使用的情况是必要的。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#pragma once // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef FOO_H              // OK
#define FOO_H
/* ... */
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 26 条规则

2. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1

3. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-27</key>
<configkey>JSF-27</configkey>
<name><![CDATA[ 使用多重包含保护机制 [JSF-27] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用多重包含保护机制 [JSF-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每一个包括文件必须包含一种机制，防止文件被多次 
列入."
多重包含机制应界定为:

#ifndef FILENAME_H
#define FILENAME_H
// 代码
#endif

或

#if !defined(FILENAME_H)
#define FILENAME_H
// 代码
#endif

参见: PFO-07, PFO-08, MISRA2004-19_15



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范可以提高代码可维护性和优化.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file foo.hh
// 违规 - 无多重包含机制存在



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file foo.hh
// 正确
#ifndef FOO_HH
#define FOO_HH
int i;
#endif


参考:

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   出处: 4 源码文件 - 4.4 头文件 - Rule 7

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.6 章节 预处理指令 (Pre-Processing Directives), AV Rule 27

3. MISRA C++:2008 - 在关键系统中使用 C++ 语言的
   指导, 第 6 章节, 16 段, Rule 16-2-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-28</key>
<configkey>JSF-28</configkey>
<name><![CDATA[ #ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [JSF-28] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
#ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [JSF-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#ifndef 和 #endif 预处理指令将仅用于
下面的例子中定义那样来防止重复地包含
相同的头文件。

#ifndef Header_filename
#define Header_filename
// 头文件声明...
#endif



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

有条件的代码编译应该保持最小量，
因为他能显著地使测试和维护工作变得不清晰。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifndef MAX                 // 违规

int max = 10;

#endif                      // 违规

int a;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef FOO_H               // OK
#define FOO_H 

int max = 10;
int a;

#endif                      // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 28 条规则

2. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1
3. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-29</key>
<configkey>JSF-29</configkey>
<name><![CDATA[ 函数应该优先于类似函数宏的使用 [JSF-29] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数应该优先于类似函数宏的使用 [JSF-29-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则在一个类似函数的定义中报告一个违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

尽管宏与函数相比，可以提供一种速度上的优势，
但是函数提供了一种更安全和更稳健的机制。
这对于参数的类型检查是非常适用的，并且在
像函数一样宏里面对潜在地多次估计参数值的
问题的解决也是非常适用的。


同样可参见: CODSTA-03, CODSTA-37, CODSTA-38, CODSTA-39, CODSTA-40



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define SUM(A,B) ((A)+(B))  /* 违规 */

void foo( int x, int y ) {
    /* ... */
    SUM( x, y );
    /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int sum( int a, int b ) {    /* OK*/
    return (a + b);
}

void foo( int x, int y ) {
    /* ... */
    sum( x, y );
    /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. Scott Meyers, "Effective C++: 55中特殊方法提高您的程序设计 Sp", 第三版, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章, 第2项

3. Misra 指南- 第93条规则

4. Ellemtel 编码标准 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 9 函数 - 9.5 联机函数 - 第35条规则

5. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.6章 预处理指令, AV 第29条规则	

6. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第16部分，第16-0-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-3</key>
<configkey>JSF-3</configkey>
<name><![CDATA[ 限制圈复杂度在 20 之内 [JSF-3] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制圈复杂度在 20 之内 [JSF-3-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则找出那些不符合用户定义的圈复杂度的方法.

圈复杂度的计算公式:
CC = 分支判断的数量 + 1
对于分支判断表示每次出现以下的:
-'if'
-'for'
-'while'
-'do-while'
-'case'
-'catch'
-条件表达式 'a?b:c'
-逻辑运算符 '&amp;&amp;' 和 '||'
当函数的圈复杂度高出20时，报告出来.
参见: METRICS-18, METRICS-29, METRICS-33, METRICS-34, METRICS-35



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

可以通过修改rule的定义，来修改默认的10的定义。
要更改圈复杂度的默认限制，修改规则主要的
收集器 "Count" 表达式 (Collector A) 从 "$$ &gt; 20" 到 "$$ &gt; N"，
使用 N 表示期望阀值。规则的头部也应该做相应的
修改。

如果要忽视在圈复杂度计算中的开关语句,
修改层次的收集器 "Count" 表达式 (Collector C) 从 "$$ &gt; 0" 
到 "$$ == 0".

如果要忽视在圈复杂度的计算中的具有超过N层的
开关语句, 修改层次的收集器 "Count" 表达式
(Collector C) 从 "$$ &gt; 0" 到 "$$ &lt;= N" ，使用 N 表示期望阀值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

研究发现，圈复杂度较高的方法是错误的多发地.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo2(int i, int a, int b, int j, int k)   // 违规- CC value: 21
{
    switch (i)
    {
        case 1:  // 1
            i++;
        default:
            i++;
    }
    switch (j)
    {
        case 1:  // 2
            j++;
        default:
            j++;
    }
    switch (k)
    {
        case 1:  // 3
            k++;
        default:
            k++;
    }

    if(a||b)      // 4, 5
    {
    }
    if((a||b)&amp;&amp;(a&amp;&amp;b)) // 6, 7, 8, 9
    {
    }
    do                // 10
    {
    }while(0);
    switch (i)
    {
        case 1:  // 11
            i++;
        default:
            i++;
    }
    switch (j)
    {
        case 1:  // 12
            j++;
        default:
            j++;
    }
    switch (k)
    {
        case 1:  // 13
            k++;
        default:
            k++;
    }

    if(a||b)      // 14, 15
    {
    }
    if((a||b)&amp;&amp;(a&amp;&amp;b)) // 16, 17, 18, 19
    {
    }
    do                // 20
    {
    }while(0);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

保持圈复杂度在20之下.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 3.2 Code Size and Complexity, AV Rule 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-30</key>
<configkey>JSF-30</configkey>
<name><![CDATA[ 不要通过#define定义常量 [JSF-30] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要通过#define定义常量 [JSF-30-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用 const 或者 enum 定义常量，而不要使用 #define。
预处理器会将源码中的宏替换为相应的定义，然后编译 
这将导致很多负面效应。例如，如果通过#define定义 
一个常量，而该常量的名字很多调试器均不认得。
如果该常量用于表示一个表达式，则该表达式在 
不同的情况下表达式的值不一样，他依赖于该名字的
范围。此外，宏常常容易写错”
See also: MISRA2004-19_7, CODSTA-37, CODSTA-38, CODSTA-39, CODSTA-40



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

代码调试方便。防止宏定义错误。


事例：

#define PI 3.1416    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const float PI = 3.1416; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 2

2. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 10 Constants - Rule 36

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.6 Pre-Processing Directives, AV Rule 30

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-31</key>
<configkey>JSF-31</configkey>
<name><![CDATA[ 避免使用宏 [JSF-31] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用宏 [JSF-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

宏通常是从 C 语言继承来的一个陈旧的构造。 
使用宏的主要问题是:
- 不是类型安全的
- 是被预处理器扩大了，所以调试它们是不可能的
- 纯粹根据运气创建丑陋问题的程序可以编译


例外:

宏几乎没有必要存在于 C++ 语言中。此规则的例外是:
- #ifdef
- #ifndef
- #if
- #if defined
当被用作 include 防范和条件编译。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可靠性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PI 3.14  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const double PI = 3.14; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范” Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Coding Style", 第 16 条规则

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 31 条规则

3. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-32</key>
<configkey>JSF-32</configkey>
<name><![CDATA[ 仅可以在包含头文件(*.h)时使用 #include 预处理指令 [JSF-32] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
仅可以在包含头文件(*.h)时使用 #include 预处理指令 [JSF-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#include 预处理指令只能用来包含
头文件 (*.h).


例外:

在类模板或函数定义, 代码可能
由头文件和实施文件划分. 此情
况下, 实施文件可能是头文件的
一部分. 规范允许此例外如果实
施文件有着和头文件一样的名字.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改善代码的清晰.
在 .cpp 文件里的包含将
只和头文件 (*.h) 相关.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
#include &lt;file2.cpp&gt;  // 违规
#include &lt;file3.hh&gt;   // 违规

// file.h
#include &lt;file2.cpp&gt;  // 违规
#include &lt;file3.hh&gt;   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cpp
#include &lt;file2.h&gt;    // OK - 头文件 (*.h)
#include &lt;file3.h&gt;    // OK - 头文件 (*.h)

// file.h
#include &lt;file.cpp&gt;   // OK - 和 file.h 同名的实施文件 file.cpp
#include &lt;file2.h&gt;    // OK - 头文件 (*.h)
#include &lt;file3.h&gt;    // OK - 头文件 (*.h)



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.6 章节 Pre-Processing Directives, AV 第 32 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-33</key>
<configkey>JSF-33</configkey>
<name><![CDATA[ #include 指令只能使用 <filename.h> 符号来包含头文件 [JSF-33] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
#include 指令只能使用 &lt;filename.h&gt; 符号来包含头文件 [JSF-33-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#include 指令只能使用&lt;filename.h&gt;符号来包含头文件.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

include指令格式 "filename.h" 通常是用于包括当地的头文件
然而，由于在供应商在实现方面的分歧，只有&lt;filename.h&gt;形式将被使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "foo.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;foo.h&gt;           // OK
#include &lt;dir1/dir2/foo.h&gt; // OK: 使用相对路径



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机,飞行器,C++编码标准
第4.7章,第AV 33条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-35</key>
<configkey>JSF-35</configkey>
<name><![CDATA[ 使用某种机制以防止文件的多重包含，例如，包含保护或者使用 "#pragma once" 预处理指令 [JSF-35] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用某种机制以防止文件的多重包含，例如，包含保护或者使用 "#pragma once" 预处理指令 [JSF-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每一个包括文件必须包含一种机制，防止文件被多次 
列入."
多重包含机制应界定为:

- #pragma once - 预处理指令

或

- 如下方式定义包含防护:
#ifndef FILENAME_H
#define FILENAME_H
// 代码
#endif

或

#if !defined(FILENAME_H)
#define FILENAME_H
// 代码
#endif

参见: PFO-02, PFO-07, and MISRA2004-19_15



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范可以提高代码可维护性和优化.


始自:

v7.1



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file foo.hh
// 违规 - 无多重包含机制存在



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file foo.hh
// 正确
#pragma once


参考:

1. Ellemtel 代码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   出处: 4 源码文件 - 4.4 头文件 - Rule 7

2. 联合攻击战斗机, 飞行器, C++ 代码规范
   第 4.7 章节 头文件, AV Rule 35

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-39_a</key>
<configkey>JSF-39_a</configkey>
<name><![CDATA[ 在头文件中不能定义带有连接的实体 [JSF-39_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在头文件中不能定义带有连接的实体 [JSF-39_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“头文件应该用来声明对象，函数，内联函数，
函数模板，类型定义(typedef)，宏，类和类模板。
并不得包含或者产生需要占据存储空间的对象或者函数的定义
（或者函数或者对象的片段）。”
参见：MISRA2004-8_5



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

作为头文件，规则检测包含如下扩展名的文件 ".h", ".hh", ".hxx", ".i"
(例如： "file.h", "file.hh", "file.hxx", "file.i").


例外:

在头文件允许下面的定义:
- 内联函数
- 函数模板
- 类模板的静态数据成员
- const 变量（如果它们有内部或没有连接）(C++ 模式)
- 静态 const 变量



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。
通过不在头文件中包含定义，
可以在多个翻译单元包含头文件。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* file.h */
void f1(){}            // 违规
int var;               // 违规
class C {
   void f2();
};
void C::f2() {}        // 违规

/* file.cpp */
#include "file.h"



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* file.h */
void f1();             // OK
extern int var;        // OK
class C {
   void f2();
};
template &lt;typename T&gt;
void f3 ( T ) { }      // OK

/* file.cpp */
#include "file.h"
void f1(){}
int var;
void C::f2() {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章，第 3 节, 第 3-1-1 条规则

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Namespaces and Modules", Rule 61

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.7章 Header Files, AV Rule 39

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-41</key>
<configkey>JSF-41</configkey>
<name><![CDATA[ 源代码行应该保持在 120 个字符之内 [JSF-41] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
源代码行应该保持在 120 个字符之内 [JSF-41-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if a physical line contains more
than 120 characters. Very long source lines can be difficult
to read and understand.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

Tab is counted as one character.
White spaces at the end of line are counted in the same way as other characters.
Comments with 'parasoft-suppress' are not counted.

To change the default limit of characters modify the variable 'lineLengthLimit'
at the begin of python method 'check'.(e.g. 'lineLengthLimit = 100' means that
the maximal allowed number of characters in a physical line is 100) 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule improves readability of code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int       /* ....................................................................................*/  i1 ; /* 违规 */
int       /* ..........white spaces at the end of line.......................................*/  i2 ; /* 违规 */    
/* multiline comment ....................................................................................违规.......
 * ......................................................................................................违规.....*/
#define MACCCCC(xxxxxxxxxxxxxxxxxxxxxxxxxxxx) xxxxxxxxxxxxxxxxxxxxxxxxxxxx + xxxxxxxxxxxxxxxxxxxxxxxxxxxx + xxxxxxxxxxxxxxxxxxxxxxxxxxxx /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int       /* ..........................................................................................*/  i1 ; /* OK */
int       /* ..........There is no spaces at the end.......................................*/  i2 ; /* Violation */
/* multiline comment ....................................................................................OK......
 * ......................................................................................................OK....*/
#define MACCCCC(xxxxxxxxxxxxxxxxxxxxxxxxxxxx) xxxxxxxxxxxxxxxxxxxxxxxxxxxx + xxxxxxxxxxxxxxxxxxxxxxxxxxxx + \
	            xxxxxxxxxxxxxxxxxxxxxxxxxxxx /* OK */
int       /* .........................................................................................*/  i3 ;  /* parasoft-suppress ITEM ... OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.9 Style, AV Rule 41

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-42</key>
<configkey>JSF-42</configkey>
<name><![CDATA[ 每行只允许有一条语句 [JSF-42] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每行只允许有一条语句 [JSF-42-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测每个代码行是否只有一个语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这规范由降低代码的复杂度来提升可读性和维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
   int i; char c; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int ii; // OK
    char cc; 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 42

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-43</key>
<configkey>JSF-43</configkey>
<name><![CDATA[ 禁止使用未用 ASCII 空格的 Tab 字符 [JSF-43] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用未用 ASCII 空格的 Tab 字符 [JSF-43-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检查您是否使用ASCII的空格为制表符. 
不同的操作系统, 显示设备, 和编辑器在处理制表符
有着不同的方式. 代码所包含的制表符会因移植到不同的
环境而有缩进不正确的情况。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这规范预防了包含制表符的代码在不同的环境
有不一致的缩进显示.




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
	int i; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int j; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 43

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-46</key>
<configkey>JSF-46</configkey>
<name><![CDATA[ 用户指定的标识符(内部或者外部的)不能多于 64 个字符 [JSF-46] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
用户指定的标识符(内部或者外部的)不能多于 64 个字符 [JSF-46-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

超过64个字符的标志符不允许被使用.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则确保代码在大多数的编译器/链接器
的可移植性，不需要修改或者(缩小)标志符的名称



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int really_long_paaaaaaaaaaaaaaaaraaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaam) // 违规 65 字符
{

}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int really_long_paaaaaaaaaaaaaaaaraaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaam)  // OK 64 字符
{

}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.9 Style, AV Rule 46

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-47</key>
<configkey>JSF-47</configkey>
<name><![CDATA[ 标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头 [JSF-47] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头 [JSF-47-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不要使用以一个或两个下划线 (`_' or `__') 开头的命名."
参见: CODSTA-92, CODSTA-93



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规范预防了不确定的行为.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void _foo( );  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( );   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 5 Assigning Names - 第 16 规则

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.9 章节 Style, AV 第 47 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-48</key>
<configkey>JSF-48</configkey>
<name><![CDATA[ 不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字 [JSF-48] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字 [JSF-48-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

标识符将相同如果:
- 只有大小写的混合
- 下划线字符存在与否
- 只有字母 'O', 和数字 '0' 或字符 'D' 交换
- 只有字母 'I', 和数字 '1' 或字符 'l' 交换
- 只有字母 'S' 和数字 '5' 交换
- 只有字母 'Z' 和数字 '2' 交换
- 只有字母 'n' 和字符 'h' 交换.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int paramS, int param5);   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int param1, int param2);   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 48 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-50</key>
<configkey>JSF-50</configkey>
<name><![CDATA[ 类，结构，命名空间，枚举或自定义类型(typedef)的名字中，只有第一个字母可以大写 [JSF-50] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类，结构，命名空间，枚举或自定义类型(typedef)的名字中，只有第一个字母可以大写 [JSF-50-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类, 结构体, 命名空间, 枚举, 或由 typedef
创建的类型命名应以大写字母开头.
其余的字母都为小写.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果想排除缩写名称的检查，则可以在
此规范里的 python 脚本 checkNamingConvention() 方法中
的 abb_table 数组添加缩写字符串 如 abb_table = ["RGB", "IBM"]


例外:

在 typedef 类型名的第一个字母可以为小写如果 typedef 对象是类成员或
当它用来替代基本类型.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规范提高可读性与维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class sample_Class   // 违规
{
   // ...
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Sample_class   // OK
{
   // ...
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 50 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-51</key>
<configkey>JSF-51</configkey>
<name><![CDATA[ 在函数和变量名中包含的字母应该全部以小写字母组成 [JSF-51] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数和变量名中包含的字母应该全部以小写字母组成 [JSF-51-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在函数和变量名中包含的字母应该全部以
小写字母组成.


例外:

构造函数和解构造函数.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高可读性与维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Sample_class
{
public:
    int Some_function();      // 违规
private:
    int Some_variable;        // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Sample_class
{
public:
    int some_function();      // OK
private:
    int some_variable;        // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 51 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-52</key>
<configkey>JSF-52</configkey>
<name><![CDATA[ 常量和枚举(enum)类型的标识符必须是小写 [JSF-52] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
常量和枚举(enum)类型的标识符必须是小写 [JSF-52-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

常量和枚举应为小写.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

尽管在常量和枚举中使用大写是
允许的, 仍有可能第三方库会替
换常量 / 枚举名为宏替换过程的
一部分 (宏通常也是以大写字母来呈现).



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

const int Max_pressure = 100;    // 违规
enum Switch_position {Up, down}; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int max_pressure = 100;     // OK
enum Switch_position {up, down};  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 52 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-53</key>
<configkey>JSF-53</configkey>
<name><![CDATA[ 确保头文件应该始终具有扩展名 '.h' [JSF-53] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保头文件应该始终具有扩展名 '.h' [JSF-53-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检查源码当的头文件不是以
".h" 文件扩展名为后缀时报告违规。
参见: PREPROC-08, NAMING-37, NAMING-38



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

头文件声明成为任意文件是通过 '#include.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规范提高了代码的可读性与维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
#include "file.hpp"

// file.hpp                 // 违规
extern int i;         



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cpp
#include "file.h"

// file.h                   // OK
extern int i;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 53 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-53.1</key>
<configkey>JSF-53.1</configkey>
<name><![CDATA[ 下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 " [JSF-53.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 " [JSF-53.1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

下面的字符序列不该出现在头文件
名称: ', \, /*, //, or ".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果这些字符序列 ', \, /*, //, 或 " 出现在
头文件名 (如 &lt;字符序列&gt;), 将有无可预知
的结果.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "foo's.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;foo_s.h&gt; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.9 章节 Style, AV 第 53.1 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-54</key>
<configkey>JSF-54</configkey>
<name><![CDATA[ 源文件的扩展名必须为 ".cpp" [JSF-54] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
源文件的扩展名必须为 ".cpp" [JSF-54-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果文件后缀名不是 ".h" (为头文件所用) 则
应该是 ".cpp" (实现文件).
此规范侦测如果文件后缀名不是 ".cpp" 和 ".h".
".cpp" 应为实现文件所用而
".h" 是给头文件使用 (规则 NAMING-41).
参见: NAMING-41



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规范只对 C++ 代码检测.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性与维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

//file.cc          // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

//file.cpp        // OK   



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 54 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-57_a</key>
<configkey>JSF-57_a</configkey>
<name><![CDATA[ 在一个类的范围顺序中： public 位置应在最前面 [JSF-57_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在一个类的范围顺序中： public 位置应在最前面 [JSF-57_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

Public 位置必须在 protected and private 之前。
参见： CODSTA-CPP-45, CODSTA-CPP-47, CODSTA-CPP-48, CODSTA-CPP-49



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

易读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test {  // 违规
protected:
    void foo2( );
private:
    void foo3( );
public:
    void foo1( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test {  // OK
public:
    void foo1( );
protected:
    void foo2( );
private:
    void foo3( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 6 Style - 6.1 Classes - 第20条规则

2. J联合攻击战斗机, 飞行器, C++ 编码规范
   第4.9章 Style, AV 第57条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-57_b</key>
<configkey>JSF-57_b</configkey>
<name><![CDATA[ 在一个类的范围顺序中： protected 位于 private 之前 [JSF-57_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在一个类的范围顺序中： protected 位于 private 之前 [JSF-57_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

Protected 必须位于 private 之前。
参见： CODSTA-CPP-45, CODSTA-CPP-46, CODSTA-CPP-48, CODSTA-CPP-49



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增加易读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test {	// 违规
public:
    void foo1( );
private:
    void foo3( );
protected:
    void foo2( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test {	// OK
public:
    void foo1( );
protected:
    void foo2( );
private:
    void foo3( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 6 Style - 6.1 Classes - 第20条规则

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.9章 Style, AV 第57条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-58</key>
<configkey>JSF-58</configkey>
<name><![CDATA[ 当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个 [JSF-58] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个 [JSF-58-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当声明和定义多于两个参数的函数时,
前括号和第一个参数应该和函数名一
起位于同行. 每个增加的参数应分别
写在不同的代码行 (结束括号直接跟
在最后一个参数).



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可读性及风格佳。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b, int c);// 违规

void zoo(                     // 违规    
         int a, int b,        // 违规
         int c
         )                    // 违规
{

}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a,
         int b,
         int c);        // OK

void zoo( int a, 
          int b,
          int c)        // OK
{
}

void goo(int a, int b); // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 58

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-59_a</key>
<configkey>JSF-59_a</configkey>
<name><![CDATA[ 'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [JSF-59_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [JSF-59_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

组成switch语句或者while 语句、do...while语句或者for语句的主体的应该是复杂语句，
甚至是包含简单语句的复杂语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x ) {
    int i;

    switch(i)             // Violation
    ;

    for (i=0; i&lt; 10; i++) // Violation 
        foo( x );
    while (1)             // Violation
        foo( x );

    do                    // Violation
    foo( x );
    while(1);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x ) {
    int i;

    switch(i)             // OK
    {
    }

    for (i=0; i&lt; 10; i++) // OK
            {foo( x );}
    while (1)             // OK
        {foo( x );}

    do                    // OK
        {foo( x );}
    while(1);
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Misra 指南-第59条规则

3.Ellemtel 编码规范
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    from: 6 Style - 6.4 Flow Control Statements - Rec. 25

4.联合攻击战斗机, 飞行器 C++ 编码规范
   第4.9设计章节,AV第59条规则

5.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第六部分,第6-4-1规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-59_b</key>
<configkey>JSF-59_b</configkey>
<name><![CDATA[ 在 'if' 和 'else' 之后应该紧跟着复合语句 [JSF-59_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'if' 和 'else' 之后应该紧跟着复合语句 [JSF-59_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

if语句结构应该是一个复杂语句.
else关键字后面应该是一个复杂语句或者是另外一个if语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高了代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x, int y )
{
    int i, j;
    if(x &gt; 0)      // Violation
        x = i;
    else if(y &gt; 0) // Violation
        y = i;
    else
        y = j;     // Violation
        x = j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x, int y )
{
    int i, j;
    if(x &gt; 0)      // OK
    {
        x = i;
    }
    else if(y &gt; 0) // OK
    {
        y = i;
    }
    else
    {
        y = j;     // OK
        x = j;
    }
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Misra 指南-第59条规则

3. Ellemtel 编码规范
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    from: 6 Style - 6.4 Flow Control Statements - Rec. 25

4.联合攻击战斗机, 飞行器 C++ 编码规范
   第4.9设计章节,AV第59条规则

5. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第六部分,第6-4-1规则示例

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-60</key>
<configkey>JSF-60</configkey>
<name><![CDATA[ 包含一个区域的括号 "{}" 应该放置在同一列 [JSF-60] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
包含一个区域的括号 "{}" 应该放置在同一列 [JSF-60-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则用于检查做大括号和右大括号是否在同一列.
参见: FORMAT-02, FORMAT-03


例外:

本规则不适用于枚举,舒适化或者空的块.
enum E {EN1 = 2, EN2 = 1};  // OK
int array[] = {1,2,3,4,5};  // OK
class FooBar{};             // OK
本规则如果行中使用'tab'将不会报出违规.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则可以提高代码的可阅读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Foobar {   // 违规
   int a;
};

struct S1 {      // 违规
    int a;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Foobar 
{                // OK
    int a;
};

struct S1
{                // OK
    int a;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 6 Style Classes - 6.3 Compound Statements- Rec. 24

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.9 Style, AV Rule 60

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-61_a</key>
<configkey>JSF-61_a</configkey>
<name><![CDATA[ 左边大括号 '{' 应该单独显示在一行上 [JSF-61_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
左边大括号 '{' 应该单独显示在一行上 [JSF-61_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查左边的大括号显示在一行上. 
参见: FORMAT-03, FORMAT-34


例外:

规则不遵守枚举，初始化和空的块。
enum E {EN1 = 2, EN2 = 1};  // OK
int array[] = {1,2,3,4,5};  // OK
class FooBar{};             // OK



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了可阅读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A1
{ int a;                      // 违规
};

struct S1 {                   // 违规
    int a;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A1
{
    int a;                    // OK
};

struct S1
{                             // OK
    int a;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>


1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 6 Style Classes - 6.3 Compound Statements- Rec. 24

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.9 Style, AV Rule 61

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-61_b</key>
<configkey>JSF-61_b</configkey>
<name><![CDATA[ 右边大括号 '{' 应该单独显示在一行上 [JSF-61_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
右边大括号 '{' 应该单独显示在一行上 [JSF-61_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测大括号 "}" 独自显示在一行。
参见: FORMAT-02, FORMAT-34


例外:

规范对于枚举, 初始化和空区块排除检查.
它允许在以下的情况时同一行在 '}' 之后放置标识符：
- '}' 结束 'do-while' 构造
- '}' 结束 class/structure/union/enum 的声明



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高可读性及维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo(int i)
{
    if (i == 0) { return i; }   // 违规
    do { i++; } while (i &lt; 10); // 违规
}

struct S{ int i; float f; }ss;  // 违规      



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo(int i)
{
    if (i == 0)
    {
    	return i;
    }   // OK
    do
    {
    	i++;
    } while (i &lt; 10); // OK - Exception
}

struct S
{
    int i;
    float f;
}ss;                   // OK - Exception

enum E {EN1 = 2, EN2 = 1};  // OK - Exception
int array[] = {1,2,3,4,5};  // OK - Exception
class FooBar{};             // OK - Exception



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 6 Style Classes - 6.3 Compound Statements- Rec. 24

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.9 Style, AV Rule 61

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-62</key>
<configkey>JSF-62</configkey>
<name><![CDATA[ 解引用操作符 '*' 和地址操作符 `&' 应直接与类型名连接在一起 [JSF-62] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
解引用操作符 '*' 和地址操作符 `&amp;' 应直接与类型名连接在一起 [JSF-62-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"解引用操作符 * 和地址运算符 &amp; 应该
直接连接在声明和定义的类型名."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范使代码的可读性更好。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int k=42;
    int *p1;	// 违规
    int &amp;r1 = k;// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int k=42;
    int* p2;	// OK
    int&amp; r2 = k;// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel 编程规范 
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#6.5">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#6.5</A>
  出自: 6 Style - 6.4 Pointers and References - Rec. 26

2.联合攻击战斗机, 飞行器, C++ 编程规范
  第 4.9 章节 Style, AV Rule 62

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-63_a</key>
<configkey>JSF-63_a</configkey>
<name><![CDATA[ 在 '.' 或 '->' 操作符之后不能有空白格 [JSF-63_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 '.' 或 '-&gt;' 操作符之后不能有空白格 [JSF-63_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测在 '.' 或 '-&gt;' 操作符后是否存在空格.
参见: FORMAT-18



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这促进了操作符和成员/对象之
间关系的连续性. 这些操作符是
为了访问成员/对象使用而不能分开考虑.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct MyStruct {
   int x;
};

void foo(struct MyStruct* myObjPtr) {
    struct MyStruct myObj;
    myObj. x;     /* 违规 */
    myObjPtr-&gt; x; /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct MyStruct {
   int x;
};

void foo(struct MyStruct* myObjPtr) {
    struct MyStruct myObj;
    myObj.x;     /* OK */
    myObjPtr-&gt;x; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel 编程规范 
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
  出自: 6 Style - 6.7 Miscellaneous - Rec. 27

2.联合攻击战斗机, 飞行器, C++ 编程规范
  第 4.9 章节 Style, AV Rule 63

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-63_b</key>
<configkey>JSF-63_b</configkey>
<name><![CDATA[ 在 '.' 或 '->' 操作符之前不能有空白格 [JSF-63_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 '.' 或 '-&gt;' 操作符之前不能有空白格 [JSF-63_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测在特定行的 '.' 或 '-&gt;' 操作符前是否存在空格.
参见: FORMAT-17



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这促进了操作符和成员/对象之
间关系的连续性. 这些操作符是
为了访问成员/对象使用而不能分开考虑.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct MyStruct {
   int x;
};

void foo(struct MyStruct* myObjPtr) {
    struct MyStruct myObj;
    myObj .x;     /* 违规 */
    myObjPtr -&gt;x; /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct MyStruct {
   int x;
};

void foo(struct MyStruct* myObjPtr) {
    struct MyStruct myObj;
    myObj.x;     /* OK */
    myObjPtr-&gt;x; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel 编程规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
  出自: 6 Style - 6.7 Miscellaneous - Rec. 27

2.联合攻击战斗机, 飞行器, C++ 编程规范
  第 4.9 章节 Style, AV Rule 63

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-63_c</key>
<configkey>JSF-63_c</configkey>
<name><![CDATA[ 在前缀一元运算符及其操作之间不能有空格 [JSF-63_c] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在前缀一元运算符及其操作之间不能有空格 [JSF-63_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测在前缀一元运算符和操作数
间没有存在空格. 这促进了操作符和其
操作数之间关系的连续性. 这些操作符
只在他们的操作数上运作而不能分开考虑.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int i=0;
    -- i;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int i=0;
    --i;   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 63

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-63_d</key>
<configkey>JSF-63_d</configkey>
<name><![CDATA[ 在后缀一元运算符及其操作之间不能有空格 [JSF-63_d] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在后缀一元运算符及其操作之间不能有空格 [JSF-63_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测在后缀一元运算符和操作数
间没有存在空格. 这促进了操作符和其
操作数之间关系的连续性. 这些操作符
只在他们的操作数上运作而不能分开考虑.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   int y = 0;
   y ++;       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   int y = 0;
   y++;        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV Rule 63

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-67_a</key>
<configkey>JSF-67_a</configkey>
<name><![CDATA[ 避免"public"数据成员 [JSF-67_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免"public"数据成员 [JSF-67_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则能检测出"public"数据成员被不受信任代码
访问的情况。
参见：OOP-19



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则会跳过'static const'变量的检查。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
防止使用"public"数据成员。公有数据成员
可以被任何用户代码直接访问。
使用公有存取成员函数返回数据能防止未经
授权的访问。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    int iData;      // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
private:
    int iData;      // OK
public:
    const int accessiData( ); 
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
  摘自：第7章 类 - 7.1与访问权限相关的考虑 - 第22条规则

2.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)2005 Pearson Education. Inc.,
  章节：“类设计及继承”，第41条规则

3.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,  第4章，第22项

4.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“类和函数：设计与声明”，第20项

5.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第67条

6. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-67_b</key>
<configkey>JSF-67_b</configkey>
<name><![CDATA[ 避免'protected'数据成员 [JSF-67_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免'protected'数据成员 [JSF-67_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查"protected"数据成员的用法。
参见：OOP-18



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则将跳过对'static const'变量的检查。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用"protected"数据成员。保护数据
成员，当在其类中不可访问时，能被使用继承
的不受信任类直接访问。使用保护存取成员函
数能防止未经授权的访问。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
protected:
    int iProtectedData;  // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
private:
    int iPrivateData;
protected:
    const int accessData();  // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C) 2005 Pearson Education, Inc.
  第4章，第22项

2.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C) 2005 Pearson Education, Inc.
  章节：“类设计及继承”，第41条规则

3.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
  摘自：第7章 类 - 7.1 与访问权限相关的考虑 - 第22条规则

4.JOINT STRIKE FIGHTER， AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第67条

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-68</key>
<configkey>JSF-68</configkey>
<name><![CDATA[ 未在类中声明复制构造函数以及拷贝赋值运算符为私有，而在特殊设计的基类型中进行声明 [JSF-68] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
未在类中声明复制构造函数以及拷贝赋值运算符为私有，而在特殊设计的基类型中进行声明 [JSF-68-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“通过在经特殊设计能防止复制的基类型中声明复制
析构函数以及拷贝赋值运算符能将连接时错误上移至
编译时错误（这是有好处的，尽早发现错误比晚期发
现错误更好）。
这样的做法是管用的，因为编译器会试图为试图拷贝
类对象的类生成复制构造函数以及拷贝赋值运算符 -
即使是成员或友元函数”
参见：CODSTA-CPP-02，CODSTA-CPP-19，CODSTA-CPP-21，
         CODSTA-CPP-24，MRM-04，MRM-05，MRM-37，MRM-38，
         MRM-40，MRM-47，MRM-48，OOP-27，OOP-34



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“编译器生成的这些函数会试图调用与其基类型对应
的函数，这些调用将会被拒绝，因为在基类型中复制
操作是私有的”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class HomeForSale {
    public:
        HomeForSale();
    private:
        HomeForSale(const HomeForSale&amp;);            // Violation
        HomeForSale&amp; operator=(const HomeForSale&amp;);  // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Uncopyable {
    protected: 
        Uncopyable() {} 
        ~Uncopyable() {} 
    private:
        Uncopyable(const Uncopyable&amp;);              // OK
        Uncopyable&amp; operator=(const Uncopyable&amp;);   // OK
};

class HomeForSale2 : private Uncopyable { };    



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  第2章，第6项

2.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第68条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-69</key>
<configkey>JSF-69</configkey>
<name><![CDATA[ 成员函数应该被尽可能的声明为 const [JSF-69] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
成员函数应该被尽可能的声明为 const [JSF-69-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"const是值得的，有效的，高度推荐的。
理解在何处以及如何一个程序的状态改变是至关重要的，同时const
直接地书写在代码中，使编译器可以帮助其确保为不变。
如果你发现无法使成员函数为 const, 你通常会获得
对成员函数可能修改的一个对象状态的途径的更好的理解和
信息。"
参见: CODSTA-CPP-78



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"书写const可以帮助你获得对你设计的更好的理解
并确保你的代码强健和安全."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
     int foo(int a)  // 违规
     {
         return a;
     }	
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
     int foo(int a) const  // OK
     {
         return a;
     }	
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Coding Style", Rule 15

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Functions, AV Rule 69

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-70.1</key>
<configkey>JSF-70.1</configkey>
<name><![CDATA[ 释放的内存在任何情况下都不能访问。析构函数不能人工调用 [JSF-70.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
释放的内存在任何情况下都不能访问。析构函数不能人工调用 [JSF-70.1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"There are three major kinds of invalid objects:
- Destroyed objects: Typical examples are automatic objects that have gone out
  of scope and deleted heap-based objects.
- Semantically invalidated objects: Typical examples include dangling pointers
  to deleted objects (e.g., a pointer p after a delete p;) and invalidated 
  iterators. It is generally undefined and unsafe to do anything except assign
  another valid value to an invalidated object.
- Objects that were never valid.
Be aware of object lifetimes and validity. Never dereference an invalid iterator
or pointer. Don't make assumptions about what delete does and doesn't do; 
freed memory is freed, and shouldn't be subsequently accessed under
any circumstances. Don't try to play with object lifetime by calling
the destructor manually (e.g. obj.~T())."

The rule reports violations on the use of pointers to deleted objects
and on explicit calls of destructors.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule checks only simple cases (use of variables, parameters, 
a[b], a.b, a-&gt;b, or *a expressions after they were deleted).
The rule does not check a flow. It assumes that pointer to deleted object
is used if between 'delete' and an use of that pointer there is no
'case', 'default', 'break', 'return', 'throw', 'goto', exit(), abort().



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents writing unsafe and error prone code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
	A();
    ~A();
};

void foo1( ) {
    A obj;
    obj.~A( );        // Violation
}

char* foo2( ) {	
    char * a = new char;
    delete a;
    return a;         // Violation
};

char* foo3(char * ptr){
    char * a = new char;
    if(a &gt; ptr){
        delete a;
        (*a)++;       // Violation
    } else {
    	(*a)++;       // OK
    }
    a = ptr + 1;
	return a;     // OK
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Don't use invalid objects.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Type Safety", Rule 99

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.10 Classes, AV Rule 70.1

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-71</key>
<configkey>JSF-71</configkey>
<name><![CDATA[ 公共的(public)和被保护的(protected)方法不应被类的构造函数调用 [JSF-71] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
公共的(public)和被保护的(protected)方法不应被类的构造函数调用 [JSF-71-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范的目的是预防未经完全初始化的
对象被使用. 当构造类包含了公有或受
保护的方法其对象得到充分初始化为方
法调用的先决条件.
如果构造类包含了公有或受保护的方法
规范会报告违例.
参见: OOP-16, INIT-06



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

公有方法 (有时受保护方法也是) 会假设对象和
类变量在调用前已设置和初始化. 因此,
在对象构造期间调用这些方法将有造成使用这
些未初始化的对象或不正确数据的风险因为类
变量的内容在对象完全构造前并不能保证.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
  public:
    A();
    void foo();
  private:
    int obj1;
};


A::A()
{
  foo();    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要从构造函数调用公有或受保护方法.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.10 章节 Classes, AV 第 71 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-71.1</key>
<configkey>JSF-71.1</configkey>
<name><![CDATA[ 避免调用构造函数和析构函数中的虚拟函数 [JSF-71.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免调用构造函数和析构函数中的虚拟函数 [JSF-71.1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在构造函数和析构函数中，虚拟函数并不体现出
“虚拟”的特征。当在执行构造函数时调用，虚
拟函数将总是表现为构造函数的类型。这一事实
也同样适用于析构函数。更进一步而言，构造函
数对一个纯虚拟函数的调用将造成未定义行为。

因此，总的而言，在构造函数和析构函数中调用
虚拟函数是很容易引发错误的，并且可能引起从
内存泄漏到程序崩溃等一系列问题。

在这些情况下使用不同方式调用虚拟函数很大程
度上包括对后置构造函数调用的需求：
-为代码中的客户端记录需求
-在第一次调用成员函数的时候调用后置构造函数
-使用工厂函数以确保正确的初始化顺序



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升代码的可靠性以及可维护性，并可能查找出
应用程序中的运行时缺陷。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {
public:
    Base( ) {
    	init_Base( );          // Violation
    }
    virtual void init_Base( );
};

class Derived : public Base {
    Derived* derived;
public:
    Derived( ) {
    	init_Base( );           // Violation
    	init_Derived1( );       // Violation
    	this-&gt;init_Derived2( ); // Violation
    }
    virtual void init_Derived1( );
    virtual void init_Derived2( );
};

void Base::init_Base(){}
void Derived::init_Derived1( ) {}
void Derived::init_Derived2( ) {}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    Base( ) {
    	Base::init_Base( );        // OK
    }
    virtual void init_Base( );
};

class Derived : public Base {
    Derived* derived;
public:
    Derived( ) {
    	Base::init_Base( );        // OK
    	Derived::init_Derived1( ); // OK
    	derived-&gt;init_Derived2( ); // OK
    }
    virtual void init_Derived1( );
    virtual void init_Derived2( );
};

void Base::init_Base(){}
void Derived::init_Derived1( ) {}
void Derived::init_Derived2( ) {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)2005 Pearson Education. Inc.,
  章节：“构造，析构及拷贝”，第49条规则

2.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  第2章，第9项

3.Scott Meyers与Martin Klaus，《检查C++程序分析器》
  Dr. Dobbs' Journal，1997 1月号，
  章节：“构造函数/析构函数/赋值”，第13项
  <A HREF="http://www.aristeia.com/ddjpaper1_frames.html">http://www.aristeia.com/ddjpaper1_frames.html</A>

4.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第71.1条

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-74</key>
<configkey>JSF-74</configkey>
<name><![CDATA[ 在构造函数中推荐使用初始化列表而非赋值 [JSF-74] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在构造函数中推荐使用初始化列表而非赋值 [JSF-74-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检测构造函数中是否通过赋 
值进行初始化。赋值操作可能造成 
首先调用默认构造函数，然后再执 
行赋值操作。初始化能够消除这种 
问题。 注意常量和引用只能初始 
化而不能赋值。 
参见： INIT-06, INIT-10, MISRA-030



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

改善代码一致性和运行时性能 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

class A {
public:
    A( const char* file, const char* path ) {  
        myFile = file;     // 违规
        myPath = path;     // 违规
    }
private:
    string myFile;
    string myPath;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

class A {
public:
    A( const char* file, const char* path ) : 
        myFile(file), myPath(path) {}    // OK
private:
    string myFile;
    string myPath;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Design Style", Rule 09,
   Chapter: "Construction, Destruction, and Copying", Rule 48

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   Chapter: "Constructors, Destructors, and Assignment Operators", Item 12

3. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 4

4. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.10 Classes, AV Rule 74

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-75</key>
<configkey>JSF-75</configkey>
<name><![CDATA[ 初始化列表的初始化顺序应该与其声明的顺序一致 [JSF-75] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
初始化列表的初始化顺序应该与其声明的顺序一致 [JSF-75-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“析构函数对于成员变量的析构顺序总是与构造函数 
中相反的顺序。 这样，如果成员变量的初始化顺序 
与声明时保持一致，则编译器将跟踪每个对象的成 
员变量，以确保析构函数按正确的顺序进行析构, 
这是较为昂贵的提议，为避免这样的开销，对于 
指定类型的对象，构造函数和析构函数的顺序是 
一样的，并且在初始化列表中的成员变量的顺序被忽略。”
事例代码中来自类 A 的成员变量 b 没有按我们假定的 
顺序初始化 (用相同值初始化)。
参见: INIT-06, INIT-14, MISRA-030



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防访问空指针。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( int x ) : a( x ), b( a ) {}    // 违规 - b 声明在 a 之前
private:
    int b;
    int a;
};

class B : public A {
public:
    B( int );
private:
    int a;
    float b;
};

B::B( int y ) : b( 5 ), A( 1 ), a( y ) {}   // 违规 - a 声明在 b 之前



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A( int x ) : a( x ), b( a ) {}   // OK - a 声明在 b 之前
private:
    int a;
    int b;
};

class B : public A {
public:
    B( int );
private:
    float b;
    int a;
};

B::B( int y ) : b( 5 ), A( 1 ), a( y ) {}   // OK - b 声明在 a 之前



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 4

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   Chapter: "Constructors, Destructors, and Assignment Operators", Item 13

3, JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.10 Classes, AV Rule 75

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-76_a</key>
<configkey>JSF-76_a</configkey>
<name><![CDATA[ 为动态分配内存的类定义了赋值运算符 [JSF-76_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
为动态分配内存的类定义了赋值运算符 [JSF-76_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检测使用'new'分配数据成员或者使用'delete'释放数据成员的类
是否显示地定义了经典的复制运算符。经典赋值运算符将返回类的引用类型并
且取该类的常量引用。
“复制不会像其它运算符那样被继承。如果复制运算符未被显示定义，那么将
自动为进行定义。
如果你进行了以下赋值'b=a'；（此处‘a’与‘b’都为指针）此处无法调
用客户定义的运算符=，因此C++将生成并调用默认的赋值运算符进行替代。
默认的赋值运算符将按成员进行成员'a'向成员'b'的赋值，对于指针而
言既逐位复制。这种处理方法至少有两个问题。
第一，内存'b'原始指向的内存区域未被删除；
因此，该片区域永久丢失。这是内存泄漏发生的典型示例。
第二，'a'和'b'都包含指向同一字符串的指针。
当两者之一被释放时，其析构函数将会删除另一指针仍然指向的内存区域。”
参见：CODSTA-CPP-02，CODSTA-CPP-21，CODSTA-CPP-24，MRM-04，MRM-38，
MRM-40，MRM-47，OOP-27，OOP-30，OOP-34


例外：

本规则不会报告基类型中含有赋值运算符的情况，因为这种情况阻止了类中隐式
的分配运算符的使用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“逐位复制仅对含有主类型成员数据进行。其结果之一就是逐位复制是对具有指
针类型的成员数据进行的。如果某个对象管理该指针成员指向的对象实例的分配
这将很有可能会导致问题：无论是对管理对象多次调用析构函数还是试图使用该
释放的对象。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class MyClass { // Violation
public:
    MyClass( );
    ~MyClass( ) { delete p; }
private:
    int *p;
};

MyClass::MyClass( ) {
    p = new int;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass { // OK
public:
    MyClass( );
    MyClass&amp; operator=( const MyClass&amp; );
    ~MyClass( ) { delete p; }
private:
    int *p;
};

MyClass::MyClass( ) {
    p = new int;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
  论坛：7 类 - 7.5赋值运算符 - 第27条规则

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“构造函数，析构函数以及赋值运算符”，第11项

3.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“构造，析构以及复制”，第53条规则

4.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第76条
   Chapter 4.10 Classes, AV Rule 76

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-76_b</key>
<configkey>JSF-76_b</configkey>
<name><![CDATA[ 为动态分配内存的类声明复制构造函数 [JSF-76_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
为动态分配内存的类声明复制构造函数 [JSF-76_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检测使用'new'分配数据成员或'delete'释放数据成员的类是否
显示定义了复制构造函数。
参见：CODSTA-CPP-19，MRM-05，MRM-37，MRM-40，MRM-48，OOP-27，OOP-30，OOP-34


例外：

本规则不会报告基类型中有复制构造函数的情况，因为这种情况会阻止使用
隐式声明的复制构造函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“推荐复制构造函数避免相同类型的对象初始化另一对象的不可预知情况。
如果某个对象管理堆中的对象的分配以及释放（管理对象含有一个指向该类
的构造函数创建的对象的指针），那么复制操作将仅对指针的值进行。这可
会对同一对象（该堆中）调用两次析构函数，可能会造成运行时错误”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class MyClass{ // Violation
public:
    MyClass();
    ~MyClass(){ delete p; }
private:
    int *p;
};

MyClass::MyClass() {
    p = new int;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass{ // OK
public:
    MyClass();
    MyClass(MyClass&amp;);
    ~MyClass(){ delete p; }
private:
    int *p;
};

MyClass::MyClass() {
    p = new int;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
  论坛：7 类 - 7.5 构造函数和析构函数 - 第25规则

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc., 
  章节：“构造函数，析构函数以及赋值运算符”第11项

3.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)Pearson Education, Inc.,
  章节：“构造，析构以及复制”第53条规则

4.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第76条

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-77</key>
<configkey>JSF-77</configkey>
<name><![CDATA[ 复制构造函数应复制所有的数据成员以及基类型 [JSF-77] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
复制构造函数应复制所有的数据成员以及基类型 [JSF-77-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类可能含有很多数据成员以及存在于继承的层次结构中。
因此复制构造函数必须复制所有的成员，包括其中的基类
型。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
确保在复制对象时能够正确地处理数据成员以及基类型。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base
{
	public:
		Base();
		Base (int x) : base_member (x) { }
		Base (const Base&amp; rhs) : base_member (rhs.base_member) {}
	private:
		int base_member;
};

class Derived : public Base
{
	public:
		Derived (int x, int y, int z) : Base (x),
		derived_member_1 (y),
		derived_member_2 (z) { }
		
		Derived(const Derived&amp; rhs)  // Violation
		{
		}
	
	private:
		int derived_member_1;
		int derived_member_2;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base
{
	public:
		Base();
		Base (int x) : base_member (x) { }
		Base (const Base&amp; rhs) : base_member (rhs.base_member) {}
	private:
		int base_member;
};

class Derived : public Base
{
	public:
		Derived (int x, int y, int z) : Base (x),
		derived_member_1 (y),
		derived_member_2 (z) { }
		
		Derived(const Derived&amp; rhs) : Base(rhs),             // OK
		derived_member_1 (rhs.derived_member_1),
		derived_member_2 (rhs.derived_member_2) 
		{
		}
	
	private:
		int derived_member_1;
		int derived_member_2;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
   第4.10章 类，AV规则第77条

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-77.1</key>
<configkey>JSF-77.1</configkey>
<name><![CDATA[ 构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的拷贝构造函数完全一样的签名 [JSF-77.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的拷贝构造函数完全一样的签名 [JSF-77.1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

成员函数的定义不应包含默认参数生成和相应
的类 / 结构体中隐形声明的拷贝构造函数一样
的参数签名.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果在类定义中没有明确声明拷贝构造函数,
将有一个隐式声明. 因此, 针对类定义而言
class X 
{
   X(const X&amp;, int);
};

拷贝构造函数会被隐式声明. 如果后来客制
化构造函数如

X::X(const X&amp; x, int i =0) 
{ 
   /* ... */ 
}

则 X 类拷贝构造函数的使用将是非法因为模糊不清.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
	A(const A&amp;, int);
	A(const A&amp;);
};

A::A(const A&amp; x, int i =0) // 违规
{
	 /* ... */ 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
	A(const A&amp;, int i=0);
	A(const A&amp;);
};

A::A(const A&amp; x, int i) // OK
{
	 /* ... */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.10 章节 Classes, AV 第 77.1 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-78</key>
<configkey>JSF-78</configkey>
<name><![CDATA[ 在含有虚拟函数的基类型中使用的类应定义虚拟析构函数 [JSF-78] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在含有虚拟函数的基类型中使用的类应定义虚拟析构函数 [JSF-78-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有用作基类型并且含有虚拟函数的类
必须定义相应的虚拟析构函数。如果某
类含有虚拟函数但却没有虚拟析构函数
被用作了基类型，那么当使用指向该类
的指针时将会发生意外情况。如果将这
样的指针赋值给一个衍生类的实例并且
对该指针进行了删除操作，那么将仅调
用该基类型的析构函数。如果程序的运
行与否取决于该衍生类的析构函数，那
么该程序将无法运行。
参见：OOP-23，OOP-24，OOP-31



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

为了防止数据崩溃应定义一个虚拟析构
函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base            // Violation
{
    public:
        virtual void foo( );
        ~Base( );
};

class Derived : public Base{};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base           // OK
{
    public:
        virtual void foo( );
        virtual ~Base( );
};

class Derived : public Base{};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
 摘自：第7章 类 - 7.5 构造函数和析构函数 - 第26条规则

2.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第78条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-79</key>
<configkey>JSF-79</configkey>
<name><![CDATA[ 在析构函数中调用fclose()函数来关闭用于打开文件的指针成员 [JSF-79] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在析构函数中调用fclose()函数来关闭用于打开文件的指针成员 [JSF-79-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则报告在构造函数中使用指针成员打开文件并且
该文件在析构函数中未被关闭的违规。
参见：MRM-33



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防资源泄漏，尤其是在出现错误的情况下。
在析构函数中释放资源为资源管理提供了一种便捷的方法，
尤其针对一些例外情况。而且，如果存在某个资源泄漏的可
能性，那么该资源应该在自动清除该资源的析构函数的类中
被包裹起来。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class File_ptr
{ 
	public:
		File_ptr (const char *n, const char * a) 
		{ 
			p = fopen(n,a); 
		}
		
		
		~File_ptr ()                  // Violation
		{
		}

	private:
		FILE *p;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class File_ptr
{ 
	public:
		File_ptr (const char *n, const char * a) 
		{ 
			p = fopen(n,a); 
		}
		
		
		~File_ptr ()            // OK
		{
			if (p)
			{
				fclose(p);
			}
		}

	private:
		FILE *p;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
   第4.10章 类， AV规则第79条

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-81</key>
<configkey>JSF-81</configkey>
<name><![CDATA[ 在运算符=中检查自身赋值操作 [JSF-81] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在运算符=中检查自身赋值操作 [JSF-81-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查代码中赋值运算符中使用的别名。不对
=运算符的自身赋值进行检查会释放资源，而这些资
源在分配新资源过程中可能会被用到。
参见：CODSTA-CPP-02，CODSTA-CPP-21，CODSTA-CPP-24，
      MRM-04，MRM-37，MRM-40，MRM-47，OOP-27，OOP-30



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

检查自身赋值的情况可能帮助您节省很多在实现赋值时
不得不做的工作。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A  {
public:
    A( ) { }
    A&amp; operator=( A&amp; a ) {  // Violation
        return *this;
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A  {
public:
    A( ) { }
    A&amp; operator=( A&amp; a ) {  // OK
        if (&amp;a != this) {
            // ...
        }
        return *this;
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   第2章，第11项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   章节：“构造函数，析构函数以及赋值运算符”，第17项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第81条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-82</key>
<configkey>JSF-82</configkey>
<name><![CDATA[ 使赋值操作符返回一个 *this 指向的引用；且其返回类型是指向自身类类型的非 const 引用 [JSF-82] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使赋值操作符返回一个 *this 指向的引用；且其返回类型是指向自身类类型的非 const 引用 [JSF-82-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规范确保赋值操作符的返回类型是一个指向 
自身类型的非 const 引用或返回一个指向
*this 的引用。 赋值操作符operator= 返
回一个指向 *this 的引用将使你不用知道其
在哪里销毁而允许你声明 operator= 的参数
为一个指向 const 类型的引用，这样会比仅
仅声明为一个引用更安全。 
参见: CODSTA-CPP-21, CODSTA-CPP-24, MRM-04, MRM-37, MRM-40, MRM-47, OOP-27,
          OOP-30, OOP-34



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

 赋值操作符operator= 返回一个指向 *this 的引用将
使你不用知道其在哪里销毁而允许你声
明 operator= 的参数为一个指向 const 类型的引用，
这样会比仅仅声明为一个引用更安全。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( ) { }
    void operator=( A&amp; a ) {         // 违规
        return;
    }
};
class C {
public:
    C( ) { }
    C operator=( C&amp; c ) {            // 违规
        C *cp;
        return *cp;
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A( ) { }
    A&amp; operator=( A&amp; a ) {           // OK
        return *this;
    }
};
class C {
public:
    C( ) { }
    C&amp; operator=( C&amp; c ) {           // OK
        return *this;
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 章节 3, 项 15

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc.,
   章节: "Constructors, Destructors, and Assignment Operators", Item 15

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   章节 4.10 Classes, AV Rule 82

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-83</key>
<configkey>JSF-83</configkey>
<name><![CDATA[ 赋值运算符必须对所有成员，包括基类型中的成员进行赋值 [JSF-83] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
赋值运算符必须对所有成员，包括基类型中的成员进行赋值 [JSF-83-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在继承的层次结构中，某个特定类可能含有很多数据成员。
因此，其赋值运算符必须对所有的成员，包括基类型中的成
员赋值。
本规则报告未调用基类型赋值运算符或者基类型的成员变量
未在衍生类的赋值运算符中进行赋值的违规。
参见：INIT-11



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在operator=function中对所有成员变量进行赋值以预防数
据崩溃。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned int int32;

class Base
{
public:
    Base (int32 x) : base_member (x) {}
    Base &amp;operator=(const Base&amp; rhs)
    {
        if (this != &amp;rhs)
        {
            base_member = rhs.base_member;
        }
        else
        {
        }
        return *this;
    }
private:
    int32 base_member;
};


class Derived : public Base
{
public:
    Derived (int32 x, int32 y, int32 z) : Base (x),
        derived_member_1 (y),
        derived_member_2 (z) {}
    Derived&amp; operator=(const Derived&amp; rhs)           // Violation
    {
        if (this != &amp;rhs)
        {
            derived_member_1 = rhs.derived_member_1;
            derived_member_2 = rhs.derived_member_2;
        }
        else
        {
        }
        return *this;
    }
private:
    int32 derived_member_1;
    int32 derived_member_2;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned int int32;

class Base
{
public:
    Base (int32 x) : base_member (x) {}
    Base &amp;operator=(const Base&amp; rhs)
    {
        if (this != &amp;rhs)
        {
            base_member = rhs.base_member;
        }
        else
        {
        }
        return *this;
    }
private:
    int32 base_member;
};


class Derived : public Base
{
public:
    Derived (int32 x, int32 y, int32 z) : Base (x),
        derived_member_1 (y),
        derived_member_2 (z) {}
    Derived&amp; operator=(const Derived&amp; rhs)
    {
        if (this != &amp;rhs) // Check for self-assignment
        {
            Base::operator=(rhs);                            // OK
            derived_member_1 = rhs.derived_member_1;
            derived_member_2 = rhs.derived_member_2;
        }
        else
        {
        }
        return *this;
    }
private:
    int32 derived_member_1;
    int32 derived_member_2;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
   第4.10章 类，AV规则第83条

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-85</key>
<configkey>JSF-85</configkey>
<name><![CDATA[ 当两个操作符作用相反的时候(例如 == 和 !=)，两个都应该定义 [JSF-85] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当两个操作符作用相反的时候(例如 == 和 !=)，两个都应该定义 [JSF-85-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当类的对象通过相应操作符与另一个类进行 
运算时，同样需要实现其针对该类相对应的操作符。 
一个很好的例子是操作符 ==，其相反操作符是 !=， 
当操作符 == 被定义时，!= 操作符同样需要被定义。"

该规划预防：
- '==' 操作符没有 '!=' 操作符
- '&lt;=' 操作符没有 '&gt;=' 操作符
- '&lt;' 操作符没有 '&gt;' 操作符
- '++' 操作符没有 '--' 操作符
- '+' 操作符没有 '-' 操作符
- '&lt;&lt;' 操作符没有 '&gt;&gt;' 操作符
- '&amp;&amp;' 操作符没有 '||' 操作符



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规范可提高代码可读性和代码可维护性并 
防止误解重载操作符的含义。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C { // 违规
public:
    bool operator&lt;=( C&amp; c );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C { // OK
public:
    bool operator&lt;=( C&amp; c );
    bool operator&gt;=( C&amp; c );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 7 Classes - 7.7 Operator Overloading - Rec. 36

2. 联合攻击战斗机，飞行器， C++ 编码规范
   章节 4.10 Classes, AV 规则 85

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-87</key>
<configkey>JSF-87</configkey>
<name><![CDATA[ 层次结构应该基于抽象类 [JSF-87] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
层次结构应该基于抽象类 [JSF-87-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

公有的继承层次结构应该从抽象类开始。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

基于抽象类的层次结构倾向于关注能够生
成干净接口的设计，将实现细节从接口中
剥除，并且能减小编译的依赖性同时允许
与不同实现的共存。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B
{
};

class A: public B // Violation
{

};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B
{
public:
  virtual int foo()=0;
  /* ... */
};


class A: public B // OK
{
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
第4.10章，AV规则第87条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-88.1</key>
<configkey>JSF-88.1</configkey>
<name><![CDATA[ 有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明 [JSF-88.1] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明 [JSF-88.1-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有状态的虚拟类应该在每个访问该类的衍生类中进行
显式地声明。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“在层次结构（使用该类）的每个级别上显式地声明
有状态的虚拟类，值得指出的是，不应对独占使用虚
拟类中的数据作出任何的假设。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class AA {};
class BB : virtual AA {};
class CC : virtual AA {};
class DD : BB{};          // Violation
class EE : CC{};          // Violation
class FF : DD{};          // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class AA {};
class BB : virtual AA {};
class CC : virtual AA {};
class DD : BB, virtual AA {};     // OK
class EE : CC, virtual AA {};     // OK
class FF : DD, EE, virtual AA {}; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范 
   第4.10章 类，AV规则第88.1条

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-89</key>
<configkey>JSF-89</configkey>
<name><![CDATA[ 在同一层次结构中，基类型不能同时具有虚拟及非虚拟的属性 [JSF-89] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在同一层次结构中，基类型不能同时具有虚拟及非虚拟的属性 [JSF-89-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在同一层次结构中一个基类型不能同时具有虚拟
及非虚拟的属性。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

层次结构更易于理解及使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
class B : virtual A {};
class C : B, A {};           // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {};
class B : virtual A {};
class C : B, virtual A {};   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第89条

2.MISRA C++：2008 - 在关键系统中使用C++语言的准则
  第6章，第10节，第10-1-3规则

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-9</key>
<configkey>JSF-9</configkey>
<name><![CDATA[ 只能使用定义在 ISO C 标准里的字符 [JSF-9] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只能使用定义在 ISO C 标准里的字符 [JSF-9-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只能使用定义在 ISO C 标准里的那些 
字符和转义序列。

第 5.2.1 章节的 ISO C 标准定义了 91 个字符，
这个是所有编译器最低的源字符集
这些是唯一应使用的字符，
即使编译器支持一个更大的字符集，
或支持其他的字符集。

这些字符是:
- 拉丁字母里的 26 个大写字母
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z

- 拉丁字母里的 26 个小写字母
a b c d e f g h i j k l m
n o p q r s t u v w x y z

- 10 个十进位数字
0 1 2 3 4 5 6 7 8 9

- 以下的 29 图形字符
!"#%&amp;' ()*+,-./:
;&lt;=&gt;?[\]^_{|}~
空格字符和控制字符代表 
水平制表符，垂直制表符， 换页。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

只需要最少的字符集



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    char c1 = '$';  /* 违规 */
    char c2 = '`';  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用没有定义在 ISO C 标准里的字符。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 5 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.4 章 Environment， AV 第 9 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-94_a</key>
<configkey>JSF-94_a</configkey>
<name><![CDATA[ 禁止对继承的非虚拟函数进行重定义 [JSF-94_a] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对继承的非虚拟函数进行重定义 [JSF-94_a-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“非虚拟函数是静态约束的。从本质上讲，非虚拟函数
会隐藏起相应的基类型版本。因此，某个特定的衍生类
对象将表现为一个基类型对象或者一个取决于其访问方
式的衍生类对象 - 通过基类型指针/引用或者衍生类的
指针/引用。为了避免出现具有二元性的行为，禁止对非
虚拟函数进行重定义。”
参见：OOP-33



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
本规则报告无模板参数的函数的违规。
OOP-33规则报告具有模板参数的函数的违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止对调用函数的错误解释。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base
{
    public:
        void func1(void) {};
        void func2(int x) {};
        void func3(int x) {};
};

class Derived: public Base
{
    public:
        void func1(void) {};    // Violation
        void func2(int x) {};   // Violation
        void func3(int x) {};   // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base
{
    public:
        virtual void func1(void) {};
        virtual void func2(int x) {};
        void func3(int x) {};
};

class Derived: public Base
{
    public:
        virtual void func1(void) {};    // OK
        virtual void func2(int x) {};   // OK
        void func3_renamed(int x) {};   // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  第6章，第36项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  章节：“继承与面向对象的设计”，第37项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章，类，AV规则第94条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-94_b</key>
<configkey>JSF-94_b</configkey>
<name><![CDATA[ 禁止对含有模板参数的继承非虚拟函数进行重定义 [JSF-94_b] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对含有模板参数的继承非虚拟函数进行重定义 [JSF-94_b-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“非虚拟函数是静态约束的。从本质上讲，非虚拟函数
会隐藏其相应的基类型版本。因此，某个特定的衍生类
对象可能表现为一个基类型对象或者取决于其访问方式
的衍生类对象 - 通过基类型指针/引用或者衍生类指针/引用。
为了避免这种具有二义性的行为，禁止对虚拟函数进行
重定义。”
参见：OOP-32



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
本规则报告具有模板参数的函数的违规。
OOP-32规则报告无模板参数的函数的违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则预防对调用函数进行错误解释。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template &lt;class T&gt; class Base
{
    public:
        void foo1(T i) {}
        void foo2(T i) {}
        void foo3(T i) {}
};

template &lt;class T&gt; class Derived : public Base &lt;T&gt;
{
    public:
        void foo1(int i) {} // Violation
        void foo2(T i) {}   // Violation
        void foo3(T i) {}   // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

template &lt;class T&gt; class Base
{
    public:
        virtual void foo1(T i) {}
        virtual void foo2(T i) {}
        void foo3(T i) {}
};

template &lt;class T&gt; class Derived : public Base &lt;T&gt;
{
    public:
        virtual void foo1(int i) {} // OK
        virtual void foo2(T i) {}   // OK
        void foo3_renamed(T i) {}   // OK
};


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  第6章，第36项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  章节：“继承与面向对象的设计”，第37项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第94条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-95</key>
<configkey>JSF-95</configkey>
<name><![CDATA[ 禁止对继承的虚拟函数重定义为不同的默认参数值 [JSF-95] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对继承的虚拟函数重定义为不同的默认参数值 [JSF-95-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“虚拟函数是被动态约束的，但是默认参数却为静态约束。
这意味着您可能会使用基类型中的默认参数调用衍生类中的
虚拟函数。”
本规则能检测出将继承的虚拟函数被重定义为不同的默认参
数值的情况。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则不检测一下情况：
-具有模板参数的函数
-默认参数值为非常数
-具有复杂表达式的默认参数值



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能预防对默认传递的参数进行错误解释的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base
{
public:
    virtual void func(int i = 1);
};

class Derived: public Base
{
public:
    virtual void func(int i = 0);  // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base
{
    public:
        virtual void func1(int i = 1);
        virtual void func2(int i = 1);
};

class Derived: public Base
{
    public:
        virtual void func1(int i);      // OK
        virtual void func2(int i = 1);  // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   第6章，第37项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“继承与面向对象的设计”，第38项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第95条

4.MISRA C++：2008 - 在关键系统中使用C++语言的准则
  第6章，第8节，第8-3-1条规则

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-96</key>
<configkey>JSF-96</configkey>
<name><![CDATA[ 不要将数组视为多态的 [JSF-96] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要将数组视为多态的 [JSF-96-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"数组被不适调整: 视多态数组是一种严重的 
类型错误而编译器也许只会无视这问题.
别跌入陷阱."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范预防造成代码问题的痛苦. 
数组操作几乎都是包含指针运算, 
所以数组和多态不能混合使用.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class BST {
public:
    void cleanBSTArray(BST array[], int numElements)
    {
        for (int i = 1; i &lt; numElements; ++i) 
        {
            array[i] = array[0];              
        }                             
    }                               
	
    void deleteArray(BST array[])
    {
        delete [] array;
    }
};

class BalancedBST: public BST {};

void foo()
{
    BalancedBST *p;
    BST BSTArray[10];
    BalancedBST bBSTArray[10];
	
    p-&gt;cleanBSTArray(bBSTArray, 10);   // 违规
    p-&gt;deleteArray(bBSTArray);         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class BST {
public:
    void cleanBSTArray(BST array[], int numElements)
    {
        for (int i = 1; i &lt; numElements; ++i) 
        {
            array[i] = array[0];              
        }                             
    }                               
	
    void deleteArray(BST array[])
    {
        delete [] array;
    }
};

class BalancedBST: public BST {};

void foo()
{
    BalancedBST *p;
    BST BSTArray[10];
    BalancedBST bBSTArray[10];
	
    p-&gt;cleanBSTArray(BSTArray, 10);    // OK
    p-&gt;deleteArray(BSTArray);          // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编程规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Type Safety", 第 100 规则

2. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: "Basics", 第 3 项

3. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.10 章节 Classes, AV 第 96 规则

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-97</key>
<configkey>JSF-97</configkey>
<name><![CDATA[ 在接口中不应该使用数组类型参数 [JSF-97] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在接口中不应该使用数组类型参数 [JSF-97-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在公共方法中不应该使用数组类型参数。
反而，用该使用数组类。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则定义接口作为一个公共方法。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

当作为参数时，数组退化成指针。
"数组 衰退" 长期以来认识到问题的来源。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Sample
{
  public:
    void foo(int a[]); //违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Array
{
  /* Array implementation*/
};


class Sample
{
  public:
    void goo(Array a); // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编码规范
第4.10章 Classes, AV 第97条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-98</key>
<configkey>JSF-98</configkey>
<name><![CDATA[ 避免在文件中使用命名空间外的全局变量，全局函数，和类 [JSF-98] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在文件中使用命名空间外的全局变量，全局函数，和类 [JSF-98-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测命名空间外的全局变量，
类，和全局函数的使用。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用命名空间外的全局变量，类，和全局函数。
一个文件中的所有数据和函数都应该在一个或多个
命名空间的内部。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int var = 0;        // 违规

void globalfoo( ) { // 违规
}

class A {           // 违规
    int i;
    void foo( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace name1 {
    int var = 0;        // OK

    void globalfoo( ) { // OK
    }

    class A {           // OK
        int i;
        void foo();
    };
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机， 飞行器 C++ 编码规范
   章节 4.11 命名空间, AV 第98条规则

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第7节, 规则7-3-1

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>JSF-99</key>
<configkey>JSF-99</configkey>
<name><![CDATA[ 命名空间的嵌套不能超过两层 [JSF-99] ]]></name>
<tag>jsf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
命名空间的嵌套不能超过两层 [JSF-99-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

命名空间的嵌套不能超过两层。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

简洁和清晰。
深嵌套命名空间难理解和正确的使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace A
{
  namespace B
  {
  	namespace C
  	{
  		namespace D //违规
  		{
  		}
  	}
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace A
{
  namespace B
  {
  	namespace C  // OK
  	{
  	}
	namespace D // OK
	{
	}
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编码规范
第4.11章 Namespaces, AV 第99条规范

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-01</key>
<configkey>METRICS-01</configkey>
<name><![CDATA[ 避免函数超过 50 行 [METRICS-01] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid functions with over 50 lines [METRICS-01-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

If a function is too long, it can be difficult to comprehend.
The program is easier to create and to understand if it contains
functions that do not have more than 50 lines.
The rule counts lines between opening and closing brace {} of function's body.
See also: METRICS-20, METRICS-21, METRICS-22



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

The rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void too_long_function() 	// Violation
{
  int a1;
  int a2;
  int a3;
/*
 * lines of code, comment lines, empty lines
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the size of the function to 50 lines.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-02</key>
<configkey>METRICS-02</configkey>
<name><![CDATA[ 避免 switch 代码段包含过多 case [METRICS-02] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid switch statements with many cases [METRICS-02-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Many case statements makes code difficult to follow. More importantly,
switches with many cases often indicate places where polymorphic behavior could
better be used to provide different behavior for different types. 
Note that although the general principle is to avoid many cases in a switch, 
the actual cutoff point is arbitrary.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo(int i) {
      // There are over 10 cases in the switch statement.
      switch (i) {          // Violation
      case 1:
         break;
      case 2:
         break;
      case 3:
         break;
      case 4:
         break;
      case 5:
         break;
      case 6:
         break;
      case 7:
         break;
      case 8:
         break;
      case 9:
         break;
      case 10:
         break;
      case 11:
         break;
      default:
         break;
      }
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Look for cleaner ways to invoke the alternative behaviors.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-03</key>
<configkey>METRICS-03</configkey>
<name><![CDATA[ 函数内的代码块 [METRICS-03] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of blocks of code in a function [METRICS-03-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This metric measures the number of blocks of code in a function. 
Rule checks if the number of blocks within the function exceeds 10.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void func(int i) {	// Violation
  if (1) {
     // do something;
  } else {
     // do another;	
  }

  if (1) {
     // do something;
  } else {
     // do another;
  }

  if (1) {
     // do something;
  } else {
     // do another;
  }

  if (1) {
     // do something;
  } else {
     // do another;
  }
  
  if (1) {
     // do something;
  }

  do {
  } while(1);
  switch(i) {
  case 1:
    break;
  default:
    break;
  }
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

The number of blocks within the function should be limited to 10.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December 1999, pg. 34.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-04</key>
<configkey>METRICS-04</configkey>
<name><![CDATA[ 函数中有过多函数调用 [METRICS-04] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of function calls within function [METRICS-04-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Rule measures the number of calls to methods
and system functions within function.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

The rule reports a violation if the number of function calls 
within the function exceeds 10.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo {
public:
   void func1() {}	// OK
   void func2() {	// Violation
      func1();
      func1();
      func1();
      func1();
      func1();
      func1();
      func1();
      func1();
      func1();
      func1();
      func1();
  }
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of function calls within the function to 10.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December, 1999, pg. 32.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-05</key>
<configkey>METRICS-05</configkey>
<name><![CDATA[ 类的继承级别 [METRICS-05] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Class inheritance level [METRICS-05-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This metric measures the class inheritance level by calculating the number
of base classes. 
Rule triggers if the class inheritance level exceeds 10.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"An unnecessarily deep class hierarchy adds to complexity and can represent 
a poor use of the inheritance mechanism."



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Base {};			// OK
class Dev1 : public Base {};	// OK
class Dev2 : public Dev1 {};	// OK
class Dev3 : public Dev2 {};	// OK
class Dev4 : public Dev3 {};	// OK
class Dev5 : public Dev4 {};	// OK
class Dev6 : public Dev5 {};	// OK
class Dev7 : public Dev6 {};	// OK
class Dev8 : public Dev7 {};	// OK
class Dev9 : public Dev8 {};	// OK
class Dev10 : public Dev9 {};	// OK
class Dev11 : public Dev10 {};	// Violation



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit he number of base classes to 10.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December, 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-06</key>
<configkey>METRICS-06</configkey>
<name><![CDATA[ 每个函数的成员变量数不应该超过 15个 [METRICS-06] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of data member(s) per class should not exceed 15 [METRICS-06-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This metric measures the number of data members per class. 
Rule checks if number of declared data members per class exceeds 15.
See also: METRICS-17



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo { // Violation
public:
  int i1;
  int i2;
  int i3;
  int i4;
  int i5;
  int i6;

protected:
  int j1;
  int j2;
  int j3;
  int j4;
  int j5;
  int j6;
  int j7;

private:
  int k1;
  int k2;
  int k3;
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of data members to 15 per class.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December, 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-07</key>
<configkey>METRICS-07</configkey>
<name><![CDATA[ 每个类的方法数 [METRICS-07] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of methods per class [METRICS-07-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"The number of methods per class indicates the total level of functionality
implemented by a class." 
This metric measures the number of methods per class. 
Rule triggers if the number of methods per class exceeds 20.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo {	// Violation
public:
  void method1();
  void method2();
  void method3();
  void method4();
  void method5();
  void method6();

protected:
  void method7();
  void method8();
  void method9();
  void method10();
  void method11();
  void method12();

private:
  void method13();
  void method14();
  void method15();
  void method16();
  void method17();
  void method18();
  void method19();
  void method20();
  void method21();

};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of methods to 20 per class.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December, 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-08</key>
<configkey>METRICS-08</configkey>
<name><![CDATA[ 每个方法参数不应该超过10 [METRICS-08] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of parameter(s) per method should not exceed 10 [METRICS-08-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"A high number of parameters indicates a complex interface to calling objects,
and should be avoided." 
This metric measures the number of parameters in each method. 
Rule triggers if the number of parameters exceeds 10 per method.
See also: METRICS-15


</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo
{
public:
void func2(int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ); // Violation
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

// Limit the number of parameters to 10 per method.
class Foo
{
public:
   void func(int i, double d, float f, char c, Foo &amp;); // OK
};



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December, 1999, pg. 34.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-09</key>
<configkey>METRICS-09</configkey>
<name><![CDATA[ 每个类的私有成员变量数目 [METRICS-09] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of private data member(s) per class [METRICS-09-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This metric measures the number of private data members per class.
Rule triggers if the number of private data members exceeds 15 per class.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo { // Violation
private:
  int i1;
  int i2;
  int i3;
  int i4;
  int i5;
  int i6;

  int j1;
  int j2;
  int j3;
  int j4;
  int j5;
  int j6;
  int j7;

  int k1;
  int k2;
  int k3;
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of private data members to 15 per class.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-10</key>
<configkey>METRICS-10</configkey>
<name><![CDATA[ 每个类的私有方法数 [METRICS-10] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of private methods per class [METRICS-10-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"The number of methods per class indicates the total level of functionality
implemented by a class."
This metric measures the number of private methods per class. 
Rule triggers if the number of private methods exceeds 10 per class.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo {	// Violation
private:
  void method1();
  void method2();
  void method3();
  void method4();
  void method5();
  void method6();
  void method7();
  void method8();
  void method9();
  void method10();
  void method11();
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of private methods to 10 per class.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-11</key>
<configkey>METRICS-11</configkey>
<name><![CDATA[ 每个类的 protected 成员变量数 [METRICS-11] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of protected data member(s) per class [METRICS-11-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This metric measures the number of protected data members per class. 
Rule triggers if the number of protected data members exceeds 15 per class.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo {	// Violation
protected:
  int i1;
  int i2;
  int i3;
  int i4;
  int i5;
  int i6;

  int j1;
  int j2;
  int j3;
  int j4;
  int j5;
  int j6;
  int j7;

  int k1;
  int k2;
  int k3;
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of protected data members to 15 per class.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-12</key>
<configkey>METRICS-12</configkey>
<name><![CDATA[ 每个类的 protected 方法的数量 [METRICS-12] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of protected methods per class [METRICS-12-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"The number of methods per class indicates the total level of functionality
implemented by a class."
This metric measures the number of protected methods per class.
Rule triggers if the number of protected methods exceeds 10 per class.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo {	// Violation
protected:
  void method1();
  void method2();
  void method3();
  void method4();
  void method5();
  void method6();
  void method7();
  void method8();
  void method9();
  void method10();
  void method11();
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of protected methods to 10 per class.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-13</key>
<configkey>METRICS-13</configkey>
<name><![CDATA[ 每个类的公共成员变量数目 [METRICS-13] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of public data member(s) per class [METRICS-13-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This metric measures the number of public data members per class. 
Rule triggers if the number of public data members exceeds 15 per class.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo {	// Violation
public:
  int i1;
  int i2;
  int i3;
  int i4;
  int i5;
  int i6;

  int j1;
  int j2;
  int j3;
  int j4;
  int j5;
  int j6;
  int j7;

  int k1;
  int k2;
  int k3;
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of public data members to 15 per class.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-14</key>
<configkey>METRICS-14</configkey>
<name><![CDATA[ 每个类的公共方法数目 [METRICS-14] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Number of public methods per class [METRICS-14-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"The number of methods per class indicates the total level of functionality
implemented by a class."
This metric measures the number of public methods per class. 
Rule triggers if the number of public methods exceeds 20 per class.



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

This rule applies only to the C++ programming language.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Foo {	// Violation
public:
  void method1();
  void method2();
  void method3();
  void method4();
  void method5();
  void method6();
  void method7();
  void method8();
  void method9();
  void method10();
  void method11();
  void method12();
  void method13();
  void method14();
  void method15();
  void method16();
  void method17();
  void method18();
  void method19();
  void method20();
  void method21();
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of public methods to 20 per class.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

By Mark Schroeder "A Practical Guide to Object-Oriented Metrics"
IT Professional, November/December 1999, pg. 33.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-15</key>
<configkey>METRICS-15</configkey>
<name><![CDATA[ 避免函数的参数数目超过5个 [METRICS-15] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid functions with more than 5 parameters [METRICS-15-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

The number of parameters in a function should be limited to five or less.
This should be done to reduce the amount of coupling between functions.
If more parameters are needed, a structure could be used to hold 
related data and a pointer could be passed.
See also: METRICS-08



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo(int a, int b, int c, int d, int e, int f) // Violation
{ 
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of parameters to 5 per function.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. [Ellemtel 92] "Programming in C++: Rules and Recommendations"
   Ellemtel Telecommunication Systems Laboratories, Sweden.
   From: 9 Function - 9.1 Function Arguments - Rec. 41

2. Motorola Coding Standards G-6

3. HIS Source Code Metriken, version 1.3.1
   Metrik "PARAM"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-16</key>
<configkey>METRICS-16</configkey>
<name><![CDATA[ 宏参数应该不超过 5个 [METRICS-16] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Macros should not use more than 5 parameters [METRICS-16-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule checks that macros do not use more than 5 parameters. 
If a large number of parameters are passed to a macro,
it may become hard to read and understand. 
If this occurs, it may be beneficial to break the macro down 
into multiple macros or make it into a function.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

#define PLUS(a,b,c,d,e,f) (a+b+c+d+e+f) // Violation



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of parameters to 5 per macro.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-17</key>
<configkey>METRICS-17</configkey>
<name><![CDATA[ 避免 structs, unions, 或类有超过20个范围 [METRICS-17] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid structs, unions, or classes with more than 20 fields [METRICS-17-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule is purely informational and will report a message when a struct,
union or class declaration is found with more than 20 fields.
See also: METRICS-06



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

struct _tA	// Violation
{
    int i0;
    int i1;
    int i2;
    int i3;
    int i4;
    int i5;
    int i6;
    int i7;
    int i8;
    int i9;
    int i10;
    int i11;
    int i12;
    int i13;
    int i14;
    int i15;
    int i16;
    int i17;
    int i18;
    int i19; 
    int i20;
    int i21;
    int i22;
    int i23;
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of fields to 20.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-18</key>
<configkey>METRICS-18</configkey>
<name><![CDATA[ 将圈复杂度限制在 10 之内 [METRICS-18] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the Cyclomatic Complexity limit of 10 [METRICS-18-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule identifies methods that do not satisfy the user-defined requirement
for Cyclomatic Complexity.

Cyclomatic Complexity is calculated according to the formula:
CC = Number of decisions + 1
By decision we mean every occurrence of:
-'if'
-'for'
-'while'
-'do-while'
-'case'
-'catch'
-conditional expression 'a?b:c'
-logical operator '&amp;&amp;' and '||'
An error is reported if a function have a Cyclomatic Complexity higher than 10.
See also: METRICS-28, METRICS-29, METRICS-33, METRICS-34, METRICS-35



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

To change the default limit of the Cyclomatic Complexity modify the main
"Count" expression of the rule (Collector A) from "$$ &gt; 10" to "$$ &gt; N"
using desired threshold value for N. Rule's header should be also changed
accordingly.

To ignore switch statements in the computation of the Cyclomatic Complexity,
modify the "Count" expression for the cases (Collector C) from "$$ &gt; 0" 
to "$$ == 0".

To ignore switch statements having more than N cases in the computation
of the Cyclomatic Complexity, modify the "Count" expression for the cases
(Collector C) from "$$ &gt; 0" to "$$ &lt;= N" using desired threshold value for N.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Studies have found that methods with high Cyclomatic Complexity are error-prone.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo(int a, int b) // Violation - CC value: 11
{
    switch (a)
    {
        case 1:        // 1
            break;        
        case 2:        // 2
            break;
        case 3:        // 3
            break;
        default:      
            break;
    }
    if(a||b)           // 4, 5
    {
    }
    if((a||b)&amp;&amp;(a&amp;&amp;b)) // 6, 7, 8, 9
    {
    }
    do                 // 10
    {
    }while(0);
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Keep a Cyclomatic Complexity value on the level lower than 10.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

McCabe, T., "A Complexity Measure," IEEE Transactions on Software
Engineering, December 1976.

HIS Source Code Metriken, version 1.3.1
Metrik "v(G)"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-19</key>
<configkey>METRICS-19</configkey>
<name><![CDATA[ 模块中注释行所占比例应该为20到60 [METRICS-19] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
The percentage of comment lines versus the total number of module lines should be between 20 and 60 [METRICS-19-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Rule checks if percentage of comment lines versus the total number of method
lines is between 20 and 60.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo1(int y) {	// Violation
	//
	//
	//
	//
}

void foo12() {		// Violation
	/*


  */
}

void foo3() {		// Violation
	/**//**//**//**/
}

void foo4() {		// Violation




}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

void foo1() {		// OK
	//
	//
	//
	//





}

void foo2() {		// OK
	/*

  */




}

void foo3() {		// OK
	/**//**//**//**/



}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-20</key>
<configkey>METRICS-20</configkey>
<name><![CDATA[ 避免太长的函数声明和代码段 [METRICS-20] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid too long functions (declarations and statements) [METRICS-20-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Long functions have disadvantages:
"If a function is too long, it can be difficult to comprehend. 
Generally, it can be said that a function should not be longer 
than two pages, since that is about how much that can be comprehended 
at one time. 
If an error situation is discovered at the end of an extremely long function,
it may be difficult for the function to clean up after itself and 
to "undo" as much as possible before reporting the error to 
the calling function. "
See also: METRICS-01, METRICS-21, METRICS-22



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

Rule triggers when the number of declarations and statements within
function body exceeds 50.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

By always using short functions, such an error can be more exactly localized.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void too_long_function() {	// Violation
    int a1;
    int a2;
    int a3;
    int a4;
    int a5;
    int a6;
    int a7;
    int a8;
    int a9;
    int a10;
    int a11;
    int a12;
    int a13;
    int a14;
    int a15;
    int a16;
    int a17;
    int a18;
    int a19;
    int a20;
    int a21;
    int a22;
    int a23;
    int a24;
    int a25;
    int a26;
    int a27;
    int a28;
    int a29;
    int a30;
    int a31;
    int a32;
    int a33;
    int a34;
    int a35;
    int a36;
    int a37;
    int a38;
    int a39;
    int a40;
    int a41;
    int a42;
    int a43;
    int a44;
    int a45;
    int a46;
    int a47;
    int a48;
    int a49;
    int a50;
    int a51;
    int a52;
    int a53;
    int a54;
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Number of declarations and statements within function body
should be limited to 50.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. [Ellemtel 92] "Programming in C++: Rules and Recommendations"
   Ellemtel Telecommunication Systems Laboratories, Sweden.
   From: 9 Functions - 9.7 General - Rec 47

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-21</key>
<configkey>METRICS-21</configkey>
<name><![CDATA[ 避免太长的函数块 [METRICS-21] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid too long functions (blocks) [METRICS-21-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"Avoid long and complex functions. Complex functions are difficult to test. 
If a function consists of 15 nested if statements, then there are 2**15
(or 32768) different branches to test in a single function."
See also: METRICS-01, METRICS-20, METRICS-22



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

Rule triggers if function contains more than 10 blocks.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

By always using short and simple functions, such an error can be more exactly
localized and function testing is much easier.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void func( int i ) {  // Violation
    if (1) {
    } else {
    }
    do {
    } while(1);
    switch(i) {
    case 1:
        break;
    default:
        break;
    }
    if (1) {
    } else {
    }
    if (2) {
    } else {
    }
    if (3) {
    } else {
    }
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit the number of blocks within function body to 10.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. [Ellemtel 92] "Programming in C++: Rules and Recommendations"
   Ellemtel Telecommunication Systems Laboratories, Sweden.
   From: 9 Functions - 9.7 General - Rec. 47

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-22</key>
<configkey>METRICS-22</configkey>
<name><![CDATA[ 避免函数的行数超过75行 [METRICS-22] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid functions with over 75 lines of code [METRICS-22-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"Excessively long functions and nested code blocks are often caused by failing
 to give one function one  cohesive responsibility, and both are usually solved
 by better refactoring."
See also: METRICS-01, METRICS-20, METRICS-21



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves  readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class A 
{
    void foo( int x )     // Violation
    {
        // ...
        // more than 75 lines of constants, declarations, expressions, 
        // statements, types
        // ...
    }
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Do not type functions longer than 75 lines of code.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Coding Style", Rule 20

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-23</key>
<configkey>METRICS-23</configkey>
<name><![CDATA[ 嵌套块深度不应高于 5 [METRICS-23] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Nested block depth should not be higher than 5 [METRICS-23-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"Each level of nesting adds intellectual overhead when reading code because you
need to maintain a mental stack. Prefer better functional decomposition to help
avoid forcing readers to keep as much context in mind at a time"

The rule reports violation if the nesting level in function is higher than 5.

Following elements of code are recognized as levels:
- if-else construction
- try-catch construction
- for, while, do-while loops
- switch statement
- block {} that is not a part of any of the above statements

See also: METRICS-40



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

It is possible to change the allowed nesting level by modifying 
one element of rule in Rule Wizard. The level is checked by expression
in last "Count" node. The default "$$==5" expression imposes maximum
nesting level of 5. For example, to report violation if nesting level is
higher than 10, change the expression to "$$==10".



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"Excessive block nesting depth (e.g. if, for, while, and try blocks) make 
functions more difficult to understand and maintain, and often needlessly so."



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

int foo1(int i)
{
    if(i &gt; 1){
        if(i &gt; 2){
            if(i &gt; 3){
                if(i &gt; 4){
                    if(i &gt; 5){         // OK - 5 level
                        ++i;
                        if(i &gt; 6){     // Violation - 6 level
                            ++i;
                            if(i &gt; 7){ // OK - 7 level - violation already reported on level 6
                                return i;
                            }
                        }
                    } else {
                        ++i;
                        if(i == 6){     // Violation - 6 level
                            return 6;
                        }
                    }
                 }
             }
        }
    }
}

int foo2(int i)
{
    if(i == 1)
        return i;
    else if(i == 2)
        return i;
    else if(i == 3)
        return i;
    else if(i == 4)
        return i;
    else if(i == 5)  // OK - 5 level
        return i;
    else if(i == 6)  // Violation - 6 level
        return i;
    else if(i == 7)  // OK - 7 level - violation already reported on level 6
        return i;

    // The above statement is in fact identical to following:

    if(i == 1) {
        return i;
    } else {
        if(i == 2) {
            return i;
        } else {
            if(i == 3) {
                return i;
            } else {
                if(i == 4) {
                    return i;
                } else {
                    if(i == 5) { // OK - 5 level
                        return i;
                    } else {
                        if(i == 6) { // Violation - 6 level
                            return i;
                        } else {
                            if(i == 7) { // OK - 7 level - violation already reported on level 6
                                return i;
                            }
                        }
                    }
                }
            }
        }
    }
}

int foo3(int i)
{
    {
        {
            {
                {
                    {       // OK - 5 level
                        {   // Violation - 6 level
                            return i;
                        }
                    }
                }
            }
        }
    }
}

void foo4()
{
    // try-catch is linear and introduces one level, same as if-else:
    try {                       // OK - 1 level
    } catch(char) {     // OK - 1 level
    } catch(int) {        // OK - 1 level
    } catch(long) {     // OK - 1 level
    } catch(float) {     // OK - 1 level
    } catch(double) { // OK - 1 level
    } catch(...) {          // OK - 1 level
    }
}

int foo5(int i)
{
   while(i) { // 1
       for(;;) { // 2
           if(i) { // 3
           } else { // still 3
               switch(i) { // 4
               case 1: // still 4
                   ++i;
                   {  // 5
                       do { // 6 - Violation
                           return i;
                       } while(0);
                   }
               }
           }
       }
   }
}

#define MACRO(x) { { { { { { return x; } } } } } }
int foo6(int i)
{
    // Code from macros might produce violations
    MACRO(i);  // Violation
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Do not nest statements more than 5 levels.
"Avoid nested consecutive ifs where an &amp;&amp; condition will do.
Prefer automatic cleanup via destructors over try blocks.
Prefer algorithms: They're flatter than loops, and often better."



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Coding Style", Rule 20

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-24</key>
<configkey>METRICS-24</configkey>
<name><![CDATA[ 避免超过 500 行的源代码 [METRICS-24] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid source files that are longer than 500 lines [METRICS-24-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Source files should be no longer than 500 lines. Experience has shown 
that larger files are cumbersome to edit correctly and to maintain.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Improves maintainability and readability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

// Source file - Violation
/*

  code

*/
#line 501
int i = 0;
// line: 501



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Limit source files to 500 lines.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-25</key>
<configkey>METRICS-25</configkey>
<name><![CDATA[ 任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC) [METRICS-25] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs) [METRICS-25-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Any one function (or method) will contain no more than 200
logical source lines of code (L-SLOCs).



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

Logical line of code is a single declaration or statement terminated
by semicolon.
Two semicolons in parenthesis after 'for' keyword are counted as one.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule prevents using long functions which tend to be complex and
therefore difficult to comprehend and test.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

int sample_function(int p)      // Violation
{
    int x, y;                   // L-SLOCs number = 1
    
    // ...
    
    x++;                        // L-SLOCs number = 99
    for(y = 10; y &gt; 0; y--){    // L-SLOCs number = 100
    	x = y;                  // L-SLOCs number = 101
    }
    
    // ...
    
    x = x + p; y = y + p;       // L-SLOCs number = 150, L-SLOCs number = 151

    // ...
    
    return x;                   // L-SLOCs number = 201
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Do not use functions containing more than 200
logical source lines of code (L-SLOCs).



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 3.2 Code Size and Complexity, AV Rule 1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-26</key>
<configkey>METRICS-26</configkey>
<name><![CDATA[ 源代码行应该保持在 120 个字符之内 [METRICS-26] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Source lines will be kept to a length of 120 characters or less [METRICS-26-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

The rule reports a violation if a physical line contains more
than 120 characters. Very long source lines can be difficult
to read and understand.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

Tab is counted as one character.
White spaces at the end of line are counted in the same way as other characters.
Comments with 'parasoft-suppress' are not counted.

To change the default limit of characters modify the variable 'lineLengthLimit'
at the begin of python method 'check'.(e.g. 'lineLengthLimit = 100' means that
the maximal allowed number of characters in a physical line is 100) 



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

The rule improves readability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

int       /* ....................................................................................*/  i1 ; /* Violation */
int       /* ..........white spaces at the end of line.......................................*/  i2 ; /* Violation */    
/* multiline comment ....................................................................................Violation.......
 * ......................................................................................................Violation.....*/
#define MACCCCC(xxxxxxxxxxxxxxxxxxxxxxxxxxxx) xxxxxxxxxxxxxxxxxxxxxxxxxxxx + xxxxxxxxxxxxxxxxxxxxxxxxxxxx + xxxxxxxxxxxxxxxxxxxxxxxxxxxx /* Violation */



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

int       /* ..........................................................................................*/  i1 ; /* OK */
int       /* ..........There is no spaces at the end.......................................*/  i2 ; /* Violation */
/* multiline comment ....................................................................................OK......
 * ......................................................................................................OK....*/
#define MACCCCC(xxxxxxxxxxxxxxxxxxxxxxxxxxxx) xxxxxxxxxxxxxxxxxxxxxxxxxxxx + xxxxxxxxxxxxxxxxxxxxxxxxxxxx + \
	            xxxxxxxxxxxxxxxxxxxxxxxxxxxx /* OK */
int       /* .........................................................................................*/  i3 ;  /* parasoft-suppress ITEM ... OK */



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.9 Style, AV Rule 41

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-27</key>
<configkey>METRICS-27</configkey>
<name><![CDATA[ 不要使用多于 7 个参数的函数 [METRICS-27] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Functions with more than 7 parameters will not be used [METRICS-27-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Functions having long argument lists can be difficult to read, 
use, and maintain. Functions with too many parameters may
indicate an under use of objects and abstractions.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo(int a, int b, int c, int d, int e, int f, int g, int h)  // Violation
{ 
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

// Limit the number of parameters to 7 per function.

void foo(int a, int b, int c, int d, int e, int f, int g)  // OK
{ 
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
4.13 Function, AV Rule 110

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-28</key>
<configkey>METRICS-28</configkey>
<name><![CDATA[ 限制圈复杂度在 20 之内 [METRICS-28] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the Cyclomatic Complexity limit of 20 [METRICS-28-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule identifies methods that do not satisfy the user-defined requirement
for Cyclomatic Complexity.

Cyclomatic Complexity is calculated according to the formula:
CC = Number of decisions + 1
By decision we mean every occurrence of:
-'if'
-'for'
-'while'
-'do-while'
-'case'
-'catch'
-conditional expression 'a?b:c'
-logical operator '&amp;&amp;' and '||'
An error is reported if a function have a Cyclomatic Complexity higher than 20.
See also: METRICS-18, METRICS-29, METRICS-33, METRICS-34, METRICS-35



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

To change the default limit of the Cyclomatic Complexity modify the main
"Count" expression of the rule (Collector A) from "$$ &gt; 20" to "$$ &gt; N"
using desired threshold value for N. Rule's header should be also changed
accordingly.

To ignore switch statements in the computation of the Cyclomatic Complexity,
modify the "Count" expression for the cases (Collector C) from "$$ &gt; 0"
to "$$ == 0".

To ignore switch statements having more than N cases in the computation
of the Cyclomatic Complexity, modify the "Count" expression for the cases
(Collector C) from "$$ &gt; 0" to "$$ &lt;= N" using desired threshold value for N.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Studies have found that methods with high Cyclomatic Complexity are error-prone.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo2(int i, int a, int b, int j, int k)   // Violation - CC value: 21
{
    switch (i)
    {
        case 1:  // 1
            i++;
        default:
            i++;
    }
    switch (j)
    {
        case 1:  // 2
            j++;
        default:
            j++;
    }
    switch (k)
    {
        case 1:  // 3
            k++;
        default:
            k++;
    }

    if(a||b)      // 4, 5
    {
    }
    if((a||b)&amp;&amp;(a&amp;&amp;b)) // 6, 7, 8, 9
    {
    }
    do                // 10
    {
    }while(0);
    switch (i)
    {
        case 1:  // 11
            i++;
        default:
            i++;
    }
    switch (j)
    {
        case 1:  // 12
            j++;
        default:
            j++;
    }
    switch (k)
    {
        case 1:  // 13
            k++;
        default:
            k++;
    }

    if(a||b)      // 14, 15
    {
    }
    if((a||b)&amp;&amp;(a&amp;&amp;b)) // 16, 17, 18, 19
    {
    }
    do                // 20
    {
    }while(0);
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Keep a Cyclomatic Complexity value on the level lower than 20.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 3.2 Code Size and Complexity, AV Rule 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-29</key>
<configkey>METRICS-29</configkey>
<name><![CDATA[ 报告圈复杂度 [METRICS-29] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Report Cyclomatic Complexity [METRICS-29-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule reports the Cyclomatic Complexity value for each function.

Cyclomatic Complexity is calculated according to the formula:
CC = Number of decisions + 1
By decision we mean every occurrence of:
-'if'
-'for'
-'while'
-'do-while'
-'case'
-'catch'
-conditional expression 'a?b:c'
-logical operator '&amp;&amp;' and '||'

See also: METRICS-18, METRICS-28, METRICS-33, METRICS-34, METRICS-35



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

To change the default limit of the Cyclomatic Complexity modify the main
"Count" expression of the rule (Collector A) from "$$ &gt; 0" to "$$ &gt; N"
using desired threshold value for N. Rule's header should be also changed
accordingly.

To ignore switch statements in the computation of the Cyclomatic Complexity,
modify the "Count" expression for the cases (Collector C) from "$$ &gt; 0"
to "$$ == 0".

To ignore switch statements having more than N cases in the computation
of the Cyclomatic Complexity, modify the "Count" expression for the cases
(Collector C) from "$$ &gt; 0" to "$$ &lt;= N" using desired threshold value for N.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Studies have found that methods with high Cyclomatic Complexity are error-prone.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo(int a, int b) // Violation - CC value: 8
{
    if(a||b)           // 1, 2
    {
    }
    if((a||b)&amp;&amp;(a&amp;&amp;b)) // 3, 4, 5, 6
    {
    }
    do                 // 7
    {
    }while(0);
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

This rule is an informational rule and reports message
on each function implementation.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-30</key>
<configkey>METRICS-30</configkey>
<name><![CDATA[ 函数不应该超过 60 行代码 [METRICS-30] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
No function should be longer than 60 lines of code [METRICS-30-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"No function should be longer than what can be printed on a single sheet
of paper in a standard reference format with one line per statement
and one line per declaration. Typically, this means no more than about
60 lines of code per function."
See also: METRICS-01, METRICS-20, METRICS-21, METRICS-22



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

The rule counts non-empty lines inside body of function.
Lines containing only comment are not counted.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"Each function should be a logical unit in the code that is understandable
and verifiable as a unit. It is much harder to understand a logical unit that
spans multiple screens on a computer display or multiple pages when printed.
Excessively long functions are often a sign of poorly structured code."



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo( int x )     // Violation
{
    // ...
    // more than 60 lines of constants, declarations, expressions, 
    // statements, types
    // ...
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Refactor long functions into several smaller functions.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

The Power of Ten - Rules for Developing Safety Critical Code.
Rule 4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-31</key>
<configkey>METRICS-31</configkey>
<name><![CDATA[ 代码的断言密度应该平均到每个函数应至少有两个断言 [METRICS-31] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
The assertion density of the code should average to a minimum of two assertions per function [METRICS-31-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"The assertion density of the code should average to a minimum of two assertions
per function. Assertions are used to check for anomalous conditions that should
never happen in real-life executions."
The rule reports a violation if  A &lt; 2*F  where A is the number of assertions 
and F is the number of defined functions.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

The rule detects all using of macros which names are ended by 'assert' 
e.g. 'assert', 'c_assert', 'checkAssert' etc.
The rule checks one file at time.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"Statistics for industrial coding efforts indicate that unit tests often
find at least one defect per 10 to 100 lines of code written. The odds
of intercepting defects increase with assertion density. Use of assertions
is often also recommended as part of a strong defensive coding strategy.
Assertions can be used to verify pre- and post-conditions of functions,
parameter values, return values of functions, and loop-invariants. 
Because assertions are side-effect free, they can be selectively disabled
after testing in performance-critical code."



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

/* Violation - 2 functions defined and 1 assertion used */

#define c_assert(x) ((x) ? 1 : 0);
void foo(int x) {
    /* Some code */
    c_assert(x); /* Use of assertion */
}
void bar(int x, int y) {
    /* Some code */
}
int baz();



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

/* OK - 2 functions defined and 4 assertions used (density: 2) */

#define c_assert(x) ((x) ? 1 : 0);
void foo(int x) {
    c_assert(x); /* Use of assertion */
    /* Some code */    
}
void bar(int x, int y) {
    c_assert(x); /* Use of assertion */
    c_assert(y); /* Use of assertion */
    /* Some code */
    c_assert(x+y); /* Use of assertion */
}
int baz();



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

The Power of Ten - Rules for Developing Safety Critical Code.
Rule 5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-32</key>
<configkey>METRICS-32</configkey>
<name><![CDATA[ 所有超过 20 行的函数应该包含至少两个断言 [METRICS-32] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
All functions with more than 20 lines should contain at least 2 assertions [METRICS-32-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

The rule checks if a function that has more than M lines has at least
N assertions. M and N are parameters that could be set inside rule in 
python method 'setValue'.
They are default set to:
  MinimalNumberOfAssertions = 2
  MinimalNumberOfFunctionLines = 20
In this case the rule reports a violation if a function that has more than 20
lines does not contain at least 2 assertions.
See also: METRICS-31



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

As assertion the rule sees any use of macro with name that 
ends with 'assert', e.g. 'assert', 'c_assert', 'checkAssert' etc.
The first line of function is a line containing opening brace '{'
and the last is line containing closing brace '}'. All lines are
counted, including empty and commented out.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"Statistics for industrial coding efforts indicate that unit tests often
find at least one defect per 10 to 100 lines of code written. The odds
of intercepting defects increase with assertion density. Use of assertions
is often also recommended as part of a strong defensive coding strategy.
Assertions can be used to verify pre- and post-conditions of functions,
parameter values, return values of functions, and loop-invariants. 
Because assertions are side-effect free, they can be selectively disabled
after testing in performance-critical code."



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

#define c_assert(x) ((x) ? 1 : 0);

void foo(int x, int y) {  // Violation - 21 lines, 1 assertion used
    /* Some code */
    c_assert(x);  /* Use of assertion */
    /*
     * code
     *
     *
     *
     *
     *
     *
     *
     *
     *
     * code
     *
     *
     *
     *
     */
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

#define c_assert(x) ((x) ? 1 : 0);

void foo(int x, int y) {  // OK - 21 lines, 2 assertion used
    /* Some code */
    c_assert(x); /* Use of assertion */
    c_assert(x); /* Use of assertion */
    /*
     * code
     *
     *
     *
     *
     *
     *
     *
     *
     * code
     *
     *
     *
     *
     */
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

The Power of Ten - Rules for Developing Safety Critical Code.
Rule 5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-33</key>
<configkey>METRICS-33</configkey>
<name><![CDATA[ 报告基本复杂度 [METRICS-33] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Report Essential Complexity [METRICS-33-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule reports the Essential Complexity value for each function.

The Essential Complexity metric quantifies the extent to which software is unstructured.

The metric is calculated according to the formula:
  EC = Number of unstructured decisions + 1
By decision we mean every occurrence of:
  - 'if', 'for', 'while', 'do-while', 'case'
  - conditional expression 'a?b:c' inside 'if', 'for', 'while', 'do-while' condition
  - logical operator '&amp;&amp;' and '||' inside 'if', 'for', 'while', 'do-while' condition
By unstructured decisions we mean conditional jumps into or out of other decisions, e.g. 
'goto' inside 'if' which is in turn inside 'switch', or
'return' inside 'while' which is in turn inside 'for'.
If a decision contains unstructured decision then it's a unstructured decision itself.

See also: METRICS-18, METRICS-28, METRICS-29, METRICS-34, METRICS-35



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

Rule does not consider exception handling ('catch') as a decision.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"Structured programming avoids unmaintainable "spaghetti code" by restricting the usage 
of control structures to those that are easily analyzed and decomposed."

By comparing Essential Complexity with Cyclomatic Complexity it's possible to find
functions that are complicated but well structured, which means they can be refactored.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void Example(int x, int y) /* Violation: Essential Complexity = 8  */
{
    for(;x || y;) {                     // +2
        switch (x*y) {
            case 1:                     // +1
                while (--x &gt; 0) {  // +1
                    if (x % y) {        // +1
                        return;
                    }
                }
                if (x &gt; y) {            // +1
                    goto OUT;
                }
                break;
            case 2:                     // +1
                do {
                    x++;
                } while (x &amp;&amp; y &amp;&amp; (x * y &lt; 100));
                break;
        }
        OUT:
        if (y) {
            ++y;
        }
    }
    if (y) {
        goto END;
    }
    END:
    return;
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

This rule is an informational rule and reports Essential Complexity
on each function implementation.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. A Complexity Measure
   Thomas J. McCabe
   308 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-2, NO.4, DECEMBER 1976

2. Structured Testing: A Testing Methodology Using the Cyclomatic Complexity Metric
   NIST Special Publication 500-235   
   Chapter 10 Essential Complexity
   <A HREF="http://hissa.nist.gov/HHRFdata/Artifacts/ITLdoc/235/chaptera.htm#446037">http://hissa.nist.gov/HHRFdata/Artifacts/ITLdoc/235/chaptera.htm#446037</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-34</key>
<configkey>METRICS-34</configkey>
<name><![CDATA[ 遵守基本复杂度为 4 的限制 [METRICS-34] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the Essential Complexity limit of 4 [METRICS-34-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule identifies methods that do not satisfy the user-defined requirement
for Essential Complexity.
An error is reported if a function have the Essential Complexity higher than 4.

The Essential Complexity metric quantifies the extent to which software is unstructured.

The metric is calculated according to the formula:
  EC = Number of unstructured decisions + 1
By decision we mean every occurrence of:
  - 'if', 'for', 'while', 'do-while', 'case'
  - conditional expression 'a?b:c' inside 'if', 'for', 'while', 'do-while' condition
  - logical operator '&amp;&amp;' and '||' inside 'if', 'for', 'while', 'do-while' condition
By unstructured decisions we mean conditional jumps into or out of other decisions, e.g. 
'goto' inside 'if' which is in turn inside 'switch', or
'return' inside 'while' which is in turn inside 'for'.
If a decision contains unstructured decision then it's a unstructured decision itself.

See also: METRICS-18, METRICS-28, METRICS-29, METRICS-33, METRICS-35



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

Rule does not consider exception handling ('catch') as a decision.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"Structured programming avoids unmaintainable "spaghetti code" by restricting the usage 
of control structures to those that are easily analyzed and decomposed."

By comparing Essential Complexity with Cyclomatic Complexity it's possible to find
functions that are complicated but well structured, which means they can be refactored.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void Example(int x, int y) /* Violation: Essential Complexity = 8  */
{
    for(;x || y;) {                     // +2
        switch (x*y) {
            case 1:                     // +1
                while (--x &gt; 0) {  // +1
                    if (x % y) {        // +1
                        return;
                    }
                }
                if (x &gt; y) {            // +1
                    goto OUT;
                }
                break;
            case 2:                     // +1
                do {
                    x++;
                } while (x &amp;&amp; y &amp;&amp; (x * y &lt; 100));
                break;
        }
        OUT:
        if (y) {
            ++y;
        }
    }
    if (y) {
        goto END;
    }
    END:
    return;
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

This rule is an informational rule and reports Essential Complexity
on each function implementation.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. A Complexity Measure
   Thomas J. McCabe
   308 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-2, NO.4, DECEMBER 1976

2. Structured Testing: A Testing Methodology Using the Cyclomatic Complexity Metric
   NIST Special Publication 500-235   
   Chapter 10 Essential Complexity
   <A HREF="http://hissa.nist.gov/HHRFdata/Artifacts/ITLdoc/235/chaptera.htm#446037">http://hissa.nist.gov/HHRFdata/Artifacts/ITLdoc/235/chaptera.htm#446037</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-35</key>
<configkey>METRICS-35</configkey>
<name><![CDATA[ 遵守基本复杂度为 10 的限制 [METRICS-35] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the Essential Complexity limit of 10 [METRICS-35-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule identifies methods that do not satisfy the user-defined requirement
for Essential Complexity.
An error is reported if a function have the Essential Complexity higher than 10.

The Essential Complexity metric quantifies the extent to which software is unstructured.

The metric is calculated according to the formula:
  EC = Number of unstructured decisions + 1
By decision we mean every occurrence of:
  - 'if', 'for', 'while', 'do-while', 'case'
  - conditional expression 'a?b:c' inside 'if', 'for', 'while', 'do-while' condition
  - logical operator '&amp;&amp;' and '||' inside 'if', 'for', 'while', 'do-while' condition
By unstructured decisions we mean conditional jumps into or out of other decisions, e.g. 
'goto' inside 'if' which is in turn inside 'switch', or
'return' inside 'while' which is in turn inside 'for'.
If a decision contains unstructured decision then it's a unstructured decision itself.

See also: METRICS-18, METRICS-28, METRICS-29, METRICS-33, METRICS-34



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

Rule does not consider exception handling ('catch') as a decision.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"Structured programming avoids unmaintainable "spaghetti code" by restricting the usage 
of control structures to those that are easily analyzed and decomposed."

By comparing Essential Complexity with Cyclomatic Complexity it's possible to find
functions that are complicated but well structured, which means they can be refactored.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void Example(int x, int y)    /* Violation: Essential Complexity = 12  */
{
    for(;x || y;) {                                // +2
        switch (x*y) {
            case 1:                                // +1
                for(;x &amp;&amp; y &amp;&amp; x &lt; y;) {    // +3
                    while (--x &gt; 0) {          // +1
                        if (y &amp;&amp; x % y) {        // +2
                            return;
                        }
                    }
                    if (x &gt; y) {                     // +1
                        goto OUT;
                    }
                }
                break;
            case 2:                                  // +1
                do {
                    x++;
                } while (x &amp;&amp; y &amp;&amp; (x * y &lt; 100));
                break;
        }
        OUT:
        if (y) {
            ++y;
        }
    }
    if (y) {
        goto END;
    }
    END:
    return;
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

This rule is an informational rule and reports Essential Complexity
on each function implementation.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. A Complexity Measure
   Thomas J. McCabe
   308 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-2, NO.4, DECEMBER 1976

2. Structured Testing: A Testing Methodology Using the Cyclomatic Complexity Metric
   NIST Special Publication 500-235   
   Chapter 10 Essential Complexity
   <A HREF="http://hissa.nist.gov/HHRFdata/Artifacts/ITLdoc/235/chaptera.htm#446037">http://hissa.nist.gov/HHRFdata/Artifacts/ITLdoc/235/chaptera.htm#446037</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-36</key>
<configkey>METRICS-36</configkey>
<name><![CDATA[ 函数不得从超过 5 个不同的函数中调用 [METRICS-36] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
A function should not be called from more than 5 different functions [METRICS-36-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

A function should not be called from more than 5 different functions.
All calls within the same function are counted as 1.
The rule is limited to translation unit scope.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo(){} /* Violation */

void goo1(){
	foo();  /* 1 */
}
void goo2(){
	foo();  /* 2 */
}
void goo3(){
	foo();  /* 3 */
}
void goo4(){
	foo();  /* 4 */
}
void goo5(){
	foo();  /* 5 */
}
void goo6(){
	foo();  /* 6 */
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

void foo(){} /* OK */

void goo1(){
	foo();
	foo();
	foo();
	foo();
	foo();
	foo();
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

HIS Source Code Metriken, version 1.3.1
Metrik "CALLING"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-37</key>
<configkey>METRICS-37</configkey>
<name><![CDATA[ 函数不得调用超过 7 个不同的函数 [METRICS-37] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
A function should not call more than 7 different functions [METRICS-37-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

The rule reports a violation if a function contains more than 7 calls
of different functions. All calls of the same function are counted as 1.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void goo1(){}
void goo2(){}
void goo3(){}
void goo4(){}
void goo5(){}
void goo6(){}
void goo7(){}
void goo8(){}

void foo2()     /* Violation */
{
    goo1();
    goo2();
    goo3();
    goo4();
    goo5();
    goo6();
    goo7();
    goo8();
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

void goo1(){}
void goo2(){}
void goo3(){}
void goo4(){}
void goo5(){}
void goo6(){}
void goo7(){}
void goo8(){}

void foo1()    /* OK */
{
    goo1();
    goo2();
    goo3();
    goo4();
}

void foo2()    /* OK */
{
    foo1();
    goo5();
    goo6();
    goo7();
    goo8();
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

HIS Source Code Metriken, version 1.3.1
Metrik "CALLS"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-38</key>
<configkey>METRICS-38</configkey>
<name><![CDATA[ 函数中的语句数量应该介于 1-50 的范围之间 [METRICS-38] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
The number of statements within function should be in range 1 - 50 [METRICS-38-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

The rule reports a violation if the number of statements in function body 
is more than 50 or the function does not contain any statements.
Counted statements are: asm, break, continue, do...while, empty, for,
goto, if, return, switch, while and the top level expressions.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void foo(){}  /* Violation */
void foo2(){} /* Violation */

int goo1(int i){  /* Violation */
    int e;
    foo();                   /* 1 */
    foo2();                  /* 2 */
    if(i){                   /* 3 */
        i++;                 /* 4 */
        return i;            /* 5 */
    }else{ 
        i--;                 /* 6 */
        return 0;            /* 7 */
    }
    for(e = 0;  e &lt; 1; e++){ /* 8 */
        while(i &lt; 4)         /* 9 */
            i = i + 4;       /* 10 */
    }
    switch (i){              /* 11 */
    case 0:
        i = 7;               /* 12 */
    case 1: 
        i = 30;              /* 13 */
    case 2: 
        i = 50;              /* 14 */
    default:
        return i;            /* 15 */
    }
    ;                        /* 16 */
    a: 
    foo();                   /* 17 */
    foo2();                  /* 18 */
    if(i){                   /* 19 */
        i++;                 /* 20 */
        return i;            /* 21 */
    }else{
        i--;                 /* 22 */
        return 0;            /* 23 */
    }
    for(e = 0;  e &lt; 1; e++){ /* 24 */
        while(i &lt; 4)         /* 25 */
            i = i + 4;       /* 26 */
    }
    switch (i){              /* 27 */
    case 0:
        i = 7;               /* 28 */
    case 1: 
        i = 30;              /* 29 */
    case 2: 
        i = 50;              /* 30 */
    default:
        return i;            /* 31 */
    }
    ;                        /* 32 */
    foo();                   /* 33 */
    foo2();                  /* 34 */
    for(e = 0;  e &lt; 1; e++)  /* 35 */
        ;                    /* 36 */
    if(i){                   /* 37 */
        i++;                 /* 38 */
        return i;            /* 39 */
    }else{
        i--;                 /* 40 */
        i--;                 /* 41 */
        i--;                 /* 42 */
        return 0;            /* 43 */
    }
    for(e = 0;  e &lt; 1; e++){ /* 44 */
        while(i &lt; 4)         /* 45 */
            i = i + 4;       /* 46 */
    }
    i = i + 5 + 4 * (2 / 3); /* 47 */
    do{                      /* 48 */
        i = (i &lt; 4) ? 2 : 5; /* 49 */
    }while(i &lt; 5);
    goto a;                  /* 50 */
    return 10;               /* 51 */
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

The function should have at least 1 statement and the number of statements
within function body should be limited to 50.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

HIS Source Code Metriken, version 1.3.1
Metrik "STMT"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-39</key>
<configkey>METRICS-39</configkey>
<name><![CDATA[ 函数的 VOCF 度量指标值不应该高于 4 [METRICS-39] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
The value of VOCF metric for a function should not be higher than 4 [METRICS-39-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

The rules checks the value of VOCF metric for a function. 
Rule reports a violation if the value of VOCF metric
is higher than 4.

VOCF is defined in the following way:
    VOCF = (N1 + N2)/(n1 + n2)
where:
    N1 - the number of all operators within function
    N2 - the number of all operands within function
    n1 - the number of distinct operators within function
    n2 - the number of distinct operands within function

Tokens recognized as operators:
- operators:
 =, +=, -=, *=, /=, %=, |=, &amp;=, ^=, &lt;&lt;=, &gt;&gt;=, +, -, *, /, %, |, &amp;, ^,
 &lt;&lt;, &gt;&gt;, ~, !, ||, &amp;&amp;, ++, --, &lt;, &lt;=, !=, ==, &gt;, &gt;=, -&gt;, ?:, &lt;%, &lt;:,
 (), [], {}, ,(comma), ;(semicolon), .(dot) , ...(ellipsis),
- keywords:
asm, auto, break, case, const, continue, default, do, else, enum, extern,
for, goto, if, inline, register, restrict, return, sizeof, static, struct,
switch, typedef, union, volatile, while

Tokens recognized as operands:
- all identifiers which are not keywords
- type specifiers: void, char, short, int, long, float, double, signed, unsigned
- constants: numbers and strings 



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

/* operators: brace{}(1), parentheses()(10), return(2), = (2), ;(6), 
 * + (8), * (5), if (2), &gt;= (2),
 * - N1 (38), n1 (9)
 * operands: int(4), foo(1), i(9), a(3), b (3), 1 (2), 2 (6), 3 (3)
 * - N2 (31), n2 (8) 
 * VOCF = (N1 + N2) / (n1 + n2) = (38 + 31) / (9 + 8) = 4.06 */

int foo(int i){  /* Violation */
    int a;
    int b;

    a = i + (2 * (i + 1)) + (3 * (i + 2));
    b = (i + (2 * (i + 1)) + (3 * (i + 2))) * 2;

    if(i &gt;= 3)
        return a;
    if(i &gt;= 2)
        return b;
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

/* operators: brace{}(1), parentheses()(5), return(2), = (2), ;(6), 
 * + (4), * (3), if (2), &gt;= (2),
 * - N1 (27), n1 (9)
 * operands: int(4), foo(1), i(6), a(4), b (3), 1 (1), 2 (4), 3 (2)
 * - N2 (25), n2 (8) 
 * VOCF = (N1 + N2) / (n1 + n2) = (27 + 25) / (9 + 8) = 3.06 */

int foo1(int i){  /* OK */
    int a;
    int b;

    a = i + (2 * (i + 1)) + (3 * (i + 2));
    b = a * 2;

    if(i &gt;= 3)
        return a;
    if(i &gt;= 2)
        return b;
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

HIS Source Code Metriken, version 1.3.1
Metrik "VOCF"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-40</key>
<configkey>METRICS-40</configkey>
<name><![CDATA[ 函数中语句的嵌套深度不得超过 4 层 [METRICS-40] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Statements within function should not be nested deeper than 4 levels [METRICS-40-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Statements should not be nested deeper than 4 levels.
The rule as a level detects a block of code enclosed with curly braces '{}'



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves easier code understanding, and maintain, and often needlessly so.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

int foo2( int x ) {
/* level-0 */    if (x &gt; 0) {                    /* OK */
/* level-1 */        if (x &gt; 1) {                /* OK */
/* level-2 */            if (x &gt; 2) {            /* OK */
/* level-3 */                if (x &gt; 3) {        /* OK */
/* level-4 */                    if (x &gt; 4) {    /* Violation - level 5 starts */
/* level-5 */                       if (x &gt; 5) { /* OK - Violation on higher level */
/* level-6 */	                        return x;
	                            }
                                 }
                             }
                         }
                     }
                 }
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Do not use excessive block nesting depth (more than 4 levels)



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

HIS Source Code Metriken, version 1.3.1
Metrik "LEVEL"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-41</key>
<configkey>METRICS-41</configkey>
<name><![CDATA[ 函数前面和内部的注释模块的数量与函数内语句的数量之比应该 > 0.2 [METRICS-41] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
The number of blocks of comments before and inside function to the number of statements in function should be &gt; 0.2 [METRICS-41-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

The rule reports a violation if the number of blocks of comments in function
body (BCOM) and before function (BCOB) to number of statements in function
(STMT) is not higher than 0.2
    (BCOM + BCOB)/STMT &lt;= 0.2 /* Violation */
Counted statements are: asm, break, continue, do...while, empty, for, goto,
if, return, switch, while and the top level expressions.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule improves readability and maintainability.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

/* 1 block */
/* 1 block */

int comm /* Violation - function 'comm' contains 20 statements
            and 4 blocks of comments - COMF = 0.2
            2 block */
(
    unsigned short s
)
{
    int i;

    if (s &gt; 0)
       i = 3;
    else
       i = 4;
    if (s &gt; 0)
       i = 3;
    else
       i = 4;
    if (s &gt; 0)
       i = 3;
    else        /* 3 block */
       i = 4;
    if (s &gt; 0)
       i = 3;
    else
       i = 4;
    if (s &gt; 0)
       i = 3;
    else
       i = 4;   /* 4 block */
    if (s &gt; 0){
       i = 3;
       i = 5;
    }
    else
       i = 4;
    return i;
} 



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

/* 1 block */
/* 1 block */

int comm1 /* OK - function 'comm' contains 20 statements
            and 10 blocks of comments - COMF = 0.5
            2 block */
(
   unsigned short s /* 3 block */
                    /* 4 block */
)
{
    int i;

    if (s &gt; 0)
       i = 3;
    else
       i = 4;
    if (s &gt; 0)
       i = 3;
    else
       i = 4;
    if (s &gt; 0)
       i = 3;   /* 5 block */
    /* 6 block */
    else        /* 7 block */
       i = 4;
    if (s &gt; 0)
    	/* 8 block */
    	/* 8 block */
    	/* 8 block */ i = 3;
    else
       i = 4;
    if (s &gt; 0)
       i = 3;
    /* 9 block */
    else
       i = 4;
    if (s &gt; 0){
       i = 3;
       i = 5;
    }
    else
       i = 4;
    return i;
}/* 10 block */



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

HIS Source Code Metriken, version 1.3.1
Metrik "COMF"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-CBO</key>
<configkey>METRICS-CBO</configkey>
<name><![CDATA[ 遵守对象之间的耦合限制 [METRICS-CBO] ]]></name>
<tag>metrics</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Coupling Between Objects [METRICS-CBO-1]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of classes to which a class is coupled

A class is coupled to another class when it calls methods or uses variables
declared by the other class. Only method calls and variable references are
counted. Other types of uses (for example simply declaring variable of the
other class, or using typedef declared in the other class) does not count as
coupling.

High coupling between object classes means modules depend on each other too
much and will be hard to reuse. The more independent a class is, the easier
it is to reuse it in another application. In order to improve modularity and
promote reuse, inter-object class couples should be kept to a minimum.
The larger the number of couples, the higher the sensitivity to changes in
other parts of the design, and therefore maintenance is more difficult.

When computing CBO value for a class, only defined methods are taken into
account.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // CBO = 0
public:
    void foo() {}
    int x;
};

class B : public A { // CBO = 0
public:
    void bar1() {
        foo(); // class is not coupled to it's parents
    }
    int bar2() {
        x = 0; // class is not coupled to it's parents
        return y;
    }
    int y;
};

class C { // CBO = 2
public:
    int bar(A a) {
        B b;
        a.foo(); // coupling to A
        a.x = 0; // coupling to A
        return b.bar2(); // coupling to B
    }
};


</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>
1. Shyam R. Chidamber, Chris F. Kemerer
   A Metrics Suite for Object Oriented Design
   IEEE Transactions on Software Engineering, Vol 20., No. 6, June 1994

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-ID</key>
<configkey>METRICS-ID</configkey>
<name><![CDATA[ 遵守继承深度的限制 [METRICS-ID] ]]></name>
<tag>metrics</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Inheritance Depth [METRICS-ID-5]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
The ordinal distance from the class to the root of the inheritance tree.
In cases involving multiple inheritance, the maximum length from to class to
the root of the tree is taken into account.

The deeper a class is in the hierarchy, the greater the number of methods and
state variables it is likely to inherit, which make it more difficult to
predict its behavior. If there are a majority of ID values below 2, it may
represent poor exploitation of the advantages of OO design and inheritance.

Industry standards recommend a maximum ID value of 5 since deeper trees
constitute greater design complexity as more methods and classes are involved.
It is often difficult to understand a system with many inheritance layers,
however, there is a greater potential reuse of tested inherited methods.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // ID = 0
};

class B : public A { // ID = 1
};

class C : public B { // ID = 2
};

class D { // ID = 0
};

class E : public C, public D { // ID = 3
};


</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>
1. Shyam R. Chidamber, Chris F. Kemerer
   A Metrics Suite for Object Oriented Design
   IEEE Transactions on Software Engineering, Vol 20., No. 6, June 1994

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-LCOM</key>
<configkey>METRICS-LCOM</configkey>
<name><![CDATA[ 遵守内聚缺乏度的限制 [METRICS-LCOM] ]]></name>
<tag>metrics</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Lack Of Cohesion [METRICS-LCOM-1]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
LCOM = (avg(m(a)) - m)/(1-m)
  m - number of methods which use at least one field
  m(a) - number of methods which use field "a"
  avg(m(a)) - average number of methods which use field a
    (computed over all fields which are used by at least one method)
    In other words: avg(m(a)) = (m(a1) + m(a2) + ... + m(an)) / n
    
Metric calculates Lack of Cohesion in Methods (Henderson-Sellers "LCOM3" or
"LCOM*" variant). Only fields which are accessed by at least one method,
and methods which access at least one field are included in the count.

Cohesion is a measure of relatedness in a class. If a class has low cohesion
it may perform various tasks which have little relation to one another.
These classes may be candidates for refactoring into separate, more targeted,
classes.

LCOM can take values between 0 and 1, where 0 means class is cohesive (lack of
cohesion is at minimum), and 1 means class is not cohesive (lack of cohesion is
at maximum). Value 0 means that every field is used by every method (class is
cohesive - all methods work on the same set of fields and perform common task),
and 1 means that every field is used by only 1 method (class is not cohesive -
every method has it's own field and performs it's own task separated from other
methods/tasks).

When computing LCOM value for a class, only defined methods are taken into
account.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // LCOM = 0
    void foo1() {
        x = 0;
        y = 0;
    }
    void foo2() {
        x = y;
    }
    int x;
    int y;
};

class B { // LCOM = 1
    void foo1() {
        x = 0;
    }
    void foo2() {
        y = 0;
    }
    int x;
    int y;
};

class C { // LCOM = 0.5
    void foo1() {
        x = 0;
    }
    void foo2() {
        y = x;
    }
    int x;
    int y;
};


</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>
Consider splitting classes into separate, more targetted, classes.
For example:

class B1 { // LCOM = 0
    void foo1() {
        x = 0;
    }
    int x;
};

class B2 { // LCOM = 0
    void foo2() {
        y = 0;
    }
    int y;
};


</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. Henderson-Sellers, B.
   Object-oriented metrics: measures of complexity
   Prentice-Hall, pp.142-147, 1996.

2. Lack of Cohesion in Methods
   <A HREF="http://eclipse-metrics.sourceforge.net/descriptions/pages/cohesion/LackOfCohesionInMethods.html">http://eclipse-metrics.sourceforge.net/descriptions/pages/cohesion/LackOfCohesionInMethods.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NOCT</key>
<configkey>METRICS-NOCT</configkey>
<name><![CDATA[ 遵守构造函数的数量限制 [METRICS-NOCT] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of Constructors [METRICS-NOCT-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of constructors declared explicitly in a class.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NOCT = 0
};

class B { // NOCT = 1
public:
    B();
};

class C { // NOCT = 4
public:
    C();
    C(int i);
    C(float f);
    C(const C&amp; o);
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NOF</key>
<configkey>METRICS-NOF</configkey>
<name><![CDATA[ 遵守实例字段的数量限制 [METRICS-NOF] ]]></name>
<tag>metrics</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of Instance Fields [METRICS-NOF-4]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of non-static fields in a type.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NOF = 1
public:
    static int I;
private:
    int _i;
};

class B { // NOF = 3
public:
    int i;
    float f;
    long l;
};

struct C { // NOF = 2
    int i;
    float f;
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NOFT</key>
<configkey>METRICS-NOFT</configkey>
<name><![CDATA[ 遵守字段的数量限制 [METRICS-NOFT] ]]></name>
<tag>metrics</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of Fields [METRICS-NOFT-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of fields in a type.

This includes both instance and static fields declared in a type.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NOFT = 2
public:
    static int I;
private:
    int _i;
};

struct B { // NOFT = 3
    int i;
    float f;
    long l;
};

union C { // NOFT = 2
    int i;
    float f;
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NOM</key>
<configkey>METRICS-NOM</configkey>
<name><![CDATA[ 遵守实例方法的数量限制 [METRICS-NOM] ]]></name>
<tag>metrics</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of Instance Methods [METRICS-NOM-4]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of non-static methods (including constructors and destructors)
declared explicitly in a class.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NOM = 1
public:
    void foo();
    static void bar();
};

class B { // NOM = 4
public:
    B();
    void foo();
    ~B();
private:
    void bar();
};

class C { // NOM = 0
public:
    static void foo();
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NOO</key>
<configkey>METRICS-NOO</configkey>
<name><![CDATA[ 遵守方法的数量限制 [METRICS-NOO] ]]></name>
<tag>metrics</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of Methods [METRICS-NOO-4]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of methods declared explicitly in a class.

This includes both instance and static methods declared in a class.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NOO = 2
public:
    void foo();
    static void bar();
};

class B { // NOO = 4
public:
    B();
    void foo();
    ~B();
private:
    void bar();
};

class C { // NOO = 1
public:
    static void foo();
}; 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NPRIF</key>
<configkey>METRICS-NPRIF</configkey>
<name><![CDATA[ 遵守 "private" 字段的数量限制 [METRICS-NPRIF] ]]></name>
<tag>metrics</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of "private" Fields [METRICS-NPRIF-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of private fields in a type.

This includes both instance and static fields declared in a type.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NPRIF = 1
public:
    static int I;
private:
    int _i;
};

class B { // NPRIF = 3
private:
    int _i;
    static float _F;
    static long _L;
};

class C { // NPRIF = 0
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NPRIM</key>
<configkey>METRICS-NPRIM</configkey>
<name><![CDATA[ 遵守 "private" 方法的数量限制 [METRICS-NPRIM] ]]></name>
<tag>metrics</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of "private" Methods [METRICS-NPRIM-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of private methods in a class.

This includes both instance and static methods declared in a class.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NPRIM = 1
public:
    static int foo();
private:
    int bar();
};

class B { // NPRIM = 3
private:
    void foo();
    static float bar();
    static void foo(int i);
};

class C { // NPRIM = 0
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NPROF</key>
<configkey>METRICS-NPROF</configkey>
<name><![CDATA[ 遵守 "protected" 字段的数量限制 [METRICS-NPROF] ]]></name>
<tag>metrics</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of "protected" Fields [METRICS-NPROF-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of protected fields in a type.

This includes both instance and static fields declared in a type.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NPROF = 1
public:
    static int I;
protected:
    int _i;
};

class B { // NPROF = 3
protected:
    int _i;
    static float _F;
    static long _L;
};

class C { // NPROF = 0
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NPROM</key>
<configkey>METRICS-NPROM</configkey>
<name><![CDATA[ 遵守 "protected" 方法的数量限制 [METRICS-NPROM] ]]></name>
<tag>metrics</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of "protected" Methods [METRICS-NPROM-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of protected methods in a class.

This includes both instance and static methods declared in a class.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NPROM = 1
public:
    static int foo();
protected:
    int bar();
};

class B { // NPROM = 3
protected:
    void foo();
    static float bar();
    static void foo(int i);
};

class C { // NPROM = 0
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NPUBF</key>
<configkey>METRICS-NPUBF</configkey>
<name><![CDATA[ 遵守 "public" 字段的数量限制 [METRICS-NPUBF] ]]></name>
<tag>metrics</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of "public" Fields [METRICS-NPUBF-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of public fields in a type.

This includes both instance and static fields declared in a type.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NPUBF = 1
public:
    static int I;
private:
    int _i;
};

class B { // NPUBF = 3
public:
    int _i;
    static float _F;
    static long _L;
};

class C { // NPUBF = 0
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NPUBM</key>
<configkey>METRICS-NPUBM</configkey>
<name><![CDATA[ 遵守 "public" 方法的数量限制 [METRICS-NPUBM] ]]></name>
<tag>metrics</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of "public" Methods [METRICS-NPUBM-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of public methods in a class.

This includes both instance and static methods declared in a class.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NPUBM = 1
public:
    static int foo();
protected:
    int bar();
};

class B { // NPUBM = 3
public:
    void foo();
    static float bar();
    static void foo(int i);
};

class C { // NPUBM = 0
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NSF</key>
<configkey>METRICS-NSF</configkey>
<name><![CDATA[ 遵守静态字段的数量限制 [METRICS-NSF] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of Static Fields [METRICS-NSF-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of static fields in a type.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NSF = 1
public:
    static int I;
private:
    int _i;
};

class B { // NSF = 3
public:
    static int I;
    static float F;
    static long L;
};

struct C { // NSF = 0
    int i;
    float f;
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>METRICS-NSM</key>
<configkey>METRICS-NSM</configkey>
<name><![CDATA[ 遵守静态方法的数量限制 [METRICS-NSM] ]]></name>
<tag>metrics</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Follow the limit for Number Of Static Methods [METRICS-NSM-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
Number of static methods in a class.


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v9.2


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
class A { // NSM = 1
public:
    static int foo();
private:
    int bar();
};

class B { // NSM = 3
public:
    static int foo();
    static float bar();
    static long foo(int i);
};

class C { // NSM = 0
};

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-004_a</key>
<configkey>MISRA-004_a</configkey>
<name><![CDATA[ 应当作出适当的运行时检查的规定 [MISRA-004_a] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应当作出适当的运行时检查的规定 [MISRA-004_a-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在索引数组之前，先确保数组索引是在数组大小的范围内。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以防止 取/放 超出范围的值。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int j;
    int k[10]; 
    int m;
	m = k[j]; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void moo() 
{
    int j;
    int k[10];
    int m;

    if ((j &lt; 10) &amp;&amp; (j &gt;= 0)) /* OK */
	{
	m = k[j];
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 4 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-004_b</key>
<configkey>MISRA-004_b</configkey>
<name><![CDATA[ 应当作出适当的运行时检查的规定 [MISRA-004_b] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应当作出适当的运行时检查的规定 [MISRA-004_b-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

左移一个整数可能把最重要的位 
丢失, 同时也是一种溢出。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止溢出。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void main() 
{
    int i = 4;
    int j = 2;
    int k = j &lt;&lt; i;  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要对一个整数使用左移



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 4 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-005</key>
<configkey>MISRA-005</configkey>
<name><![CDATA[ 只能使用定义在 ISO C 标准里的字符 [MISRA-005] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只能使用定义在 ISO C 标准里的字符 [MISRA-005-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只能使用定义在 ISO C 标准里的那些 
字符和转义序列。

第 5.2.1 章节的 ISO C 标准定义了 91 个字符，
这个是所有编译器最低的源字符集
这些是唯一应使用的字符，
即使编译器支持一个更大的字符集，
或支持其他的字符集。

这些字符是:
- 拉丁字母里的 26 个大写字母
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z

- 拉丁字母里的 26 个小写字母
a b c d e f g h i j k l m
n o p q r s t u v w x y z

- 10 个十进位数字
0 1 2 3 4 5 6 7 8 9

- 以下的 29 图形字符
!"#%&amp;' ()*+,-./:
;&lt;=&gt;?[\]^_{|}~
空格字符和控制字符代表 
水平制表符，垂直制表符， 换页。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

只需要最少的字符集



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    char c1 = '$';  /* 违规 */
    char c2 = '`';  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用没有定义在 ISO C 标准里的字符。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 5 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.4 章 Environment， AV 第 9 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-006</key>
<configkey>MISRA-006</configkey>
<name><![CDATA[ 字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集 [MISRA-006] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集 [MISRA-006-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“所选择的C 的执行应该符合10646-1标准的子集，
而选定的子集应作记录。”
明确指定数值的字符可能不符合 
所选择的ISO 10646-1标准的子集。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

字符类型值的定义和记录是 ISO 10646-1 的子集。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    const char * s[] = {"a",
                        "\012" /* 违规 */
    };
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

定义字符的类型是 ISO 10646-1 的子集。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 006 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规则
   第 4.4 章 Environment， AV 第 10 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-008</key>
<configkey>MISRA-008</configkey>
<name><![CDATA[ 不得使用宽字符串字面量 [MISRA-008] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用宽字符串字面量 [MISRA-008-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不得使用宽字符串字面量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止各种与他们相关的不确定和实施明确的行为。
他们不可以被使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
void foo() {
  wchar_t* x = L"Fred";	/* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
void foo() {
  char* x = "Fred";	/* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 8 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.4 章 Environment， AV 第 13 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-013</key>
<configkey>MISRA-013</configkey>
<name><![CDATA[ 不应该使用 char, int, short, long, float 和 double 基本类型，而是应该用typedef来定义特定长度的等量 [MISRA-013] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应该使用 char, int, short, long, float 和 double 基本类型，而是应该用typedef来定义特定长度的等量 [MISRA-013-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“类型的存储长度可以根据不同的编译器而变化。 如果 
程序员工作在他们知道的一个给定长度时，这样就更安全。”
如果使用基本数值类型(例如， signed char)或者 typedef
的名称不包含任何数字来指示类型的长度(例如， my_int)，
规则报告一个违规信息。
参见: MISRA2004-6_3


例外:

该规则不对下列的情况报告一个违规：
- "main" 函数返回类型
- 外部变量声明
- 布尔和枚举类型
- 位域类型
- 以 'bool' 作为前缀的typedef自定义类型，或者普通字符的typedef自定义类型
  (即使它不包含任何数字)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“该规则可以帮助阐明存储空间的大小，但是因为整型
提升的不对称行为该规则不保证可移植性。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int my_int; /* 违规 - no digits */
static signed char a;      /* 违规 - not typedef */

short int foo(             /* 违规 (for return type) */
        char* p_char,      /* 违规 */
        float&amp; r_float)    /* 违规 */
{
    double h;              /* 违规 */
    const int z = 1;       /* 违规 */
    return 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Exceptions: */
typedef char char_t;            /* OK (plain char) */
typedef unsigned char BOOL;     /* OK (typedef name starts with 'bool' prefix */
struct STRUCT {
        unsigned int i:2;       /* OK (bit-bield type) */
};
bool b;                         /* OK (boolean type) */
enum ENUM { EV };               /* OK (enum type) */
extern signed char a;           /* OK (extern variable) */
int main() { return 0; }        /* OK ("main" return type) */

/* Correct use of typedef: */
typedef signed int my_int32;    /* OK */
typedef signed char int8_t;     /* OK */
typedef short int s16_t;        /* OK */
typedef float&amp; float32ref;      /* OK */
typedef double float64;         /* OK */
typedef const int cs32_t;       /* OK */
s16_t foo(                      /* OK */
        char_t* p_char,         /* OK */
        float32ref r_float)     /* OK */
{
    float64 h;                  /* OK */
    cs32_t z = 1;               /* OK */
    return 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 规则 13

2. MISRA C++:2008  C++ 语言在关键系统中的使用指南
   第 6 章，第 3 节， 规则 3-9-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-014</key>
<configkey>MISRA-014</configkey>
<name><![CDATA[ 显式地声明 'char' 类型为有符号类型或者无符号类型 [MISRA-014] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
显式地声明 'char' 类型为有符号类型或者无符号类型 [MISRA-014-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

'char' 的类型可以被编译器自动定义成有符号或是 
无符号的类型。开发人员一定要在定义 'char' 
类型时指定是否要有符号， 而不是假设所使用 
的编译器，让编译器自动定义 'char' 类型的符号。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果一个变量的类型是一个 typedef 为 char 的，那么将会在
typedef 声明上报告一个违规。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守这一规则可以提升代码安全性和可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef char CHAR; // 违规

char foo(char)     // 违规 x 2
{
   char var1;      // 违规
   CHAR var2;      // OK - Violation is reported on a typedef declaration
}

char (*fptr1)();      // 违规
void (*fptr2)(char);  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char UC; // OK
void foo()
{
   signed char b;         // OK
}
void bar1(signed char d); // OK
unsigned char bar5();     // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 14 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-016</key>
<configkey>MISRA-016</configkey>
<name><![CDATA[ 不得使用浮点型数向下转换表示 [MISRA-016] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用浮点型数向下转换表示 [MISRA-016-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
	
程序员不得以任何方式使用
浮点型数向下转换表示。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止转换时可能会丟失数据



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int* pi;
    float* pf;
    double* pd;
    short int* ps;
    long * pl;

    pi = (int*)pf;    /* 违规 */
    pi = (int*)pd;    /* 违规 */
    ps = (short*)pf;  /* 违规 */
    pl = (long*)pf;   /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int* pi;
    float* pf;
    double* pd;
    short int* ps;
	
    pf = (float*)pd;  /* OK */ 
    ps = (short*)pi;  /* OK */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 16 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.17 章 Types， AV 第 147 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-018_a</key>
<configkey>MISRA-018_a</configkey>
<name><![CDATA[ 数字常量必须使用类型后缀 [MISRA-018_a] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
数字常量必须使用类型后缀 [MISRA-018_a-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数字常量应该使用后缀表示类型，
这里一个适当的后缀是可用。
规则只检查在 65536 和 2147483647 之间的数值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则提升可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned long lVar = 65537; /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned long lVar = 65537L; /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 18 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-018_b</key>
<configkey>MISRA-018_b</configkey>
<name><![CDATA[ 数字常量必须使用类型后缀 [MISRA-018_b] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
数字常量必须使用类型后缀 [MISRA-018_b-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数字常量应该使用后缀表示类型，
这里一个适当的后缀是可用。
规则只检查在 65536 和 2147483647 之间的数值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则提升可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned long arrL[] = {
	0, 
	1, 
	32767, 
	32768, 
	65535, 
	65536, 			/* 违规 */
	2147483547,		/* 违规 */
	2147483648,
	4294967295
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned long arrL[] = {
	0,			/* OK */
	1, 			/* OK */
	32767, 			/* OK */
	32768, 			/* OK */
	65535,			/* OK */
	65536L, 		/* OK */
	2147483547L,		/* OK */
	2147483648,		/* OK */
	4294967295		/* OK */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 18 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-018_c</key>
<configkey>MISRA-018_c</configkey>
<name><![CDATA[ 数字常量必须使用类型后缀 [MISRA-018_c] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
数字常量必须使用类型后缀 [MISRA-018_c-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数字常量应该使用后缀表示类型，
这里一个适当的后缀是可用。
规则只检查在 65536 和 2147483647 之间的数值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则提升可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned long lVar = 32768; /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned long lVar = 32768U; /* OK */
unsigned long lVar3 = 32767; /* OK */
unsigned long lVar4 = 65536; /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 18 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-018_d</key>
<configkey>MISRA-018_d</configkey>
<name><![CDATA[ 数字常量必须使用类型后缀 [MISRA-018_d] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
数字常量必须使用类型后缀 [MISRA-018_d-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数字常量应该使用后缀表示类型，
这里一个适当的后缀是可用。
规则只检查在 65536 和 2147483647 之间的数值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则提升可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned long arrL[] = {
	0, 
	1, 
	32767, 
	32768, 			/* 违规 */ 
	65535,  		/* 违规 */
	65536,
	2147483547,
	2147483648,
	4294967295
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned long arrL[] = {
	0,			/* OK */
	1, 			/* OK */
	32767, 			/* OK */
	32768U, 		/* OK */
	65535U,			/* OK */
	65536, 			/* OK */
	2147483547,		/* OK */
	2147483648,		/* OK */
	4294967295		/* OK */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 18 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-020</key>
<configkey>MISRA-020</configkey>
<name><![CDATA[ 所有对象和函数必须先声明再使用 [MISRA-020] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有对象和函数必须先声明再使用 [MISRA-020-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则要求所有对象和函数要被声明后才能使用。
一个声明可以提供编译器有关于类型的对象或函数的信息。
例如，如果发现未声明的函数，编译器將作出有关函数原型的假设，
并不会验证是否实际参数类型匹配函数声明中指定的类型。
这可能导致未定义的行为，导致难以在运行时发现错误。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这条规则只针对 C 代码



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则可阻止未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>


void goo()
{
  foo1();       /* 违规 - function undeclared */
  foo2();       /* 违规 - function declared after use */
}
void foo2();



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

//--------file.h-----------------
void foo1_h();
void foo2_h(){}

//--------file.c-----------------
#include "file.h"
void foo1();
void foo2(){}

void goo()
{
    foo1(); /* OK - function declared before use */
    foo2(); /* OK - function defined before use */
    foo1(); /* OK - function declared in header */
    foo2(); /* OK - function defined in header */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 第 20 条规则

2. Multiplatform Porting to 64 Bits
   <A HREF="http://www.ddj.com/showArticle.jhtml;jsessionid=GJEIYBMN14LMIQSNDBCSKHSCJUMEKJVN?articleID=184406427">http://www.ddj.com/showArticle.jhtml;jsessionid=GJEIYBMN14LMIQSNDBCSKHSCJUMEKJVN?articleID=184406427</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-022</key>
<configkey>MISRA-022</configkey>
<name><![CDATA[ 在函数范围内声明对象 [MISRA-022] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数范围内声明对象 [MISRA-022-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

声明的对象应该在函数范围
除非有必要在更大范围。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用全局变量



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int globalVar;  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int localVar;   // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 第 22 条规则

2. Ellemtel 编码规范 
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    出自: 16 Memory Allocation - Rec. 57

3. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 136 条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-023</key>
<configkey>MISRA-023</configkey>
<name><![CDATA[ 尽可能在文件范围中的声明都是静态 static 的 [MISRA-023] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽可能在文件范围中的声明都是静态 static 的 [MISRA-023-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在可能的情況，所有在文件范围中的声明应该是静态 static 的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止意外覆盖的函数或者变量。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int g1; /* 违规 */
void foo1() {}; /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static int g2; /* OK */
static void foo2(){}; /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 23 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
   第 4.15 章 Declarations and Definitions， AV 第 137 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-024</key>
<configkey>MISRA-024</configkey>
<name><![CDATA[ 对标识符使用一致的连接 [MISRA-024] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对标识符使用一致的连接 [MISRA-024-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在同一个转换单位标识符不得同时
有内部和外部连接。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以阻止变量名隐藏，应为这样会造成困惑



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static unsigned short x;
static unsigned short y;

void foo( ) {
    extern unsigned short x;     // 违规
    extern unsigned short y;     // 违规
    {
        extern unsigned short y; // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

在同一个转换单位不要同时声明变量
在内部和外部连接。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源:  Misra 指南 - 第 24 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 138 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-027</key>
<configkey>MISRA-027</configkey>
<name><![CDATA[ 外部对象不得声明在多个文件中 [MISRA-027] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
外部对象不得声明在多个文件中 [MISRA-027-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

外部对象应在头文件中声明，然后由包含在所有
这些的源文件使用这些对象。此规则将通知关于多
声明符号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则提升代码的可读性，让代码更清晰，防止错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* misra_027.h */
/* 不得在多个文件中声明外部对象。 */
extern int a;           /* 违规 */

/* misra_027.c */
#include "misra_027.h"
extern int a;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* misra_027.h */
extern int a;           /* OK */

/* misra_027.c */
#include "misra_027.h"
int a;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 27 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 139 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-028</key>
<configkey>MISRA-028</configkey>
<name><![CDATA[ 不要用寄存器式存储类别 [MISRA-028] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要用寄存器式存储类别 [MISRA-028-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可使用寄存器存储类别关键字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止依赖于编译器。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    register int a;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 'register' 存储类别关键字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源:  Misra 指南 - 第 28 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.15 章 Declarations and Definitions， AV 第 140 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-029</key>
<configkey>MISRA-029</configkey>
<name><![CDATA[ 标签的使用应该和它的声明一致 [MISRA-029] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标签的使用应该和它的声明一致 [MISRA-029-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

标签的使用应该和它的声明一致。 
当标签初始化跟标签结构声明不一样时，此规则会报告错误。
这条规则只针对 C 语言。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则改善代码的可读性，让代码更清晰，防止错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct tagSTRUCT {
    int _x;
};

struct tagSTRUCT t = { "abc" }; /* 违规 - 'char *' 初始化程序不匹配 _x 字段的类型: */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct tagSTRUCT {
    int _x;
};

struct tagSTRUCT s = { 123 }; /* OK - 初始化程序匹配 _x 字段的类型: */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 29 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-030</key>
<configkey>MISRA-030</configkey>
<name><![CDATA[ 所有自动变量在使用之前必须被赋值 [MISRA-030] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有自动变量在使用之前必须被赋值 [MISRA-030-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这个规则的意图是在变量读取之前，所有的变量
要先被赋值。 变量并不一定需要在初始化声明时
被赋值。 理想的静态检查应该检查任何有可能被
利用又没有被赋值的自动变量。”
参见: INIT-06, INIT-10, INIT-14, BD-PB-NOTINIT



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这条规则假设通过传递的一个常量定指到外部函数，
局部变量有可能会被初始化。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止从未初始化的变量中读取。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int b;          // 违规      
    b++; 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int b = 0;     // OK 
    b++;        
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 1 章, 第 4 项

2. Misra 指南 - 第 30 条规则

3. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
   出自: 第 11 Variables - 第 40 条规则

4. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.16 章 Initialization， AV 第 142 条规则

5. MISRA C++:2008 C++ 语言在关键系统中的使用指南，
   第 6 章， 第 8 节， 第 8-5-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-038</key>
<configkey>MISRA-038</configkey>
<name><![CDATA[ 移位运算符右边操作数越界 [MISRA-038] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
移位运算符右边操作数越界 [MISRA-038-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

移位运算符的右边操作数应当介于零
和一个小于左边操作数宽度位的之间（包含) 。
这条规则假设类型的大小: char 有 8 位， short 有 16 位，
int 有 32 位， long 有 64 位。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以让提升代码的可读性，减少困惑。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifndef uint8_t
    typedef unsigned char   uint8_t;
#endif
#ifndef uint16_t
    typedef unsigned short  uint16_t;
#endif
#ifndef uint32_t
    typedef unsigned int    uint32_t;
#endif

void foo( ) {
    uint8_t  it8;
    uint16_t it16;
    uint32_t it32;

    it8  &lt;&lt; 8;  // 违规
    it16 &lt;&lt; 16; // 违规
    it32 &gt;&gt; 32; // 违规
    it16 &gt;&gt; it8;// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef uint8_t
    typedef unsigned char   uint8_t;
#endif
#ifndef uint16_t
    typedef unsigned short  uint16_t;
#endif
#ifndef uint32_t
    typedef unsigned int    uint32_t;
#endif

void foo( ) {
    uint8_t  it8;
    uint16_t it16;
    uint32_t it32;

    it8  &lt;&lt; 7;  // OK
    it16 &lt;&lt; 15; // OK
    it32 &gt;&gt; 31; // OK
    if (it8 &gt; 0 &amp;&amp; it8 &lt; sizeof( it8 ))
        it16 &gt;&gt; it8; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 38 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-041</key>
<configkey>MISRA-041</configkey>
<name><![CDATA[ 整数除法操作语句之前必须有注释 [MISRA-041] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整数除法操作语句之前必须有注释 [MISRA-041-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在选定的编译器中
执行整数除法应该
明确地记录和考虑。
这条规则检查，在代码中凡是有一个
整数除法，那么代码的前一行必须要有注释。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防不预期的数据和准确度的流失 。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int i=2;
    int j=3;
    int k;

    k=j/i;  /* 违规 - 除法之前没有注释*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void boo() 
{
    int i=2;
    int j=3;
    int k;

/*  OK - 整数除法之前的注释 */    
    k=i/j;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 41 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 167 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-042</key>
<configkey>MISRA-042</configkey>
<name><![CDATA[ 除了在 FOR 循环的控制表达式之外，不得使用逗号运算符 [MISRA-042] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
除了在 FOR 循环的控制表达式之外，不得使用逗号运算符 [MISRA-042-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了在循环的控制表达式中使用逗号运算符，
在其他的地方使用逗号运算符会不利于代码的可读性。
同样的效果可以通过其他的方式来实现。”
参见: misra2004-12_10



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

广泛的使用逗号运算符会降低代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1( int x, int y )
{
    int i;
    i = (x = 1, y = 0);            // 违规
    x++, y++;                      // 违规
    for (i = 0; i &lt; 10; i++){
        foo1( (x--, y + 2), y );   // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo2( int x, int y ) {
    int i;
    x++;
    y++;                                       // OK
    for (i = 0; i &gt;=0, i &lt; 10; i++)	{     // OK 
    }
    x--;
    foo2( y + 2, y );                      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 42 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 168 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-043</key>
<configkey>MISRA-043</configkey>
<name><![CDATA[ 不得使用会导致信息丢失的隐式类型转换 [MISRA-043] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用会导致信息丢失的隐式类型转换 [MISRA-043-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"C performs many type conversions implicitly and silently, so as to harmonize
types within an expression before evaluating it. Some of these conversions can
result in loss of information. Such implicit conversions shall not be used,
but explicit casts should be used instead."
The rule reports a violation if a parameter/variable/expression of integral
or floating type is implicitly cast to a narrower type.
参见: MISRA2004-10_1_b, MISRA2004-10_2, PORT-27, PORT-28



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule assumes the following order of sizes:
char &lt; short &lt; int &lt; long &lt; long long
float &lt; double &lt; long double
The rule assumes that the size of enumeration type is the same as int type.


例外:

The rule does not report violation if a conversion is used:
- on a constant expression
- between integral and floating type
- between signed and unsigned type
- on a bit field



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"Explicit casts should normally only be used in the case where a conversion 
which could result in a loss of information is specifically required by the 
programmer. If the static checking of implicit conversions is overridden by
the use of explicit casts in this way, then the programmer should be aware
of the issues of truncation and lost of precision associated with the operation,
and should provide appropriate checking of values in the code"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void bar(unsigned char c);

void foo(unsigned int ui, double d)
{
    float f;
    unsigned short us1;
    unsigned short us2 = ui; /* 违规 */
    us1 = us2 + us2;         /* 违规 - due to integral promotion */
    f = d;                   /* 违规 */
    bar(ui);                 /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>


void bar(unsigned char c);

void foo(unsigned int ui, double d)
{
    float f;
    unsigned short us = (unsigned short)ui; /* OK */
    f = (float)d;                           /* OK */
    bar((unsigned char)ui);                 /* OK */
}

/* exceptions */

void except(unsigned int ui){
    unsigned char uc = 300;   /* OK - constant expression */
    int i = ui;               /* OK - only signed/unsigned conversion */
    float f = ui;             /* OK - integral/floating conversion */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines rule 43

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.23 Type Conversions, AV Rule 180

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-043_b</key>
<configkey>MISRA-043_b</configkey>
<name><![CDATA[ 避免在同一个表达式中混合使用不同精度的算术运算 [MISRA-043_b] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在同一个表达式中混合使用不同精度的算术运算 [MISRA-043_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"C performs many type conversions implicitly and silently, so as to harmonize
types within an expression before evaluating it. Some of these conversions can
result in loss of information. Such implicit conversions shall not be used,
but explicit casts should be used instead.
As a general principle, avoid mixing arithmetic of different precisions in the 
same expression."
The rule reports a violation if as operands of binary arithmetic, relational
equality or bitwise operator are used two non-constant operands of different
types.
参见: MISRA-043, MISRA-048_e, MISRA2004-10_1_b, MISRA2004-10_2, PORT-27,
PORT-28, 



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule does not report violations on conversions:
- between signed and unsigned types
- between integral and floating types



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents unexpected behaviours.
"Mixed arithmetic normally entails implicit promotions and balancing
of types (i.e. conversions), some of which can lead to unexpected behaviour."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(){
    int i;
    short s1, s2, s3;
    float f;
    double d;
	
    s1 = i + s2;        // 违规
    i = s1 + (s2 - s3); // 违规 - due to integral promotion
    if( i &gt; s1 ){       // 违规
        //...
    }
		
    d = f - d;          // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(unsigned int ui){
    int i;
    short s1, s2, s3;
    float f;
    double d;
	
    s1 = i + (int)s2;          // OK
    i = s1 + (short)(s2 - s3); // OK
    if( i &gt; (int)s1 ){         // OK
    	
        //...
    }
		
    d = (double)f - d;         // OK
    
    /* exceptions */
    f = f + i;          // OK
    s1 = s2 + 10;       // OK
    ui = ui + i;        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines rule 43

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-044</key>
<configkey>MISRA-044</configkey>
<name><![CDATA[ 不允许冗余显式转换为同一类型 [MISRA-044] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许冗余显式转换为同一类型 [MISRA-044-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Explicit casting between identical types is unnecessary and clutters code.
Furthermore it can mask problems if changes are made to the code (e.g. one of 
the types changes and a conversion with possible loss of information occurs)"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"The use of casting should be sufficient to cause the calculations required 
to occur with the desired precision. Unnecessary casting adds the possibility
of confusion, and may be such that its interaction with the rules of promotion
leads to results other than those expected. Unnecessary casting may also lead
to code which is harder to maintain, should the types of variables change."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int INT;

int someFunction1();
INT someFunction2();

void foo(int p)
{
    /* ... */
    p = (int)someFunction1();  // 违规
    p = (int)someFunction2();  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int INT;

int someFunction1();
INT someFunction2();

void foo(int p)
{
    /* ... */
    p = someFunction1();  // OK
    p = someFunction2();  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines - Rule 44

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.5 Libraries, AV Rule 181

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-046_a</key>
<configkey>MISRA-046_a</configkey>
<name><![CDATA[ 不要使用 volatile 关键字 [MISRA-046_a] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 volatile 关键字 [MISRA-046_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用 volatile 关键字。
参见: misra2004-12_2_f



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则防止表达式的求值依赖于编译器版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1() {
  volatile int v;  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 volatile 关键字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 46 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.25 章 Expressions， AV 第 205 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-046_c</key>
<configkey>MISRA-046_c</configkey>
<name><![CDATA[ 表达式的值不得依赖于赋值顺序 [MISRA-046_c] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值不得依赖于赋值顺序 [MISRA-046_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在标准允许的任何顺序求值下
表达式的值应是相同的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升可读性和维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo46c(){
    int array[3] = {0};
    int iVar = 1;
    array[iVar++] = iVar;/* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo46c(){
    int array[3] = {0};
    int iVar = 1;
    array[iVar] = iVar + 1;/* OK */
    iVar++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 46 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-046_d</key>
<configkey>MISRA-046_d</configkey>
<name><![CDATA[ 表达式的值不得依赖于赋值顺序 [MISRA-046_d] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值不得依赖于赋值顺序 [MISRA-046_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在标准允许的任何顺序求值下
表达式的值应是相同的。


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不可预测的程式行为。


范例:

void foo46(){
    int array[3] = {0};
    int iVar = 1;
    array[iVar] = --iVar; /* 违规 */
    return;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo46(){
    int array[3] = {0};
    int iVar = 1;
    array[iVar] = iVar-1; /* OK */
    return;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 46 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-048_a</key>
<configkey>MISRA-048_a</configkey>
<name><![CDATA[ 在混合精度运算中必须使用显式的强制类型转换 [MISRA-048_a] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在混合精度运算中必须使用显式的强制类型转换 [MISRA-048_a-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

混合精度运算应该使用显式的强制
类型转换生成期望的结果



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止数据的丢失



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo48b()
{
    int iVar = 2;
    long lVar = 1;
    float fVar = 1.0;
    iVar = (((iVar==2) ? fVar : lVar) + 22); /* 违规 */
    return;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo48b()
{
    int iVar = 2;
    long lVar = 1;
    float fVar = 1.0;
    iVar = (((iVar==2) ? (int)fVar : (int)lVar) + 22); /* OK */
    return;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 48 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-048_b</key>
<configkey>MISRA-048_b</configkey>
<name><![CDATA[ 在混合精度运算中必须使用显式的强制类型转换 [MISRA-048_b] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在混合精度运算中必须使用显式的强制类型转换 [MISRA-048_b-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

混合精度运算应该使用显式的强制
类型转换生成期望的结果



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止数据的丢失



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo48c()
{
    int iVar = 2;
    long lVar = 1;
    float fVar = 1.0;   
    iVar = (((iVar==2) ? lVar : fVar ) + 22); /* 违规 */
    return;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo48c()
{
    int iVar = 2;
    long lVar = 1;
    float fVar = 1.0;
    iVar = (((iVar==2) ? lVar : (int)fVar ) + 22); /* OK */
    return;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 48 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-048_c</key>
<configkey>MISRA-048_c</configkey>
<name><![CDATA[ 在混合精度运算中必须使用显式的强制类型转换 [MISRA-048_c] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在混合精度运算中必须使用显式的强制类型转换 [MISRA-048_c-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

混合精度运算应该使用显式的强制
类型转换生成期望的结果



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止数据的丢失



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo48()
{
    int iVar = 2;
    int iVar2 = 1;
    float fVar = 1.0;
    fVar = (float) (iVar2/iVar); /* 违规 */
    return;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo48()
{
    int iVar = 2;
    long lVar = 1;
    float fVar = 1.0;
    fVar = 34 + lVar/(float)iVar - 2; /* OK */
    return;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 48 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-048_d</key>
<configkey>MISRA-048_d</configkey>
<name><![CDATA[ 在混合精度运算中必须使用显式的强制类型转换 [MISRA-048_d] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在混合精度运算中必须使用显式的强制类型转换 [MISRA-048_d-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

混合精度运算应该使用显式的强制
类型转换生成期望的结果



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止数据的丢失



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo48b()
{
    int iVar = 2;
    long lVar = 1;
    float fVar = 1.0;
    iVar = (((iVar==2) ? fVar : lVar) + 22); /* 违规 */
    return;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo48b()
{
    int iVar = 2;
    long lVar = 1;
    float fVar = 1.0;
    iVar = (((iVar==2) ? (int)fVar : (int)lVar) + 22); /* OK */
    return;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 48 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-048_e</key>
<configkey>MISRA-048_e</configkey>
<name><![CDATA[ 有符号和无符号值的运算中必须使用显式的类型转换 [MISRA-048_e] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
有符号和无符号值的运算中必须使用显式的类型转换 [MISRA-048_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有符号和无符号值的运算中必须使用显式的类型转换



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守这一条规则得到更安全，更可读的代码



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(signed char a)
{
    signed char b = 'b';
    unsigned char c = 'c';
    a = b + c;                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(signed char a)
{
    signed char b = 'b';
    unsigned char c = 'c';
    a = (unsigned char)b + c;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范 
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    来自: 18 Portable Code - 18.3 Type Conversions - Port. Rec. 8

2. Misra 指南 - 第 48 条规则

3. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 162 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-051</key>
<configkey>MISRA-051</configkey>
<name><![CDATA[ 对无符号型常量表达式的求值不应该导致循环 [MISRA-051] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对无符号型常量表达式的求值不应该导致循环 [MISRA-051-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>


“因为无符号整数表达式不会严格意义上溢出，而是
按照模块化的方式循环， 任何无符号常量整数表达式
在实际上 '溢出' 时不会被编译器检查到。”
如果两个常量整数减法的结果是小于零
这条规则会报告错误。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这条规则只能检查简单的符号常量整数的减法。
这条规则没有办法检查:
- 减法以外的表达式
- 复杂的表达式
- 使用宏定义或是十六进位值的表达式



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防无符号整数的回绕。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#if (1u - 2u) /* 违规 */
/* ... */
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免无符号整数的回绕。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 51 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.25 章 Expressions， AV 第 203 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-054</key>
<configkey>MISRA-054</configkey>
<name><![CDATA[ 空语句只能单独出现在一行之中并且在同一行中禁止出现其他字符 [MISRA-054] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空语句只能单独出现在一行之中并且在同一行中禁止出现其他字符 [MISRA-054-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“通常不应该刻意包括空语句， 但是当他们
被使用时，他们应该要单独出现在一行，不能与任何其他
文本在一起 （包括注释）。当空语句与其他文字出现在同
一行时， 根据这条规则会使静态检查工具报告警告，这 
通常表明编程错误。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以提升代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1()
{
    ;        // 违规
    int a;; // 违规
    /* 违规 */ ;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1()
{
    ;        // OK
    int c
    ;        // OK
    for(;;); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 54 条规则


参见: MISRA2004-14_3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-055</key>
<configkey>MISRA-055</configkey>
<name><![CDATA[ 避免使用标签 [MISRA-055] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用标签 [MISRA-055-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要在 switch 语句以外使用标签



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用标签可能会导致错误和混乱



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int count) 
{
    /* ... */
    goto stop_operation;
    /* ... */
    stop_operation: return; /* 违规 */
    /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在 switch 语句以外使用标签



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 55 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.24 章 Flow Control Structures， AV 第 188 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-058</key>
<configkey>MISRA-058</configkey>
<name><![CDATA[ 避免在非 switch 中使用 break 语句 [MISRA-058] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在非 switch 中使用 break 语句 [MISRA-058-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可使用 break 语句
(除了终止 switch 语句的 cases 以外)。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用 'break' 可能导致错误和混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define true 1
void foo(int i)
{
  while (true) 
  {
    if (i==10) 
    {
      break; /* 违规 */
    }        
  }
    
  switch( i ) 
  {
    case -1:
    while (true) 
    {
      if (i==10) 
      {
        break; /* 违规 */
      }        
    }        
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define true 1
void foo(int i)
{
  switch( i ) 
  {
    case -1 :
    break; /* OK */
                
    case 0 :
    break; /* OK */
                
    default:
    break; /* OK */
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 58 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.24 章 Flow Control Structures， AV 第 191 条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-065</key>
<configkey>MISRA-065</configkey>
<name><![CDATA[ 不得使用浮点变量作为循环计数器 [MISRA-065] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用浮点变量作为循环计数器 [MISRA-065-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

浮点变量不得用作循环计数器



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止变量判断时的意外的结果



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
  float i;
  for (i=0.;i&lt;10.;i++)  /* 违规 */
  { 
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
  int i;
  for (i=0;i&lt;10;i++) /* OK */
  {  
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 65 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.24 章 Flow Control Structures， AV 第 197 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-069</key>
<configkey>MISRA-069</configkey>
<name><![CDATA[ 避免使用有可变数量参数的函数 [MISRA-069] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用有可变数量参数的函数 [MISRA-069-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用有可变数量参数的函数



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以防止很多潜在的问题



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int x, ...)   // 违规
{  
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用有可变数量参数的函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 第 69 条规则

2. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   从: 9 Functions - 9.1 Function Arguments - 第 31 条规则 

3. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   "Type Safety" 章， 第 98 条规则

4. Scott Meyers and Martin Klaus, "Examining C++ Program Analyzers", 
   Dr. Dobbs' Journal, the February 1997, 
   "Implementation" 章， 第 23 项
   <A HREF="http://www.aristeia.com/ddjpaper1_frames.html">http://www.aristeia.com/ddjpaper1_frames.html</A>

5. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.13 章 Function， AV 第 108 条规则

6. MISRA C++:2008 C++ 语言在关键系统中的使用指南，
   第 6 章， 第 8 节， 第 8-4-1 条规则 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-071</key>
<configkey>MISRA-071</configkey>
<name><![CDATA[ 函数在定义和调用之时必须始终有可见的原型 [MISRA-071] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数在定义和调用之时必须始终有可见的原型 [MISRA-071-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数在定义和调用之时必须始终有可见的原型。
根据 ISO/IEC 9989:1999 C 标准, 一个函数原型
是一个函数的声明，声明他的参数的类型。MISRA 
规则 71 要求一定要在函数被调用或定义前声明所有的
函数。这意味着函数原型必须出现在定义和调用
之前。下面的例子说明了用这条规则验证的情况。
这条规则只针对 C 语言。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以防止禁用编译器的能力来找出
某些在不使用原型时在函数调用所发生的错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* file *.c */

/* definition without prototype */
void case2goo(void) {       /* 违规*/
}

/* call without prototype */
void case3goo(void);
void case3foo(void) {       /* 违规*/
}
void case3goo(void) {
	case3foo();         /* 违规*/ 
}

/* definition with prototype declared after function definition */
void case6goo(void) {       /* 违规*/
}
void case6goo(void);

/* call with prototype declared after function call */
void case7goo(double x);
void case7goo(double x) {
	case7foo(x);         /* 违规*/
}

int case7foo(double);



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* file *.c */

/* both function call and definition have visible prototype */
void case1foo(void);       /* prototype */
void case1goo(void);       /* prototype */
void case1goo(void) {      /* OK */ 
	case1foo();        /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 71 规则
2. MISRA-C:2004 C 语言在关键系统中的使用指南
   第 6 章， 第 8 节， 第 8.1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-073</key>
<configkey>MISRA-073</configkey>
<name><![CDATA[ 函数的参数要么不提供标识符要么提供所有标识符 [MISRA-073] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数的参数要么不提供标识符要么提供所有标识符 [MISRA-073-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

必须在函数原型声明中提供所有的
标识符， 或者全部都不提供标识符。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以提升代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo3(int a, int);  /* 违规 */
void foo4(int a, int, int b);  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo();  /* OK */
void foo1(int, int);  /* OK */
void foo2(int a, int b);  /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 73 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-083</key>
<configkey>MISRA-083</configkey>
<name><![CDATA[ 非 void 函数的返回语句必须提供返回表达式 [MISRA-083] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非 void 函数的返回语句必须提供返回表达式 [MISRA-083-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于每一个非 void 返回值的函数， 其返回语句都
应该要有返回表达式。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不确定的行为
（编译器可能不会提供错误）。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* compilable by 'c' compiler */

int foo2() {
  return ; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo3() {
  return 0; /* OK */
}

void foo1() {
  return;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 83 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-084</key>
<configkey>MISRA-084</configkey>
<name><![CDATA[ 避免在 void 函数的返回语句中有返回表达式 [MISRA-084] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在 void 函数的返回语句中有返回表达式 [MISRA-084-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于返回值类型为 void 的函数，
返回语句不能有表达式。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不确定的行为 （编译器可能不会提供错误）。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* compilable by 'c' compiler */
void foo2() {
  return 1;  /* 违规 */
}

void foo3() {
  int a=0;
  return a;  /* 违规 */
}

void foo4(int a) {
  return a;  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* compilable by 'c' compiler */

void foo1() {
  return;    /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 84 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-085</key>
<configkey>MISRA-085</configkey>
<name><![CDATA[ 当调用没有参数的函数时必须使用空括号 [MISRA-085] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当调用没有参数的函数时必须使用空括号 [MISRA-085-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

调用没有参数的函数，函数应该要有空括号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以防止代码错误和提升代码品质。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>
int foo()
{
    int iVar = 0;
    if( foo == 0 ) { /* 违规 */
        iVar++;
    }
    if( 0 == foo ) { /* 违规 */
        iVar++;
    }
  return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo()
{
    int iVar = 0;
    if( foo() == 0 ) { /* OK */
        iVar++;
    }
    if( 0 == foo() ) { /* OK */
        iVar++;
    }
  return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 85 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-089</key>
<configkey>MISRA-089</configkey>
<name><![CDATA[ #include 指令后的文件名必须是在尖括号或者双引号中 [MISRA-089] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
#include 指令后的文件名必须是在尖括号或者双引号中 [MISRA-089-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#include 指令应当遵循 &lt;filename&gt; 或是 "filename" 序列。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// #include "misra89.h"
#define MISRA_HEADER "misra89.h"
#include MISRA_HEADER /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "misra89.h" /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 89 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-096</key>
<configkey>MISRA-096</configkey>
<name><![CDATA[ 必须把类函数形式的宏定义放进括号中 [MISRA-096] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
必须把类函数形式的宏定义放进括号中 [MISRA-096-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在定义一个如函数的宏时， 整个定义
应该括在括号内。
参见: MISRA2004-19_10



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升代码的可读性并确保操作顺序。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define abs( x ) (x)&gt;=0 ? c: -(x)           /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define abs2( x ) ((x)&gt;=0 ? c: -(x))        /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 96 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-100</key>
<configkey>MISRA-100</configkey>
<name><![CDATA[ 只能使用没有歧义性的预处理操作符格式 [MISRA-100] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只能使用没有歧义性的预处理操作符格式 [MISRA-100-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

已定义的预处理操作符只能用在两个标准的形式之一。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* EXAMPLE.H - Example header file */
#if defined TEST+1     /* 违规 */
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* EXAMPLE.H - Example header file */
#if defined TEST       /* OK */ 
#endif 

#if defined EXAMPLE_H
#endif

#if defined ( TEST )    /* OK */ 
#endif

#if !defined ( EXAMPLE_H )
#define EXAMPLE_H        /* OK */ 

struct Example
{
    int _i;
};

#endif /* !defined( EXAMPLE_H ) */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 100 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-101</key>
<configkey>MISRA-101</configkey>
<name><![CDATA[ 避免使用指针进行算术运算 [MISRA-101] ]]></name>
<tag>misra</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用指针进行算术运算 [MISRA-101-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用指针进行运算。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止访问意外或是无效的内存地址。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
  int* a;
  int* b;
  int tab[10];
  a=tab;  
  a++;        /* 违规 */
  --a;        /* 违规 */
  b = a+5;    /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用指针运算。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 101 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.28 章 Portable Code， AV 第 215 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-104</key>
<configkey>MISRA-104</configkey>
<name><![CDATA[ 不要使用非常量指针指向函数 [MISRA-104] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用非常量指针指向函数 [MISRA-104-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用非常量指针指向函数。
参见: CODSTA-CPP-03, CODSTA-CPP-38, CODSTA-CPP-43, CODSTA-CPP-44, MISRA2004-16_7, OPT-21



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用非常量指针指向函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( );
typedef void (*PFUNC) (void);
const PFUNC pf = foo;

void bar( ) {
    PFUNC f1 = foo;         /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( );
typedef void (*PFUNC) (void);
const PFUNC pf = foo; 

void bar( ) {
    const PFUNC f1 = foo;   /* OK */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 第 104 条规则

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-105</key>
<configkey>MISRA-105</configkey>
<name><![CDATA[ 函数指针应该与其指向的所有函数的参数个数，参数类型和返回值类型相同 [MISRA-105] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数指针应该与其指向的所有函数的参数个数，参数类型和返回值类型相同 [MISRA-105-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if a pointer to function is:
- assigned to other pointer to function, or
- initialized by other pointer to function, or
- cast to type of pointer to function
and pointed functions are not identical.
The rule assumes that two functions are identical if they have the same number
and types of parameters and the same return types.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

This rule is active for C code only.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"Pointers to functions can easily violate type integrity, 
so all pointed-to functions should be of identical type."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int(*PTF1)(int, char*);
typedef void(*PTF2)(int, char*);
typedef int(*PTF3)(int, int);
typedef int(*PTF4)(int, char*, ...);

int foo1(int, char*);
void foo2(int, char*);
int foo3(int, int);
int foo4(int, char*, ...);

void test(void)
{
    PTF1 p1;
    PTF2 p2 = foo1; /* 违规 */
    PTF3 p3;
    PTF4 p4;

    p1 = p2;          /* 违规*/
    p1 = p3;          /* 违规*/
    p1 = (PTF1)p4;    /* 违规*/
    p1 = foo2;        /* 违规*/
    p1 = (PTF1)foo3;  /* 违规*/
    p1 = foo4;        /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int(*PTF1)(int, char*);
typedef void(*PTF2)(int, char*);
typedef int(*PTF3)(int, int);
typedef int(*PTF4)(int, char*, ...);

int foo1(int, char*);
void foo2(int, char*);
int foo3(int, int);
int foo4(int, char*, ...);

void test(void)
{
    PTF1 p1;
    PTF2 p2 = foo2;  /* OK */
    PTF3 p3;
    PTF4 p4;

    p1 = (PTF1)foo1; /* OK */
    p3 = foo3;       /* OK */
    p4 = (PTF4)foo4; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Misra Guidelines - Rule 105

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-107_a</key>
<configkey>MISRA-107_a</configkey>
<name><![CDATA[ 空指针不得解除引用 [MISRA-107_a] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空指针不得解除引用 [MISRA-107_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Where a function returns a pointer and that pointer is subsequently 
de-referenced, the program should first check that the pointer is not NULL."
If a control statement contains in condition non-dereferenced pointer, then 
the rule assumes that this pointer is checked. In such cases rule does not
report violations in spite of it does not check if a control statement is
really used to prevent null pointer dereference. 
参见: MISRA-107_b, BD-PB-NP



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Complying with this rule leads to safer code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* ret_ptr(int* p){
    return p;
}

void func(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    /* here pointer 'ptr' should be checked */
    i = *ptr;    /* Violation - pointer 'ptr' may be null */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int* ret_ptr(int* p){
    return p;
}

int check(int* p){
    if(p == 0)
        return 0;
    if(p &gt; 0)
        return 1;
}

void func1(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    if(ptr){
    	i = *ptr;    /* OK - pointer 'ptr' was checked in 'if' condition */
    }

}

void func2(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    if(!ptr){
        return;
    }
    i = *ptr;       /* OK - pointer 'ptr' was checked in 'if' condition */

}

void func3(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    if(check(ptr)){
    	i = *ptr;   /* OK - pointer 'ptr' was checked in 'check' function */
    }
}

void func4(int i, int* par){
    int* ptr;

    ptr = ret_ptr(par);
    if(ptr == 0){
        i = *ptr;    /* OK - pointer 'ptr' was checked in 'if' condition.
                        The 'if' condition is not correct, but the rule
                        does not check such cases. To detect this issue
                        could be used Bug Detectiv rule - BD-PB-NP */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines - Rule 107

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 174

3. <A HREF="http://cwe.mitre.org/data/definitions/476.html">http://cwe.mitre.org/data/definitions/476.html</A>

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-107_b</key>
<configkey>MISRA-107_b</configkey>
<name><![CDATA[ 空指针不得解除引用 [MISRA-107_b] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空指针不得解除引用 [MISRA-107_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Where a function returns a pointer and that pointer is subsequently 
de-referenced, the program should first check that the pointer is not NULL."
If a control statement contains in condition non-dereferenced pointer, then 
the rule assumes that this pointer is checked. In such cases rule does not
report violations in spite of it does not check if a control statement is
really used to prevent null pointer dereference. 
参见: MISRA-107_a, BD-PB-NP



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Complying with this rule leads to safer code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S{
    int si;
};

struct S* ret_ptr(struct S* p){
    return p;
}

void func(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    /* here pointer 's' should be checked */
    s-&gt;si = i;    /* Violation - pointer 's' may be null */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S{
    int si;
};

struct S* ret_ptr(struct S* p){
    return p;
}

int check(struct S* p){
    if(p == 0)
        return 0;
    if(p &gt; 0)
        return 1;
}

void func1(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    if(s){
        s-&gt;si = i;    /* OK - pointer 's' was checked in 'if' condition */
    }

}

void func2(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    if(!s){
        return;
    }
    s-&gt;si = i;       /* OK - pointer 's' was checked in 'if' condition */

}

void func3(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    if(check(s)){
        s-&gt;si = i;   /* OK - pointer 's' was checked in 'check' function */
    }
}

void func4(int i){
    struct S* s;
    struct S* ptr;

    s = ret_ptr(ptr);
    if(s == 0){
        s-&gt;si = i;    /* OK - pointer 's' was checked in 'if' condition.
                         The 'if' condition is not correct, but the rule
                         does not check such cases. To detect this issue
                         could be used Bug Detectiv rule - BD-PB-NP */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines - Rule 107

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.22 Pointers &amp; References, AV Rule 174

3. <A HREF="http://cwe.mitre.org/data/definitions/476.html">http://cwe.mitre.org/data/definitions/476.html</A>

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-108</key>
<configkey>MISRA-108</configkey>
<name><![CDATA[ 结构体和联合体中的所有成员必须完全指定 [MISRA-108] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构体和联合体中的所有成员必须完全指定 [MISRA-108-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在规范内的 structure 或是 union 的类型，
所有成员的 structure 或是 union 应该
完全指定。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用未定义的变量类型。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct X {
    int i;
};

struct Y {
    struct X* x;    /* 违规 */
    int i;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct X {
    int i;
};

struct Y {
    struct X x;     /* OK */
    int i;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 108 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-110</key>
<configkey>MISRA-110</configkey>
<name><![CDATA[ 不能使用联合体访问大数据结构的子部分 [MISRA-110] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用联合体访问大数据结构的子部分 [MISRA-110-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

联合体(Unions)不得使用于访问大数据结构的子部分。

在 C 语言中访问大数据结构的子部分的一个机制
(例如，单个位的 I/O 端口) 是使用 unions 覆盖一个数据结构
在另外一个数据结构上。
例如， 一个包含位域的结构可能会覆盖
上一个整数。
这不是一个安全的机制来实现预期的目标，因为它
假设了太多如何存储不同的数据类型的方式。

当一个 union 有一些位域的成员变量，或是
当 union 包括了其他本身有包括位域的数据结构， 或是
当 union 有了一个成员变量的字符类型的数组的维数
是某种类型的 sizeof 时会触发此规则 （见示例）。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef union {  /* 违规 */
    struct {
        unsigned int en      :1;
        unsigned int dly     :1;
        unsigned int tm_en   :1;
        unsigned int dta_inv :1;
        unsigned int clk_inv :1;
    } _bitfield; 
    unsigned long _int;
} REG_PTR;

union A { /* 违规 */
    int field;
    int firstTwoBits :2;
};

typedef int* TYPE;

union B { /* 违规 */
    TYPE t;
    char bytes[sizeof(TYPE)];
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用联合体(union)结构。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 110 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-113</key>
<configkey>MISRA-113</configkey>
<name><![CDATA[ 结构体或联合体的所有成员变量必须被命名 [MISRA-113] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构体或联合体的所有成员变量必须被命名 [MISRA-113-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

命名所有结构体(structure) 或 联合体(union)的成员。

在 C 语言中 "位域" 设施是其中的一个最不好定义
的部分。位域有两个主要的用途，他们可以用在:

1) 访问单个位，或是一组位，在更大的数据类型，
与联合会一道 (见规则 110).
2) 让标记或是其他短长度数据能够被包装，以节省存储空间

使用位域包装短长度的数据以节省存储空间是本
文档认为唯一的合理使用。

提供了只通过他们的名称访问结构体的元素，
程序员不能做任何有关于位域是如何
存储在结构体里的假设。

这条规则检查所有声明位域的名称。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用不可访问的数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int t;
typedef int plain;
struct tag {
    unsigned t:4;
    const t:5;   /* 违规 */
    plain r:5;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

提名所有 structure 或 union 的成员。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源:  Misra 指南  - 第 113 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.21 章 Operators， AV 第 156 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-115</key>
<configkey>MISRA-115</configkey>
<name><![CDATA[ 不得重复使用标准库函数的名称 [MISRA-115] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得重复使用标准库函数的名称 [MISRA-115-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不得重复使用标准库函数的名称。
这条规则要求任何新版本的标准函数的名称
不能与原函数的名称相同。
这个是为了避免混淆，是否是一个标准库函数被使用或
是否是一个修改后的函数版本被使用。 
当罗列在 Annex B 的 ISO/IEC 9899:1999 标准中的函数
被重复定义，这条规则会报告违反错误。
还会在当任何函数定义的名称和任何定义在标准中的函数宏
发生冲突时报告违反错误 （看下面的示例）。
这条规则只能用于 C 语言。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止编写容易出错的代码，并提供可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

double sqrt(double arg)             /* 违规 - redefined */ 
{
	return (arg);
}

void strpbrk(double arg) { }        /* 违规 - redefined */ 

/* macro redefined as function */ 
void offsetof(double arg) { }       /* 违规 - std. macro name */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

double sqrt(double);                /* OK - just declared */ 
void foo()                          /* OK - user function */
{
	sqrt(123.0);                /* OK - std. C function call */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 115 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-121_a</key>
<configkey>MISRA-121_a</configkey>
<name><![CDATA[ 不要使用 locale.h 头文件和 setlocale 函数 [MISRA-121_a] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 locale.h 头文件和 setlocale 函数 [MISRA-121_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用 &lt;locale.h&gt; 和 setlocale 函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用者把标准 C locate 修改为 locate。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;locale.h&gt;
void foo(void)
{
  /* Set the locale back to the default environment */
  setlocale(LC_ALL, "C");  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 'setlocale' 函数。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源: Misra 指南 - 第 121 条规则

2. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.5 章 Libraries， AV 第 19 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA-121_b</key>
<configkey>MISRA-121_b</configkey>
<name><![CDATA[ 不要使用 locale.h 头文件和 setlocale 函数 [MISRA-121_b] ]]></name>
<tag>misra</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 locale.h 头文件和 setlocale 函数 [MISRA-121_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用 &lt;locale.h&gt; 和 setlocale 函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用者把标准 C locate 修改为 locate。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;locale.h&gt;  /* 违规 */
void foo(void)
{
  /* Set the locale back to the default environment */
  setlocale(LC_ALL, "C");  
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 'setlocale' 函数。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

来源: Misra 指南 - 第 121 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_a</key>
<configkey>MISRA2004-10_1_a</configkey>
<name><![CDATA[ 避免隐式的无符号整型和有符号整型的转换 [MISRA2004-10_1_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的无符号整型和有符号整型的转换 [MISRA2004-10_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
该规则检查是否使用了有符号和无符号类型之间的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned int u32a, u32b;
    signed int s32a, s32b;

    s32a = u32a;            /* Violation */
    s32b = s32a + u32a;     /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned int u32a, u32b;
    signed int s32a, s32b;

    s32a = (signed int)u32a;        /* OK */
    s32b = s32a + (signed int)u32b; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-4条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_b</key>
<configkey>MISRA2004-10_1_b</configkey>
<name><![CDATA[ 避免隐式的整型和浮点类型的转换 [MISRA2004-10_1_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的整型和浮点类型的转换 [MISRA2004-10_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
该规则检查是否使用了整型和浮点类型之间的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    float f32a;
    unsigned int u32a;

    f32a = u32a;                /* Violation */
    f32a = f32a + u32a;         /* Violation */
    f32a = u32a + 2.5f;         /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    float f32a;
    unsigned int u32a;

    f32a = (float)u32a;         /* OK */
    f32a = f32a + (float)u32a;  /* OK */
    f32a = (float)u32a + 2.5f;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-5条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_c</key>
<configkey>MISRA2004-10_1_c</configkey>
<name><![CDATA[ 避免隐式的复合表达式的数据类型转换 [MISRA2004-10_1_c] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的复合表达式的数据类型转换 [MISRA2004-10_1_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
“限制复杂表达式的隐性转换的目的
是要求在一个表达式里的一系列算术运算里，
所有的运算需要按照相同的算术类型来执行。
注意这并不意味着该表达式里所有的操作数都是
相同的数据类型。
表达式u32a + u16b + u16c是合乎要求的-两个加法运算将理论上
按照U32类型来执行。
表达式u16a + u16b + u32c是不合乎要求的-第一次加法运算
理论上是按照U16类型执行的而第二次运算则是U32类型。
这里使用措辞“理论上的”是因为，算术运算执行时所使用的类型
依赖于该系统中整型类型的实际长度。
该规则检查是否使用了复杂表达式的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = u16b + u16a + u32b;          /* Violation */
    u32a = u32b + (u16a + u16b);        /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = u32b + u16b + u16a;          /* OK */
    u32a = u16b + (u16a + u32b);        /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-3条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_d</key>
<configkey>MISRA2004-10_1_d</configkey>
<name><![CDATA[ 避免隐式的从宽类型到窄类型的转换 [MISRA2004-10_1_d] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的从宽类型到窄类型的转换 [MISRA2004-10_1_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值不能隐式转换
为不同的基本类型。
术语underlying type（基本类型）是指可以从表达式
的运算中获得的运算类型，并且是该表达式
不经过整型提升。
整型提升描述了一个依靠算术运算对（有符号或无符号）
int或long整型操作数进行操作的过程。
其他整型操作数（如：char, short, bit-field 和 enum）
通常在算术运算前转换为int或无符号int类型。
整数常量表达式的基础类型
会根据它的大小和正负决定。”
规则检测是否存在长宽类型向窄类型隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果所有的操作都由一致的潜在类型
执行，可以避免程序员的困惑
和关于整型提升的危险。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned char u8a;
    unsigned short u16a;
    unsigned int u32a;

    u16a = u32a;        /* 违规*/
    u8a  = u32a;        /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned char u8a;
    unsigned short u16a;
    unsigned int u32a;

    u16a = (unsigned short)u32a;       /* OK */
    u8a  = (unsigned char)u32a;        /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004C语言在关键系统的使用指南 
    第 6 章，第 10 节

2. MISRA-C++: 2008C++语言在关键系统的使用指南 
    第 6 章，第 5 节，第 5-0-6 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_e</key>
<configkey>MISRA2004-10_1_e</configkey>
<name><![CDATA[ 避免隐式的函数返回表达式类型转换 [MISRA2004-10_1_e] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的函数返回表达式类型转换 [MISRA2004-10_1_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果一个整型表达式不是constant型，
并且是一个返回表达式，
这个整型表达式的值不能隐式转换成不同的基础类型。
基本类型是指可以
从表达式的运算中获得的运算类型，并且是该表达式
不经过整形提升。
整型提升描述了一个
常常依靠算术运算对（无符号或有符号）int或long整型操作数进行操作的过程。
其他整型操作数（如：char, short, bit-field 和 enum）
通常在算术运算前转换为int或无符号int类型。
规则检测函数返回表达式中是否使用了隐式转换。




</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned int Conv_ret1( signed char a )
{
    return a;                            /*  违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned int Conv_ret1( signed char a )
{
    return (unsigned int)a;              /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004 C语言在关键系统中的使用指南 
   第6章，第10节

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_f</key>
<configkey>MISRA2004-10_1_f</configkey>
<name><![CDATA[ 避免隐式的复合表达式的类型转换 [MISRA2004-10_1_f] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的复合表达式的类型转换 [MISRA2004-10_1_f-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不应该隐式
转换为不同的基础类型。
基本类型是指可以
从表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。
限制复杂表达式隐式转换的目的是
要求表达式中算术运算按一定的顺序执行，
所有的操作应当以完全一致的运算类型进行。”
规则检查复杂表达式隐式转换是否被使用。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

规则只能检查简单表达式。当表达式太复杂
时规则不能报告违例。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned short u16a,u16b;
    unsigned int u32a;

    u32a = u16b + u16a;                      /*  违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned short u16a,u16b;
    unsigned int u32a;

    u32a = (unsigned int)(u16b + u16a);      /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004C语言在关键系统中的使用指南 
    第6章，第10节

2. MISRA-C++: 2008C++语言在关键系统中的使用指南  
    第6章，第5节，第5-0-3条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_g</key>
<configkey>MISRA2004-10_1_g</configkey>
<name><![CDATA[ 避免隐式的函数实参类型转换 [MISRA2004-10_1_g] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的函数实参类型转换 [MISRA2004-10_1_g-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值在该表达式不是常数
并且是一个函数参数时，不应该被隐式转换为
不同的基础类型。
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不
经过整形提升。
整型提升描述了一个常常
依靠算术运算对（无符号或有符号）int或long整型操作数进行操作的过程。
其他整型操作数（如：char, short, bit-field 和 enum）
通常在算术运算前转换为int或无符号int类型。”
规则检测是否存在函数参数的隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

    void takes_signed_double(double);
    void takes_unsigned_int(unsigned int);
    void takes_signed_int(signed int);

    void foo(signed int si, unsigned int ui) {
        unsigned char uc;
        takes_signed_double(si);    /*  违规*/ 
        takes_unsigned_int(uc);     /*违规*/
        takes_signed_int(ui);       /* 违规*/
    }



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

    void takes_signed_double(double);
    void takes_unsigned_int(unsigned int);
    void takes_signed_int(signed int);

    void foo(signed int si, unsigned int ui) {
        unsigned char uc;
        takes_signed_double((double) si);       /* OK */
        takes_unsigned_int(ui);                 /* OK */
        takes_signed_int((int) ui);             /* OK */
    }



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004C语言在关键系统中的使用指南  
    第6章，第10节

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_h</key>
<configkey>MISRA2004-10_1_h</configkey>
<name><![CDATA[ 避免隐式的无符号整型和有符号整型的转换 [MISRA2004-10_1_h] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的无符号整型和有符号整型的转换 [MISRA2004-10_1_h-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值不应当隐式
转换为不同的基础类型。
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。”
规则检查变量初始化时是否使用了有符号数和无符号数
之间的隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned int u32a;
    signed int s32a = u32a;                 /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned int u32a;
    signed int s32a = (signed int)u32a;     /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004C语言在关键系统中的使用指南	
    第6章，第10节

2. MISRA-C++: 2008C++语言在关键系统中的使用指南	
    第6章，第5节，第5-0-4条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_1_i</key>
<configkey>MISRA2004-10_1_i</configkey>
<name><![CDATA[ 避免隐式的复合表达式的数据类型转换 [MISRA2004-10_1_i] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的复合表达式的数据类型转换 [MISRA2004-10_1_i-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值不应当被隐式
转换为不同的基础类型。
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。
限制复杂表达式隐式转换的目的是要求表达式
中算术运算按一定的顺序执行，
所有的操作应当以完全一致的运算类型进行。”
规则检查是否使用了复杂表达式的隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

“规则只能检查简单表达式。当表达式太复杂时，
规则无法报告违例。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned short u16a,u16b;
    unsigned int u32a = u16b + u16a;                      /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned short u16a,u16b;
    unsigned int u32a = (unsigned int)(u16b + u16a);      /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004C语言在关键系统中的使用指南
    第6章，第10节

2. MISRA-C++: 2008C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-3条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_2</key>
<configkey>MISRA2004-10_2</configkey>
<name><![CDATA[ 避免隐式的浮点类型转换，防止数据丢失 [MISRA2004-10_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的浮点类型转换，防止数据丢失 [MISRA2004-10_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型的表达式的值不应当被隐式转换
为一个不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = f32a;                // 违规
    s32b = f32a;                // 违规
    f32a = f64a;                // 违规
    f64a = f32b + f32a + f64b;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = (unsigned int)f32a;  // OK
    s32b = (signed int)f32a;    // OK
    f32a = (float)f64b;         // OK
    f64a = f64b + f32b + f32a;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004 C语言在关键系统中的使用指南

2. 联合攻击战斗机，飞行器，C++编码规范 
    4.23章节 类型转换， 飞行器第184条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-5条规则

4.MISRA-C++:  2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_2_b</key>
<configkey>MISRA2004-10_2_b</configkey>
<name><![CDATA[ 避免隐式的浮点类型转换，防止数据丢失 [MISRA2004-10_2_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式的浮点类型转换，防止数据丢失 [MISRA2004-10_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型表达式的值不应当隐式转换
为不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef float float32_t;

void goo_float( ) {
    double f64a;
    float f32a;

    float32_t f32bt = f64a;      // 违规
    unsigned int u32a = f32a;    // 违规
    unsigned short u16a = 1.0;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef float float32_t;

void goo_float( ) {
    double f64a;
    float f32a;

    float32_t f32bt = (float)f64a;             // OK
    unsigned int u32a = (unsigned int)f32a;    // OK
    unsigned short u16a = (unsigned short)1.0; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1．MISRA-C:2004 C语言在关键系统中的使用指南

2．联合攻击战斗机，飞行器，C++编码规范 
     4.23章节 类型转换， 飞行器第184条规则

3．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-5条规则

4．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_3</key>
<configkey>MISRA2004-10_3</configkey>
<name><![CDATA[ 整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型 [MISRA2004-10_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型 [MISRA2004-10_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个复杂整型表达式被强制转换为不同符号类型或比
基础类型表达式要长的类型时，
规则报告违例。
“复杂表达式这一术语定义为除下列条件外的任何表达式：
	-一个常量表达式
	-一个lvalue（例如一个对象）
	-函数的返回值
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则预防了和开发者预期不一致的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction()
{
    unsigned int ui1, ui2;
    signed int si1, si2;
    unsigned short us1, us2;
    double d;
	
    ui1 = (unsigned int)(si1 + si2); /* 违规-有符号类型强制转换成无符号类型 */
    si1 = (signed int)(ui1 / ui2);   /* 违规-有符号类型强制转换成无符号类型 */
    ui1 = (unsigned int)(us1 - us2); /* 违规-有符号类型强制转换成无符号类型 */
    d = (double)(ui1 * ui2);         /* 违规-有符号类型强制转换成无符号类型 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction()
{
    unsigned int ui1, ui2;
    signed int si1, si2;
    unsigned short us1, us2;
    double d;
	
    ui1 = (unsigned int)si1 + (unsigned int)si2; /* OK */
    si1 = (signed int)ui1 / (signed int)ui2;     /* OK */
    ui1 = (unsigned int)us1 - (unsigned int)us2; /* OK */
    d = (double)ui1 * (double)ui2;               /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1．MISRA-C: 2004 C语言在关键系统中的使用指南
     第6章，第10节

2．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-7条规则

3．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-8条规则

4．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-9条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_4</key>
<configkey>MISRA2004-10_4</configkey>
<name><![CDATA[ 浮点类型的复合表达式的值只能被强制转换到较短的浮点类型 [MISRA2004-10_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
浮点类型的复合表达式的值只能被强制转换到较短的浮点类型 [MISRA2004-10_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果强制转换被用到任何复杂表达式上，
须严格限制强制转换类型。
复杂表达式的转换经常引起
混淆，因此应谨慎使用之。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免了数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef float           float32_t;
typedef double          float64_t;
typedef long double     float128_t;

void goo( ) {
    float128_t f128a, f128b;
    float64_t f64a, f64b;
    float32_t f32a, f32b;

    (float64_t)(f32a + f32b);   /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef float           float32_t;
typedef double          float64_t;
typedef long double     float128_t;

void goo( ) {
    float128_t f128a, f128b;
    float64_t f64a, f64b;
    float32_t f32a, f32b;

    (float32_t)(f64a + f64b);  /* 正确-强制转换成短float类型*/
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1．MISRA-C:2004 C语言在关键系统中的使用指南
     第6章，第10节

2．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_5</key>
<configkey>MISRA2004-10_5</configkey>
<name><![CDATA[ 如果对无符号字符型或无符号短整型进行 ~  和 << 位运算后，其结果应立即强制转换成操作数的基本类型 [MISRA2004-10_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果对无符号字符型或无符号短整型进行 ~  和 &lt;&lt; 位运算后，其结果应立即强制转换成操作数的基本类型 [MISRA2004-10_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当(~ 和 &lt;&lt;)操作符应用于小整数类型(如无符号字符或无符号短整型)，
这些运算符对整数进行操作，运算结果的高位是不可预测的。
&lt;&lt;操作符对小整型进行操作也存在类似的问题那么高位被保留。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可避免高位保留。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;

void foo()
{
	uint8_t port = 0x5aU;
	uint8_t result_8;
	uint16_t result_16;
	uint16_t mode;	
	
	result_8 = (~port) &gt;&gt; 4;                                    /* 违规 */
	result_16 = ((port &lt;&lt; 4) &amp; mode) &gt;&gt; 6;                      /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;

void foo()
{
	uint8_t port = 0x5aU;
	uint8_t result_8;
	uint16_t result_16;
	uint16_t mode;	
	
	result_8 = ((uint8_t)(~port)) &gt;&gt; 4 ;                        /* OK */ 
	result_16 = (   (uint16_t) (~(uint16_t)port)    ) &gt;&gt; 4 ;    /* OK */ 
	result_16 = ((uint16_t)((uint16_t)port &lt;&lt; 4) &amp; mode) &gt;&gt; 6;  /* OK */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第10节

2. MISRA C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-0-10条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-10_6</key>
<configkey>MISRA2004-10_6</configkey>
<name><![CDATA[ A 'U' suffix shall be applied to all constants of unsigned type [MISRA2004-10_6] ]]></name>
<tag>misra2004</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
A 'U' suffix shall be applied to all constants of unsigned type [MISRA2004-10_6-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"The type of an integer constant is a potential source of confusion,
because it is dependent on a complex combination of factors including:
- The magnitude of the constant
- The implemented sizes of the integer types
- The presence of any suffixes
- The number base in which the value is expressed (i.e. decimal, octal or
  hexadecimal)

Signedness of constants should be explicit. Consistent signedness is an
important principle in constructing well formed expressions. If a constant
is of an unsigned type, it is helpful to avoid ambiguity by applying a “U”
suffix. When applied to larger values, the suffix may be redundant (in the
sense that it does not influence the type of the constant); however its
presence is a valuable contribution towards clarity."

The rule checks if integer constant of unsigned type has 'U' or 'u' suffix.

See also: MISRA-018_a, MISRA-018_b, MISRA-018_c, MISRA-018_d, MISRA2004-10_1_a,
MISRA2004-10_1_h



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule improves readability and maintainability.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* the type depends from the implemented size of the various integer types */
long lVar = 2147483648;     /* Violation */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

long lVar = 2147483648U;    /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 10

2. Origin: Misra Guidelines - Rule 18

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-11_1</key>
<configkey>MISRA2004-11_1</configkey>
<name><![CDATA[ 除了整数类型外不允许其他类型和函数指针进行类型转换 [MISRA2004-11_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
除了整数类型外不允许其他类型和函数指针进行类型转换 [MISRA2004-11_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Conversion of a function pointer to a different type of pointer results
in undefined behaviour. This means that a function pointer can be converted
to or from and integral type. No other conversion involving function pointers
are permitted."
This rule allows conversions between two pointers to function if these pointers
have exactly the same type.
As integral types the rule detects the following types: bool, char, short,
int, long, long long, wchar_t and typedefs to mentioned types. 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Prevents undefined behaviour and loss of data.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* Examples of incorrect code */
typedef int (*func_t1)();
typedef short (*func_t2)();

void foo()
{
    int (*fp1)(char* c);
    func_t1 t1 ;
    func_t2 t2 ;
    int* ptr_int;

    t1 = t2;             /* 违规 */
    t1 = fp1;            /* 违规 */
    t1 = (func_t2)t1;    /* 违规 */
    fp1 = t2;            /* 违规 */
    ptr_int = t1;        /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Examples of correct code */
typedef int (*func_t1)();
typedef int (*func_t2)();
int func ();


void foo()
{
    func_t1 t1 ;
    func_t2 t2 ;
    int i;

    t1 = t2;        /* OK */
    t1 = func;      /* OK */
    i = t1;         /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 Guidelines for the use of the C language in critical systems
Chapter 6, Section 11

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-11_2</key>
<configkey>MISRA2004-11_2</configkey>
<name><![CDATA[ 对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一个指向对象的指针仅能转换成或者来自如下：
a) 整型
b) 指向对象类型的其他指针
c) 指向void类型指针

参见：MISRA2004-11_2_b, MISRA2004-11_2_c



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义转换。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int (*FunctionPointer)(void);
struct A;
void foo(int* int_p, float fl, FunctionPointer funct_ptr) {
    struct A *incomplete_type_ptr;

    int_p = (int*)fl;                   /* 违规-指向对象指针
                                              和单精度类型之间的转换*/

    funct_ptr = (FunctionPointer)int_p; /*违规-指向对象指针和指向
                                                         函数类型指针之间的转换 */
    int_p = incomplete_type_ptr;        /* 违规-指向对象指针和指向
                                                      不完全类型指针之间的转换 */
}


修复 ：

不能执行非法转换。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第11节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-11_2_b</key>
<configkey>MISRA2004-11_2_b</configkey>
<name><![CDATA[ 对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一个指向对象的指针仅能转换成或者来自如下：
a) 整型
b) 指向对象类型的其他指针
c) 指向void类型指针

这个规则是规则 MISRA2004-11_2的补充，
如果发现了声明函数参数类型和传递参数类型之间非法转换，
报告违规消息。
参见：MISRA2004-11_2, MISRA2004-11_2_c



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义转换。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int (*FunctionPointer)(void);
struct A;

void someFunction(int *);


void foo(FunctionPointer funct_ptr)
{
    struct A *incomplete_type_ptr;

    someFunction(incomplete_type_ptr); /* 违规-指向对象指针和指向
                                                          不完全类型指针之间的转换 */
    someFunction(funct_ptr);           /*违规-指向对象指针和指向
                                                      函数类型指针之间的转换  */
}


修复 ：

不要执行非法转换。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第11节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-11_2_c</key>
<configkey>MISRA2004-11_2_c</configkey>
<name><![CDATA[ 对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2_c] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针 [MISRA2004-11_2_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一个指向对象的指针仅能转换成或者来自如下：
a) 整型
b) 指向对象类型的其他指针
c) 指向void类型指针

这个规则是规则 MISRA2004-11_2的补充，
如果发现函数返回类型和返回表达式的类型非法转换，
报告违规消息。
参见：MISRA2004-11_2, MISRA2004-11_2_b



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义转换。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int (*FunctionPointer)(void);
struct A;

int* someFunction(FunctionPointer funct_ptr, int flag)
{
   struct A *incomplete_type_ptr;

   if(flag)
   {
      return incomplete_type_ptr;  /* 违规-指向对象指针和指向
                                                不完全类型指针之间的转换 */
   }else{
       return funct_ptr;           /* 违规-指向对象指针和指向
                                            函数类型指针之间的转换 */
   }
}


修复 ：

不能执行非法转换。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第11节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-11_3_a</key>
<configkey>MISRA2004-11_3_a</configkey>
<name><![CDATA[ 不允许指针类型和整数类型之间进行类型转换 [MISRA2004-11_3_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许指针类型和整数类型之间进行类型转换 [MISRA2004-11_3_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“将指针转换成指向整形的指针时，需要定义整型大小，此数值由实现方式决定。
指针和整数类型之间的强制转换应尽可能避免，
但有时寻址内存映射寄存器或其他硬件特定性能可能不可避免。”


例外：

规则允许强制转换成UINT_PTR或者INT_PTR类型。
这些类型是整数类型，分别给32位和64位Windows指针扩展大小。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止未定义或由实现方式定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int* pi;
    int i;
    i = (int) pi;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能把指针强制转换成非指针。




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

2. Misra指南第45条规则

3. Ellemtel编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3</A>
   出自：18可移植代码-18.3类型转换- Port. Rec. 7

4. <A HREF="http://msdn2.microsoft.com/en-gb/library/aa489560.aspx">http://msdn2.microsoft.com/en-gb/library/aa489560.aspx</A>

5. <A HREF="http://www.codeproject.com/system/64BitOSAndPortingIssues.asp">http://www.codeproject.com/system/64BitOSAndPortingIssues.asp</A>

6. 联合攻击战斗机，飞行器，C++编码规范
    4.24章节流量控制结构，飞行器第128条规则

7. MISRA C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-2-9条规则

8. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-11_3_b</key>
<configkey>MISRA2004-11_3_b</configkey>
<name><![CDATA[ 禁止将其它类型变量强制转换成指针变量 [MISRA2004-11_3_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止将其它类型变量强制转换成指针变量 [MISRA2004-11_3_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

整数类型不能强制转换成指针。
当一个任意的整型转换成指针时可能出现问题。


例外：

规则允许整型常量0强制转换成指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义或由实现方式定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int* pi;
    int i;
    pi = (int*)i;    // 违规
}


修复 ：

不能把非指针强制转换成指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 来源：Misra指南45规则

2. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

3. 联合攻击战斗机，飞行器，C++编码规范
    4.24章节流量控制结构，飞行器第182条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-11_4</key>
<configkey>MISRA2004-11_4</configkey>
<name><![CDATA[ 不允许不同的指针对象之间进行强制转换 [MISRA2004-11_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许不同的指针对象之间进行强制转换 [MISRA2004-11_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个指向对象类型的指针和一个指向不同类型对象的指针之间不能执行强制转换。
如果新指针类型需要严格对齐，这种转换可能无效。
指针类型可以如下分类：
-指向对象指针
-指向函数指针
-指向void类型指针
-空指针常量(数值0强制转换成void类型*)”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则不检查const或volatile类型的指针。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不正确的指针校准。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
    unsigned int* ui;
    signed char*  sc;

    /* Examples of incorrect code */
    ui = (unsigned int*) sc;          /* 违规 */
    ui = (unsigned int*) &amp;sc;         /* 违规*/
}


修复 ：

typedef unsigned int uint32_t;
void foo( )
{
    unsigned int* ui;
    uint32_t*  ui_t;

    /* Examples of correct code */ 
    ui = (unsigned int*) ui_t;         /* OK */
    ui = (unsigned int* const) ui_t;   /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

2. 来源：Misra指南第45条规则

3. MISRA C++:2008 c++语言在关键系统中的使用指南，
    第6章，第5节，第5-2-7条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-11_5</key>
<configkey>MISRA2004-11_5</configkey>
<name><![CDATA[ 禁止强制类型转换操作删除以指针指定的 const 或 volatile 限制 [MISRA2004-11_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止强制类型转换操作删除以指针指定的 const 或 volatile 限制 [MISRA2004-11_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“任何试图通过强制转换来删除与地址类型
相关的限定符都违反了类型限定的原则。
注意，这里提到的限定不同于可能应用在指针本身的任何限定。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止了未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned short uint16_t;
void foo( ) 
{
    uint16_t *pi, **ppi;
    uint16_t * const * pcpi;  /*指针指向常量指针*/
    const uint16_t * * ppci;  /*指向常量指针的指针 */
    const uint16_t * pci;     /* 指向常量指针 */
    volatile uint16_t * pvi;  /* 指向变量指针 */

    pi = (uint16_t *)pci;     /* 违规*/
    pi = (uint16_t *)pvi;     /* 违规 */
    ppi = (uint16_t * *)pcpi; /* 违规*/
    ppi = (uint16_t * *)ppci; /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能把'const'或'volatile'类型地址指针强制转换成
'non-const'或'non-volatile'类型。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

2. MISRA C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-2-5条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_10</key>
<configkey>MISRA2004-12_10</configkey>
<name><![CDATA[ 禁止使用逗号运算符 [MISRA2004-12_10] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用逗号运算符 [MISRA2004-12_10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用逗号运算符会降低代码的可读性, 
可以通过其他方法实现逗号运算符的功能。”
参见 misra-042



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高代码的可读性和可维护性.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = 0, y = 0;           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = 0;
    y = 0;                 // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
   第6章，第12节

2. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，规则5-18-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_12</key>
<configkey>MISRA2004-12_12</configkey>
<name><![CDATA[ 禁止对浮点数值进行位操作 [MISRA2004-12_12] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对浮点数值进行位操作 [MISRA2004-12_12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不同编译器对于浮点类型指针的存储是
不同的，因此对浮点类型指针的操作绝不能
依赖于它的存储方式，应该使用那些对程序员
隐蔽了存储细节的内置操作符和函数。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在很多情况下，浮点类型的位域将会被标记为语法错误。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免产生由实现方式定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S {
	float f:6; // 违规
};

union U {
	float f:6; // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S {
	int f:6; // OK
};

union U {
	int f:6; // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节
   
2. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，第3-9-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_13</key>
<configkey>MISRA2004-12_13</configkey>
<name><![CDATA[ 禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符 [MISRA2004-12_13] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符 [MISRA2004-12_13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“此规则的目的是说明，当使用递增或递减运算
符时，递增或递减操作应该是语句完成的唯一附加功能.
此规则建议在使用++和--运算符时不要与其他 
数学运算符混合起来使用因为：
 - 影响代码的可读性
 - 对在声明中没有明确定义的函数行为产生额外
   的影响
I建议单独使用++和--运算符比较
安全。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性。 
降低由于额外影响导致函数潜在的
不确定行为的危险



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = --y + x++;  /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int x, y;
    --y;            /* OK */
    x = y + x;
    x++;            /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 联合攻击战斗机，飞行器，C++编码规范，
    第4.25章，飞行器第204条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南，
    第6章，第12节，第5-2-10条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_1_a</key>
<configkey>MISRA2004-12_1_a</configkey>
<name><![CDATA[ 谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
当操作符的右操作数是赋值表达式时，通常需要使用括号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
	int a, b;
	b = a = 0;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
	int a, b;
	b = (a = 0);	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节 可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_1_b</key>
<configkey>MISRA2004-12_1_b</configkey>
<name><![CDATA[ 谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_b] ]]></name>
<tag>misra2004</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_b-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。
在复杂的C语言运算规则中，很容易出错，
使用括号可以避免发生这种错误，也有助于我们理解代码。
但是不要使用太多的括号，这样会使代码变得零乱，
并且影响代码的可读性。”
“对于赋值运算符的右侧操作数不是必须使用括号，
除非它的右侧包含一个赋值语句。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

不检查宏的结构体。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
	int a, b;

	b = (a = 0);	// OK
	b = (a + 0);	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
	int a, b;

	b = (a = 0);	// OK
	b = a + 0;	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器 第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_1_c</key>
<configkey>MISRA2004-12_1_c</configkey>
<name><![CDATA[ 一元运算符的操作数不需要括号 [MISRA2004-12_1_c] ]]></name>
<tag>misra2004</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一元运算符的操作数不需要括号 [MISRA2004-12_1_c-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
对于一元运算符的操作数，本规则要求其不使用圆括号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) 
{
    int a, b;
    b = a * (-1);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) 
{
    int a, b;
    b = a * -1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_1_d</key>
<configkey>MISRA2004-12_1_d</configkey>
<name><![CDATA[ 谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_d] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
“如果所有的运算符优先级相同，可以使用括号来控制操作数的
运算顺序。部分运算符（例如加法和乘法）在代数上可以结合
但在C语言里并不一定能够结合。同样，整型运算
涉及很多混合类型（有些类型已被某些规则禁止使用），
可能会由于整型提升产生不同类型的运算结果。下面的例子中
对于16位数据加法的执行情况充分证明
加法是不能结合的，并且对于表达式的结构清晰非常重要：”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则在算术运算中增加了安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifdef _MSC_VER
typedef unsigned __int16 uint16;
typedef unsigned __int32 uint32;
#elif __GNUC__
#include &lt;sys/types.h&gt;
typedef u_int16_t uint16;
typedef u_int32_t uint32;
#endif

void fooPlus( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = (a + b) + c; /* 违规- d 等于 9; a + b 超出范围 65536 */ 
}

void fooMultiply( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = (a * b) * c; /* 违规- d 等于 65526; a * b 超出范围 65536 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifdef _MSC_VER
typedef unsigned __int16 uint16;
typedef unsigned __int32 uint32;
#elif __GNUC__
#include &lt;sys/types.h&gt;
typedef u_int16_t uint16;
typedef u_int32_t uint32;
#endif

void fooPlus( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = a + (b + c); /* 正确-d 的值是65545 */
}

void fooMultiply( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = a * (b * c); /* 正确- d的值是 655350 */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_1_e</key>
<configkey>MISRA2004-12_1_e</configkey>
<name><![CDATA[ 除非表达式中的所有操作符都相同才使用括号 [MISRA2004-12_1_e] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
除非表达式中的所有操作符都相同才使用括号 [MISRA2004-12_1_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。
除非某表达式内仅使用一种操作符，否则应使用括号。”
参见: MISRA2004-12_5, CODSTA-90



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

逻辑 &amp;&amp; 和 || 的操作数由 MISRA2004-12_5 规则检查



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a, b;
    b = a * a + a;      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int a, b;
    b = (a * a) + a;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器 第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_1_f</key>
<configkey>MISRA2004-12_1_f</configkey>
<name><![CDATA[ 谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_f] ]]></name>
<tag>misra2004</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
谨慎使用 C 语言中表达式的优先运算规则 [MISRA2004-12_1_f-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
如果括号嵌套的太多，很可能会违反某个代码解析的限制，
如果发生这种情况，表达式有可能是非常复杂的，应该进行拆分。
此规则检查嵌套的括号层数-如果嵌套层数超过10，就会提示违规信息。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

括号嵌套层数被设置为10，但可以更改。要更改默认的
括号嵌套层数，修改规则(Collector A)的主"Count"表达式，
把"$$ &gt; 9"改为"$$ &gt; N"，N是预设的门限值。
规则头也需要相应的修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
   int a, b,c,d;
   a=(((((((((((b+1)+1)+c)*d)/2)+1)*b)+c)*d)+8)/(b+d))+3; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( )
{
    int a, b,c,d;
    int h;
    h = (((((((((b+1)+1)+c)*d)/2)+1)*b)+c)*d)+8;   // OK
    a =(h*(b+d))+3;                                // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节 可移植代码，飞行器 第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_2_a</key>
<configkey>MISRA2004-12_2_a</configkey>
<name><![CDATA[ 表达式的值应该在任何标准允许的赋值顺序下是一样的 [MISRA2004-12_2_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值应该在任何标准允许的赋值顺序下是一样的 [MISRA2004-12_2_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了少数运算符（特别是函数调用运算符 (), &amp;&amp;, ||, ?: 
和，逗号）中的子表达式被赋值的顺序是未指定并可能变化的。
这意味着子表达式的赋值顺序是不可靠的，尤其不能信赖
副作用发生的顺序。这些在表达式赋值中
该点前面所有的副作用都可以被确定的点
被称作“顺序点”。顺序点和副作用
被描述在ISO 9899:1990[2]的节5.1.2.3,6.3和6.6中。
注意，赋值顺序不能通过使用括号得到解决，
因为这不是一个优先级的问题。
下面说明依赖于顺序的赋值是如何发生的，
并且有助于对该规则的理解。”
“这会得出不同的结果取决于是否b[i]在 i++之前被赋值，反之亦然。
在另一个单独的语句中放置增量语句可以避免该问题。”
参见:MISRA2004-12_4_a, MISRA2004-12_4_b



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止表达式的赋值依赖于编译器的版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) 
{
    int a, b[10];
    a = b[a] + a++; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( )
{
    int a, b[10];
    a = b[a] + a;  // OK
    a++;           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.联合攻击战斗机，飞行器，C++编码规范
  第4.25章节 可移植代码，飞行器 第204条规则

4.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_2_b</key>
<configkey>MISRA2004-12_2_b</configkey>
<name><![CDATA[ 不要编写需要依赖函数参数赋值顺序的代码 [MISRA2004-12_2_b] ]]></name>
<tag>misra2004</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要编写需要依赖函数参数赋值顺序的代码 [MISRA2004-12_2_b-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数参数的赋值顺序是不确定的。这就意味着
如果函数参数包含副作用那么其产生的影响也是不确定的。
一个函数调用可以给出不同的结果取决于
该函数的哪一个参数首先被赋值。
我们可以通过副作用，理解如何访问volatile对象，修改某个对象，
或者调用包含上述操作的某个函数。

该规则检查调用的函数至少有两个参数。
在函数参数赋值期间，如果出现以下情况
   * 读取或修改某易失对象
   * 修改某非易失对象
而该对象在函数的其他参数赋值时，亦被访问
或被修改，此时报告违规。


例外：

只有一层函数调用被检查。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止编写可能在不同编译器产生不同结果的源代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Transmogrify(int,int);
int Bump(int&amp; x) {return ++x;}
void foo()
{
    int count = 5;
    Transmogrify(Bump(count),Bump(count)); // 违规
    Transmogrify(count++,count);           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Transmogrify(int,int);
int Bump(int&amp; x) {return ++x;}
void foo()
{
    int count = 5;
    int temp1 = Bump(count);
    Transmogrify(temp1,Bump(count)); // OK
    Transmogrify(count,count);       // OK
    count++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.Herb Sutter，Andrei Alexandrescu，“C++编码规范”，Addison-Wesley，
     (C) 2005 Pearson教育公司
  章节：“函数和操作符”，第31条规则

4.联合攻击战斗机，飞行器，C++编码规范
   第4.25章节可移植代码，飞行器第204条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_2_c</key>
<configkey>MISRA2004-12_2_c</configkey>
<name><![CDATA[ 表达式的值应该在任何标准允许的计算顺序下是一样的 [MISRA2004-12_2_c] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值应该在任何标准允许的计算顺序下是一样的 [MISRA2004-12_2_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了少数运算符（特别是函数调用运算符 (), &amp;&amp;, ||, ?: 
和, (逗号)）中的子表达式被赋值的顺序是未指定并可能变化的。
这意味着子表达式的赋值顺序是不可靠的，尤其不能信赖
副作用发生的顺序。这些在表达式赋值中
该点前面所有的副作用都可以被确定的点
被称作“顺序点”。顺序点和副作用
被描述在ISO 9899:1990[2]的节5.1.2.3,6.3和6.6中。
注意，赋值顺序不能通过使用括号得到解决，
因为这不是一个优先级的问题。”
“如果一个函数通过函数指针被调用，
那么它将不会依赖于函数标示符和函数参数被赋值的顺序。
p-&gt;task_start_fn(p++);”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止表达式的赋值依赖于编译器版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S {
    void (*task_start_fn)( struct S* );
};

void foo() {
    struct S* p;
    p-&gt;task_start_fn( p++ );   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S {
    void (*task_start_fn)( struct S* );
};

void foo() {
    struct S* p;
    p-&gt;task_start_fn( p );     // OK
    p++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_2_d</key>
<configkey>MISRA2004-12_2_d</configkey>
<name><![CDATA[ 对涉及一个函数调用的表达式不要编写依赖表达式求值顺序的代码 [MISRA2004-12_2_d] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对涉及一个函数调用的表达式不要编写依赖表达式求值顺序的代码 [MISRA2004-12_2_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了少数运算符（特别是函数调用运算符 (), &amp;&amp;, ||, ?: 
和, (逗号)）中的子表达式被赋值的顺序是未指定并可能变化的。
这意味着子表达式的赋值顺序是不可靠的，尤其不能信赖
副作用发生的顺序。
函数当他们被调用的时候可能有额外的影响（例如修改一些
全局数据）。在表达式使用它之前先调用函数，
生成一个临时变量来赋值，可以避免对赋值优先级的依赖。” 

如果一个表达式被两个函数调用，
其中第一个函数将参数作为一个指针或一个引用，
用于一个非const变量并修改该变量，
而第二个函数使用了与第一个函数相同的变量作为参数，
该规则会报告一个违规。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果一个变量在函数中通过赋值直接地修改
或函数体没有定义在当前的编译单元，规则假设这个变量被修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止表达式的赋值依赖于编译器版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int* ptr)
{
    (*ptr)++;
    return 0;
}
int bar(int local_param)
{
    return local_param;
}

void foo_t(int i, int j)
{
    i = foo(&amp;j) + bar(j);    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int* ptr)
{
    (*ptr)++;
    return 0;
}
int bar(int local_param)
{
    return local_param;
}

void foo_t(int i, int j)
{
    int temp = foo(&amp;j);
    i = temp + bar(j);    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_2_e</key>
<configkey>MISRA2004-12_2_e</configkey>
<name><![CDATA[ 表达式的值应该在任何标准允许的计算顺序下是一样的 [MISRA2004-12_2_e] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值应该在任何标准允许的计算顺序下是一样的 [MISRA2004-12_2_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了一些运算符（如：函数调用操作 (), &amp;&amp;, ||, ?: 和, (逗号)）之外，
其它的运算符在子表达式中的赋值顺序是没有被明确规定的而且
还是可以改变的。这意味着子表达式的赋值顺序不可靠，
尤其不能信赖副作用发生的顺序。

在表达式中对参数进行嵌套的赋值将造成额外的副作用。
在表达式中不使用嵌套赋值是避免表达式对赋值顺序产生
依赖性的最好方式。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则避免了表达式的赋值对编译器版本的依赖。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x, int y, int z ) {
    x = y = z / 3;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x, int y, int z ) {
    y = z / 3;  // OK
    x = y;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C:2004 C语言在关键系统中的使用指南 
   第6章，第12部分

2. 来源：Misra指南-第46条规则

3. MISRA C++:2008-C++语言在关键系统中的使用指南，
    第6章，5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_2_f</key>
<configkey>MISRA2004-12_2_f</configkey>
<name><![CDATA[ 禁止在复杂的表达式中使用 volatile 类型的变量 [MISRA2004-12_2_f] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在复杂的表达式中使用 volatile 类型的变量 [MISRA2004-12_2_f-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在C语言里面提供了关键字volatile，它是一个变量类型修饰符，
用它声明的类型变量的值可以独立的随程序的执行而改变
（例如一个输入寄存器）。如果一个volatile类型变量被访问也
许会改变它的值。C编译器遇到volatile关键字声明的变量，
对访问该变量的代码就不再进行优化。另外，
如果是C程序读取volatile关键字时存在一定副作用
（改变volatile类型变量的值）。通常，存取volatile数据作
为表达式的一部分是必须的，因此这也意味着它可能依赖于
赋值的顺序。在简单的赋值语句里面volatile还是值得推荐的。”
如果在一个表达式里面使用的volatile关键字超过一个时，
本规则将报告一处违规。

参见：MISRA2004-12_2_b



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果多个Volatile类型变量被作为函数调用的入口参数使用时，
本规则将不报错。这种情况将在规则MISRA2004-12_2_b中使用。

    void goo(int, int);
    void foo()
    {
        volatile int v;
        goo(v, v);  // 违规- MISRA2004-12_2_b
    }



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则避免了表达式的赋值对编译器版本的依赖。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
    volatile int x;
    int y;
    y = x * x;  // 违规
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( )
{
    volatile int x;
    int y;
    y = x;      // OK
    y = y * y;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南  
   第6章，第12部分

2. 来源：Misra 指南 第46条规则

3. MISRA C++:2008 –C++语言在关键系统中的使用指南，
   第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_2_g</key>
<configkey>MISRA2004-12_2_g</configkey>
<name><![CDATA[ 不要写依赖于求值函数调用顺序的代码 [MISRA2004-12_2_g] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要写依赖于求值函数调用顺序的代码 [MISRA2004-12_2_g-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

除了一些运算符（如：函数调用操作(),&amp;&amp;,||,?:和, (逗号)）之外，
其它的运算符在子表达式中的赋值顺序是没有被明确规定的
而且还是可以改变的。这意味着子表达式的赋值顺序不可靠，
尤其不能信赖副作用发生的顺序。
当函数被调用时可能会产生额外的影响（例如修改全局变量）。
在表达式使用它之前先调用函数，生成一个临时变量来赋值，
可以避免对赋值优先级的依赖。

当两个函数调用相同的全局变量或静态变量，并且至少
一个函数修改了这个变量，规则将报告一处违规。


例外：

本规则只检查单层调用关系的函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用本规则可以避免表达式赋值对编译器版本的依赖。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int global;

int modify_global()
{
    global++;
    return global;
}
int use_global()
{
    return global;
}

void expr1()
{
    int a = modify_global() + use_global();  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int global;

int modify_global()
{
    global++;
    return global;
}
int use_global()
{
    return global;
}

void expr1()
{
    int a = modify_global();
    a += use_global();           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统的使用指南
   第6章节，第12部分

2. 来源：Misra指南-第46条规则

3. MISRA C++:2008-C++语言在关键系统中的使用指南，
   第6章节，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_3</key>
<configkey>MISRA2004-12_3</configkey>
<name><![CDATA[ sizeof 操作符的参数不应该是含副作用的表达式 [MISRA2004-12_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
sizeof 操作符的参数不应该是含副作用的表达式 [MISRA2004-12_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在C语言编程中的一个可能错误是评估一个表达式和预期表达式 
的时候申请使用sizeof 操作符。 可是表达式
却无法被评估: sizeof只能作用于表达式类型。 
为了避免这类错误， sizeof 不能用于包含副作用的表达式。"
"这个操作引起的副作用是访问了不稳定的对象,
如修改一个对象, 修改一个文件, 或者调用一个函数这些
会导致调用函数执行环境变化的操作方法。"



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只能检测三层函数调用。


例外:

操作数形如 sizeof(i)  i 变量是允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止由 sizeof 引起的错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int glob;

int fun_with_se(){
    glob++; // side-effect
    return glob;
}

void foo1(int i){
    int j, k, l, m;
    j = sizeof(k = 2);         // 违规 - k is not set to 2
    l = sizeof(i++);           // 违规 - i is not incremented
    m = sizeof(fun_with_se()); // 违规 - glob is not incremented
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int fun_without_se(){
    // no side-effect
    return 1;
}

void foo1(int i){
    int j, k, l, m, n, o;
    volatile int vol;
    k = 2;
    j = sizeof(k);                // OK
    i++;
    l = sizeof(i);                // OK
    // examples of correct code
    m = sizeof(fun_without_se()); // OK
    n = sizeof(int);              // OK
    o = sizeof(vol);              // OK - volatile objects are permitted
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
    Chapter 6, Section 12

2. Origin: Misra Guidelines - Rule 40

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.21 Operators, AV Rule 166

4. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 5, Rule 5-3-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_4_a</key>
<configkey>MISRA2004-12_4_a</configkey>
<name><![CDATA[ 逻辑 && 或者 || 运算符的右边操作数不应该包含副作用 [MISRA2004-12_4_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑 &amp;&amp; 或者 || 运算符的右边操作数不应该包含副作用 [MISRA2004-12_4_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

含副作用，而且这些副作用
依赖于其他子表达式的值，有可能发生也有可能
不发生。可能导致这一问题的运算符包括&amp;&amp;和||，
在这两种运算符中，对右边操作数的赋值要受到
左边操作数值的条件限制。有可能引起副
作用的操作包括：访问volatile类型
对象，修改某个对象，修改某个文件，或调用某个
执行了上述某个操作的函数等。这些操作可能改
变调用函数的运行环境状态。”
参见：MISRA2004-12_2_a, MISRA2004-12_4_b



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则只能检查三层嵌套级别的函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果开发者信赖一个副作用的发生，
使用本规则可以避免对右操作数进行有条件赋值造成的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int i;
    int j;
    if ((j == i) || (0 == i++)) ; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int i;
    int j;
    if ((j == i) || (0 == i)) i++; // OK
}


参考文献：

1. MISRA-C:2004 C语言在关键系统的使用指南 
   第6章，第12部分

2. 来源：Misra指南-第33条规则

3. 联合攻击战斗机，飞行器，C++编程规范
   4.21章节操作符，飞行器第157条规则

4. MISRA C++:2008-C++语言在关键系统中的使用指南，
   第6章，第5部分，第5-14-1条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_4_b</key>
<configkey>MISRA2004-12_4_b</configkey>
<name><![CDATA[ 三元运算符 '?:' 的第二个或第三个操作数不得含有副作用 [MISRA2004-12_4_b] ]]></name>
<tag>misra2004</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
三元运算符 '?:' 的第二个或第三个操作数不得含有副作用 [MISRA2004-12_4_b-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“C或C++代码中包含某些表达式不能被赋值的情况。
如果这些子表达式包含副作用，而且这些副作用依赖
于其他子表达式的值，有可能发生也有可能不发生。
导致这种问题的运算符包括：&amp;&amp;, ||和?:。对于操作符’?:’来说，
只能对其第二或第三个操作数中的一个进行赋值而不是全部赋值。
有了‘?:’ 操作符就可以在两个子表达式之间进行选择了，
因此不太可能产生错误。”
参见：MISRA2004-12_2_a, MISRA2004-12_4_a



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则只能检查两层嵌套等级的函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果开发者信赖副作用的发生，使用本规则可以避免对三目运算符的
第二或第三个操作数有条件的赋值造成的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int i;
int j;
int foo( ) {
    return (i &gt; j) ? j++ : i++; // 违规 -开发人员期望第二和第三个
                                // 操作数被赋值
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int i;
int j;
int foo( ) {
    if (i &gt; j) {      // OK
        ++i;
        return j++;
    } else {
        ++j;
        return i++;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统的使用指南 
   第6章，第12部分

2. 联合攻击战斗机，飞行器，C++编程规范
   4.25章节公式，飞行器第204条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_5</key>
<configkey>MISRA2004-12_5</configkey>
<name><![CDATA[ 逻辑运算符 && 或者 || 的操作数应该是基本表达式 [MISRA2004-12_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑运算符 &amp;&amp; 或者 || 的操作数应该是基本表达式 [MISRA2004-12_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在ISO 9899:1990，第 6.3.1部分中定义了"基本表达式"。
本质上它们可以是独立的标识符、常量或一个带圆括号的表达式。本规则要求
一个操作数如果不是一个独立的操作符或常数必须使用圆括号括起来，
这里的表达式如果仅仅只包括逻辑&amp;&amp;或逻辑
||就不需要外加圆括号
参见：MISRA2004-12_1_e, CODSTA-90



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“圆括号在提高代码的可读性和确保程序行为按程序员预期执行方面起着很重要作用。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || y &amp;&amp; z );         // 违规
    if ( x &amp;&amp; !y );             // 违规
    if ( foo( x, y, z ) &amp;&amp; x ); //违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || ( y &amp;&amp; z ) );         // OK
    if ( x &amp;&amp; ( !y ) );             // OK
    if ( ( foo( x, y, z ) ) &amp;&amp; x ); // OK
    return 0;
}


参考文献：

1. MISRA-C:2004 C语言在关键系统中的使用指南 
   第6章，第12节

2. Misra指南-第34条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_6_a</key>
<configkey>MISRA2004-12_6_a</configkey>
<name><![CDATA[ 逻辑运算符 (&&, || 和 !) 的操作数应该是有效的布尔值 [MISRA2004-12_6_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑运算符 (&amp;&amp;, || 和 !) 的操作数应该是有效的布尔值 [MISRA2004-12_6_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

(&amp;&amp;, ||, !)逻辑运算符是有效的布尔型。
一个有效的布尔类型表达式可能是构造的布尔类型
或者是强制转换得到的布尔类型，具体定义如下。
构造的布尔类型值是由以下操作符运算后得到的：
- 等于运算符(== 和 !=)
- 逻辑运算符(!, &amp;&amp; 和 ||)
- 关系运算符(&lt;, &gt;, &lt;= 和 &gt;=)
强制转换布尔类型值可以使用工具实现一个特定的强制类型来产生
强制类型来产生。此时布尔类型与特定的
typedef相关联， 并且可以用于任何布尔对象。

如果使用下列逻辑运算符，规则将不会检查出违规：
- 构造的布尔类型
- 布尔型常量
- 定义为0或1的整型或枚举常量
- 变量、参数或表达式的类型：
  - 布尔，
  - 使用typedef定义的bool，
  - 使用bool声明的枚举变量（忽略case）
    和使用bool声明的包含2个枚举常量的枚举体
  - 使用typedef定义以bool开头的char/short/enum类型（忽略case）
  - 引用以上类型



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高代码的可读性和可维护性。
此规则防止将逻辑运算符和位运算符之间的混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo();
void foo()
{
    int x, y, z;

    z = (x &gt; y) &amp;&amp; goo();         // 违规
    z = (x &gt; y) || goo();         // 违规
    z = !(x = y);                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo();
void foo()
{
    int x, y, z;

    z = (x &gt; y) &amp;&amp; (goo() != 0);  // OK
    z = (x &gt; y) || (goo() != 0);  // OK
    x = y;
    z = (x == 0);                 // OK
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra指南-第36条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_6_b</key>
<configkey>MISRA2004-12_6_b</configkey>
<name><![CDATA[ 布尔表达式不应使用除 (&&, ||, !, =, ==, !=, ?:)以外的操作符 [MISRA2004-12_6_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
布尔表达式不应使用除 (&amp;&amp;, ||, !, =, ==, !=, ?:)以外的操作符 [MISRA2004-12_6_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了这些运算符(&amp;&amp;, ||, !, =, ==, !=, ?:)之外，其他
运算符中的有效布尔表达式不能作为操作数参与运算，
一个有效的布尔类型表达式可能是构造的布尔类型
或者是强制转换得到的布尔类型。它的定义如下。
构造的布尔类型值是通过以下运算符得到的：
- 等于运算符(== and !=)
- 逻辑运算符(!, &amp;&amp; and ||)
- 关系运算符(&lt;, &gt;, &lt;= and &gt;=)
强制转换的布尔值可以使用工具实现一个特定
的强制类型来产生。此时布尔类型与特定的
typedef相关联，并且可以用于任何布尔对象。”

如果不是在这些运算符(&amp;&amp;, ||, !, =, ==, !=, ?:)中把有效的
布尔表达式当作操作数进行运算，此规则将给出违规报告：
- 构造的布尔类型值
- 布尔型常量
- 变量、参数或表达式的类型：
  - 布尔类型，
  - 使用typedef定义的布尔，
  - 使用bool声明的枚举变量（忽略case）
    使用bool声明的包含2个枚举常量的枚举体
  - 使用typedef定义的以bool开头的char/short/enum类型（忽略case）
  - 引用以上类型



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高代码的可读性和可维护性。
此规则防止将逻辑运算符和位运算符混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo();
void foo()
{
    int x, y, z;

    z = (x &gt; y) &amp; (goo()); // 违规
    z = x | (goo() != 0);  // 违规
    z = ~(x == y);         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo();
void foo()
{
    int x, y, z;
    int tmp;

    tmp = x &gt; y;
    z = tmp &amp; goo();     // OK

    tmp = goo() != 0;
    z = x | tmp;         // OK

    tmp = x == y;
    z = ~tmp;            // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C：2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra指南-第36条规则 

3.MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第4节，规则4-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_7</key>
<configkey>MISRA2004-12_7</configkey>
<name><![CDATA[ 禁止对有符号类型使用位操作 [MISRA2004-12_7] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对有符号类型使用位操作 [MISRA2004-12_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对有符号数进行位运算(~, &lt;&lt;, &gt;&gt;, &amp;, ^ 和 |)通常是没有 
意义的。 比如，会出现这样的问题，对有符号数进行右移运算会将 
符号位移入数据位，左移运算会将数据位
移入符号位。
术语 underlying type（基本类型）是用来描述通过对
无整形提升的表达式运算后得到的一种基础
类型。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和理解性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int x, int y )
{
    x = y &gt;&gt; 2;       // 违规
    x = y &amp; 0x0F;     // 违规
    return x | 5;     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int x, int y )
{
    /* 调用程序必须保证x和y是非负数 */
    x = (unsigned int)y &gt;&gt; 2u;       /* OK */
    x = (unsigned int)y &amp; 0x0Fu;     /* OK */
    return (unsigned int)x | 5u;     /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra指南-第37条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_8</key>
<configkey>MISRA2004-12_8</configkey>
<name><![CDATA[ 移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间 [MISRA2004-12_8] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间 [MISRA2004-12_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“例如，左移或右移运算符的左操作数是一个
16位整数， 那么移位数必须是一个
0~15之间的数字常量。

现在有很多方法可以遵循此规则，最简单的办法
就是保证右操作数是常量（它的值可以通过静态分析来
检查）。对于无符号整型必须保证操作数是 
非负数，此时只要检查上限值就可以（使用运行时检测
或通过代码检查）。否则上限值和下限值都必须被检查。”
此规则规定数据类型大小：字符型8bit，短整型16bit，
整型32bit，长整型64bit。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和易理解性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
void foo( uint16_t p ) 
{
   uint8_t u8a;

   u8a = (uint8_t) (u8a &lt;&lt; 9); /* 违规 */
   u8a = (uint8_t) (u8a &lt;&lt; p); /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
void foo( uint16_t p )
{
   uint8_t u8a;
   uint16_t u16a;
 
   u16a = (uint16_t) ((uint16_t) u8a &lt;&lt; 9); /* OK */

   if (p &gt;= 0 &amp;&amp; p &lt;= 8) {
     u8a = (uint8_t) (u8a &lt;&lt; p); /* OK - p range checked */
   }

   u8a = (uint8_t) (u8a &lt;&lt; 4); /* OK - constant value in range */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.  MISRA-C:2004 C语言在关键系统中的使用指南，
     第6章，第12节

2. 联合攻击战斗机，飞行器，C++编码规范，
    第4.21章，飞行器第164条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-8-1条规则 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-12_9</key>
<configkey>MISRA2004-12_9</configkey>
<name><![CDATA[ 一元减法运算符不得适用于其原始类型是无符号型的表达式 [MISRA2004-12_9] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一元减法运算符不得适用于其原始类型是无符号型的表达式 [MISRA2004-12_9-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对无符号整型或者无符号长整型表达式
进行一元减法运算是没有意义的。
有时对一个小的无符号整型操作数进行一元
减法运算整形提升后会得到一个有意义的
整型值，但这并不是好的编程习惯。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止整型提升时产生不可预期的结果。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    unsigned char  ui1;
    signed short si2;
    si2 = -ui1;                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    unsigned char  ui1;
    signed short si2;
    si2 = -(signed short) ui1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C：2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra 指南 - 第39条规则

3. 联合攻击战斗机，飞行器，C++编码规范，
   第4.21章，飞行器第165条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，第5-3-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_1</key>
<configkey>MISRA2004-13_1</configkey>
<name><![CDATA[ 禁止在产生布尔值的表达式中使用赋值运算符 [MISRA2004-13_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在产生布尔值的表达式中使用赋值运算符 [MISRA2004-13_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止给布尔表达式赋值.
阻止对布尔表达式的操作数使用简单或复合的赋值运算符.
但是，变量还是可以被赋以布尔值的.
如果需要对布尔表达式的操作数赋值，则必须单独在操作数外面赋值.
这样做可避免混淆"="和"==",并帮助错误的静态检测.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

表达式被认为是布尔表达式有两种原因,一
种是表达式所在的位置应该是布尔值,
另一种是它使用的操作符会产生布尔值.布尔值在下面情况下出现:
—If 语言的控制表达式
—迭代语句的控制表达式
—条件运算符？的第一个操作数


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止混淆 "=" 和 "==".


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x = y);                // Violation
    if ((x &gt; y) &amp;&amp; (x = 4));  // Violation
    if (!(x = y));                // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x == y);               // OK
    if ((x &gt; y) &amp;&amp; (x == 4)); // OK
    if (!(x == y));               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Misra 指南 -第35条规则

2. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第13部分

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.21操作章节, AV 第160条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南l
    第六章节,第六部分,第6-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_2</key>
<configkey>MISRA2004-13_2</configkey>
<name><![CDATA[ 与零的比较应该是显式的，除非操作数是有效的布尔值 [MISRA2004-13_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
与零的比较应该是显式的，除非操作数是有效的布尔值 [MISRA2004-13_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于一个数据值是否为零的测试必须是显式的,除非数据是布尔值.
"布尔有效"的表达式要么是"创建为布尔",要么是"强制为布尔",定义如下:
下列操作符将生成"创建为布尔"的值:
-相等运算符 (== 和 !=)
-逻辑运算符(!, &amp;&amp; 和 ||)
-关系运算符 (&lt;, &gt;, &lt;= 和 &gt;=)
使用工具执行特定类型的强制机制,产生强制为布尔的值.
布尔类型可能和特定的typedef相联系,用于任何布尔型的对象.

使用逻辑运算符的操作数,不会造成违规:
-创建为布尔值
-布尔常量
-定义为“0”或者“1”的整型或者enum常量
-变量，参数或者以下类型的表达式
   -布尔
   -typedef为布尔
   -名称以"bool"（忽略大小写）开头的enum,
      在主体中包含2个enum常量
   -typedef为char/short/int/enum，并且名称以"bool"开头（忽略大小写）
   -参考以上类型



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对于常量表达式此规则不会报告违规.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

清楚地区分整型和逻辑值.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo()
{
    return 1;
}

void foo( int x, int y )
{
  if (goo()) {}	// Violation
  if (y) {}     // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo()
{
    return 1;
}

void foo( int x, int y )
{
  if (goo() != 0) {}	// OK
  if (y != 0) {}        // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第23部分

2. Misra 指南 - 第49条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_3</key>
<configkey>MISRA2004-13_3</configkey>
<name><![CDATA[ 禁止对浮点数类型的变量或表达式做比较操作 [MISRA2004-13_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对浮点数类型的变量或表达式做比较操作 [MISRA2004-13_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可以测试浮点数等值或不等值.浮点数比较推荐的方法是写一个库函数,
用来执行比较操作.库函数应该考虑到浮点粒度（FLT_EPSILON）和被比较值的数量级.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

等值和不等值的间接测试同样是问题,在Misra标准中是不允许的,但此规则不能检查出:
if ( ( x &lt;= y ) &amp;&amp; ( x &gt;= y ) )
{
  /* ... */ 
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

浮点类型的内在属性是等值比较一般都不为真,即便预期为真.
此外,在运行前无法预测比较的结果,甚至每次执行的结果会不一样.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    float x, y;

    if (x == y);      // Violation
    if (x == 0.0f);   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( float epsilon ) {
    float x, y;

    if (x - epsilon &lt;= y &amp;&amp; y &lt;= x + epsilon);  // OK
    if (-epsilon &lt;= x &amp;&amp; x &lt;= epsilon);         // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2. Misra 指南 - 第50条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.25 公式章节, AV 第202条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第六部分,第6-2-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_4</key>
<configkey>MISRA2004-13_4</configkey>
<name><![CDATA[ for 循环语句中的控制表达式不能包含浮点类型对象 [MISRA2004-13_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
for 循环语句中的控制表达式不能包含浮点类型对象 [MISRA2004-13_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"for"语句的三个表达式只能用作如下目的:
-第一个表达式用来初始化循环的计数变量（下例中的i）.
-第二个表达式应该包含测试循环的计数变量（i）,也可选择包含其他循环控制变量（标记）.
-第三个表达式作用是循环计数变量增一或者减一.
这个规则分析for语句,查找初始化的变量以及后面更新的地方,但是并不关心循环控制.
通常,变量是在for语句内部初始化,即使它们与循环的终止条件无关.在极端情况下,整个条件
块可能移到了for语句内,这样就使代码既易出错又难读.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

按照此规则,代码会更安全,可读性较好.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( float max )  {
    float y;
    for (y = 0; y &lt; max; y++);  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int max )  {
    int y;
    for (y = 0; y &lt; max; y++);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

 MISRA-C:2004 C语言在关键系统中的使用指南
 第六部分,第13部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_5</key>
<configkey>MISRA2004-13_5</configkey>
<name><![CDATA[ for 循环语句的三个表达式应该仅与循环控制相关 [MISRA2004-13_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
for 循环语句的三个表达式应该仅与循环控制相关 [MISRA2004-13_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在目前， for 循环语句的三个表达式应该只能用于
 以下目的：
 - 第一个表达式初始化循环计数器 (在下面的示例中指的是 i)
 - 第二个表达式应该包括判断循环计数器 (i)， 以及可选的 
   其他循环控制变量 (标志)
 - 第三个表达式是循环计数器 (i) 的递增或递减”
这条规则分析 for 循环语句来查找任何在语句的 
初始化或更新部分中使用， 但是似乎和循环控制 
没有关系的变量。通常情况下， 即使变量跟循环停 
止条件没有关系，也在 for 循环语句中被初始化。
在极端的条件下，整个语句块移到 for 循环语句内， 
这样会使代码既容易出错又难以阅读。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守这条规则可以得到更加安全，更高可读性的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
    int x, j;
    for ( x = 5; j &lt; 2 ; x++ );       // 违规
    for ( x = 5; x &lt; 2 ; j++ );       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( )
{
    int x, j;
    for ( x = 5; x &lt; 2; x++);         // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 语言在关键系统中的使用指南
    第 6 章, 第 13 部分

2. Origin: Misra Guidelines - Rule 66

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_6</key>
<configkey>MISRA2004-13_6</configkey>
<name><![CDATA[ 禁止在循环体中修改循环计数器 [MISRA2004-13_6] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在循环体中修改循环计数器 [MISRA2004-13_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数字变量作为for循环的循环计数不要在循环体内部被修改.
但是，循环中其它代表逻辑值的循环控制变量可以被改变,
比如,for循环中检查指明动作完成的标志变量,



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防循环体中循环计数改变导致的错误和混淆.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int i;
    for ( i = 0; i &lt; 5; i++ ) {
        i = i + 3;                  /* Violation */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {    
    int i;
    for ( i = 0; i &lt; 5; i = i + 3 ) {} /* OK */
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节、第13部分

2. 来源: Misra 指南

3. J联合攻击战斗机, 飞行器, C++ 编码标准
   第 4.24 控制流结构章节, AV 第 201条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第 六章节, 第 6部分, 第6-5-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_a</key>
<configkey>MISRA2004-13_7_a</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许使用逻辑运算符'&amp;&amp;'的表达式的值一直是'true'或者'false'.


优点;

如果一个使用逻辑运算符'&amp;&amp;'的表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &lt;= 1)&amp;&amp;(a &gt;= 2)); // Violation 
    if((a &lt; 1)&amp;&amp;(a &gt; 2));   // Violation 
    if((a &gt;= 2)&amp;&amp;(a &lt;= 1)); // Violation 
    if((a &gt; 2)&amp;&amp;(a &lt; 1));   // Violation 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &lt;= 5)&amp;&amp;(a &gt;= 2)); // OK
    if((a &lt; 5)&amp;&amp;(a &gt; 2));   // OK
    if((a &gt;= 2)&amp;&amp;(a &lt;= 5)); // OK
    if((a &gt; 2)&amp;&amp;(a &lt; 5));   // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节、第13部分

2. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节、第 0部分, 第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_aa</key>
<configkey>MISRA2004-13_7_aa</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_aa] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_aa-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &gt;= 2)
    if(b &lt; 2) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &gt;= 2)
    if(b &lt; 7) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第0部分, 第0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_ab</key>
<configkey>MISRA2004-13_7_ab</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_ab] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_ab-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &lt; 2)
    if(b &gt;= 2) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &lt; 2)
    if(b &gt;= 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分, 第0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_ac</key>
<configkey>MISRA2004-13_7_ac</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_ac] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_ac-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &lt;= 2)
    if(b &lt; 3) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &lt;= 2)
    if(b &lt; 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_ad</key>
<configkey>MISRA2004-13_7_ad</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_ad] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_ad-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b == 2)
    if(b &lt; 1) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b == 2)
    if(a &lt; 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_ae</key>
<configkey>MISRA2004-13_7_ae</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_ae] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_ae-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &gt; b)
    if(b &lt; 5) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &gt; b)
    if(b &lt; 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_af</key>
<configkey>MISRA2004-13_7_af</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_af] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_af-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.





</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &gt;= b)
    if(b &lt; 5) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &gt;= b)
    if(b &lt; 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_ag</key>
<configkey>MISRA2004-13_7_ag</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_ag] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_ag-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &lt; b)
    if(b &gt; 1) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &lt; b)
    if(b &gt; 5) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_ah</key>
<configkey>MISRA2004-13_7_ah</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_ah] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_ah-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &lt;= b)
    if(b &gt; 1) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &lt;= b)
    if(b &gt; 5) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_ai</key>
<configkey>MISRA2004-13_7_ai</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_ai] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_ai-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个无符变量的逻辑运算表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunc()
{
    unsigned int a;
    if (a &gt;= 0)     // Violation
        a++; 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunc()
{
    unsigned int a;
    if (a &gt;= 2)     // OK
        a++; 
}



参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_aj</key>
<configkey>MISRA2004-13_7_aj</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_aj] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_aj-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>


不允许一个逻辑运算表达式的值是不变的.


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunc()
{
    unsigned char a;
    signed char b;

    if (b &gt;= 128)   // Violation
        b++;
    if (a &lt; 256)    // Violation
        a++; 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunc()
{
    unsigned char a;
    signed char b;

    if (b &gt;= 127)    // OK
        b++;
    if (a &lt; 255)     // OK
        a++; 
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_ak</key>
<configkey>MISRA2004-13_7_ak</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_ak] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_ak-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个逻辑运算表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunc()
{
    unsigned short a;
    signed short b;

    if (a &lt; 65536)    // Violation
        a++;
    if (b &lt;= 32767)   // Violation
        b++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunc()
{
    unsigned short a;
    signed short b;

    if (a &lt; 65535)    // OK
        a++;
    if (b &lt;= 32766)   // OK
        b++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_b</key>
<configkey>MISRA2004-13_7_b</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'&amp;&amp;'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -1)&amp;&amp;(a &lt; -2));   // Violation 
    if((a &gt;= -1)&amp;&amp;(a &lt;= -2)); // Violation 
    if((a &lt; -2)&amp;&amp;(a &gt; -1));   // Violation 
    if((a &lt;= -2)&amp;&amp;(a &gt;= -1)); // Violation 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -5)&amp;&amp;(a &lt; -2));   // OK
    if((a &gt;= -5)&amp;&amp;(a &lt;= -2)); // OK
    if((a &lt; -2)&amp;&amp;(a &gt; -5));   // OK
    if((a &lt;= -2)&amp;&amp;(a &gt;= -5)); // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_c</key>
<configkey>MISRA2004-13_7_c</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_c] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'&amp;&amp;'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; 0)&amp;&amp;(a &lt; -1));    // Violation
    if((a &lt; -1)&amp;&amp;(a &gt;= 0));   // Violation
    if((a == -5)&amp;&amp;(a == 5));  // Violation
    if((3 &lt; a)&amp;&amp;(-3 &gt; a));    // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &lt; 0)&amp;&amp;(a &gt; -1));    // OK
    if((a &gt; -1)&amp;&amp;(a &lt;= 0));   // OK
    if((a != -5)&amp;&amp;(a != 5));  // OK
    if((3 &gt; a)&amp;&amp;(-3 &lt; a));    // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_d</key>
<configkey>MISRA2004-13_7_d</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_d] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'&amp;&amp;'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a, int b)
{
    if((a &gt; b)&amp;&amp;(a &lt; b));   // Violation
    if((a &lt; b)&amp;&amp;(a &gt;= b));  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a, int b, int c)
{
    if((a &gt; b)&amp;&amp;(a &lt; c));   // OK
    if((a &lt; b)&amp;&amp;(a &gt;= c));  // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_j</key>
<configkey>MISRA2004-13_7_j</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_j] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_j-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'||'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑运算的表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt;= 0)||(a &lt; 0));   // Violation
    if((5 &gt; a)||(a &gt; 3));    // Violation
    if((a &lt;= 4)||(a &gt;= 3));  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt;= 10)||(a &lt; 0));   // OK
    if((5 &gt; a)||(a &gt; 13));    // OK
    if((a &lt;= 4)||(a &gt;= 13));  // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_k</key>
<configkey>MISRA2004-13_7_k</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_k] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_k-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'||'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果使用逻辑运算操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -4)||(a &lt; -3));   // Violation
    if((-1 &gt; a)||(-3 &lt; a));   // Violation
    if((a &lt; -3)||(-5 &lt; a));   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -4)||(a &lt; -13));   // OK
    if((-11 &gt; a)||(-3 &lt; a));   // OK
    if((a &lt; -13)||(-5 &lt; a));   // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_l</key>
<configkey>MISRA2004-13_7_l</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_l] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_l-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'||'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个逻辑运算操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -2)||(a &lt; 1));   // Violation
    if((4 &gt; a)||(-3 &lt; a));   // Violation
    if((a &gt; -4)||(2 &gt; a));   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &lt; -2)||(a &gt; 1));   // OK
    if((4 &lt; a)||(-3 &gt; a));   // OK
    if((a &lt; -4)||(2 &lt; a));   // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_m</key>
<configkey>MISRA2004-13_7_m</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_m] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_m-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'||'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个逻辑运算操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a, int b)
{
    if((a &gt;= b)||(a &lt;= b));  // Violation
    if((a &lt; b)||(a &gt;= b));   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a, int b, int c)
{
     if((a &gt;= b)||(a &lt;= c));   // OK
     if((a &lt; c)||(a &gt;= b));    // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_n</key>
<configkey>MISRA2004-13_7_n</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_n] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_n-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个逻辑运算操作的表达式产生的结果被证实一直是'true'或者'false'，
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if(a == a);  // 违规
    if(1 == 1);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if(a == 1);  // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_s</key>
<configkey>MISRA2004-13_7_s</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_s] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_s-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(col &lt; GREEN);	 // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(col &lt; RED);	 // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_t</key>
<configkey>MISRA2004-13_7_t</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_t] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_t-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(col &gt; YELLOW);	 // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(col &gt; RED);	 // OK
}

参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_u</key>
<configkey>MISRA2004-13_7_u</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_u] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_u-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(YELLOW &lt; col);	 // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(GREEN &lt; col);	 // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则
 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_v</key>
<configkey>MISRA2004-13_7_v</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_v] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_v-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(GREEN &gt; col);	 // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(BLUE &gt; col);	 // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_w</key>
<configkey>MISRA2004-13_7_w</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_w] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_w-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.


f示例:

void myFunctionEnum(){
    
 	 enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

 	 if(col1 &lt; 0);   // Violation
	 if(col1 &lt; 16);  // Violation
 	 if(col1 &lt;= 15); // Violation
	 if(col1 &lt;= 16); // Violation
 	 if(col1 &gt; 15);  // Violation
	 if(col1 &gt; 16);  // Violation
	 if(col1 &gt;= 0);  // Violation
	 if(col1 &gt;= 16); // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

	if(col1 &lt; 1);   // OK
 	if(col1 &lt; 15);  // OK
	if(col1 &lt;= 0);  // OK
	if(col1 &lt;= 1);  // OK
	if(col1 &gt; 0);   // OK
	if(col1 &gt; 1);   // OK
	if(col1 &gt;= 1);  // OK
 	if(col1 &gt;= 15); // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_x</key>
<configkey>MISRA2004-13_7_x</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_x] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_x-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
  	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

 	if(15 &lt; col1);  // Violation
	if(16 &lt; col1);  // Violation 
	if(0 &lt;= col1);  // Violation
	if(16 &lt;= col1); // Violation
	if(0 &gt; col1);   // Violation
	if(16 &gt; col1);  // Violation 
 	if(15 &gt;= col1); // Violation
	if(16 &gt;= col1); // Violation 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

	if(0 &lt; col1);   // OK
	if(1 &lt; col1);   // OK
	if(1 &lt;= col1);  // OK
 	if(15 &lt;= col1); // OK
	if(1 &gt; col1);   // OK
 	if(15 &gt; col1);  // OK
	if(0 &gt;= col1);  // OK
	if(1 &gt;= col1);  // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六部分,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_y</key>
<configkey>MISRA2004-13_7_y</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_y] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_y-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
  	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

 	 if(col1 == 14 ); // Violation
 	 if(col1 != 14 ); // Violation
 	 if(14 == col1);  // Violation
 	 if(14 != col1);  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

	 if(col1 == 15);  // OK
	 if(col1 != 15);  // OK
	 if(15 == col1);  // OK
	 if(15 != col1);  // OK
}

参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-13_7_z</key>
<configkey>MISRA2004-13_7_z</configkey>
<name><![CDATA[ 不允许其结果是不变的布尔运算 [MISRA2004-13_7_z] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许其结果是不变的布尔运算 [MISRA2004-13_7_z-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个if语句嵌套在另一个if语句中,而且这个if语句中条件表达式的结果
是不变的.


好处:

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int b)
{
  if(b &gt; 2)
    if(b &gt;= 1)   /* Violation */
      b++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int b)
{
  if(b &gt; 2)
    if(b &gt;= 5)   /* OK */
      b++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_10</key>
<configkey>MISRA2004-14_10</configkey>
<name><![CDATA[ 所有的 'if...else-if' 结构中应该由 'else' 分支结束 [MISRA2004-14_10] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的 'if...else-if' 结构中应该由 'else' 分支结束 [MISRA2004-14_10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则适用于任何一个 'if' 语句是否都由一个或多个
'else-if' 语句结尾； 最后的 'else-if' 应该紧跟着一个 'else'
语句。 在一个简单的 'if' 语句中，那么应该包括 'else' 
语句。
对最后 'else' 语句的需求是防御性的编程。 
其中 'else' 语句应该要么有合适的操作或包含
一个为什么没有操作合理的注释。"
参见: CODSTA-23



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

确保合适的数据流、提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a)
{
    if(a &gt; 0)
    {
    }
    else if (a &gt; 10)   // Violation
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a)
{
    if(a &gt; 0)
    {
    }
    else if (a &gt; 10)   // OK
    {
    }
    else
    {
        // comment or action
    }
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南 - 第 60条规则

3.联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构章节, AV 第 192条规范

4.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第6部分,第6-4-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_1_a</key>
<configkey>MISRA2004-14_1_a</configkey>
<name><![CDATA[ 在 "else" 语句块中不应存在不可达代码 [MISRA2004-14_1_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 "else" 语句块中不应存在不可达代码 [MISRA2004-14_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在else语句中不应该有覆盖不到的语句。
“这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的。”
参考：
MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_d, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
    if(a == a){
        a = a + b;
    }
    else{               // Violation
        a = a - b;
    }                     
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
    if(a == 3){
        a = a + b;
    }
    else{               // OK
        a = a - b;
    }                     
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南 - 第 52条规则

3.联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构章节, AV 第 186条规范

4.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第0-1-1规则
 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_1_b</key>
<configkey>MISRA2004-14_1_b</configkey>
<name><![CDATA[ 在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在不可达代码 [MISRA2004-14_1_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在不可达代码 [MISRA2004-14_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。能够覆盖到但是从不执行的代码
将从这条规则中排出（例如，防御性编程代码）
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在return','break', 'continue'和 'goto' 语句后有覆盖不到的语句.
参见:MISRA2004-14_1_a, MISRA2004-14_1_c, MISRA2004-14_1_d, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo();
int myFunction(int i, int j)
{
    switch(i)
    {
        case 1:
            j = 5;
            break;    // Violation
            foo();
        case 2:
            j = 3;
            return j; // Violation
            foo();
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo();
int myFunction(int i, int j)
{
    switch(i)
    {
        case 1:
            j = 5;
            break;    // OK
        case 2:
            j = 3;
            return j; // OK
    }
    foo();
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6,章节, 第 14部分

2. 来源: Misra 指南 - 第 52条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV 第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章节, 第0部分, 第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_1_c</key>
<configkey>MISRA2004-14_1_c</configkey>
<name><![CDATA[ 在 "if/else/while/for" 语句块中不应存在不可达代码 [MISRA2004-14_1_c] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 "if/else/while/for" 语句块中不应存在不可达代码 [MISRA2004-14_1_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在if/while/for/else块中如果一个条件值不变而出现无用代码.
参见:MISRA2004-14_1组规则 and MISRA2004-13_7组规则



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

vo7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助防止无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int unreachable_code = 1;
    if(0)                         // Violation
    { 
        unreachable_code = 2; 
    }                 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不得有不可达代码



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分
   
2. 来源: Misra 指南- 第52条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制结构章节,AV第186条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节, 第0部分,第 0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_1_d</key>
<configkey>MISRA2004-14_1_d</configkey>
<name><![CDATA[ 在 Switch 语句中不应存在不可达代码 [MISRA2004-14_1_d] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 Switch 语句中不应存在不可达代码 [MISRA2004-14_1_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在"switch"语句中不应该有覆盖不到的代码.
这条规则预防语句、表达式被放置在case和default块外面.
"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在if/while/for/else块中如果一个条件值不变而出现无用代码.
参见:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i ) {
    switch (i) {    // Violation
        i = 0;
    case 1:
        i = 1;
        break;
    default:
        i = 2;
        break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i ) {
    switch (i) {    // OK
    case 0:
        i = 0;
        break;
    case 1:
        i = 1;
        break;
    default:
     	i = 2;
        break;
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_1_e</key>
<configkey>MISRA2004-14_1_e</configkey>
<name><![CDATA[ 在 'for' 循环中不应存在不可达代码 [MISRA2004-14_1_e] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'for' 循环中不应存在不可达代码 [MISRA2004-14_1_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。能够覆盖到但是从不执行的代码
将从这条规则中排出（例如，防御性编程代码）。一部分代码
如果没有控制流路径从相关的输入点进入是覆盖不到的。"
如果一个 'for' 循环在条件中包含单关系表达式
'VAR &lt; FB',  'VAR &lt;= FB', 'FB  &gt; VAR', 'FB &gt;= VAR'
并且其结果始终是 false 时，报告一个违规， 这里 FB 是
一个常量或一个 const 变量，而 VAR 是一个在 for 初始化语句中复制的变量。
如果一个 for 条件的结果始终是 false 那么循环体将不会被执行。
参见:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c,
MISRA2004-14_1_d, MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i, int j ) 
{
    for ( i = 0; i &lt; 0; i++ )  // Violation
    {
      j = 1; 
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i, int j ) 
{
    for ( i = 0; i &lt; 5; i++ )  // OK
    {
      j = 1; 
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分
  
2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_1_f</key>
<configkey>MISRA2004-14_1_f</configkey>
<name><![CDATA[ 在 'if' 或 'switch' 语句之后不应存在不可达代码 [MISRA2004-14_1_f] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'if' 或 'switch' 语句之后不应存在不可达代码 [MISRA2004-14_1_f-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码.
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
如果出现下面的情况这条规则就会报错：
-'if/else' 结构中每条分支都没有'return'语句
-'switch'结构中每个'case'分支和'default'中都没有'return'语句
参考：MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_d,
MISRA2004-14_1_e, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1( int c ) {
    if ( c &gt; 2 ) {    // Violation
        return 0;
    } else {
        return 1;
    }
    return c;         // 不可达代码
}

int foo2( int i ) {
    switch(i){        // 违规
    case 1:
        i++;
        return 0;
    case 2:
        i = i + 2;
        return 1;
    default:
        return 2;
    }
    return i;         // 不可达代码
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1( int c ) {
    if ( c &gt; 2 ) {    // OK
        return 0;
    } else {
        return c;
    }
}

int foo2( int i ) {
    switch(i){        // OK
    case 1:
        i++;
        return 0;
    case 2:
        i = i + 2;
        return 1;
    default:
        return i;
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
     第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24 控制流结构章节, AV 第186条规则

3. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_1_g</key>
<configkey>MISRA2004-14_1_g</configkey>
<name><![CDATA[ 在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在不可达代码 [MISRA2004-14_1_g] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在不可达代码 [MISRA2004-14_1_g-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码.
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
如果出现下面的情况这条规则就会报错:
-在'if/else'结构中每条分支都没有'break', 'continue' or 'return'
-switch结构中每条'case'和'default'中都没有 'return' 
参考:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c,
          MISRA2004-14_1_d, MISRA2004-14_1_e, MISRA2004-14_1_f



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int c ) {
    while ( c &gt; 1 ) {
        if ( c &gt; 2 ) {    // Violation
            continue;
        } else {
            break;
        }
        c++;              // 不可达代码
    }

    for (int i = 0; i &gt; 1; i++ ) {
        switch(i){        // 违规
        case 1:
            i++;
            return i;
        case 2:
            i = i + 2;
            return i;
        default:
            return i;
        }
        c++;              // 不可达代码
    }
    return c;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int c ) {
    while ( c &gt; 1 ) {
        c++;
        if ( c &gt; 2 ) {    // OK
            continue;
        } else {
            break;
        }
    }

    for (int i = 0; i &gt; 1; i++ ) {
        c++;
        switch(i){        // OK
        case 1:
            i++;
            return i;
        case 2:
            i = i + 2;
            return i;
        default:
            return i;
        }
    }
    return c;
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24 控制流结构章节, AV 第186条规则

3. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_2</key>
<configkey>MISRA2004-14_2</configkey>
<name><![CDATA[ 所有非 null 语句应该至少有一个执行或者导致控制流变化的副作用 [MISRA2004-14_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有非 null 语句应该至少有一个执行或者导致控制流变化的副作用 [MISRA2004-14_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"任何 (除了空语句以外) 没有副作用而且不会
对导致控制流变化的语句通常表示一个编程错误，
因此对这类语句应该执行静态检查。" 

ISO/IEC 9899:1999标准中,副作用是这样定义的:访问某个可变对象,
修改某个对象,修改某个文件或者调用包含上述任一操作的函数都是副
作用.副作用即是那些在执行中的发生的变化.

Null语句定义为:只含有一个分号的语句.
如果检测到不带副作用的非空语句,就会报告违规.
比如,某个表达式的估算结果未被使用,原因是程序员忘记使用赋值
符来保存该值,或者他不小心把"="写成了"==".此语句会被认
为没有副作用.这样的编程错误具有潜在的危害性。

如果检测到空的块语句,也会报告违规,因为这样的语句也不会带有副作用.
空函数体并不违反此条规则,因为本规则把所有函数调用看作是带有副作用的,即使
函数调用没有改变任何变量的值.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
 
空的函数体并不被这条规则视为违规。 
就这条规则的目的而言，任何函数调用都被认为 
有副作用，即使作为这个函数调用的结果， 
没有任何变量被修改
这条规则不对空块报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

符合此规则会使代码更安全和可读.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct tagStruct {
    int _iField;
    char * _p;
};

int bar( );

void foo( ) {
    int i = 0;
    struct tagStruct s, *ps;
    /* Examples of incorrect code - no side effects: */
    i + 3;                    /* Violation - result not used */
    3;                        /* Violation - result not used */
    i;                        /* Violation - result not used */
    i + bar();                /* Violation - result not used */
    ps-&gt;_p + s._iField;       /* Violation - result not used */
    ps-&gt;_iField &lt;&lt; s._iField; /* Violation - result not used */
    *(ps-&gt;_p);                /* Violation - result not used */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct tagStruct{
    int _iField;
    char * _p;
};

volatile struct tagStruct volStr;

int bar( );

void foo( ) {
    int i = 0;
    volatile int j = 0;
    struct tagStruct s, *ps;

    /* Examples of correct code - with side effects: */
    i = i + 3;               /* OK - assignment */
    i &lt;&lt;= 3;                 /* OK - assignment */
    bar();                   /* OK - function call */
    j;                       /* OK - volatile variable */
    volStr._p;               /* OK - volatile variable */
    if(ps-&gt;_iField){}        /* OK - cause control flow to change */

    ;                        /* OK - null statement */
    {}                       /* OK - empty block */
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南-第53条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.24 章节控制流结构, AV第 187条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_3</key>
<configkey>MISRA2004-14_3</configkey>
<name><![CDATA[ 空语句只允许单独存在一行或可能在其后面跟着注释 [MISRA2004-14_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空语句只允许单独存在一行或可能在其后面跟着注释 [MISRA2004-14_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一般情况下,不要包含空语句。空语句在使用时应该自成一行。
Null语句之前应该有空格符.作为行首空格。空语句后如果有注释,
至少应该用一个空格符隔开。
为了增加代码可读性,必须使用空格符隔开空语句和其后的注释。
也可以参考:MISRA-054。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则使能静态检测工具，当空语句和其他字符出现在一行时，
一般表示编程错误，这时候会发出警告。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{

/* Violation */ ;
;/* Violation */

}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void goo()
{
/* OK */
;
; /* OK */
;   /* OK */  
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分
   
2. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第6部分,第6-2-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_4</key>
<configkey>MISRA2004-14_4</configkey>
<name><![CDATA[ 不要使用 goto 语句 [MISRA2004-14_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 goto 语句 [MISRA2004-14_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用goto语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

goto语句会导致错误和混乱.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int a ) {
    if (a &lt; 0) {     
        goto end;       /* 违规 */
    } 
    a = foo(a-1);
end:
    return a+1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int a ) {
    /* Code was changed and does not use goto anymore */
    if (a &gt;= 0) {
        a = foo(a-1);
    }
    return a+1;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   出自: 第14章节控制流结构  -第49规则 

3.Misra 指南 - 第 56条规则

4. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构, AV 第 189规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

6. HIS Source Code Metriken, version 1.3.1
   Metrik "GOTO"

7. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_5</key>
<configkey>MISRA2004-14_5</configkey>
<name><![CDATA[ 不要使用 continue 语句 [MISRA2004-14_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 continue 语句 [MISRA2004-14_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免使用continue.continue用来跳出循环.
但是，如果用其他语句代替（continue）代码更容易读懂.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用continue导致错误和混乱.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int bar( int );
void foo( int i ) {
    while (i--) {
        if (bar( i )) {
            continue;     /* Violation */
        }
        i /= 2;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int bar( int );
void foo( int i ) {
    while (i--) {
        if (bar( i )) {
            /* OK - code was changed and does not use continue anymore */
        } else {
            i /= 2;
        }
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rec. 53

3. 来源: Misra 指南- 第57条规则

4. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24控制流结构,AV 第190条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_6</key>
<configkey>MISRA2004-14_6</configkey>
<name><![CDATA[ 在循环体中至多只允许一个用于结束循环的 break 语句 [MISRA2004-14_6] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在循环体中至多只允许一个用于结束循环的 break 语句 [MISRA2004-14_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

任何迭代语句应该最多有一个用于结束循环的break语句.
break语句允许在像循环输出两部分结果或者优化代码时使用.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

有利于编写结构合理的程序.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a;

    for (a = 0; a &lt; 10; a++) { /* Violation */
        if (a == 5) {
            break;
        }
        if (a == 7) {
            break;
        }
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int a;

    for (a = 0; a &lt; 10; a++) { /* OK */
        if (a == 5 || a == 7) {
            break;
        }
    }
}


参考文献:

MISRA-C:2004 C语言在关键系统中的使用指南
第六章节,第14部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_7</key>
<configkey>MISRA2004-14_7</configkey>
<name><![CDATA[ 函数应该在其最后有单一的出口 [MISRA2004-14_7] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数应该在其最后有单一的出口 [MISRA2004-14_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数应该有单一的出口.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则包括函数调用出口、终止,标准库的出口.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

帮助编写安全、易读的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int i)
{
    if (i == 0) {
        return 0;        // Violation	
    } else if (i == 1) {
        return 1;        // Violation
    } else {
        return 2;        // Violation
    }
}

int foo2(int a) {  
    int result;
    if (a &gt; 0) {
        return result;  // Violation
    } 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int i)
{
	int result = 0;
    if (i == 0) {
        result = 0;
    } else if (i == 1) {
    	result = 1;
    } else {
    	result = 2;
    }
    return result;   // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分

2. 来源: Misra 指南-第82条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
  第4-13功能章节,AV第113条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_8</key>
<configkey>MISRA2004-14_8</configkey>
<name><![CDATA[ 'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [MISRA2004-14_8] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [MISRA2004-14_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

组成switch语句或者while 语句、do...while语句或者for语句的主体的应该是复杂语句，
甚至是包含简单语句的复杂语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x ) {
    int i;

    switch(i)             // Violation
    ;

    for (i=0; i&lt; 10; i++) // Violation 
        foo( x );
    while (1)             // Violation
        foo( x );

    do                    // Violation
    foo( x );
    while(1);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x ) {
    int i;

    switch(i)             // OK
    {
    }

    for (i=0; i&lt; 10; i++) // OK
            {foo( x );}
    while (1)             // OK
        {foo( x );}

    do                    // OK
        {foo( x );}
    while(1);
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Misra 指南-第59条规则

3.Ellemtel 编码规范
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    from: 6 Style - 6.4 Flow Control Statements - Rec. 25

4.联合攻击战斗机, 飞行器 C++ 编码规范
   第4.9设计章节,AV第59条规则

5.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第六部分,第6-4-1规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-14_9</key>
<configkey>MISRA2004-14_9</configkey>
<name><![CDATA[ 在 'if' 和 'else' 之后应该紧跟着复合语句 [MISRA2004-14_9] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'if' 和 'else' 之后应该紧跟着复合语句 [MISRA2004-14_9-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

if语句结构应该是一个复杂语句.
else关键字后面应该是一个复杂语句或者是另外一个if语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高了代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x, int y )
{
    int i, j;
    if(x &gt; 0)      // Violation
        x = i;
    else if(y &gt; 0) // Violation
        y = i;
    else
        y = j;     // Violation
        x = j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x, int y )
{
    int i, j;
    if(x &gt; 0)      // OK
    {
        x = i;
    }
    else if(y &gt; 0) // OK
    {
        y = i;
    }
    else
    {
        y = j;     // OK
        x = j;
    }
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Misra 指南-第59条规则

3. Ellemtel 编码规范
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    from: 6 Style - 6.4 Flow Control Statements - Rec. 25

4.联合攻击战斗机, 飞行器 C++ 编码规范
   第4.9设计章节,AV第59条规则

5. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第六部分,第6-4-1规则示例

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-15_0_a</key>
<configkey>MISRA2004-15_0_a</configkey>
<name><![CDATA[ switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRA2004-15_0_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRA2004-15_0_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

switch语句中应该只能包含switch标签和switch子句



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a,int b)
{
    int c;     
    switch(a)
    {
        
    case 1:
        break;
        
        c = 1;  /* Violation */
        
    case 2:
        break;
        
        c = 2;  /* Violation */   
        
    default:
        break;
        
        c = 3;  /* Violation */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(int a,int b)
{
    int c;     
    switch(a)
    {
        
    case 1:
        c = 1; /* OK */
        break;
        
    case 2:
        c = 2; /* OK */
        break;
        
    default:
        c = 3; /* OK */
        break;
    }
}


参考文献:

MISRA-C:2004 C语言在关键系统中的使用指南
第6章,第15部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-15_0_b</key>
<configkey>MISRA2004-15_0_b</configkey>
<name><![CDATA[ switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRA2004-15_0_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRA2004-15_0_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

switch语句中应该只能包含switch标签和switch从句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a,int b)
{
    int c;     
    switch(a)
    {
        c = 0;  /* Violation */
    case 1:
        break;
    case 2:
        break;
        
    default:
        break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(int a,int b)
{
    int c;  
    c = 0;    /* OK */
    switch(a)
    {
    case 1:
        break;
    case 2:
        break;
        
    default:
        break;
    }
}


参考文献:

MISRA-C:2004 C语言在关键系统中的使用指南
第6章,第15部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-15_0_c</key>
<configkey>MISRA2004-15_0_c</configkey>
<name><![CDATA[ switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRA2004-15_0_c] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRA2004-15_0_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

switch语句中应该只能包含switch标签和switch从句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define SWITCH(a)   \
    switch (a)      \
    {               \
    case 1:         \
        break;      \
        a &lt;&lt; 2; /* Violation */\
    case 2:         \
        break;      \
    default:        \
        break;      \
    }



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define SWITCH(a)   \
    switch (a)      \一新
    {               \
    case 1:         \
        a &lt;&lt; 2; /* OK */\
        break;      \
    case 2:         \
        break;      \
    default:        \
        break;      \
    }



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第六章节,第15部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-15_1</key>
<configkey>MISRA2004-15_1</configkey>
<name><![CDATA[ 只能当最接近的封闭复合语句是 switch 语句主体部分时才能使用 switch 标签 [MISRA2004-15_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只能当最接近的封闭复合语句是 switch 语句主体部分时才能使用 switch 标签 [MISRA2004-15_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“case作用域或者default作用域，作为switch语句的主体部分，
应该混合出现。所有case分支和default分支应该是有相同的作用域。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a, int b ) {
    switch(a) {
    case 1:
        {
            case 6:     /* 违规 */
            ;
            default:    /* 违规 */
            break;
        }
        break;
    case 2:
        if (b == 1) {
             case 3:      /* 违规 */
             break;
        }
        break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

删除嵌套的'case'和'default'语句.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第15部分

2. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章，第6部分，第6-4-3条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章，第6部分，第6-4-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-15_2</key>
<configkey>MISRA2004-15_2</configkey>
<name><![CDATA[ 必须以 break 作为 switch 每个子句的结束语句 [MISRA2004-15_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
必须以 break 作为 switch 每个子句的结束语句 [MISRA2004-15_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个switch分句的最后一句应该是break语句，
或者如果switch分句是复合语句，那么这个
复合语句的最后一句应该是break语句。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本条规则允许使用return替代break语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不可预测的程序行为.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 违规
            i = 4;
            break;
            i++;
        case 1 :         // 违规
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
        case 2 :         // 违规
            {
                i = 3;
            }
        default:         // 违规
            i = 8;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 通过
            i = 4;
            i++;
            break;
        case 1 :         // 通过
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
            break;
        case 2 :         // 通过
            {
                i = 3;
                break;
            }
        case 3 :         // 通过 - 空case语句
        default:         // 通过
            i = 8;
            break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第15部分

2. Misra 指南 - 第61条规则

3. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 14 Flow Control Structures - Rule 47

4. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.24章流量控制结构， AV 第193条规则
   

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-15_3</key>
<configkey>MISRA2004-15_3</configkey>
<name><![CDATA[ switch 语句中最后必须为 default 子句 [MISRA2004-15_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句中最后必须为 default 子句 [MISRA2004-15_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有switch语句应当含有最终的default子句
最终default子句是防御性编程的需求。
这个子句要么执行恰当的动作，要么包含合适的注释
--那就是为什么没有执行动作
另见: CODSTA-35



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则提高switch语句的可读性和可维护性.

实例:

void foo(int i) {
    switch(i) /* 违规 */
    {
        case 0 : break;
        case 1 : break;
    }
    switch(i) /* 违规 */
    {
        case 0 : break;
        default: break;
        case 1 : break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i) {
    switch(i) /* 通过 */
     {
        case 0 : break;
        case 1 : break;
        default: break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第15部分

2. 来源：Misra 指南 - 第62条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-15_4</key>
<configkey>MISRA2004-15_4</configkey>
<name><![CDATA[ switch 的表达式中不能出现有效的布尔类型值 [MISRA2004-15_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 的表达式中不能出现有效的布尔类型值 [MISRA2004-15_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

switch条件中不能出现有效的布尔类型值。
本规则禁止使用以下产生布尔类型值的运算符：
a) 等号运算符 (== and !=)
b) 逻辑运算符 (!, &amp;&amp; and ||)
c) 关系运算符 (&lt;, &gt;, &lt;= and &gt;=)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则可以阻止在switch条件中使用布尔数值.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i)
{
    switch(i == 0)           // 违规
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(int i) 
{
    switch(i)                   //通过
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章，第15部分

2. 来源: Misra 指南—第63条规则

3. 联合攻击战斗机, 飞行器
   第4.24章Chapter 4.24 Flow Control Structures, AV 第195条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-15_5</key>
<configkey>MISRA2004-15_5</configkey>
<name><![CDATA[ 每一个 switch 语句至少有一个 case 子句 [MISRA2004-15_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个 switch 语句至少有一个 case 子句 [MISRA2004-15_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个switch语句应当至少含有一个case子句。
另见: OPT-21, OPT-22, CODSTA-54



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提供可维护性的switch语句.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* 违规 */ 
    {
        default:
            ;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* OK */ 
    {
      case 1:
      {
      }
      default:
            ;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6条长，第15部分

2. 来源: Misra 指南 - 第64条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-8条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_1</key>
<configkey>MISRA2004-16_1</configkey>
<name><![CDATA[ 不要使用可变数量的参数来定义函数 [MISRA2004-16_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用可变数量的参数来定义函数 [MISRA2004-16_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不要使用可变数量的参数来定义函数，否则将带来许多潜在的问题。
用户不能使用一些可变数量的参数来书写增加的函数。
将阻止使用stdarg.h, va_arg, va_start and va_end。”
本条规则将在下列地方报出违规信息：
-包含&lt;stdarg.h&gt; or &lt;cstdarg&gt;的头文件
-使用va_arg/va_start/va_end的函数
-使用可变数量的参数来定义的函数（没有声明）



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则阻止不确定的行为.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdarg.h&gt;                     /* 违规 */
int average( int first, ... );          /* OK - Violation on definition */

int average( int first, ... ) {         /* 违规 */
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start( marker, first );          /* 违规 */
    while( i != -1 ) {
        sum += i;
        count++;
        i = va_arg( marker, int );      /* 违规 */
    }
    va_end( marker );                   /* 违规 */
    return( sum ? (sum / count) : 0 );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用可变参数的函数.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第6章，第16部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_10</key>
<configkey>MISRA2004-16_10</configkey>
<name><![CDATA[ 如果函数返回错误信息，该错误信息必须经过测试 [MISRA2004-16_10] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数返回错误信息，该错误信息必须经过测试 [MISRA2004-16_10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不管函数是来自标准库，还是第三方的库，或者是用户定义的函数，
它可能提供一些方式来标志一个错误的发生。这种方式可能是通过设
置一个错误标志，一些特别的返回值或者其它的方式。
无论何种方式，调用这个函数的程序应该在函数返回时，检查错误标志。
但是，注意对函数输入参数进行检查是一种比试图在函数完成之后检查
错误的更稳健的一种方式（参见MISRA2004-20_3）。  
同样也要注意对errno（用来从函数返回错误信息）的使用是笨拙的，
要小心使用（参见MISRA2004-20_5）。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
函数调用可能返回char, short int, int, enum类型或者这些类型的引用的值，
此规则用来检查返回这些类型值的函数调用并在这个值没有被赋值，
检查或者强制转换成了void类型时报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来帮助书写安全性高的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int SomeFunctionReturningError( );
void foo( )
{
    SomeFunctionReturningError( );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int SomeFunctionReturningError( );
int foo( ) 
{
    int x;
    x = SomeFunctionReturningError( );       // OK
    (void)SomeFunctionReturningError( );    //OK
    if (SomeFunctionReturningError( ));       // OK
    switch (SomeFunctionReturningError( )) {  //  OK
    }
    return SomeFunctionReturningError( );     //  OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源:Misra 使用指南 - 第 86 条规则

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Function, AV Rule 115

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第0部分，第0-3-2条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 7

6. <A HREF="http://cwe.mitre.org/data/definitions/391.html">http://cwe.mitre.org/data/definitions/391.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_2</key>
<configkey>MISRA2004-16_2</configkey>
<name><![CDATA[ 函数不应该直接或者间接地调用自己 [MISRA2004-16_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不应该直接或者间接地调用自己 [MISRA2004-16_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数不应该直接或者间接地调用自己。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这个规则用来检测直接递归调用或者简单地
间接地递归调用（多达三层嵌套函数调用）。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止使用递归函数调用.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int l ) {
    int x = l;

    if (l &gt; 0) {
        foo( x - 1 );   /* 违规 */
    }
}

void foo3( int );

void foo4( int i ) {
    if (i &gt; 0) {
        foo3( (int) i / 2 );  /* 违规 */
    }
}

void foo3( int i ) {
    int x = i;

    if (i &gt; 0) {
        foo4( x - i );  /* 违规 */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1( ) {          /* Ok */
    /* 空的 */
}

void foo2( );           /* Ok */

void foo3( ) {
    foo2( );            /* Ok */
}

void foo7( int );

void foo4( int i ) {
    foo7( i );    /* Ok - 不能检测复杂地间接地递归调用 */
}

void foo5( int i ) {
    foo4( i );    /* Ok -不能检测复杂地间接地递归调用*/
}

void foo6( int i ) {
    foo5( i );    /* Ok - 不能检测复杂地间接地递归调用 */
}

void foo7( int i ) {
    if (i &gt; 0) {
        foo6( i - 5 );  /* Ok - 不能检测复杂地间接地递归调用 */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源：Misra 指南 - 第70条规则

3. 联合攻击战斗机，飞行器，C++ 编码标准
   第4.13章函数，AV 第119条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-5-4条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

6. HIS Source Code Metriken, version 1.3.1
Metrik "ap_cg_cycle"

7. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_3</key>
<configkey>MISRA2004-16_3</configkey>
<name><![CDATA[ 禁止函数声明中参数只有类型没有标识符 [MISRA2004-16_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止函数声明中参数只有类型没有标识符 [MISRA2004-16_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在函数声明中，为使了提高程序的兼容性、可读性和可维护性， 所有的函数名都应该给出。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的可读性和清晰度.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1( void );          /* OK */
void foo2( int a, int );    /* 违规*/
void foo3( int a, int ){}   /* OK */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1( void );          /* OK */
void foo2( int a, int b );  /* OK */
void foo3( int a, int ){}   /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第6章，第16部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_4</key>
<configkey>MISRA2004-16_4</configkey>
<name><![CDATA[ 禁止函数原形中的参数与实际定义中的形参不一致 [MISRA2004-16_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止函数原形中的参数与实际定义中的形参不一致 [MISRA2004-16_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果参数名已经给与了，那么在声明
和定义的时候也要用一样的参数名。
 


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b);  
void foo(int x, int y ) {}  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b);    /* OK */
void foo(int a, int b) {}

/* 正确代码示例 */
void foo1();               /* OK */
void foo2(int  , int   );  /* OK */
void foo2(int x, int y ) {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源: Misra指南 - 第74条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第8部分，第8-4-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_5</key>
<configkey>MISRA2004-16_5</configkey>
<name><![CDATA[ 没有参数的函数必须声明参数类型为 void [MISRA2004-16_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
没有参数的函数必须声明参数类型为 void [MISRA2004-16_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果函数没有参数，参数列表应该被声明为 void。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo();  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(void); /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源： Misra指南 - 第76条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_6</key>
<configkey>MISRA2004-16_6</configkey>
<name><![CDATA[ 传递给函数的参数个数必须与函数定义的参数一致 [MISRA2004-16_6] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
传递给函数的参数个数必须与函数定义的参数一致 [MISRA2004-16_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

传递给函数的参数个数应该跟函数原型相匹配。
根据ISO/IEC 9989:1999标准，一个函数原型是表明参数类型的声明。 
这个规则需要传递给函数的参数个数与原型中声明的个数相匹配。
尽管编译器可能不能指出这种强制错误，但是规则还是应该保持的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性，可维护性，并阻止了错误的发生。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int p)
{
    foo(1);    /* 违规 - 没有 foo() 原型 */
    foo(2,p);  /* 违规 - 参数个数不一致:
                     第一个foo()调用被认做事这里的这个foo()的声明*/
}

void foo0( void );
void foo3( int, int, int );

void goo( ) {
    foo0( 7 );             /* 违规 */
    foo3( 6, 6, 6, 6);     /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int p)
{
    int foo(int, int);    /* 正常 原型 */
    foo(2,p);             /* 正常 */
}

void foo0( void );
void foo2( int, int, ... );
void foo3( int, int, int );

void goo( ) {
    foo0( );                /* OK */
    foo2( 6, 6 );           /* OK */
    foo2( 6, 6, 6, 6 );     /* OK */
    foo3( 6, 6, 6 );        /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. Misra 指南 - 第78条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_7</key>
<configkey>MISRA2004-16_7</configkey>
<name><![CDATA[ 如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [MISRA2004-16_7] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为 const 类型 [MISRA2004-16_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在函数原型中的指针参数，如果不用来修改地址参数就应该被声明为指向常量的指针。
既然被保护的是对象，这个常量的限制应该应用于指针指向的对象而不是指针本身。”
参见: CODSTA-14, CODSTA-CPP-43, CODSTA-CPP-53, MISRA-104, 



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

可能已经是参数声明为指向常量的指针的重载函数。
然后改变参数的类型为指向常量的指针会使得
代码不可编译。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
此规则可用来阻止无意的修改数据，并在函数接口定义上，提高准确性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int function(int* ptr)       // 违规
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int function(const int* ptr) // OK
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55种提高程序设计的特殊的途径 ", 
   第三版, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章，第3项

2. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

3.  联合攻击战斗机, 飞行器, C++ 编码标准
   第4.13章函数， AV 第118条规则

4. 来源: Misra 指南- 第81条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_7_b</key>
<configkey>MISRA2004-16_7_b</configkey>
<name><![CDATA[ 如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [MISRA2004-16_7_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [MISRA2004-16_7_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if a parameter in a function prototype is declared
as typedef to pointer to non-const object and the pointer is not used to modify
the addressed object. Then the type of parameter could be changed to typedef
to pointer to const object.
参见: CODSTA-14, CODSTA-CPP-43, CODSTA-CPP-53, MISRA-104



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

It is not sufficient to add 'const' identifier before typedef's
name in a function declaration, because it is applied to pointer
not to pointed object.
There can already be overloaded function with parameter declared as typedef
to pointer to const. Then changing the type of parameter to typedef to pointer
to const will make the code non-compilable.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents unintentional change of data and improves precision in the
definition of the function interface.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* PINT;
typedef const int* CINT;

int function1(PINT ptr)        // 违规
{
    return (*ptr) + 1;
}

int function2(const PINT ptr)  // 违规
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int* PINT;
typedef const int* CINT;

int function1(CINT ptr)        // OK
{
    return (*ptr) + 1;
}

int function2(const CINT ptr)  // OK
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 3

2. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 16

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Function, AV Rule 118

4. Origin: Misra Guidelines - Rule 81

5. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 7, Rule 7-1-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-16_8</key>
<configkey>MISRA2004-16_8</configkey>
<name><![CDATA[ 非 void 函数中每一个 return 语句必须有返回值 [MISRA2004-16_8] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非 void 函数中每一个 return 语句必须有返回值 [MISRA2004-16_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对于返回值是非空类型的函数，它的所有退出
路径都应该有一个表达式明确地给出返回值。
缺了这个表达式，将会导致未定义的行为
（并且编译器可能不能指出这个错误）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

"goto" 语句被认为是一个退出点。
该规则不跟踪数据流。它假定在条件语句中
每条路径应该根据条件可独立访问的。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则阻止了不可预测的函数行为。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

此规则将跳出"while", "for", 和"catch"语句段。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1(int x){ // 违规 
                 //在第二重if语句，没有返回
    if (x==0) {
        if (x==0) {
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // 违规 
                 // 在switch语句中，没有default语句的返回值
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
    }
}

int foo3(int x){ // 违规 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1(int x){ // OK
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // OK
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
        default: return 1;
    }
}

int foo3(int x){ // OK
    return 0;
}

int foo4(int x){ // OK
    if (x==0) {
        return 0;
    }
    return 0;
}

int foo5(int x){ // Ok
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        switch(x){
            case 0: return 1;
            case 1: return 1;
            case 2: return 1;
            default: return 1;
        }
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.13章函数，AV 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第8部分，第8-4-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_1</key>
<configkey>MISRA2004-17_1</configkey>
<name><![CDATA[ 不要对那些没有指向数组或数组元素地址的指针进行指针运算 [MISRA2004-17_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要对那些没有指向数组或数组元素地址的指针进行指针运算 [MISRA2004-17_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Pointer arithmetic shall only be applied to pointers that address an array or 
array element.
Addition and subtraction of integers (including increment and decrement) from 
pointers that do not point to an array or array element results in undefined 
behaviour."
The rule reports a violation when both following conditions are met:
- variable of pointer type is used as operand in arithmetic
  expression (addition, subtraction, incrementation, decrementing)
- the variable was not assigned at all in current function or 
  last assignment before the arithmetic expression was not from an "array expression"
An "array expression" is an expression or variable which
- has array type (e.g. int[]), or 
- expression which takes address of array or array element, or
- was previusly assigned an "array expression"
参见: PB-51



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

Limitation of rule:
- complex expressions might be incorrectly recognized as "array expression" if
  it contains expression with array type. In result a valid violation might 
  not be reported.
- control flow ('if' etc) is not taken into consideration, only line number, 
  when checking for last assignment
- violations on members (a-&gt;b, a.b) are not reported.
- recursive check of "array expression" is limited to 10 levels



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule makes the code more readable and less confusing.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* example of incorrect code */
void func(int* ptr1, int a[5]){
    int i;
    int* ptr2 = 0;
    int* ptr3 = &amp;i;

    ptr1++;          /* 违规 - ptr1 may points to whatever*/
    ptr1 = ptr2 + 1; /* 违规 - ptr2 is a null pointer */
    ptr3++;          /* 违规 - ptr3 points to variable of non-array type*/   
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* example of correct code */
void func(int* ptr3, int a[5]){
    int* ptr1 = &amp;a;
    int* ptr2 = &amp;a[3];

    ptr1++;          /* OK - ptr1 points to an array */
    ptr3 = ptr2 + 1; /* OK - ptr2 points to an array element */
    ptr3++;          /* OK - ptr3 points to an array element */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 Guidelines for the use of the C language in critical systems
Chapter 6, Section 17

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_2</key>
<configkey>MISRA2004-17_2</configkey>
<name><![CDATA[ 只有指向数组或数组元素地址的指针才能进行指针运算 [MISRA2004-17_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只有指向数组或数组元素地址的指针才能进行指针运算 [MISRA2004-17_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果两个指针指向或者至少看起来指向相同的数组
对象，指针减法仅适用于结果清晰可辨的对象。
缺点：在比较复杂的代码中，如果对指向数组或者数组
元素的指针使用指针计算，此规则可能不能工作。
在这样的情况下，此规则可能会报道假错误。
例如：
void foo( ) { 
    int a[10], i;
    int* p1,* p2,* p3,* p4,* p5; 

    p1 = a; i = p1 - a;    // OK
    p2 = p1;i = p2 - a;    // OK
    p3 = p2;i = p3 - a;    // OK
    p4 = p3;i = p4 - a;    // 违规 - 假错误
    p5 = p4;i = p5 - a;    // 违规 - 假错误
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则使得代码具有更好的可读性、更少的困惑。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a[] ) {
    int* p1 = 0;
    int* p2;
    int* p3 = a;
    int i;

    i = p1 - p2;   // 违规
    i = p2 - a;    // 违规
    i = p3 - a;    // OK
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要对指向不同数组元素的指针使用指针减法。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-17条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_3</key>
<configkey>MISRA2004-17_3</configkey>
<name><![CDATA[ 仅当指针指向同一个数组时才能使用 >, >=, <, <= [MISRA2004-17_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
仅当指针指向同一个数组时才能使用 &gt;, &gt;=, &lt;, &lt;= [MISRA2004-17_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

试图在指针之间做比较操作将会产生未定义的行为。


例外：

两个操作数都是相同类型并且指向同一数组。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对数组末尾的下一个元素的寻址是允许的，
但是访问这个元素是不允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此规则使得代码具有更高的可靠性，给人更少的困惑。”



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

在比较复杂的代码中，对指向同一数组的指针
使用比较操作，此规则可能不能正常工作。
因为在这样的情况下，此规则可能报告假错误。
例如：
void foo( ) {
    int a[10], i;
    int* p1,* p2,* p3,* p4,* p5;

    p1 = a; i = p1 &lt; a;    // 正常
    p2 = p1;i = p2 &lt; a;    // 正常
    p3 = p2;i = p3 &lt; a;    // 正常
    p4 = p3;i = p4 &lt; a;    // 违规 - 假错误
    p5 = p4;i = p5 &lt; a;    // 违规 - 假错误
}



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a[] ) {
    int* p1 = 0;
    int* p2;
    int* p3 = a;
    int i;

    i = p1 &lt; p2;   // 违规
    i = p2 &lt; a;    // 违规
    i = p3 &lt; a;    // 正常
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能对指向不同数组元素的指针做指针比较操作。




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第17部分

2. 来源: Misra 指南 - 第103条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.22章指针与引用, AV第171条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-18条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_4</key>
<configkey>MISRA2004-17_4</configkey>
<name><![CDATA[ 只有数组索引才能进行算术指针操作 [MISRA2004-17_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只有数组索引才能进行算术指针操作 [MISRA2004-17_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“数组下标索引是进行指针算术运算的唯一
可接受的方式，因为它更加清楚并且也比指针
操作更易于避免错误。此规则禁止了显式的
指针值的计算。数组下标索引应该只适用于
定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。”


缺点:

在比较复杂的代码中，如果有索引化的
指向数组的指针，此规则可能不能正常检查。
在这种情况下，此规则将会报告假错误。
例如:
void foo( ) {
    int a[10];
    int* p1,* p2,* p3,* p4,* p5;

    p1 = a;  p1[0] = 0;  // 正常
    p2 = p1; p2[0] = 0;  // 正常
    p3 = p2; p3[0] = 0;  // 正常
    p4 = p3; p4[0] = 0;  // 违规 - 假错误
    p5 = p4; p5[0] = 0;  // 违规 - 假错误
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void my_fn(int * p1, int p2[]) {
    int index = 0;
    int * p3;
    int * p4;
    *p1 = 0;

    p1 ++;        /* 违规 - 指针递增*/
    p1 = p1 + 5;  /* 违规 - 指针增加*/
    p1[5] = 0;    /* 违规 - p1不是以数组格式来声明的*/
    p3 = &amp;p1[5];  /* 违规 - p1不是以数组格式来声明的 */
    p2[0] = 0;
    index ++;
    index = index + 5;
    p2[index] = 0; /* OK */
    p4 = &amp;p2[5];   /* OK */
}

void foo() {
    int a1[16];
    int a2[16];
    int a[10];
    int * p;

    my_fn(a1, a2);
    my_fn(&amp;a1[4], &amp;a2[4]);
    p = a;
    *(p+5) = 0; /* 违规 */
    p[5] = 0;   /* OK */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要对没有指向数组的指针做递增或者递减操作。
不要对没有指向数组元素的指针使用数组索引操作。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
  第6章，第5部分，第5-0-15条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_5_a</key>
<configkey>MISRA2004-17_5_a</configkey>
<name><![CDATA[ 对象的声明中最多包含 2 级指针 [MISRA2004-17_5_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明中最多包含 2 级指针 [MISRA2004-17_5_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int * INTPTR;
struct s {
    int *** s3;                  /* 违规 */
};

struct s *** ps3;                /* 违规 */
int ** (***pfunc3)();            /* 违规 */
int *** ( **pfunc4)();           /* 违规 */
void function( int * par1,
    int *** par3,                /* 违规 */
    INTPTR * const * const par5  /* 违规 */
    )              
{
    int *** ptr3;                /* 违规 */
    INTPTR * const * const ptr5 = 0; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明超过两级的间接指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第170条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

4. 来源： Misra 指南 - 第102条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_5_b</key>
<configkey>MISRA2004-17_5_b</configkey>
<name><![CDATA[ 对象的声明中最多包含 2 级指针 [MISRA2004-17_5_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明中最多包含 2 级指针 [MISRA2004-17_5_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* apInt[] ;
apInt* rule12;         /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明操过两级的间接指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第170条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

4. 来源： Misra 指南 - 第102条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_5_c</key>
<configkey>MISRA2004-17_5_c</configkey>
<name><![CDATA[ 对象的声明中最多包含 2 级指针 [MISRA2004-17_5_c] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明中最多包含 2 级指针 [MISRA2004-17_5_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int*** (*rule13)();    /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明操过两级的间接指针。  



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

3. 来源： Misra 指南 - 第102条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_5_d</key>
<configkey>MISRA2004-17_5_d</configkey>
<name><![CDATA[ 对象的声明中最多包含 2 级指针 [MISRA2004-17_5_d] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明中最多包含 2 级指针 [MISRA2004-17_5_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* INTPTR;
void function(int ** par7[])    /* 违规 */
{
}
int*** (*xx5[])() = {0};        /* 违规 */
typedef int INTARR[];
INTARR* (**xx9[])() = {0};      /* 违规 */
int** rule21[] = {0};           /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明操过两级的间接指针。  



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

3. 来源： Misra 指南 - 第102条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-17_6</key>
<configkey>MISRA2004-17_6</configkey>
<name><![CDATA[ 带有自动存储空间的对象地址不能被分配给另一个对象，该对象销毁后，另一个对象仍然存在，但指针成为野指针 [MISRA2004-17_6] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
带有自动存储空间的对象地址不能被分配给另一个对象，该对象销毁后，另一个对象仍然存在，但指针成为野指针 [MISRA2004-17_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个局部变量的地址被赋值给另外一个大范围的
局部变量，或者一个静态变量，或者从一个函数中返回，
然后包含这个地址的变量的生存周期可能超过最初变量的
生存周期（它的地址变得无效）。
例如:
int * foo( void ) {
    int local_auto;
    return (&amp;local_auto);
}”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止数据的丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* global;
int* foo() {
    int iLocal;
    static int* siLocal;

    siLocal = &amp;iLocal;       // 违规
    global = &amp;iLocal;        // 违规
    return &amp;iLocal;          // 违规
}
void goo() {
    int* piLocal;
    {
        int iiLocal;
        piLocal = &amp;iiLocal;  // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要将局部变量的地址赋值给全局变量、静态变量或者函数的返回值。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第17部分

2. 来源: Misra 指南 - 第106条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第173条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-5-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-18_1</key>
<configkey>MISRA2004-18_1</configkey>
<name><![CDATA[ 在转换单元结束之前，所有的结构体和联合体必须有完整的声明 [MISRA2004-18_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在转换单元结束之前，所有的结构体和联合体必须有完整的声明 [MISRA2004-18_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一个结构体或者联合体的完整的声明都应该包含它们的
翻译单元，以便从结构体中读数据或者写到结构体里面去。
一个指向不完整类型的指针本身是完整的，并且也是允许的。
因此，使用不透明的指针是允许的。可以参考指向完整类型
的指针。对于不透明指针这种方式也是允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了为定义的行为并且提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

extern struct st *pst1;
extern struct st *pst2;

void mc2_1801 ( void )
{
//   struct st1 s;       /* 违规 - 不能被编译器编译 */

   struct {
      int a;
      int b [ ];        /* 违规 */
   } mc2_1801_st = { 1, { 2, 3, 4 } };

   pst2 = pst1;         /* OK - 使用不透明的指针 */

//   *pst2 = *pst1;       /* 违规 - 不能被编译器编译  */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct st{
    int stm;
};

struct st1{
    int st1m;
};

extern struct st *pst1;
extern struct st *pst2;

void mc2_1801 ( void )
{
   struct st1 s;       /* OK */

   struct {
      int a;
      int b [3];        /* OK */
   } mc2_1801_st = { 1, { 2, 3, 4 } };

   pst2 = pst1;         /* OK  - 使用不透明的指针 */

   *pst2 = *pst1;       /* OK  */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第6章，第18部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-18_2</key>
<configkey>MISRA2004-18_2</configkey>
<name><![CDATA[ 不应该将结构体自身的一个成员变量赋给另一个成员变量 [MISRA2004-18_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应该将结构体自身的一个成员变量赋给另一个成员变量 [MISRA2004-18_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当两个对象创建的时候在内存中有一段重叠区域，
并且一个正向另一个拷贝时，后果是未知的。
此规则检测是否存在同一联合体的不同成员使用
相同的对象赋值给另一方。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未定义的行为和数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

void main( ) {
    union U a, b;
    union U p;

    a.dValue  = a.lValue;     违规 
    p-dValue = p-iValue;    违规 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

void main( ) {
    union U a, b;
    union U p, q;
    a.dValue  = b.lValue;      /* OK */ 
    p-dValue = q-iValue;       /* OK */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C2004 C语言在关键系统中的使用指南
第6章，第18部分

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-18_2_b</key>
<configkey>MISRA2004-18_2_b</configkey>
<name><![CDATA[ 结构体的每个成员不应该赋值给自己的其他成员变量 [MISRA2004-18_2_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构体的每个成员不应该赋值给自己的其他成员变量 [MISRA2004-18_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当两个对象创建的时候在内存中有一段重叠区域，
并且一个正向另一个拷贝时，后果是未知的。
此规则检测是否存在同一联合体的不同成员
使用相同的对象赋值给另一方。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未定义的行为和数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string.h&gt;
union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

int main( ) {
    union U a, b;
    union U *p;

    (void)memcpy( &amp;a.dValue,  &amp;a.lValue, 8 );    /* 违规 */
    (void)memcpy( &amp;p-&gt;dValue, &amp;p-&gt;iValue, 8 );   /* 违规 */
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string.h&gt;
union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

int main( ) {
    union U a, b;
    union U *p, *q;
    (void)memcpy( &amp;a.dValue,  &amp;b.lValue, 8 );     /* OK */
    (void)memcpy( &amp;p-&gt;dValue, &amp;q-&gt;iValue, 8 );    /* OK */
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第18部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第0部分，第0-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-18_4</key>
<configkey>MISRA2004-18_4</configkey>
<name><![CDATA[ 禁止使用联合体 [MISRA2004-18_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用联合体 [MISRA2004-18_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

即使内存因为某些原因被重新使用，
这种操作还是存在数据可能被误解危险。
因此，这个规则禁止任何原因的结构体类型的使用。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则在每一个共同体声明的时候报告一个违规的消息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未定义的行为和错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

union U {        违规 
    int _i;
    char _buf[ sizeof( int ) ];
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用共同体。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第18部分

2. Herb Sutter, Andrei Alexandrescu, C++编码标准, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   类型安全章节，第97条规则

3. 来源： Misra 指南 - 第109条规则

4. J联合攻击战斗机, 飞行器, C++ 编码标准
   第4.20章 共同体和位域, AV 第153条规则
   
5. MISRA C++2008 C++语言在关键系统中的使用指南，第6章，第9部分，第9-5-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_1</key>
<configkey>MISRA2004-19_1</configkey>
<name><![CDATA[ #include 之前只允许有预处理命令和注释 [MISRA2004-19_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
#include 之前只允许有预处理命令和注释 [MISRA2004-19_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个特别的代码文件中，所有的#include语句
都应该被组织在一起放在靠近文件头的位置。
这个规则表明在一个文件中先于一个#include语句
的只可能是其它的预处理指令或者注释。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

用来在一条#include指令前，阻止可执行代码的位置是重要的。
否则的话，这将会有一种危险：
代码将会试图使用定义在头文件里面的代码项。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo();
int g;
#include "test.h"  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "test.h"  // OK
void foo();
int g;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-1条规则

3. Origin: Misra Guidelines - Rule 87

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_10</key>
<configkey>MISRA2004-19_10</configkey>
<name><![CDATA[ 在函数类型的宏定义中，每个参数的实例应该被括号括起来，除非其作为 # 或 ## 操作符 [MISRA2004-19_10] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数类型的宏定义中，每个参数的实例应该被括号括起来，除非其作为 # 或 ## 操作符 [MISRA2004-19_10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果不使用括号，那么当预处理器替代宏到
代码中时运算符的优先级可能不会如预期结果一样，
在一个类似函数宏的定义中，应该将参数用括号
括起来。"
参见: MISRA-096


例外:

如果宏参数在函数体中的 '.', '-&gt;', '::' 之后或在 '::'之前使用，
那么将不会报告违规， 因为在这种情况下使用的括号
使得代码非可编译。例如:
  #define INIT1(member) a-&gt;member = 0 // 没有报告违规
  #define CALL(ns,fn) ns::fn() // 没有报告违规



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的稳定性并确保操作顺序。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

在某些情况下报告一个违规，但括号的使用导致
编译错误。例如:
  #define MTYPE(type, a)  (type *)(a)  // 报告违规
  #define MT(classtype, type) classtype&lt;type&gt;  // 报告违规



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define abs(x) ((x &gt;= 0) ? x : -x)   // 违规

void foo(int a, int b){
    int z = abs(a - b);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define abs(x) (((x) &gt;= 0) ? (x) : -(x))   // OK

void foo(int a, int b){
    int z = abs(a - b);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 19

2. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 16, Rule 16-0-6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_11</key>
<configkey>MISRA2004-19_11</configkey>
<name><![CDATA[ 除了在 #ifdef 预处理命令、#ifdef 预处理命令和 defined 操作符之外，所有的宏变量在使用前必须定义 [MISRA2004-19_11] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
除了在 #ifdef 预处理命令、#ifdef 预处理命令和 defined 操作符之外，所有的宏变量在使用前必须定义 [MISRA2004-19_11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果想在一段预处理程序中使用一个标识符，
并且那个标识符没有被定义的话，处理器有时候
不会给与任何警告，仅假设它的值为0.
#ifdef, #ifndef 和defined()语句用来就是用来测试宏
的存在，因此不在以上所说情况的范围之内。

缺点：

1)当前来说，该规则的实现假设服从MISRA 2004 19-11(p. 78)
忠告提供的规则。在使用一个标识符之前，最好考虑
使用一个#ifdef测试语句。 

2) 如果#1后面没有跟随代码的话，由于技术上的原因
以下情况我们不能识别：
预处理的标识符在不同的文件中定义，在另一个文件中访问。
同样，我们不可能检测被给与的标识符被定义为编译命令行选项。

3) 如果宏标识符已经在#define预处理程序中定义了，它不能
定义在较多的嵌套的#if  #elif  #else  #endif指令里面。
在这样的情况下，此规则可能报告假错误。 

4)如果宏标识符定义在复杂的条件语句里面（包含一些分支#elif#else），
我们不能确保分支包含的宏定义是否执行了。
在这样的情况下，此规则可能报告假错误。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵从此规则将会是代码更加安全并且阻止一些难以检查的错误发生。




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#if X 
 /*违规 - X 在这里还没有被定义*/
#endif

#if Y
 /*违规 - Y 在这里还没有被定义*/
#endif

#if X + Y
 /*违规 - X 和 Y在这里还没有被定义*/
#endif

#ifdef X
#define Y 1
#else
#define Y 3
#endif

#if Y  2  // 违规 - 参见第3点
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define X 1

#if X
 /*OK*/
#endif

#ifdef Y
#if Y
 /*正常 - 已经在上面的#ifdef中做了检查 */
#endif
#endif

#ifdef X
#define Y 1
#else
#define Y 3
#endif

#ifdef Y
#if Y  2   // 正常 - 可能的工作区，参看第3点
#endif
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. 来源： Misra 指南 - 第97条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_12</key>
<configkey>MISRA2004-19_12</configkey>
<name><![CDATA[ 禁止宏定义中使用多个 # 和 ## [MISRA2004-19_12] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止宏定义中使用多个 # 和 ## [MISRA2004-19_12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有关#和##预处理操作符，赋值的顺序一直有争议。
为了避免这类问题，两个操作符仅仅只有一个
可以出现在单个的宏定义中。
(i.e. 一个#, 或者一个## 或者都没有).



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define TEST1(A,B,C) A # B # C      // 违规 
#define TEST2(A,B,C) A ## B # C      //违规 
#define TEST3(A,B,C) A ## B ## C    // 违规 



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define TESTa(A,B) A # B            // OK
#define TESTb(A,B) A ## B            // OK 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. 来源： Misra 指南 - 第98条规则

3. MISRA C++2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-3-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_13</key>
<configkey>MISRA2004-19_13</configkey>
<name><![CDATA[ 禁止使用预处理操作符 # 和 ## [MISRA2004-19_13] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用预处理操作符 # 和 ## [MISRA2004-19_13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有关#和##预处理操作符，赋值的顺序一直有争议。
编译器在这些操作符的实现中是不一致的，
因此问了避免这些问题不要使用他们。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来阻止 # 和 ##操作符的不一致的实现。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define stringer( x ) printf( #x "\n" ) /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用# 和 ## 预处理操作符。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-3-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_14</key>
<configkey>MISRA2004-19_14</configkey>
<name><![CDATA[ 预处理操作符只能用在两种标准格式之一 [MISRA2004-19_14] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
预处理操作符只能用在两种标准格式之一 [MISRA2004-19_14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

两种仅有的可允许的预处理操作符的定义的形式：
  - defined ( identifier )
  - defined identifier
  其它的形式将会导致未定义的行为。
在一个#if 或者 #elif预处理指令中，产生一个
定义代号同样也会导致未定义的行为，应该避免。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未知的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#if defined X &gt; Y             // 违规
#endif
#define DEFINED defined  
#if DEFINED(X)              // 违规  
#endif


改正:

#if defined X            // OK
#endif
#if defined (X)          // OK
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_15</key>
<configkey>MISRA2004-19_15</configkey>
<name><![CDATA[ 必须采取预防措施以防止头文件的内容被引用两次 [MISRA2004-19_15] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
必须采取预防措施以防止头文件的内容被引用两次 [MISRA2004-19_15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"When a translation unit contains a complex hierarchy of nested header files
it can happen that a particular header file is included more than once.
This can be, at best, a source of confusion. If it leads to multiple or 
conflicting definitions, the result can be undefined or erroneous behaviour."
Rule checks if any of described below mechanisms preventing the file contents 
from being included more than once is present.

#ifndef AHDR_H
#define AHDR_H
/* The following lines will be excluded by the
preprocessor if the file is included more
than once */
...
#endif

Alternatively, the following may be used:

#ifdef AHDR_H
#error Header file is already included
#else
#define AHDR_H
/* The following lines will be excluded by the
preprocessor if the file is included more
than once */
...
#endif

参见: PFO-02, PFO-07, and PFO-08.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents undefined and erroneous behaviour.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* foo.h */
/* Violation - file contains no multi inclusion mechanism */

/* foo.hh */
/* Violation - file contains no multi inclusion mechanism */

/* foo.c */
#include "foo.h"
#include "foo.hh"



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* foo.h */
/* OK */
#ifndef FOO_H
#define FOO_H
/* code here */
#endif

/* foo.hh */
/* OK */
#ifdef FOO_HH
#error Header file is already included
#else
#define FOO_HH
#endif

/* foo.c */
#include "foo.h"
#include "foo.hh"



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 Guidelines for the use of the C language in critical systems
Chapter 6, Section 19

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_16</key>
<configkey>MISRA2004-19_16</configkey>
<name><![CDATA[ 预处理指令即使被预处理器排除也必须有语法意义 [MISRA2004-19_16] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
预处理指令即使被预处理器排除也必须有语法意义 [MISRA2004-19_16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当一段源代码被预处理指令排除在外的时候，
每一个排除在外的语句的内容都会被忽略，直到遇到
一个#else, #elif 或者 #endif 指令（由上下文决定）。
如果这些排除在外的指令组织得不好的话，编译器将会
不带警告地忽略掉，这可能带来不幸的后果。
此规则要求，即使是排除在外的代码，所有的预处理指令
应在语句构成上是合法的。编译器在实施这项 ISO 要求上，
不会总是一致的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了错误的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MAX 2

int foo(void)
{
	int x = 0;
	
#ifndef MAX
	x = 1;
#else1              /* 违规 */
	x = MAX;
#endif
	return x;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MAX 2

int foo(void)
{
	int x = 0;
	
#ifndef MAX
	x = 1;
#else              /* OK */
	x = MAX;
#endif
	return x;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-8条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_17</key>
<configkey>MISRA2004-19_17</configkey>
<name><![CDATA[ 在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令 [MISRA2004-19_17] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令 [MISRA2004-19_17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当语句块的包含和不包含由一系列预处理指令控制时，
如果所有相关的指令不在一个文件里面的话，
可能会引起混淆。此规则要求预处理指令 #if/ifdef/ifndef 的
个数必须与文件中 #endi f的个数相匹配。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提升了良好的代码结构，阻止了一些问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 违规 */
#define A
#ifdef A
#include "file1.h"
#endif
#if 1
#include "file2.h"



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* OK*/
#define A
#ifdef A
#include "file1.h"
#endif
#if 1
#include "file2.h"
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
    第6章，第16部分，第16-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_2</key>
<configkey>MISRA2004-19_2</configkey>
<name><![CDATA[ 非标准字符不应该用于 #include 指令的头文件名称中 [MISRA2004-19_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非标准字符不应该用于 #include 指令的头文件名称中 [MISRA2004-19_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个头文件名预处理记号中，如果', \, "
或者 /*字符在&lt; 和 &gt;分隔符中使用，或者', \, 
或者 /*在"分隔符中使用，那么后果是未知的。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

确保仅仅只有标准的字符才在头文件名字中出现。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;sys\types.h&gt;     /* 违规 */
#include "incl\header.h"   /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;sys/types.h&gt;     /* 正常 */
#include "incl/header.h"   /* 正常 */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第19部分

2. 来源: Misra 指南 - 第88条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_4</key>
<configkey>MISRA2004-19_4</configkey>
<name><![CDATA[ 避免宏定义中存在关键字和基本类型 [MISRA2004-19_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免宏定义中存在关键字和基本类型 [MISRA2004-19_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

C 语言宏应该仅仅扩展到一个使用括号初始化的语句，
一个常量，一串字符，一个插入语，一种类型的修饰，
一种存储类别的指定，或者一个do-while-0的结构。
这些是仅允许的宏的使用。在特别的宏里，
不应该使用它来定义语句或者除了使用do-while结构部分语句。
宏也不会重定义语言的句法规则。在宏替换列表中，
无论哪种括号类型( ) { } [ ]，括号应该匹配。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

存储类别的说明和类型修饰包含这样的关键字：
typedef, extern, static, auto, register, const, volatile, restrict.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止语言句法规则的重定义。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PI 3.14159F      /* 正常 */
#define DOUBLE_PI  2*PI  /* 违规 */
#define int64_t    long  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define PI 3.14159F       /* 正常 */
#define DOUBLE_PI (2*PI)  /* 正常 */
typedef long int64_t;     /* 正常 */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2.来源: Misra 指南 - 第90条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_5</key>
<configkey>MISRA2004-19_5</configkey>
<name><![CDATA[ 禁止在块中使用 #define 或 #undef [MISRA2004-19_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在块中使用 #define 或 #undef [MISRA2004-19_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

尽管在一个代码文件的任何地方放置 #define 或者
#undef 是合法的，但是把他们放在程序块中是一个误导，
因为这样意味着给那段程序块一个范围限制，
但是本意却不是那样的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int* x ) {
#define CHECKPARAM(p) (p != 0)  // 违规
    if (CHECKPARAM(x)) {
	/* ... */
    }
#undef CHECKPARAM               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define CHECKPARAM(p) (p != 0) // OK- 宏在任何块的外面定义
void foo( int* x ) {
    if (CHECKPARAM(x)) {
        /* ... */
    }
}
#undef CHECKPARAM              // OK- 宏在任何块的外面撤销定义



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6,章 第19部分

2. 来源: Misra指南-第91条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_6</key>
<configkey>MISRA2004-19_6</configkey>
<name><![CDATA[ 禁止使用 #undef [MISRA2004-19_6] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 #undef [MISRA2004-19_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#undef通常都是不需要的。它的使用可能
导致混淆或者在代码中使用的时候意味着宏操作。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#undef TEST        /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 #undef.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. 来源: Misra指南- 第92条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
    第6章，第16部分，第16-0-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_7</key>
<configkey>MISRA2004-19_7</configkey>
<name><![CDATA[ 函数应该优先于类似函数宏的使用 [MISRA2004-19_7] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数应该优先于类似函数宏的使用 [MISRA2004-19_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则在一个类似函数的定义中报告一个违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

尽管宏与函数相比，可以提供一种速度上的优势，
但是函数提供了一种更安全和更稳健的机制。
这对于参数的类型检查是非常适用的，并且在
像函数一样宏里面对潜在地多次估计参数值的
问题的解决也是非常适用的。


同样可参见: CODSTA-03, CODSTA-37, CODSTA-38, CODSTA-39, CODSTA-40



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define SUM(A,B) ((A)+(B))  /* 违规 */

void foo( int x, int y ) {
    /* ... */
    SUM( x, y );
    /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int sum( int a, int b ) {    /* OK*/
    return (a + b);
}

void foo( int x, int y ) {
    /* ... */
    sum( x, y );
    /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. Scott Meyers, "Effective C++: 55中特殊方法提高您的程序设计 Sp", 第三版, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章, 第2项

3. Misra 指南- 第93条规则

4. Ellemtel 编码标准 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 9 函数 - 9.5 联机函数 - 第35条规则

5. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.6章 预处理指令, AV 第29条规则	

6. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第16部分，第16-0-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_8</key>
<configkey>MISRA2004-19_8</configkey>
<name><![CDATA[ 类似函数宏调用时，参数个数必须一致 [MISRA2004-19_8] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类似函数宏调用时，参数个数必须一致 [MISRA2004-19_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这是一个强制错误，但是预处理程序已经
知道忽视这个问题。在类似函数的宏里面，
每一个参数必须由至少一个预处理的记号组成，
否则行为是未定义的。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来阻止未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MAX(a, b, c)    ((a &lt; b) ? b : a)

void foo(int a, int b)
{
    int c;
    c = MAX(a, b);   /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MAX(a, b, c)    ((a &lt; b) ? b : a)

void foo(int a, int b)
{
    int c;
    c = MAX(a, b, 0); /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. 来源： Misra 指南 -第94条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-19_9</key>
<configkey>MISRA2004-19_9</configkey>
<name><![CDATA[ 类似函数的宏的参数不应该包含类似预处理命令的标识 [MISRA2004-19_9] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类似函数的宏的参数不应该包含类似预处理命令的标识 [MISRA2004-19_9-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果任何参数看起来像预处理指令，
那么当宏置换发生时，后果是不可预测的。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则仅在一个文件范围内有效。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵从此规则，将会拥有更安全的代码和更好的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MACRO1(x)
#define MACRO2(x, y)

void foo( void ) {
    int i = 0;
    MACRO1( #foo );       /* 违规 */
    MACRO2( i, #foo );    /* 违规 */
    MACRO2( i, "#foo" );  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MACRO1(x) 
#define MACRO2(x, y) 

void foo( void ) {
    int i = 0;
    MACRO1( i );          /* OK */
    MACRO2( i, i );       /* OK  */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第19部分

2. 来源: Misra 指南 - Rule 95

3. MISRA C++:2008 C++语言在关键系统中的使用指南
  第6章，第16部分，第16-0-5条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_10</key>
<configkey>MISRA2004-20_10</configkey>
<name><![CDATA[ 禁止使用 stdlib.h 中的库函数 atof, atoi 和 atol [MISRA2004-20_10] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 stdlib.h 中的库函数 atof, atoi 和 atol [MISRA2004-20_10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

来自库&lt;stdlib.h&gt;中的函数 'atof', 'atoi' 和'atol' ，
当字符串不能通过它们来转换的时候，没有确定的行为。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用那些含有没有定义行为的函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
void foo( void ) {
    char *s; double x; int i; long l;
    s = "  -2309.12E-15";    
    x = atof( s );           /* 违规 */
    s = "  -9885 pigs";      
    i = atoi( s );           /* 违规*/
    s = "98854 dollars";     
    l = atol( s );           /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用atof, atoi 和atol 这些函数.


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第20部分

2. 来源: Misra 指南 - 第125条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5章库, AV 第23条规则

4. MISRA C++:2008 C语言在关键系统中的使用指南,第6章，第18部分，第18-0-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_11</key>
<configkey>MISRA2004-20_11</configkey>
<name><![CDATA[ 禁止使用 stdlib.h 中的库函数 abort, exit, getenv 和 system [MISRA2004-20_11] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 stdlib.h 中的库函数 abort, exit, getenv 和 system [MISRA2004-20_11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许使用来自库stdlib.h，cstdlib或者库stdlib_iso.h
中的 'abort', 'exit', 'getenv' 和 'system' 函数.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用那些没有在嵌入式系统需要的函数



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include  &lt;stdlib.h&gt;
void foo( void ) {
    char *libvar;
    libvar = getenv( "LIB" );  /* 违规 */
    system( "dir" );           /* 违规 */
    abort( );                  /* 违规 */
    exit( 0 );                /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用abort, exit, getenv 和系统函数.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. 来源: Misra 指南 - 第126条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5 章库，, AV 第24条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-0-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_12</key>
<configkey>MISRA2004-20_12</configkey>
<name><![CDATA[ 禁止使用库文件 time.h 中的时间处理库函数 [MISRA2004-20_12] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用库文件 time.h 中的时间处理库函数 [MISRA2004-20_12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这个库和时钟时间关联。各个方面和执行程序
相关或者不确定，比如时间的格式”。
规则防止列入 &lt;time.h&gt; and &lt;ctime&gt; 头文件。
参见: SECURITY-01



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止不确定行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;time.h&gt;  /* 违规*/



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用time.h 头文件.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. 来源: Misra 指南 - 第127条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5 章库，, AV 第25条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第18章，第7部分，第18-0-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_1_a</key>
<configkey>MISRA2004-20_1_a</configkey>
<name><![CDATA[ 在标准库中的保留字、宏和函数不应该被定义、重定义或取消定义 [MISRA2004-20_1_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在标准库中的保留字、宏和函数不应该被定义、重定义或取消定义 [MISRA2004-20_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ #undef 一个来自在标准库定义的宏通常是一种错误的习惯。
同样， #define一个C保留字符或者标准库中的任何一个宏、
对象或者函数的C关键字的宏名，也是一种错误的习惯。
例如, 有一些特殊的保留字个函数名，如果它们被重新定义
或者没有定义，他们被用来指定一些未定义的行为，包括
定义 _ _LINE_ _, _ _FILE_ _, _ _DATE_ _, _ _TIME_ _, 
_ _STDC_ _, errno and assert。一般来说， 所有的标识
符开头的下划线字符保留。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则防止未定义行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define __A 1	    // 违规
#define assert 1   // 违规
#undef __AA         //违规
#undef assert       // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要 #define 和 #undef 保留字符



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第20部分

2. 来源: Misra 指南 - 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
  第6章，第17部分，第17-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_1_b</key>
<configkey>MISRA2004-20_1_b</configkey>
<name><![CDATA[ 不要重新定义保留字 [MISRA2004-20_1_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要重新定义保留字 [MISRA2004-20_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“#undef 或者#define C保留字是不正确的。”


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

从定义保留字将带来错误和混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define break 1     // 违规
#define continue 1  // 违规
#undef while        // 违规
#undef return       // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要#define or #undef 跟保留字



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第20部分

2. 来源: Misra 指南 - 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南,第6章，第17部分，第17-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_2</key>
<configkey>MISRA2004-20_2</configkey>
<name><![CDATA[ 标准库宏、对象和函数名不应该被重用 [MISRA2004-20_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标准库宏、对象和函数名不应该被重用 [MISRA2004-20_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"程序员使用新版本的标准库的宏、对象或者函数
的地方(例如 增强功能或者检查输入值)，这些
修改过的宏、对象或者函数需要有一个新的命名。
这样做是为了避免这样的混淆：是标准宏、
对象或者函数正在被调用，还是修改过的正在
被调用。因此，比如，新版本的开平方根函数
被写入用来检查输入是否为负值，那么这个函数
不能被命名为'sqrt'，而是需要给定一个新的名字。"
本规则检查下面的保留名字是否被使用：
-来自C标准库头文件的宏、函数、和typedef名称：assert.h,
  complex.h, ctype.h, errno.h, float.h, iso646.h, limits.h, locale.h, math.h,
  setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h, string.h, time.h,
  wchar.h, wctype.h, stdint.h, inttypes.h, fenv.h, stdbool.h, tgmath.h
- 以下划线字符开头的标示符
另见: NAMING-33, CODSTA-92, CODSTA-93



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可预防未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int memset();    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int my_memset(); // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章， 第 20 节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_3</key>
<configkey>MISRA2004-20_3</configkey>
<name><![CDATA[ 调用库函数之前，应该检查参数的合法性 [MISRA2004-20_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
调用库函数之前，应该检查参数的合法性 [MISRA2004-20_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“许多标准C库中的函数没有要求通过 ISO 标准检测
参数是否有效就传递给它们。即使那里要求需要通过
标准检测，或者通过编译器的编写者声明了检查参数。
不能保证进行了充分的检查，所以程序员需要为所有
库函数提供适当的数值检查这一规则的执行情况，将会
在库函数调用，之前看看它的参数是在条件语句的条件，
或传递给任何函数使用。这种使用将被视为参数验证
必要遵守这一规则。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止书写容易出错的代码


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void* memcpy( void *, void*, int n );

void test( void *v ) {}

int getSomeIntValue( ) {
    return 0;
}

void foo( void *p, void *q ) {
    int n;
    memcpy( p, q, n );    /* 违规 - complain about p, q and n */ 
    test( q );            /* consider it a validation of q */
    memcpy( p, q, n );    /* 违规- complain about p, and n */ 
    switch( n ) {         /* consider it a validation of n */
    case 0:
        break;
    }
    if (p == 0) {}        /* consider it a validation of p */
    memcpy( p, q, getSomeIntValue( ) );  /* 违规 - complain only about getSomeIntValue call */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void* memcpy( void *, void*, int n );

void test( void *v ) {}

int getSomeIntValue( ) {
    return 0;
}

void foo( void *p, void *q ) {
    int n;
    test( p );            /* consider it a validation of p */
    test( q );            /* consider it a validation of q */
    if (n != 0) {
        memcpy( p, q, n );    /* OK */ 
        memcpy( p, q, n );    /* OK */ 
    }
    switch( n ) {         /* consider it a validation of n */
    case 0:
        break;
    }
    if (p == 0) {}        /* consider it a validation of p */
    n = getSomeIntValue( );
    if (n != 0) {
        memcpy( p, q, n );    /* OK */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. 来源: Misra 指南- 第117条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_4</key>
<configkey>MISRA2004-20_4</configkey>
<name><![CDATA[ 禁止使用动态内存分配 [MISRA2004-20_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用动态内存分配 [MISRA2004-20_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“动态内存的使用可能导致存储溢实时失败，
这是不可取的。内置新建和删除操作，除指定版本，
使用动态堆内存。函数 calloc,malloc, realloc 和
free 使用动态对内存。 ”


例外:

该规则允许使用一个新的位置



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“有一些没有指定，为定义的和实现定义的行为
动态内存分配有关联，当然也存在缺陷。
动态堆内存泄露，数据不一致，分配导致内存，
内存耗尽，或一些非确定行为。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
  int * p = new int[10]; // 违规
  /* ... */
  
  delete[] p;            // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用，既没有 'new' 和 'delete'操作符，也没有 'calloc', 'malloc',
'realloc' 和free'函数.
 


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. Misra 指南 -第118条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-4-1条规则

4. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.26章 内存应用, AV 第206条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_5</key>
<configkey>MISRA2004-20_5</configkey>
<name><![CDATA[ 禁止使用 errno 错误标识符 [MISRA2004-20_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 errno 错误标识符 [MISRA2004-20_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"errno是才的一部分，理论上是有用的，但是实际上
没有通过标准给予明确的定义的。非零值可能会或
不会表明一个出现了问题，因此它不得使用。即使
是那些该errno的行为明确界定的职能，最好先检查
调用函数，而不是依靠使用errno来捕获错误的投入的价值
如果errno指示符被用，文件含有以下头文件：errno.h, errno, cerrno.
本规则报出一个违规信息



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则防止不确定行为



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;errno.h&gt;

int err_check( ) {
    errno = 1;       /* 违规 */
    return (errno);  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用errno.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第119条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第17条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第19部分，第19-3-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_6</key>
<configkey>MISRA2004-20_6</configkey>
<name><![CDATA[ 禁止使用库文件 stddef.h 中的宏 offsetof [MISRA2004-20_6] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用库文件 stddef.h 中的宏 offsetof [MISRA2004-20_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当操作数类型不兼容或位字段时使用的时候，
使用这个宏可能导致一些难以确定的行为，”
当宏offsetof被使用或者文件中包含以下任何一个头文件：
stddef.h, stddef, or cstddef.
本规则将会报出违规信息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则预防不确定行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规- The macro offsetof shall not be used. Macro is in line: [10]
#include &lt;stddef.h&gt;

struct S {
    int x, y, z;
    char buffer[ 128 ];
};

int main( ) {
    int i = offsetof( struct S, buffer );
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 offsetof.


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第120条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第18条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_7</key>
<configkey>MISRA2004-20_7</configkey>
<name><![CDATA[ 禁止使用 setjmp 宏和 longjmp 函数 [MISRA2004-20_7] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用 setjmp 宏和 longjmp 函数 [MISRA2004-20_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“setjmp 和 longjmp 允许普通的函数调用机制绕过和不能被使用”
当使用函数etjmp or longjmp且文件中出现任何一个头文件: 
setjmp.h, setjmp, or csetjmp，本规则将报出相关违例信息。.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则通过绕过而组织被调用



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;setjmp.h&gt;
jmp_buf mark;              /* Address for long jump to jump to */
int     fperr;             /* Global error number */

void foo( void ) {
    int jmpret;
    jmpret = setjmp( mark );        /* 违规 */
}

void fphandler( int sig, int num ) {
    longjmp( mark, -1 );            /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用宏setjmp 和longjmp函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第122条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第20条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第17部分，第17-0-5条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_8</key>
<configkey>MISRA2004-20_8</configkey>
<name><![CDATA[ 禁止使用库文件 signal.h 中的处理函数 [MISRA2004-20_8] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用库文件 signal.h 中的处理函数 [MISRA2004-20_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“信号处理包含实现定义和不确定的行为。”
如果文件中含有以下任意一个头文件signal.h, or csignal.
本规则将报出违规信息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止在信号处理中出现实现定义和不确定的行为的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;signal.h&gt;  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用&lt;signal.h&gt; 头文件。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第123条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第21条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-7-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-20_9</key>
<configkey>MISRA2004-20_9</configkey>
<name><![CDATA[ 禁止使用库文件 stdio.h 中的输入/输出函数 [MISRA2004-20_9] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用库文件 stdio.h 中的输入/输出函数 [MISRA2004-20_9-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

" I/O流和 I/O文件有相当大的不确定因素，
未定义和实现定义和它们很大的关联。
据推测，他们将不会再嵌入式系统中被使用。
如果 stdio.h中任何一个被用来代码中，
那么与性能相关的问题毫无疑问需要解决的。"
本规则将阻止使用 &lt;stdio.h&gt;, and &lt;cstdio&gt;头文件



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防在使用I/O流和文件带来大量难以确定的问题，
以及I/O流和文件相关的未指定和未执行的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;  /* 违规*/



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用&lt;stdio.h&gt;库。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第124条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第22条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第27部分，第27-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-2_1</key>
<configkey>MISRA2004-2_1</configkey>
<name><![CDATA[ 嵌入汇编程序时嵌入的过程应该是纯汇编程序 [MISRA2004-2_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
嵌入汇编程序时嵌入的过程应该是纯汇编程序 [MISRA2004-2_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果需要汇编语言指令建议把它们用
如下方式封装和隔离(a)汇编语言函数
(b)C语言函数或者(c)宏。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* compilable by cl.exe g++*/
void asmCall( ) {      /* Violation */
    int g = 0;

    #ifdef _MSC_VER
        __asm {
            mov eax, 01h
            int 10h
        }
    #elif __GNUC__
        __asm (
            "mov %eax, 0x01\n\t"
            "int $0x10"
        );
    #endif
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void asmCall( ) {       /* OK */
    #ifdef _MSC_VER
        __asm {
            mov eax, 01h
            int 10h
        }
    #elif __GNUC__
         __asm (
            "mov %eax, 0x01\n\t"
            "int $0x10"
        );
    #endif
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 2 节

2. Misra 使用指南 - 第 3 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南,
   第 6 章，第 7 节， 第7-4-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-2_2</key>
<configkey>MISRA2004-2_2</configkey>
<name><![CDATA[ 源代码只能使用 /* ... */ 来注释 [MISRA2004-2_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
源代码只能使用 /* ... */ 来注释 [MISRA2004-2_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则拒绝使用//这种C99风格和C++风格的注释格式，
因为这种注释格式在C90中试不允许的。
许多编译器支持将//注释格式作为C90的扩展。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

//的使用方法随不同的预处理器指令的不同而各不相同。
另外关于/* ... */和//混用的处理方法也不一致。
这不仅仅是个风格问题，
因为不同的（C99之前版本）编译器可能会采取不同的做法。y.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MAX 100 // Violation: bad comment
// Violation: bad comment
void foo()
{
   int x;   // Violation: bad comment
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MAX 100 /* OK */

/* OK */
void foo()
{
   int x;   /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第 6 章，第 2 节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-2_3</key>
<configkey>MISRA2004-2_3</configkey>
<name><![CDATA[ 禁止使用嵌套注释 /* [MISRA2004-2_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用嵌套注释 /* [MISRA2004-2_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

C语言不支持注释嵌套即使
有些编译器支持它作为一个语言扩展功能。
注释开始于/*直到遇到第一个*/。
任何出现在一个注释内部的/*都是违反这个规则的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C语言不支持注释嵌套因为它容易导致混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* some comment, end comment marker accidentally omitted

&lt;&lt;New Page&gt;&gt;
Perform_Critical_Safety_Function(X);
/* this comment is not compliant - Violation */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* some comment, end comment marker accidentally omitted */

&lt;&lt;New Page&gt;&gt;
Perform_Critical_Safety_Function(X);
/* this comment is compliant - OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 2 节

2. 起源： Misra 指南 - 第 9 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章，第 2 节，第 2-7-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-2_4</key>
<configkey>MISRA2004-2_4</configkey>
<name><![CDATA[ 无法被编译的代码段落不能被“注释掉” [MISRA2004-2_4] ]]></name>
<tag>misra2004</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
无法被编译的代码段落不能被“注释掉” [MISRA2004-2_4-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一段代码要求不能被编译时
就通过使用条件编译来实现（例如使用#if
或者#ifdef结构并附加一段注释）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在某些情况下规则会报告错误肯定或者错误否定。
这种情况是由于源代码和注释文本的相似性而引起的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用注释的开始和结束标识符来达到此目的是危险的
因为C语言不支持注释嵌套，任何已经存在于这段代码
中的注释会改变这种效果。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int x = 5;
    /*  Section of code     // Violation
        commented out
    if (x==0){
        x++;
    }
    */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int x = 5;
/* Comment without          // OK
   code within */
#if 0                       
    if (x==0){
        x++;
    }
#endif
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第 6 章，第 2 节

2. 来源: Misra 使用指南 - 第 10 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.14 章注释， 第 AV 127 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-7-2 条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-7-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-3_4</key>
<configkey>MISRA2004-3_4</configkey>
<name><![CDATA[ 使用 #pragma 语句必须进行说明 [MISRA2004-3_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 #pragma 语句必须进行说明 [MISRA2004-3_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有编译指令的使用都需要文档化并加注释。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#pragma TEST            /* Violation */

/* comment in wrong place */

#pragma TEST            /* Violation */

/* comment in wrong place


*/

#pragma TEST            /* Violation */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// OK
#pragma TEST


/* OK */
#pragma TEST 

/* OK - multiline comment

*/
#pragma TEST



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
  第 6 章，第 3 节

2. 起源： Misra 使用指南 - 第 99 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 16 节，第 16-6-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-3_5</key>
<configkey>MISRA2004-3_5</configkey>
<name><![CDATA[ 不要把位域和其他数据混合在同一个结构体里 [MISRA2004-3_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要把位域和其他数据混合在同一个结构体里 [MISRA2004-3_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

建议结构体应该被明确地定义为只包含
一组特定的位域，不要在该结构体中
包含其他数据。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则可防止潜在的陷阱和一些由实现环境决定
（也就是非可移植）的行为比如：
- 该存数单元里位域的对齐方式是由实现环境决定的，
  也就是说这些位域是从该存储单元的高端开始分配还是从低端
  开始分配（通常是一个字节）
- 一个位域是否可以跨越存储单元的边界也是由实现环境决定的
  （例如一个6比特位域和一个4比特位域被按照此顺序声明，那么该4比特位域
   是从一个新字节开始还是2比特在一个字节而剩下2比特在另一个字节）。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct message {  /* Violation */
    signed int little: 4;
    unsigned int x_set: 1;
    int size;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct message {  /* OK */
    signed int little: 4;
    unsigned int x_set: 1;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第 6 章， 第 3 节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-4_1</key>
<configkey>MISRA2004-4_1</configkey>
<name><![CDATA[ 代码中必须用标准的 ISO C 转义序列 [MISRA2004-4_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
代码中必须用标准的 ISO C 转义序列 [MISRA2004-4_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只有ISO C standard里面定义的那些转义序列
才可以被使用。
ISO C standards的第 5.2.2 节定义了7个可以在源代码中
使用的转义序列：
1. \a (警告)
2. \b (退格)
3. \f (换页)
4. \n (新行)
5. \r (回车)
6. \t (水平制表符)
7. \v (垂直制表符 )



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则使代码可读性更好并且减少混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
void foo( ) {
    printf("ABCD\u1111");     // Violation
    printf("abcd\hgf");       // Violation
    printf("\k");             // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用ISO C standard中没有定义的转义序列。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第 6 章， 第 4 节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-4_2</key>
<configkey>MISRA2004-4_2</configkey>
<name><![CDATA[ 禁止使用三字母词 [MISRA2004-4_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用三字母词 [MISRA2004-4_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则遇到使用三字母词的时候会报告一个违规信息。
所有在源文件里出现的下列三个字符的序列（称为三字母词序列）将被相应的
单个字符替换：
??= #
??( [
??/ \
??) ]
??' ^
??&lt; {
??! |
??&gt; }
??- ~

如果编译器用开关来忽略三字母词时
需要使用该选项，或者能够确保在
代码中绝不使用两个问号相联。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

三字母词能引起与其它使用两个问号相联的情形的意外的混淆
并导致不可预期的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

??=define TEST 1	/* Violation */
void foo() {
    const char * s = "(Date should be in the form ??-??-??)";	           /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define TEST 1	/* OK */
void foo() {
    const char * s = "(Date should be in the form " "??" "-??" "-??" ")";  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 4 节

2. 来源: Misra 指南 - 第 7 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.4 章 环境，第 AV 11 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-3-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_1</key>
<configkey>MISRA2004-5_1</configkey>
<name><![CDATA[ 标识符的长度不能超过 31 个字符 [MISRA2004-5_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标识符的长度不能超过 31 个字符 [MISRA2004-5_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

标识符不允许超过31个字符。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则确保在不同编译器、连接器之间移植代码的时候不需要
修改（缩短）标识符的名字。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void this_is_not_ok_11111111111111111( );   /* Violation */

struct ThisClassHasANameThatIsTooBig11111   /* Violation */
{
    int a;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void this_is_ok_11111111111( );             /* OK */

struct ThisClassHasANameThatIsOK            /* OK */
{
    int a;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 11 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_2_a</key>
<configkey>MISRA2004-5_2_a</configkey>
<name><![CDATA[ 在内部范围的标识符不能和外部的标识符用同样的名字，因为会隐藏那个标识符 [MISRA2004-5_2_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在内部范围的标识符不能和外部的标识符用同样的名字，因为会隐藏那个标识符 [MISRA2004-5_2_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏全局变量和全局参数的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

隐藏全局变量或者全局参数的名字
会导致错误或者混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int x;
void foo( ) {
    int x;     /* Violation */ 
    x = 3;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免使用全局变量和全局参数的名字隐藏。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. ISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_2_b</key>
<configkey>MISRA2004-5_2_b</configkey>
<name><![CDATA[ 在内部范围的标识符不能和外部的标识符用同样的名字，因为会隐藏那个标识符 [MISRA2004-5_2_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在内部范围的标识符不能和外部的标识符用同样的名字，因为会隐藏那个标识符 [MISRA2004-5_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏局部变量的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

局部变量的名字隐藏会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( ) {
    int a;
    {
        int a;    /* Violation */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免隐藏局部变量的名字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_3_a</key>
<configkey>MISRA2004-5_3_a</configkey>
<name><![CDATA[ 不能重用 typedef 名字 [MISRA2004-5_3_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能重用 typedef 名字 [MISRA2004-5_3_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类型定义得到的名字不允许被重用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

重用类型定义得到的名字会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int MyInt;
void foo() 
{
  double MyInt;  /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int MyInt;
void foo() 
{
  double MyVar;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 17 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_3_b</key>
<configkey>MISRA2004-5_3_b</configkey>
<name><![CDATA[ 不能将 typedef 的名字重用在另一个 typedef 名字 [MISRA2004-5_3_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将 typedef 的名字重用在另一个 typedef 名字 [MISRA2004-5_3_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类型定义得到的名字不允许被重用为另一个类型定义的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

重用类型定义得到的名字会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned char uint8_t;

void foo()
{
   typedef signed char uint8_t; /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char uint8_t;

void foo()
{
   typedef signed char int8_t; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 17 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_4_a</key>
<configkey>MISRA2004-5_4_a</configkey>
<name><![CDATA[ 标号的名称在程序中不得重用于其它目的 [MISRA2004-5_4_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标号的名称在程序中不得重用于其它目的 [MISRA2004-5_4_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在一段程序中任何标签的名称都不允许被重用做其它目的。
ISO 9899:1990并没有定义这种行为：一个聚集声明
使用一个不同形式的类型说明符的标签。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

标签的名称的重用会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct stag { int a; };      

void stag(void){}        // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct stag { int a; }; 

void foo(void){}         // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-4 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_4_b</key>
<configkey>MISRA2004-5_4_b</configkey>
<name><![CDATA[ 标号的名称不得被用于定义一个不同的标号 [MISRA2004-5_4_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标号的名称不得被用于定义一个不同的标号 [MISRA2004-5_4_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“任何标签的名称都不允许被重用来定义一个不同的标签。
ISO 9899:1990并没有定义这种行为：一个聚集声明使用一个
不同形式的类型说明符的标签。要么所有的对该标签的使用都
包含在一个结构体类型说明符里，要么都在一个共用体类型说明符里。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

标签的名称的重用会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct stag { int a; int b; };

void foo1()
{
    union stag  { int a; float b; }; // Violation
}

void foo2(void)
{
    struct stag { int a; };          // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct stag { int a; int b; };

void foo1()
{
    union union_tag  { int a; float b; }; // OK
}

void foo2(void)
{
    struct new_stag { int a; };          // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-4 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_5_a</key>
<configkey>MISRA2004-5_5_a</configkey>
<name><![CDATA[ 禁止重用静态对象或函数的标识符 [MISRA2004-5_5_a] ]]></name>
<tag>misra2004</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止重用静态对象或函数的标识符 [MISRA2004-5_5_a-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个程序里静态对象或者函数标识符不能被重用
来做任何其他目的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

静态标识符的重用会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static float a;
static void foo()
{
int a;    /* Violation */  
int foo;  /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在一个程序里将一个静态标识符重用做任何其它目的。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-5 条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_5_b</key>
<configkey>MISRA2004-5_5_b</configkey>
<name><![CDATA[ 禁止重用静态对象或函数的标识符 [MISRA2004-5_5_b] ]]></name>
<tag>misra2004</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止重用静态对象或函数的标识符 [MISRA2004-5_5_b-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

带有静态存储期的对象或者函数标识符必须是唯一的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

标识符名字的重用会导致错误和混淆。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static float a;
static void foo()
{
static int a ;  /* Violation */
static int foo; /* Violation */  
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not use the same names for different static object or functions.
不要给不同的静态对象或者函数起相同的名字。


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-5 条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_6</key>
<configkey>MISRA2004-5_6</configkey>
<name><![CDATA[ 除结构和联合成员名字外，一个命名空间内的标识符不能与另一个命名空间里面的标识符重名 [MISRA2004-5_6] ]]></name>
<tag>misra2004</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
除结构和联合成员名字外，一个命名空间内的标识符不能与另一个命名空间里面的标识符重名 [MISRA2004-5_6-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ISO C 定义了数个不同的命名空间。
从技术上来说在各自的命名空间里使用同一个名字来代表
完全不同的项是可以的。然而这种做法是不允许的原因是
它会带来混淆，因此名字不可以重用，
即使是在不同的命名空间里。”
C语言里有4个命名空间
1. 标签名字
2. 结构体，共用体和枚举类型的关键字
3. 结构体和共用体的成员；每个结构体或者共同体作为一个独立的命名空间
4. 所以其他标识符；例如枚举常量，变量，函数，类型定义



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

输出消息仅仅展示了第一个（行）在其它命名空间里
被重用的名字的位置。


例外：

该规则的一个例外是结构体成员的命名，
不同结构体的成员名字可以重用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef struct MyStruct  // tags name space
{
  int Member;            // members name space
} MyStruct;              // Violation - identifiers name space



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef struct MyStruct  // tags name space
{
  int Member;             // members name space
} MyStructObj;            // OK - identifiers name space



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 12 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-6 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-5_7</key>
<configkey>MISRA2004-5_7</configkey>
<name><![CDATA[ 禁止重用标识符名称 [MISRA2004-5_7] ]]></name>
<tag>misra2004</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止重用标识符名称 [MISRA2004-5_7-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

任何标识符的名字都不能重用。
不管是什么作用域，系统中任何标识符都不可以
跨文件重用。该规则检查是否所有成员的名字都是唯一的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct air_speed
{
int speed;   
} * x;
struct gnd_speed
{
int speed;         /* Violation */
} * y;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要给不同的成员起同一个名字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-6_1</key>
<configkey>MISRA2004-6_1</configkey>
<name><![CDATA[ 简单 char 类型只能用于存储和字符类型 [MISRA2004-6_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
简单 char 类型只能用于存储和字符类型 [MISRA2004-6_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“Char类型只能用来存储和使用
字符型值。
仅有的允许适用于Char类型的操作符是
赋值和等号操作符（=，==，！=）。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则使代码具有更好的可读性和更少的混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char a = 65;     /* Violation */
void foo( ) {
    a = 66;     /* Violation */
    a++;        /* Violation */
    if (a &lt; 67) /* Violation */ 
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char a = 'A';     /* OK */
void foo( ) {
    a = 'B';      /* OK */
    if (a == 'C') /* OK */ 
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 5 节， 第 5-0-11 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-6_2</key>
<configkey>MISRA2004-6_2</configkey>
<name><![CDATA[ signed char 和 unsigned char 类型只能用于存储和数值类型 [MISRA2004-6_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
signed char 和 unsigned char 类型只能用于存储和数值类型 [MISRA2004-6_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有符号和无符号的char类型只能用来存储和使用
数字型值。char类型的符号类型是由实现环境决定的
所以要慎重对待它。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则使代码具有更好的可读性和更少的混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

signed char a = 'A';          /* Violation */
void foo( ) {
    unsigned char a = 'B';    /* Violation */

    if (a == 'C')             /* Violation */
    {
    }
    if (a &lt; 'D')             /* Violation */
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

signed char a = 65;           /* OK */
void foo( ) {
    unsigned char a = 66;     /* OK */
    if (a == 67)              /* OK */
    {
    }
    if (a &lt; 68)               /* OK */
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 5 节， 第 5-0-12 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-6_3</key>
<configkey>MISRA2004-6_3</configkey>
<name><![CDATA[ 用 typedef 定义基本数据类型 [MISRA2004-6_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
用 typedef 定义基本数据类型 [MISRA2004-6_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不应该使用基本的数值类型的有符号和无符号变量,比如char，
int，short，long，和float，double类型，只有特定长度的
类型定义才可以使用。”
如果使用了基本数字值类型（例如signed char）或者类型定义
名称不包括任何数字来指示类型的长度（例如 my_int;）
，该规则会报告一个违规信息。
另见： MISRA-013


例外：

该规则不对下列的情况报告一个违规：
- "main" 函数返回类型
- 外部变量声明
- 普通字符类型，布尔和枚举类型
- 位域类型
- 以 'bool' 作为前缀的typedef自定义类型，或者普通字符的typedef自定义类型
  (即使它不包含任何数字)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“该规则可以帮助阐明存储空间的大小，但是因为整型
提升的不对称行为该规则不保证可移植性。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int my_int; /* 违规 - no digits */
static signed char a;      /* 违规 - not typedef */

short int foo(             /* 违规 (for return type) */
        short* v_short,    /* 违规 */
        float&amp; r_float)    /* 违规 */
{
    double h;              /* 违规 */
    const int z = 1;       /* 违规 */
    return 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Exceptions: */
typedef char char_t;            /* OK (plain char) */
typedef unsigned char BOOL;     /* OK (typedef name starts with 'bool' prefix */
struct STRUCT {
        unsigned int i:2;       /* OK (bit-bield type) */
};
char ch;                        /* OK (plain char) */
bool b;                         /* OK (boolean type) */
enum ENUM { EV };               /* OK (enum type) */
extern signed char a;           /* OK (extern variable) */
int main() { return 0; }        /* OK ("main" return type) */

/* Correct use of typedef: */
typedef signed int my_int32;    /* OK */
typedef signed char int8_t;     /* OK */
typedef short int s16_t;        /* OK */
typedef float&amp; float32ref;      /* OK */
typedef double float64;         /* OK */
typedef const int cs32_t;       /* OK */
s16_t foo(                      /* OK */
        char_t* p_char,         /* OK */
        float32ref r_float)     /* OK */
{
    float64 h;                  /* OK */
    cs32_t z = 1;               /* OK */
    return 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   from: 18 Portable Code - 18.1 Data Abstraction - Port. Rec. 1

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.4 章 环境，第 AV 11 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-6_4</key>
<configkey>MISRA2004-6_4</configkey>
<name><![CDATA[ 只能将位域定义为有符号的整型或无符号的整型 [MISRA2004-6_4] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只能将位域定义为有符号的整型或无符号的整型 [MISRA2004-6_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“位域只能定义成无符号整型或者有符号整型。
整形的使用是由实现环境决定的，因为整形的位域
可以是有符号也可是无符号的。枚举，短整型或者字符类型的位域
的使用是不允许的，因为其行为是不可确定的。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止这种随实现环境不同而不同的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Enum { E1, E2};
struct Struct 
{
    unsigned char  f1:2;  /* Violation */
    unsigned short f2:2;  /* Violation */
    unsigned long  f3:2;  /* Violation */
    enum Enum      f4:2;  /* Violation */
    int            f5:2;  /* Violation */
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct Struct
{
    unsigned int f1:2;  /* OK */
    unsigned int f2:2;  /* OK */
    unsigned int f3:2;  /* OK */
    signed int   f4:2;  /* OK */
    signed int   f5:2;  /* OK */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. 来源: Misra 指南 - 第 111 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.20 章 共用体和位段，第 AV 154 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-6_5</key>
<configkey>MISRA2004-6_5</configkey>
<name><![CDATA[ 有符号的位域至少有 2 个比特位的空间 [MISRA2004-6_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
有符号的位域至少有 2 个比特位的空间 [MISRA2004-6_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免使用长度小于2比特的有符号的位域。
该规则强制规定所有有符号类型的位域最少是2比特长。
也见：MISRA2004-6_4



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止潜在的陷阱和产生错误的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct MyStruct {
    signed int si01:1;    /* Violation */
    signed int si02:1;    /* Violation */
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct MyStruct {
    signed int si01:2;    /* OK */
    unsigned int si02:1;  /* OK */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. 来源: Misra 指南 - 第 112 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-7_1</key>
<configkey>MISRA2004-7_1</configkey>
<name><![CDATA[ 不应使用非零八进制常量和八进制转义序列 [MISRA2004-7_1] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应使用非零八进制常量和八进制转义序列 [MISRA2004-7_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“任何以 '0' (零)开头的整形常量被视为八进制。
这就存在着危险，例如，在写固定长度的常量的时候。
八进制的换码序列会产生问题，因为一个不经意引入
的十进制数字会中止这个换码顺序并引入
另外一个字符。最好不要使用八进制常量或者换码序列
并且静态地检查是否出现这种情况。
整形常量0（写作一个单个的数字），严格
来说，是一个八进制常量，但是可以视为这个规则的一个特例。
此外\0是唯一允许的八进制换码序列。”


例外：

该规则忽略任何pragma parasoft / codewizard 指令。
该规则忽略任何asm blocks里的数值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码的可读性与可维护性。
该规则防止使用随实现环境不同而不同的数值。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int code1;
    int code2;
    int code3;

    code1 = 052;    /* Violation */
    code2 = 071;    /* Violation */
    code3 = '\100'; /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1() 
{
    int code1;
    int code2;
    int code3;

    code1 = 42;  /* OK */
    code2 = 57;  /* OK */
    code3 = 64;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 7 节

2. 来源: Misra 指南 - 第 19 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.18 章 常量，第 AV 149 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-13-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_11</key>
<configkey>MISRA2004-8_11</configkey>
<name><![CDATA[ 带有内部链接的对象和函数应使用静态关键字进行定义和声明 [MISRA2004-8_11] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
带有内部链接的对象和函数应使用静态关键字进行定义和声明 [MISRA2004-8_11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“将关键字“static”应用到所有的有内在连结的
对象和函数的声明中是一个良好的习惯做法。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则促成好的编码风格并提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* file.h */
static int x;

/* file.c */
#include "file.h"
extern int x;        /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* file.h */
static int x;

/* file.c */
#include "file.h"
static int x;         /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 138 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_12</key>
<configkey>MISRA2004-8_12</configkey>
<name><![CDATA[ 带有外部链接的数组，其大小应该显式地声明或者在初始化时隐性地定义 [MISRA2004-8_12] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
带有外部链接的数组，其大小应该显式地声明或者在初始化时隐性地定义 [MISRA2004-8_12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一个数组被声明为带有外部连接，它的大小应该被明确声明
或者通过初始化来隐含地定义。
虽然声明一个不完整类型的数组并访问其元素是可能的，
但是当数组的大小被明确定义时这样做就
更加安全。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止产生不明确的行为并提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

extern int array2[ ]; /* Violation */
extern int array1[ ]; /* Violation */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int array2[ ] = { 0, 10, 15 };  /* OK */
extern int array1[ 10 ];        /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 3 节， 第 3-1-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_2_a</key>
<configkey>MISRA2004-8_2_a</configkey>
<name><![CDATA[ 声明或定义某个函数时，必须显式地规定其类型 [MISRA2004-8_2_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
声明或定义某个函数时，必须显式地规定其类型 [MISRA2004-8_2_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果返回类型没有明确声明，函数会隐含地将整型
作为返回类型。然而，编译器依然会报告一个缺少
返回类型的警告。为避免混淆，没有返回值的函数
应该明确将返回类型标明为void。该规则检查函数
的返回值类型是不是没有被明确指定。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static foo( void );     /* Violation - Non-compliant - implicit type */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static int foo( void ); /* OK - Compliant - explicit type */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. 来源: Misra 指南 - 第 75 条规则

3. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#9.4">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#9.4</A>
   From: 6 Style - 6.2 Functions - Rec. 20
   From: 9 Functions - 9.4 Return Types and Values - Rule 33

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_2_b</key>
<configkey>MISRA2004-8_2_b</configkey>
<name><![CDATA[ 声明或定义某个函数时，必须显式地规定其类型 [MISRA2004-8_2_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
声明或定义某个函数时，必须显式地规定其类型 [MISRA2004-8_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一旦一个对象被声明或者定义，
其类型应该被明确指定。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

extern x;  /* 违规 - Non-compliant - implicit int type */
const y;   /* 违规 - Non-compliant - implicit int type */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int16_t;
extern int16_t x;       /* OK - explicit type */
const int16_t y;        /* OK - explicit type */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
第 6 章，第 8 节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_3_a</key>
<configkey>MISRA2004-8_3_a</configkey>
<name><![CDATA[ 声明与定义的类型必须一致 [MISRA2004-8_3_a] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
声明与定义的类型必须一致 [MISRA2004-8_3_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于函数的每一个参数声明中给出的类型应该与定义
中给出的类型相同，返回值类型也应该是相同的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止产生不确定的行为并提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int MyInt;
typedef MyInt MyInt2;

int foo1( );        /* Violation */
MyInt foo1( ) {
    return 0;
}

MyInt2 foo2( );     /* Violation */
int foo2( ) {
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int MyInt;
typedef MyInt MyInt2;

int foo1( );        /* OK */
int foo1( ) {
    return 0;
}

MyInt2 foo2( );     /* OK */
MyInt2 foo2( ) {
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. 来源: Misra 指南 - 第 72 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_3_b</key>
<configkey>MISRA2004-8_3_b</configkey>
<name><![CDATA[ 函数的声明与原型的类型必须一致 [MISRA2004-8_3_b] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数的声明与原型的类型必须一致 [MISRA2004-8_3_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于函数的每一个参数声明中给出的类型应该与定义
中给出的类型相同，返回值类型也应该是相同的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止产生不确定的行为并提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int MyInt1;
typedef MyInt1 MyInt2;

void foo1( MyInt1 a, int b );	/* Violation */
void foo1( int a, MyInt1 b ) {}
void foo2( int a, MyInt1 b );	/* Violation */
void foo2( int a, MyInt2 b ) {}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int MyInt1;
typedef MyInt1 MyInt2;

void foo1( MyInt1 a, int b );   /* OK */
void foo1( MyInt1 a, int b ) {}
void foo2( int a, MyInt2 b );   /* OK */
void foo2( int a, MyInt2 b ) {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. 来源: Misra 指南 - 第 72 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_5</key>
<configkey>MISRA2004-8_5</configkey>
<name><![CDATA[ 在头文件中不应定义函数和对象 [MISRA2004-8_5] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在头文件中不应定义函数和对象 [MISRA2004-8_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“头文件应该用来声明对象，函数，类型定义(typedef)，
和宏。头文件不应该包含或者产生需要占据存储空间的对象或者函数的定义
（或者函数或者对象的片段）。”
参见：PFO-01



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则是只对 C 语言有效。
作为头文件是定义为任何通过 #include 包含的文件，
而不是指任何包含 .h 后缀的文件。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。
通过不在头文件中包含定义，
可以在多个翻译单元包含头文件。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* file.h */
int var1;                   /* Violation */
const int var2;             /* Violation */
static int var3;            /* Violation */
static const int var4;      /* Violation */
extern const int var5 = 5;  /* Violation */

void foo1(){}               /* 违规 */
extern void foo2(){}        /* 违规 */
inline void foo3(){}        /* 违规 */
static void foo4(){}        /* 违规 */

/* file.c */
#include "file.h"



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* file.h */
extern int var1;            /* OK */
extern const int var2;      /* OK */
extern const int var5;      /* OK */

void foo1();                /* OK */
extern void foo2();         /* OK */
inline void foo3();         /* OK */

/* file.c */
#include "file.h"

int var1;
const int var2;
static int var3;
static const int var4;
const int var5 = 5;

void foo1(){}
void foo2(){}
inline void foo3(){}
static void foo4(){}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_6</key>
<configkey>MISRA2004-8_6</configkey>
<name><![CDATA[ 在文件的范围内声明函数 [MISRA2004-8_6] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在文件的范围内声明函数 [MISRA2004-8_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数应该被声明在文件范围内。
在区块范围内声明函数可能会使人混淆，
并且会导致不明确的行为。




</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止产生不确定的行为并提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1( ) {
    void foo2( );  /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo2( );      /* OK */
void foo1( ) {
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. 来源: Misra 指南 - 第 112 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.13 章 函数，第 AV 107 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 3 节， 第 3-1-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-8_7</key>
<configkey>MISRA2004-8_7</configkey>
<name><![CDATA[ 如果一个对象只在一个函数中应用，应定义成局部变量 [MISRA2004-8_7] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个对象只在一个函数中应用，应定义成局部变量 [MISRA2004-8_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果有可能的话对象的作用域应该限制在函数里。
避免使用全局的标识符是一个良好的习惯做法，
除了必须之外。至于对象是声明在在区块的最外面
还是最里面很大程度上是个风格问题”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只检查具有内部链接的变量。
如果不使用变量，则不会报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则能提高代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static int max = 10; /* Violation */
void foo( ) {    
    while(max &gt;= 0) {
        max--;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {    
    int max = 10; /* OK */    
    while(max &gt;= 0) {
        max--;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-9_2</key>
<configkey>MISRA2004-9_2</configkey>
<name><![CDATA[ 在数组和结构体的非 0 初始化中，使用大括号进行标识和匹配 [MISRA2004-9_2] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在数组和结构体的非 0 初始化中，使用大括号进行标识和匹配 [MISRA2004-9_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ISO C要求有数组的初始化列表，结构体和共用体类型要被
包括在唯一的一对大括号里（虽然不这么做的后果并不明确）。
这里给出的规则进一步要求使用
额外的大括号来指示结构体嵌套。
数组或者结构体的零初始化只允许在顶层进行。
数组或者结构体的非零初始化
要求对每一个元素有一个明确地初始化程序。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则只检查多达三层括号嵌套初始化。


例外：

“数组或者结构体的所有元素可以通过仅给第一个元素一个
明确的初始化量而被初始化（为0或者空）。如果选择了
这个初始化方法那么第一个元素应该被初始化
为0（或者空），而且不需要使用大括号嵌套。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“该规则强制要求程序员明确地考虑并证实复杂数据类型
的元素被初始化的顺序。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int y[3][2] = { 1, 2, 3, 4, 5, 6 }; // Violation

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, 2}; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int y[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // OK

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, { 2 }}; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 9 节

2. 来源: Misra 指南 - 第 31 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.16 章 初始化，第 AV 144 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 8 节， 第 8-5-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2004-9_3</key>
<configkey>MISRA2004-9_3</configkey>
<name><![CDATA[ 在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化 [MISRA2004-9_3] ]]></name>
<tag>misra2004</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化 [MISRA2004-9_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在枚举数列表里，“=”不应该被用来
明确地初始化第一个成员之外的其他成员，
除非所有的元素都被明确地初始化。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

帮助避免错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum TEST { /* Violation */
    X = 1,
    Y,
    Z = 3,
};

enum TEST2 { /* Violation */
    X2,
    Y2 = 2,
    Z2,
};

enum TEST3 { /* Violation */
    X3,
    Y3,
    Z3 = 3,
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum TEST { /* OK */
    X,
    Y,
    Z,
};

enum TEST2 { /* OK */
    X2 = 1,
    Y2,
    Z2,
};

enum TEST3 { /* OK */
    X3 = 1,
    Y3 = 2,
    Z3 = 3,
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 9 节

2. 来源: Misra 指南 - 第 32 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 8 节， 第 8-5-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_10</key>
<configkey>MISRA2008-0_1_10</configkey>
<name><![CDATA[ 每个被定义的函数应该至少被调用一次 [MISRA2008-0_1_10] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每个被定义的函数应该至少被调用一次 [MISRA2008-0_1_10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"任何定义的函数都必须至少被调用一次."
如果定义函数未被使用规则会报告违规



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则检测以下函数:
- 在 C语言中: 
  - 静态函数,
- 在 C++中: 
  - 非模板全局静态函数, 
  - 在匿名命名空间中的非模板全局静态函数,
  - 非模板 非静态 非运算符 私有成员函数



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"函数或者过程没有被调用是一个很严重的问题,
例如缺少路径."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static void foo() // 违规
{
   /* ... */
}

int main()
{
  return (0);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static void foo() // OK
{
   /* ... */
}

int main()
{
  foo(); 
  return (0);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
第 6 章, 第 0 节, 规则 0-1-10

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_11</key>
<configkey>MISRA2008-0_1_11</configkey>
<name><![CDATA[ 在非虚函数中不得存在没有被使用的参数（命名的和未命名的） [MISRA2008-0_1_11] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在非虚函数中不得存在没有被使用的参数（命名的和未命名的） [MISRA2008-0_1_11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不得在非虚函数中有未使用的参数（有名或无名）."


例外:

"在一个被当作回调的函数中定义无名参数
不违反此规则."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"未使用函数往往由于设计变更和导致会造成
参数列表不匹配."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int Foo(int i, int k)   // 违规
{
    i = 5;
    return i;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int Foo(int i)          // OK
{
    i = 5;
    return i;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
第 6 章, 第 0 节, 规则 0-1-11

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_1_a</key>
<configkey>MISRA2008-0_1_1_a</configkey>
<name><![CDATA[ 项目不得在 else 模块中包含不能到执行到的代码 [MISRA2008-0_1_1_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目不得在 else 模块中包含不能到执行到的代码 [MISRA2008-0_1_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在else语句中不应该有覆盖不到的语句。
“这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的。”
参考：
MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_d, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
    if(a == a){
        a = a + b;
    }
    else{               // Violation
        a = a - b;
    }                     
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
    if(a == 3){
        a = a + b;
    }
    else{               // OK
        a = a - b;
    }                     
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南 - 第 52条规则

3.联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构章节, AV 第 186条规范

4.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第0-1-1规则
 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_1_b</key>
<configkey>MISRA2008-0_1_1_b</configkey>
<name><![CDATA[ 项目不得在 return, break, continue 和 goto 语句之后包含不能执行到的代码 [MISRA2008-0_1_1_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目不得在 return, break, continue 和 goto 语句之后包含不能执行到的代码 [MISRA2008-0_1_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。能够覆盖到但是从不执行的代码
将从这条规则中排出（例如，防御性编程代码）
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在return','break', 'continue'和 'goto' 语句后有覆盖不到的语句.
参见:MISRA2004-14_1_a, MISRA2004-14_1_c, MISRA2004-14_1_d, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo();
int myFunction(int i, int j)
{
    switch(i)
    {
        case 1:
            j = 5;
            break;    // Violation
            foo();
        case 2:
            j = 3;
            return j; // Violation
            foo();
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo();
int myFunction(int i, int j)
{
    switch(i)
    {
        case 1:
            j = 5;
            break;    // OK
        case 2:
            j = 3;
            return j; // OK
    }
    foo();
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6,章节, 第 14部分

2. 来源: Misra 指南 - 第 52条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV 第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章节, 第0部分, 第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_1_c</key>
<configkey>MISRA2008-0_1_1_c</configkey>
<name><![CDATA[ 项目不得在 if/else/while/for 模块中包含不能执行到的代码 [MISRA2008-0_1_1_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目不得在 if/else/while/for 模块中包含不能执行到的代码 [MISRA2008-0_1_1_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在if/while/for/else块中如果一个条件值不变而出现无用代码.
参见:MISRA2004-14_1组规则 and MISRA2004-13_7组规则



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

vo7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助防止无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int unreachable_code = 1;
    if(0)                         // Violation
    { 
        unreachable_code = 2; 
    }                 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不得有不可达代码



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分
   
2. 来源: Misra 指南- 第52条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制结构章节,AV第186条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节, 第0部分,第 0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_1_d</key>
<configkey>MISRA2008-0_1_1_d</configkey>
<name><![CDATA[ 项目不得在 switch 语句中包含不能执行到的代码 [MISRA2008-0_1_1_d] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目不得在 switch 语句中包含不能执行到的代码 [MISRA2008-0_1_1_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在"switch"语句中不应该有覆盖不到的代码.
这条规则预防语句、表达式被放置在case和default块外面.
"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码。
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
这条规则预防在if/while/for/else块中如果一个条件值不变而出现无用代码.
参见:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_e,
MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i ) {
    switch (i) {    // Violation
        i = 0;
    case 1:
        i = 1;
        break;
    default:
        i = 2;
        break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i ) {
    switch (i) {    // OK
    case 0:
        i = 0;
        break;
    case 1:
        i = 1;
        break;
    default:
     	i = 2;
        break;
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_1_e</key>
<configkey>MISRA2008-0_1_1_e</configkey>
<name><![CDATA[ 项目不得在 for 循环中包含不能执行到的代码 [MISRA2008-0_1_1_e] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目不得在 for 循环中包含不能执行到的代码 [MISRA2008-0_1_1_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。能够覆盖到但是从不执行的代码
将从这条规则中排出（例如，防御性编程代码）。一部分代码
如果没有控制流路径从相关的输入点进入是覆盖不到的。"
如果一个 'for' 循环在条件中包含单关系表达式
'VAR &lt; FB',  'VAR &lt;= FB', 'FB  &gt; VAR', 'FB &gt;= VAR'
并且其结果始终是 false 时，报告一个违规， 这里 FB 是
一个常量或一个 const 变量，而 VAR 是一个在 for 初始化语句中复制的变量。
如果一个 for 条件的结果始终是 false 那么循环体将不会被执行。
参见:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c,
MISRA2004-14_1_d, MISRA2004-14_1_f, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i, int j ) 
{
    for ( i = 0; i &lt; 0; i++ )  // Violation
    {
      j = 1; 
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i, int j ) 
{
    for ( i = 0; i &lt; 5; i++ )  // OK
    {
      j = 1; 
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分
  
2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24控制流结构章节,AV第186条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_1_f</key>
<configkey>MISRA2008-0_1_1_f</configkey>
<name><![CDATA[ 项目不得在 for/while/catch 模块外部的 if 或 switch 之后包含不能执行到的代码 [MISRA2008-0_1_1_f] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目不得在 for/while/catch 模块外部的 if 或 switch 之后包含不能执行到的代码 [MISRA2008-0_1_1_f-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码.
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
如果出现下面的情况这条规则就会报错：
-'if/else' 结构中每条分支都没有'return'语句
-'switch'结构中每个'case'分支和'default'中都没有'return'语句
参考：MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c, MISRA2004-14_1_d,
MISRA2004-14_1_e, MISRA2004-14_1_g



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1( int c ) {
    if ( c &gt; 2 ) {    // Violation
        return 0;
    } else {
        return 1;
    }
    return c;         // 不可达代码
}

int foo2( int i ) {
    switch(i){        // 违规
    case 1:
        i++;
        return 0;
    case 2:
        i = i + 2;
        return 1;
    default:
        return 2;
    }
    return i;         // 不可达代码
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1( int c ) {
    if ( c &gt; 2 ) {    // OK
        return 0;
    } else {
        return c;
    }
}

int foo2( int i ) {
    switch(i){        // OK
    case 1:
        i++;
        return 0;
    case 2:
        i = i + 2;
        return 1;
    default:
        return i;
    }
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
     第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24 控制流结构章节, AV 第186条规则

3. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_1_g</key>
<configkey>MISRA2008-0_1_1_g</configkey>
<name><![CDATA[ 项目不得在 while/for/catch 模块内部的 if 或 switch 之后包含不能执行到的代码 [MISRA2008-0_1_1_g] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目不得在 while/for/catch 模块内部的 if 或 switch 之后包含不能执行到的代码 [MISRA2008-0_1_1_g-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则涉及到在任何情况下都不能覆盖到、
在编译时能被识别的代码。也包括能够覆盖到但是从不执行的代码.
一部分代码如果没有控制流路径从相关的输入点进入是覆盖不到的的."
如果出现下面的情况这条规则就会报错:
-在'if/else'结构中每条分支都没有'break', 'continue' or 'return'
-switch结构中每条'case'和'default'中都没有 'return' 
参考:MISRA2004-14_1_a, MISRA2004-14_1_b, MISRA2004-14_1_c,
          MISRA2004-14_1_d, MISRA2004-14_1_e, MISRA2004-14_1_f



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则预防无用的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int c ) {
    while ( c &gt; 1 ) {
        if ( c &gt; 2 ) {    // Violation
            continue;
        } else {
            break;
        }
        c++;              // 不可达代码
    }

    for (int i = 0; i &gt; 1; i++ ) {
        switch(i){        // 违规
        case 1:
            i++;
            return i;
        case 2:
            i = i + 2;
            return i;
        default:
            return i;
        }
        c++;              // 不可达代码
    }
    return c;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int c ) {
    while ( c &gt; 1 ) {
        c++;
        if ( c &gt; 2 ) {    // OK
            continue;
        } else {
            break;
        }
    }

    for (int i = 0; i &gt; 1; i++ ) {
        c++;
        switch(i){        // OK
        case 1:
            i++;
            return i;
        case 2:
            i = i + 2;
            return i;
        default:
            return i;
        }
    }
    return c;
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分

2. 联合攻击战斗机, 飞行器, C++ 编码规范
    第4.24 控制流结构章节, AV 第186条规则

3. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第0部分,第0-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_a</key>
<configkey>MISRA2008-0_1_2_a</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许使用逻辑运算符'&amp;&amp;'的表达式的值一直是'true'或者'false'.


优点;

如果一个使用逻辑运算符'&amp;&amp;'的表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &lt;= 1)&amp;&amp;(a &gt;= 2)); // Violation 
    if((a &lt; 1)&amp;&amp;(a &gt; 2));   // Violation 
    if((a &gt;= 2)&amp;&amp;(a &lt;= 1)); // Violation 
    if((a &gt; 2)&amp;&amp;(a &lt; 1));   // Violation 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &lt;= 5)&amp;&amp;(a &gt;= 2)); // OK
    if((a &lt; 5)&amp;&amp;(a &gt; 2));   // OK
    if((a &gt;= 2)&amp;&amp;(a &lt;= 5)); // OK
    if((a &gt; 2)&amp;&amp;(a &lt; 5));   // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节、第13部分

2. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节、第 0部分, 第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_b</key>
<configkey>MISRA2008-0_1_2_b</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &gt;= 2)
    if(b &lt; 2) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &gt;= 2)
    if(b &lt; 7) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第0部分, 第0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_c</key>
<configkey>MISRA2008-0_1_2_c</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &lt; 2)
    if(b &gt;= 2) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &lt; 2)
    if(b &gt;= 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分, 第0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_d</key>
<configkey>MISRA2008-0_1_2_d</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_d] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &lt;= 2)
    if(b &lt; 3) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b &lt;= 2)
    if(b &lt; 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_e</key>
<configkey>MISRA2008-0_1_2_e</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_e] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b == 2)
    if(b &lt; 1) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(b == 2)
    if(a &lt; 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_f</key>
<configkey>MISRA2008-0_1_2_f</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_f] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_f-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &gt; b)
    if(b &lt; 5) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &gt; b)
    if(b &lt; 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_g</key>
<configkey>MISRA2008-0_1_2_g</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_g] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_g-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.





</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &gt;= b)
    if(b &lt; 5) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &gt;= b)
    if(b &lt; 1) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_h</key>
<configkey>MISRA2008-0_1_2_h</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_h] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_h-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &lt; b)
    if(b &gt; 1) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &lt; b)
    if(b &gt; 5) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_i</key>
<configkey>MISRA2008-0_1_2_i</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_i] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_i-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果'if'语句里嵌套着'if'语句,而后者中表达式的逻辑结果是不变的,规则就会报错.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果变量在'if'语句里(嵌套着'if'语句)中是易变的,规则就不会报错.
规则设定传到函数中的参数被改变.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &lt;= b)
    if(b &gt; 1) /* Violation */
      a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{
  if(2 &lt;= b)
    if(b &gt; 5) /* OK */
      a++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_j</key>
<configkey>MISRA2008-0_1_2_j</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_j] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_j-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个无符变量的逻辑运算表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunc()
{
    unsigned int a;
    if (a &gt;= 0)     // Violation
        a++; 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunc()
{
    unsigned int a;
    if (a &gt;= 2)     // OK
        a++; 
}



参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_k</key>
<configkey>MISRA2008-0_1_2_k</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_k] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_k-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>


不允许一个逻辑运算表达式的值是不变的.


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunc()
{
    unsigned char a;
    signed char b;

    if (b &gt;= 128)   // Violation
        b++;
    if (a &lt; 256)    // Violation
        a++; 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunc()
{
    unsigned char a;
    signed char b;

    if (b &gt;= 127)    // OK
        b++;
    if (a &lt; 255)     // OK
        a++; 
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_l</key>
<configkey>MISRA2008-0_1_2_l</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_l] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_l-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个逻辑运算表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunc()
{
    unsigned short a;
    signed short b;

    if (a &lt; 65536)    // Violation
        a++;
    if (b &lt;= 32767)   // Violation
        b++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunc()
{
    unsigned short a;
    signed short b;

    if (a &lt; 65535)    // OK
        a++;
    if (b &lt;= 32766)   // OK
        b++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_m</key>
<configkey>MISRA2008-0_1_2_m</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_m] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_m-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'&amp;&amp;'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -1)&amp;&amp;(a &lt; -2));   // Violation 
    if((a &gt;= -1)&amp;&amp;(a &lt;= -2)); // Violation 
    if((a &lt; -2)&amp;&amp;(a &gt; -1));   // Violation 
    if((a &lt;= -2)&amp;&amp;(a &gt;= -1)); // Violation 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -5)&amp;&amp;(a &lt; -2));   // OK
    if((a &gt;= -5)&amp;&amp;(a &lt;= -2)); // OK
    if((a &lt; -2)&amp;&amp;(a &gt; -5));   // OK
    if((a &lt;= -2)&amp;&amp;(a &gt;= -5)); // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_n</key>
<configkey>MISRA2008-0_1_2_n</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_n] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_n-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'&amp;&amp;'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; 0)&amp;&amp;(a &lt; -1));    // Violation
    if((a &lt; -1)&amp;&amp;(a &gt;= 0));   // Violation
    if((a == -5)&amp;&amp;(a == 5));  // Violation
    if((3 &lt; a)&amp;&amp;(-3 &gt; a));    // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &lt; 0)&amp;&amp;(a &gt; -1));    // OK
    if((a &gt; -1)&amp;&amp;(a &lt;= 0));   // OK
    if((a != -5)&amp;&amp;(a != 5));  // OK
    if((3 &gt; a)&amp;&amp;(-3 &lt; a));    // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_o</key>
<configkey>MISRA2008-0_1_2_o</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_o] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_o-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'&amp;&amp;'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a, int b)
{
    if((a &gt; b)&amp;&amp;(a &lt; b));   // Violation
    if((a &lt; b)&amp;&amp;(a &gt;= b));  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a, int b, int c)
{
    if((a &gt; b)&amp;&amp;(a &lt; c));   // OK
    if((a &lt; b)&amp;&amp;(a &gt;= c));  // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_p</key>
<configkey>MISRA2008-0_1_2_p</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_p] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_p-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'||'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个使用逻辑运算的表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt;= 0)||(a &lt; 0));   // Violation
    if((5 &gt; a)||(a &gt; 3));    // Violation
    if((a &lt;= 4)||(a &gt;= 3));  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt;= 10)||(a &lt; 0));   // OK
    if((5 &gt; a)||(a &gt; 13));    // OK
    if((a &lt;= 4)||(a &gt;= 13));  // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_q</key>
<configkey>MISRA2008-0_1_2_q</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_q] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_q-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'||'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果使用逻辑运算操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -4)||(a &lt; -3));   // Violation
    if((-1 &gt; a)||(-3 &lt; a));   // Violation
    if((a &lt; -3)||(-5 &lt; a));   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -4)||(a &lt; -13));   // OK
    if((-11 &gt; a)||(-3 &lt; a));   // OK
    if((a &lt; -13)||(-5 &lt; a));   // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_r</key>
<configkey>MISRA2008-0_1_2_r</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_r] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_r-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'||'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个逻辑运算操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &gt; -2)||(a &lt; 1));   // Violation
    if((4 &gt; a)||(-3 &lt; a));   // Violation
    if((a &gt; -4)||(2 &gt; a));   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if((a &lt; -2)||(a &gt; 1));   // OK
    if((4 &lt; a)||(-3 &gt; a));   // OK
    if((a &lt; -4)||(2 &lt; a));   // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_rz</key>
<configkey>MISRA2008-0_1_2_rz</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_rz] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_rz-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个if语句嵌套在另一个if语句中,而且这个if语句中条件表达式的结果
是不变的.


好处:

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int b)
{
  if(b &gt; 2)
    if(b &gt;= 1)   /* Violation */
      b++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int b)
{
  if(b &gt; 2)
    if(b &gt;= 5)   /* OK */
      b++;
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_s</key>
<configkey>MISRA2008-0_1_2_s</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_s] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_s-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许一个使用逻辑运算符'||'的表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个逻辑运算操作表达式产生的结果被证实一直是'true'或者'false',
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a, int b)
{
    if((a &gt;= b)||(a &lt;= b));  // Violation
    if((a &lt; b)||(a &gt;= b));   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a, int b, int c)
{
     if((a &gt;= b)||(a &lt;= c));   // OK
     if((a &lt; c)||(a &gt;= b));    // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_sz</key>
<configkey>MISRA2008-0_1_2_sz</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_sz] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_sz-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(GREEN &gt; col);	 // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(BLUE &gt; col);	 // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_t</key>
<configkey>MISRA2008-0_1_2_t</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_t] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_t-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算表达式的值是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果一个逻辑运算操作的表达式产生的结果被证实一直是'true'或者'false'，
很可能是一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction(int a)
{
    if(a == a);  // 违规
    if(1 == 1);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction(int a)
{
    if(a == 1);  // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_u</key>
<configkey>MISRA2008-0_1_2_u</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_u] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_u-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(col &lt; GREEN);	 // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(col &lt; RED);	 // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_v</key>
<configkey>MISRA2008-0_1_2_v</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_v] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_v-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(col &gt; YELLOW);	 // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(col &gt; RED);	 // OK
}

参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_w</key>
<configkey>MISRA2008-0_1_2_w</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_w] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_w-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(YELLOW &lt; col);	 // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
    enum ec {RED = 8, BLUE = 7, GREEN = 2, YELLOW = 10} col;

    if(GREEN &lt; col);	 // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第0部分,第 0-1-2条规则
 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_x</key>
<configkey>MISRA2008-0_1_2_x</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_x] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_x-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.


f示例:

void myFunctionEnum(){
    
 	 enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

 	 if(col1 &lt; 0);   // Violation
	 if(col1 &lt; 16);  // Violation
 	 if(col1 &lt;= 15); // Violation
	 if(col1 &lt;= 16); // Violation
 	 if(col1 &gt; 15);  // Violation
	 if(col1 &gt; 16);  // Violation
	 if(col1 &gt;= 0);  // Violation
	 if(col1 &gt;= 16); // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

	if(col1 &lt; 1);   // OK
 	if(col1 &lt; 15);  // OK
	if(col1 &lt;= 0);  // OK
	if(col1 &lt;= 1);  // OK
	if(col1 &gt; 0);   // OK
	if(col1 &gt; 1);   // OK
	if(col1 &gt;= 1);  // OK
 	if(col1 &gt;= 15); // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_y</key>
<configkey>MISRA2008-0_1_2_y</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_y] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_y-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
  	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

 	if(15 &lt; col1);  // Violation
	if(16 &lt; col1);  // Violation 
	if(0 &lt;= col1);  // Violation
	if(16 &lt;= col1); // Violation
	if(0 &gt; col1);   // Violation
	if(16 &gt; col1);  // Violation 
 	if(15 &gt;= col1); // Violation
	if(16 &gt;= col1); // Violation 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

	if(0 &lt; col1);   // OK
	if(1 &lt; col1);   // OK
	if(1 &lt;= col1);  // OK
 	if(15 &lt;= col1); // OK
	if(1 &gt; col1);   // OK
 	if(15 &gt; col1);  // OK
	if(0 &gt;= col1);  // OK
	if(1 &gt;= col1);  // OK
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六部分,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_2_z</key>
<configkey>MISRA2008-0_1_2_z</configkey>
<name><![CDATA[ 项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_z] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含不可执行到的路径 [MISRA2008-0_1_2_z-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许逻辑运算的结果是不变的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果逻辑运算产生的结果被证实一直是true或者一直是false,
原因很有可能是存在一个程序错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunctionEnum(){
    
  	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

 	 if(col1 == 14 ); // Violation
 	 if(col1 != 14 ); // Violation
 	 if(14 == col1);  // Violation
 	 if(14 != col1);  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunctionEnum(){
    
	enum ec1 {BLACK, WHITE, GREY, PINK = 15} col1;

	 if(col1 == 15);  // OK
	 if(col1 != 15);  // OK
	 if(15 == col1);  // OK
	 if(15 != col1);  // OK
}

参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第0部分,第 0-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_3_a</key>
<configkey>MISRA2008-0_1_3_a</configkey>
<name><![CDATA[ 项目中不得包含未使用的变量 [MISRA2008-0_1_3_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含未使用的变量 [MISRA2008-0_1_3_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否所有声明的局部变量都被使用了。如果一个变量
在函数体内部的定义之后被找到，则此规则判断使用的是
一个局部变量。
参见: OPT-03, OPT-06



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对象能够在其构造函数中执行一些操作。即使它们
在不使用之后也可能在创建过程中发挥作用。此规则 
不考虑这种对象为“已使用”并报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

消除未使用的局部变量提高效率和易读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    void displBalance();
};

void foo( ) {
    A a;        // 违规 
}

int func(int j) {
    int i = 0;  // 违规
    return j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    void displBalance( );
};

void foo( ) {
    A a;
    a.displBalance( );  // OK
}

int func(int j) {
    int i = j + 1;      // OK
    return i;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 0 节, 规则 0-1-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_3_b</key>
<configkey>MISRA2008-0_1_3_b</configkey>
<name><![CDATA[ 项目中不得包含未使用的变量 [MISRA2008-0_1_3_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
项目中不得包含未使用的变量 [MISRA2008-0_1_3_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否有任何声明的局部变量未使用
或没有副作用。
参见: OPT-02



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则不在有显式声明的构造函数或析构函数
type class/struct 的变量上报告违规。


优点:

消除未使用的局部变量提高效率和易读性。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

消除未使用的局部变量提高效率和易读性。
说明:

如果一个声明的局部变量在一个函数体内部
没有被使用，或者只在删除后却不改变函数功能
的表达式中使用时，此规则将报告一个违规。
参见: OPT-02



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

当变量只在 asm （汇编语言）程序块中使用
和文件是使用gcc来编译的，规则也可能误报。


示例:

void func() {
    int i = 0;    // 违规
}

int i = 0;
class A {
public:
    A(){};
};

class B {
public:
    B(){i++;};
};

void goo() {
    A a;	// 违规
    B b;	// OK
}


修复:

void func() { // OK
}

int i = 0;
class A {
public:
    A(){};
};

class B {
public:
    B(){i++;};
};

void goo() {  // OK
    B b;
}


参考资料:

1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 0 节, 规则 0-1-3

</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
};

int func(int p) {
    A a;       // 违规
    int i = 0; // 违规
    i = p;
    i++;
    return p;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A();
};

int func(int p) {
    A a;       // OK - implicit call of constructor can cause additional action
    int i = 0; // OK
    i = p;
    i++;
    return i;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 0 节, 规则 0-1-3


</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_7</key>
<configkey>MISRA2008-0_1_7</configkey>
<name><![CDATA[ 从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用 [MISRA2008-0_1_7] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用 [MISRA2008-0_1_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在 C++ 中调用一个函数而不使用其返回值，
这可能是一个错误。函数的返回值应始终被使用。”


例外:

“函数的返回值可能会由于 (void) 强制类型转换被丢失。
重载运算符除外，因为它们应该表现出和内建的运算符
同样的方式。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

short func ( short para1 )
{
    return para1;
}

void discarded ( short para2 )
{
    func ( para2 );       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

short func ( short para1 )
{
    return para1;
}

void discarded ( short para2 )
{
    (void)func ( para2 );       // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 0 节, 规则 0-1-7

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_1_8</key>
<configkey>MISRA2008-0_1_8</configkey>
<name><![CDATA[ 所有 void 返回类型的函数应该有外部的作用 [MISRA2008-0_1_8] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有 void 返回类型的函数应该有外部的作用 [MISRA2008-0_1_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一个没有外部返回值也没有外部作用的函数
只会增加时间的耗费而不会产生任何输出,
而这可能不能满足开发者的预期.
以下是外部左右的示范:
- 读或写一个文件或数据流等.;
- 改变一个非局部变量的值;
- 改变一个具有引用类型的参数值;
- 使用一个可变对象;
- 引发异常.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止没有必要的时间消耗.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( void ) // 违规
{
    int local;
    local = 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int p ) // OK
{
    int local;
    local = 10*p;
    /* ... */
    return local;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
第6章, 第 0 节, 规则 0-1-8 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_2_1_a</key>
<configkey>MISRA2008-0_2_1_a</configkey>
<name><![CDATA[ 对象不能被指定给一个重叠的对象 [MISRA2008-0_2_1_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象不能被指定给一个重叠的对象 [MISRA2008-0_2_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当两个对象创建的时候在内存中有一段重叠区域，
并且一个正向另一个拷贝时，后果是未知的。
此规则检测是否存在同一联合体的不同成员
使用相同的对象赋值给另一方。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未定义的行为和数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string.h&gt;
union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

int main( ) {
    union U a, b;
    union U *p;

    (void)memcpy( &amp;a.dValue,  &amp;a.lValue, 8 );    /* 违规 */
    (void)memcpy( &amp;p-&gt;dValue, &amp;p-&gt;iValue, 8 );   /* 违规 */
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string.h&gt;
union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

int main( ) {
    union U a, b;
    union U *p, *q;
    (void)memcpy( &amp;a.dValue,  &amp;b.lValue, 8 );     /* OK */
    (void)memcpy( &amp;p-&gt;dValue, &amp;q-&gt;iValue, 8 );    /* OK */
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第18部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第0部分，第0-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_2_1_b</key>
<configkey>MISRA2008-0_2_1_b</configkey>
<name><![CDATA[ 对象不能被指定给一个重叠的对象 [MISRA2008-0_2_1_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象不能被指定给一个重叠的对象 [MISRA2008-0_2_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对象不能赋值给一个重叠的对象。”
此规则检测是否同一个联合体(union)的
两个不同的成员使用相同的对象彼此给对方赋值。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"Assigning between objects that have an overlap in their physical storage
leads to undefined behaviour."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

void main( ) {
    union U a, b;
    union U *p;

    a.dValue  = a.lValue;    // 违规
    p-&gt;dValue = p-&gt;iValue;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

void main( ) {
    union U a, b;
    union U *p, *q;
    a.dValue  = b.lValue;     // OK
    p-&gt;dValue = q-&gt;iValue;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 0 节, 规则 0-2-1 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_3_2</key>
<configkey>MISRA2008-0_3_2</configkey>
<name><![CDATA[ 如果一个函数生成错误信息，那么这个错误信息应该被测试 [MISRA2008-0_3_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个函数生成错误信息，那么这个错误信息应该被测试 [MISRA2008-0_3_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不管函数是来自标准库，还是第三方的库，或者是用户定义的函数，
它可能提供一些方式来标志一个错误的发生。这种方式可能是通过设
置一个错误标志，一些特别的返回值或者其它的方式。
无论何种方式，调用这个函数的程序应该在函数返回时，检查错误标志。
但是，注意对函数输入参数进行检查是一种比试图在函数完成之后检查
错误的更稳健的一种方式（参见MISRA2004-20_3）。  
同样也要注意对errno（用来从函数返回错误信息）的使用是笨拙的，
要小心使用（参见MISRA2004-20_5）。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
函数调用可能返回char, short int, int, enum类型或者这些类型的引用的值，
此规则用来检查返回这些类型值的函数调用并在这个值没有被赋值，
检查或者强制转换成了void类型时报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来帮助书写安全性高的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int SomeFunctionReturningError( );
void foo( )
{
    SomeFunctionReturningError( );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int SomeFunctionReturningError( );
int foo( ) 
{
    int x;
    x = SomeFunctionReturningError( );       // OK
    (void)SomeFunctionReturningError( );    //OK
    if (SomeFunctionReturningError( ));       // OK
    switch (SomeFunctionReturningError( )) {  //  OK
    }
    return SomeFunctionReturningError( );     //  OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源:Misra 使用指南 - 第 86 条规则

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Function, AV Rule 115

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第0部分，第0-3-2条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 7

6. <A HREF="http://cwe.mitre.org/data/definitions/391.html">http://cwe.mitre.org/data/definitions/391.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-0_4_2</key>
<configkey>MISRA2008-0_4_2</configkey>
<name><![CDATA[ 使用浮点型算法应该被注释说明 [MISRA2008-0_4_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用浮点型算法应该被注释说明 [MISRA2008-0_4_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果使用浮点数，那么下面的问题需要作为误差过程的
一部分加以覆盖:
- 一个解释为什么浮点数是合适的或唯一的 
  解决方法的理由。
- 证明适当的技巧是可用的。
- 证明应用了适当的处理过程。
- 说明浮点的执行。”
此规则检查是否在浮点运算表达式的
前一行或同一行有注释。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“安全地使用浮点运算需要有高水平的数值分析技巧，
以及对编译器和目标硬件深入的知识。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 在如下行有违规: double d = d1 + d2;
double add(double d1, double d2)
{
    double d = d1 + d2;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

double add(double d1, double d2)
{
	double d = d1 + d2; // OK - 浮点运算
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 0 节, 规则 0-4-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-10_1_1</key>
<configkey>MISRA2008-10_1_1</configkey>
<name><![CDATA[ 类不得从虚类派生而来 [MISRA2008-10_1_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类不得从虚类派生而来 [MISRA2008-10_1_1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不推荐使用虚拟基类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用虚拟基类型可能引起
一系列的未定义及潜在混淆
的行为。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B {};
class D: public virtual B {}; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止从虚拟基类型进行继承



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - 在关键系统中使用C++语言的准则
第6章，第10节，第10-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-10_1_3</key>
<configkey>MISRA2008-10_1_3</configkey>
<name><![CDATA[ 能够访问的基础类在同一个层级中不得既是虚类又是非虚类 [MISRA2008-10_1_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
能够访问的基础类在同一个层级中不得既是虚类又是非虚类 [MISRA2008-10_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在同一层次结构中一个基类型不能同时具有虚拟
及非虚拟的属性。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

层次结构更易于理解及使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
class B : virtual A {};
class C : B, A {};           // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {};
class B : virtual A {};
class C : B, virtual A {};   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第89条

2.MISRA C++：2008 - 在关键系统中使用C++语言的准则
  第6章，第10节，第10-1-3规则

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-10_3_1</key>
<configkey>MISRA2008-10_3_1</configkey>
<name><![CDATA[ 在通过继承层级的各条路径上每个虚函数不得有多于一个的定义 [MISRA2008-10_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在通过继承层级的各条路径上每个虚函数不得有多于一个的定义 [MISRA2008-10_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“通过确保在类层次结构中的任意一点执行相应
函数的明确性，本规则的主要目的是为代码维护
人员及复审人员增强透明度。”


例外：

“在类层次结构中的多个成员中析构函数可以被
声明为虚拟。如果一个函数被声明为抽象的并且
在同一类中进行定义，那么将被本规则忽略。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此外，菱形层次结构中的类被其属主（dominance）
调用可能会引起调用与开发者本意不相符的函数。本规则防止属主的调用。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* Examples of incorrect code */
class A
{
    public:
        virtual void f1 ( );
        virtual void f2 ( ) { }
};
void A::f1 ( )
{
}

class B : public A
{
    public:
        virtual void f1 ( ) { }  // Violation
        virtual void f2 ( );
};
void B::f2 ( )                   // Violation
{
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Examples of correct code */
class A
{
    public:
        virtual void f1 ( );
        virtual void f2 ( ) = 0;
        virtual ~A(){}
};
void A::f2 ( )
{
}

class B : public A
{
    public:
        virtual void f1 ( ) { }  // OK
        virtual void f2 ( );
        virtual ~B(){}           // OK
};
void B::f2 ( )                   // OK
{
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++：2008 在关键系统中使用C++语言的准则
第6章，第10节，第10-3-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-10_3_2</key>
<configkey>MISRA2008-10_3_2</configkey>
<name><![CDATA[ 每个覆盖的虚函数应该被声明有虚拟关键字 [MISRA2008-10_3_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每个覆盖的虚函数应该被声明有虚拟关键字 [MISRA2008-10_3_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

任何时候使用虚拟关键词来在子类型中实现虚拟
函数都会使代码变得更易读，因为读者不必从基
类型中参考查看相关函数是否是虚拟的。本规则
能检查为使用虚拟关键词在子类型中实现虚拟函
数的情况。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

深层继承层次结构的直觉行为以及可读性，在使
用基类型中的虚拟函数时会在所有的集成类中维
持虚拟。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    virtual int foo( );
};

class B : public A {
public:
    int foo( );         // Violation
};

int B::foo() {
    return 5;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    virtual int foo( );
};

class B : public A {
public:
    virtual int foo( );         // OK
};

int B::foo() {
  return 5;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“类设计及继承”，第38条规则

2.MISRA C++：2008 - 在关键系统中使用C++语言的准则
  第6章，第10节，第10-3-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-10_3_3</key>
<configkey>MISRA2008-10_3_3</configkey>
<name><![CDATA[ 如果一个虚函数本身被声明为纯虚函数，那它只能被纯虚函数所覆盖 [MISRA2008-10_3_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个虚函数本身被声明为纯虚函数，那它只能被纯虚函数所覆盖 [MISRA2008-10_3_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“虚拟函数仅能被自身声明为纯虚拟的纯虚拟
函数进行覆盖”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止编写出与开发者本意向未被的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
    public:
    virtual void foo ( );
};
class B: public A
{
    public:
    virtual void foo ( ) = 0; // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止使用纯虚拟函数覆盖非纯虚拟函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 在关键系统中使用C++语言的准则
第6章，第10节，第10-3-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-11_0_1</key>
<configkey>MISRA2008-11_0_1</configkey>
<name><![CDATA[ 非 POD 类的成员数据应该是私有的 [MISRA2008-11_0_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非 POD 类的成员数据应该是私有的 [MISRA2008-11_0_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“非POD类类型的成员数据应具有私有的属性。”
非POD类类型应至少满足下述条件之一：
-是一个类（不是PODs的类）
-是一个具有下列属性的结构体/联合体：
 +具有用户定义的构造函数
 +具有私有或保护的数据成员
 +具有基类型
 +具有虚拟函数
 +具有带有非POD类型的非静态成员（或非POD数组）
 +具有带有类引用的非静态成员
 +具有用户声明的拷贝赋值运算符
 +具有用户声明的析构函数



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过实现带有成员函数的类接口，
该实现将能更多地掌控如何修改对象
的状态，并允许在不影响客户端的前
提下对类进行维护。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int int32_t;
class C
{
    public:
        int32_t b; // Violation
    protected:
        int32_t c; // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef signed int int32_t;
class C
{
    private:
        int32_t b; // OK
        int32_t c; // OK
    protected:
        const int32_t access_b();
        const int32_t access_c();
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - 在关键系统中使用C++语言的准则
第6章，第11节，第11-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-12_1_1</key>
<configkey>MISRA2008-12_1_1</configkey>
<name><![CDATA[ 对象的动态类型不能够从它的构造函数和析构函数的函数体中使用 [MISRA2008-12_1_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的动态类型不能够从它的构造函数和析构函数的函数体中使用 [MISRA2008-12_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在一个对象的构造和析构过程中，其最后的类型
可能不同于完全构造对象的类型。”
“成员函数(包括虚成员函数)能够为正在构造的对象调用。
同样，正在构造的对象能够是 typeid 操作符
或者 dynamic_cast 的操作数。但是，如果这些
操作在所有基类的成员初始化器完成之前的
ctor-initializer 中执行(或者从 ctor-initializer
直接或间接调用的函数中)，那么该操作的结果是不确定的。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“在构造函数或析构函数中使用对象的动态类型的
结果可能不符合开发人员的期望。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* Examples of incorrect code */
#include &lt;typeinfo&gt;
class B2
{
    public:
        virtual ~B2 ( );
        virtual void foo ( );
        B2 ( )
        {
            typeid ( B2 );                // 违规
            foo ( );                      // 违规
            dynamic_cast&lt; B2* &gt; ( this ); // 违规
        }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Examples of correct code */
#include &lt;typeinfo&gt;
class B1
{
    public:
        B1 ( )
        {
            typeid ( B1 ); // OK - B1 not polymorphic
        }
};
class B2
{
    public:
        virtual ~B2 ( );
        virtual void foo ( );
        B2 ( )
        {
            B2::foo ( );   // OK - not a virtual call
        }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 12 节, 规则 12-1-1

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-12_1_2</key>
<configkey>MISRA2008-12_1_2</configkey>
<name><![CDATA[ 一个类的所有构造函数应该显式地为它的所有直接基类和所有虚基类调用一个构造函数 [MISRA2008-12_1_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个类的所有构造函数应该显式地为它的所有直接基类和所有虚基类调用一个构造函数 [MISRA2008-12_1_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个类的所有构造函数应该显式地为它的
所有直接基类和所有虚基类调用一个构造函数。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果类没有定义任何构造函数而它的一个基类却有构造函数，
那么规则也将报告一个违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则降低了关于哪个构造函数将被使用
和包含什么参数的混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
    public:
        A ( )
        {
        }
};


class B : public A
{
    public:
        B ( ) // 违规
        {
        }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
    public:
        A ( )
        {
        }
};


class B : public A
{
    public:
        B ( ): A() // OK
        {
        }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 12 节, 规则 12-1-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-12_1_3</key>
<configkey>MISRA2008-12_1_3</configkey>
<name><![CDATA[ 能够通过单一基本类型实参调用的所有构造函数应该显式地被声明 [MISRA2008-12_1_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
能够通过单一基本类型实参调用的所有构造函数应该显式地被声明 [MISRA2008-12_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“具有单一基本类型参数可调用的构造函数应
该显式地声明。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

基本类型包括如下一些：bool，char，short，vint，
long，long long，float，double，long double，wchar_t。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止构造函数被隐式地从基本类型转换为
类类型。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C
{
    public:
        C ( int a ) // Violation
        {
        }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C
{
    public:
        explicit C ( int a ) // OK
        {
        }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 在关键系统中使用C++语言的准则
第6章，第12节，第12-1-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-12_8_1</key>
<configkey>MISRA2008-12_8_1</configkey>
<name><![CDATA[ 拷贝构造函数应该只初始化它的基类和自身是类成员的非静态成员 [MISRA2008-12_8_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
拷贝构造函数应该只初始化它的基类和自身是类成员的非静态成员 [MISRA2008-12_8_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果编译器实现检测到了对某个拷贝构造函
数的调用是冗余的，则允许省略该调用，即使
该拷贝构造函数具有除构造该对象的拷贝的其
它副作用。”
本规则能报告出是否发现了全局或静态成员变
量在拷贝构造函数中发生了修改。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则仅能监测处嵌套级数为一的函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“因此，确保拷贝构造函数不会对程序状态进
行修改是相当重要的，因为这样的修改的影响
可能是不确定的。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
    A ( A const &amp; rhs )
    : m_i ( rhs.m_i )
    {
         ++m_static;   // Violation
    }
private:
    int m_i;
    static int m_static;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止在拷贝构造函数内修改全局或静态成员变量。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++：2008 在关键系统中使用C++语言的准则
第6章，第12节，第12-8-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-12_8_2</key>
<configkey>MISRA2008-12_8_2</configkey>
<name><![CDATA[ 在抽象类中拷贝赋值运算符应该被声明为受保护的或私有的 [MISRA2008-12_8_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在抽象类中拷贝赋值运算符应该被声明为受保护的或私有的 [MISRA2008-12_8_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“抽象类代表了层次结构的接口部分。
在这类层次结构顶层调用拷贝赋值运算
符会旁路掉潜在实现，从而导致仅有基
子类型被复制。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>

用户定义的拷贝赋值运算符X::operator=
是类X的非静态、非模板成员函数，该类
仅有一个类型为X，X&amp;，常数X&amp;，非易失性
X&amp;或常数非易失性X&amp;的参数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“将抽象拷贝赋值运算符设置为保护类型
将允许从衍生类而非层次结构之外进行访
问。将拷贝赋值运算符设置为私有是一个
常用的限制拷贝该类类型的方法。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32_t;
class B1
{
    public:
        virtual void f( ) = 0;
        B1 &amp; operator= ( B1 const &amp; rhs );          // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int32_t;
class B1
{
    public:
        virtual void f( ) = 0;
    protected:
        B1 &amp; operator= ( B1 const &amp; rhs );          // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++：2008 在关键系统中使用C++语言的准则
第6章，第12节，第12-8-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-14_5_2</key>
<configkey>MISRA2008-14_5_2</configkey>
<name><![CDATA[ 当存在一个包含单个泛型参数的模板构造函数时，拷贝构造函数应该被声明 [MISRA2008-14_5_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当存在一个包含单个泛型参数的模板构造函数时，拷贝构造函数应该被声明 [MISRA2008-14_5_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“可能和开发人员的预期相反，一个模板构造函数
将不会抑制编译器生成的拷贝构造函数。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

模板类型参数 T 如果在函数声明中有(可能 cv-限定的)
T &amp;[opt] 的格式，那么它是一个泛型参数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止对需要深度拷贝成员不正确拷贝语义。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int int32_t;
class A                        // 违规
{
    public:
        A ( );
        template &lt;typename T&gt;
        A ( T const &amp; rhs )
        : i ( new int32_t )
        {
            *i = *rhs.i;
        }
    private:
            int32_t * i;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef signed int int32_t;
class A                         // OK
{
    public:
        A ( );
        A ( A const &amp; rhs );
        template &lt;typename T&gt;
        A ( T const &amp; rhs )
        : i ( new int32_t )
        {
            *i = *rhs.i;
        }
    private:
            int32_t * i;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-5-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-14_5_3</key>
<configkey>MISRA2008-14_5_3</configkey>
<name><![CDATA[ 当存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明  [MISRA2008-14_5_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明  [MISRA2008-14_5_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“可能和开发人员的预期相反，一个模板赋值运算符
将不会抑制编译器生成的拷贝赋值运算符。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

模板类型参数 T 如果在函数声明中有(可能 cv-限定的)
T &amp;[opt] 的格式，那么它是一个泛型参数。
用户声明的拷贝赋值运算符 X::operator= 
是精确地包含一个 type X, X&amp;, const X&amp;, volatile X&amp;
或 const volatile X&amp; 参数的非静态非模板成员函数



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止对需要深度拷贝成员不正确拷贝语义。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int int32_t;
class A       // 违规
{
    public:
        template &lt;typename T&gt;
        T &amp; operator= ( T const &amp; rhs )
        {
            if ( this != &amp;rhs ) {
                delete i;
                i = new int32_t; 
                *i = *rhs.i;
            }
            return *this;
         }
    private:
        int32_t * i;
};
void f ( A const &amp; a1, A &amp; a2 )
{
    a2 = a1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef signed int int32_t;
class A     // OK
{
    public:
        A &amp; operator= ( A const &amp; rhs )
        {
            i = rhs.i;
            return *this; 
        }
        template &lt;typename T&gt;
        T &amp; operator= ( T const &amp; rhs )
        {
            if ( this != &amp;rhs ) {
                delete i;
                i = new int32_t; 
                *i = *rhs.i;
            }
            return *this;
         }
    private:
        int32_t * i;
};
void f ( A const &amp; a1, A &amp; a2 )
{
    a2 = a1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-5-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-14_6_1</key>
<configkey>MISRA2008-14_6_1</configkey>
<name><![CDATA[ 在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识或 -> [MISRA2008-14_6_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识或 -&gt; [MISRA2008-14_6_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在含有依赖基础的类模板中，任何可能在这个依赖类中
被发现的名称都应该引用使用限定标识或 -&gt;”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用限定标识或用 -&gt; 限定标识符的前缀
确保选择的实体符合开发人员的预期。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int TYPE;
void g ( );
int i;
template &lt;typename T&gt;
class B;
template &lt;typename T&gt;
class A : public B&lt;T&gt;
{
    void f1 ( )
    {
        TYPE t = 0; // 违规
        g ( );      // 违规
        i++;        // 违规
    }
};
template &lt;typename T&gt;
class B
{
public:
    typedef T TYPE;
    void g ( );
    int i;
};
template class A&lt;int&gt;;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int TYPE;
void g ( );
int i;
template &lt;typename T&gt;
class B;
template &lt;typename T&gt;
class A : public B&lt;T&gt;
{
    void f1 ( )
    {
        ::TYPE t1 = 0; // OK - explicit use global TYPE
        ::g ( );       // OK - explicit use global func
        ::i++;         // OK - explicit use global var
        typename B&lt;T&gt;::TYPE t2 = 0; // OK - explicit use base TYPE
        this-&gt;g ( );                // OK - explicit use base "g"
        this-&gt;i;                    // OK - explicit use base "i"
    }
};
template &lt;typename T&gt;
class B
{
public:
    typedef T TYPE;
    void g ( );
    int i;
};
template class A&lt;int&gt;;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-6-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-14_7_3</key>
<configkey>MISRA2008-14_7_3</configkey>
<name><![CDATA[ 一个模板的所有局部和显式的特化应该在它们原始模板的同一个文件中被定义 [MISRA2008-14_7_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个模板的所有局部和显式的特化应该在它们原始模板的同一个文件中被定义 [MISRA2008-14_7_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果对于一个模板参数集，隐式的实例是由
编译器自动生成的，并且局部的或显式的
特化是在程序的其他匹配模板参数集的地方
声明和定义的，那么这是一个不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.h

template &lt;typename T&gt; void foo () {}

// file.cpp

#include "file.h"

template &lt;&gt; void foo&lt;int&gt; () {} // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.h

template &lt;typename T&gt; void foo () {}

template &lt;&gt; void foo&lt;int&gt; () {} // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-7-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-14_8_1</key>
<configkey>MISRA2008-14_8_1</configkey>
<name><![CDATA[ 重载函数模板不得显式地特化 [MISRA2008-14_8_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
重载函数模板不得显式地特化 [MISRA2008-14_8_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“重载函数模板不得显式地特化。
显式的特化将只在重载解析已经从原始函数模板集中
选择了一个最佳匹配之后被考虑。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“凡是模板没有被其他模板重载，或者被
非模板函数重载那么它可以显式地特化，
因为它是符合开发人员的预期：显式的特化
将只在选择了原始模板时才被考虑。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template &lt;typename T&gt; void f ( T );
template &lt;typename T&gt; void f ( T* );
template &lt;&gt; void f&lt;int*&gt; ( int* ); // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

template &lt;typename T&gt; void f ( T );
template &lt;&gt; void f&lt;int*&gt; ( int* );  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-8-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-14_8_2</key>
<configkey>MISRA2008-14_8_2</configkey>
<name><![CDATA[ 函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化 [MISRA2008-14_8_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化 [MISRA2008-14_8_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“函数调用的可行函数集合应该要么不包括
函数特化，要么只包括函数特化。如果一个
函数和一个函数模板的特化在重载解析之后
被认为等价，那么非特化函数会在函数特化
中被选择。”


例外:

“此规定不适用于拷贝构造函数或拷贝赋值运算符。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止编写的代码可能与
开发人员的期望不一致。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void f ( short b){}                    // Example 1
template &lt;typename T&gt; void f ( T ){}   // Example 2

void b ( short s )
{
    f ( s );      // 违规 - Calls Example 1
    f ( s + 1 );  // 违规 - Calls Example 2
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void f ( short b){}                    // Example 1
template &lt;typename T&gt; void f ( T ){}   // Example 2

void b ( short s )
{
    f&lt;&gt; ( s );      // OK - Calls Example 2
    f&lt;&gt; ( s + 1 );  // OK - Calls Example 2
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-8-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_0_2</key>
<configkey>MISRA2008-15_0_2</configkey>
<name><![CDATA[ 一个例外对象不得有指针类型 [MISRA2008-15_0_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个例外对象不得有指针类型 [MISRA2008-15_0_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果抛出指针类型的异常对象，并且该指针指向
了一个动态创建的对象，那么可能会不清楚哪一个
函数是负责销毁它的，同时也不清楚在什么时候。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止内存管理问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef short int16_t;
class A
{
    // Implementation
};
void fn ( int16_t i )
{
    static A a1;
    A* a2 = new A;
    if ( i &gt; 10 )
    {
        throw ( &amp;a1 ); // 违规– 指针类型抛出
    }
    else
    {
        throw ( a2 ); // 违规– 指针类型抛出
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef short int16_t;
class A
{
    // Implementation
};

void fn ( int16_t i )
{
    static A a1;
    A* a2 = new A;
    if ( i &gt; 10 )
    {
        throw ( a1 );  // OK
    }
    else
    {
        throw ( *a2 ); // OK
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 15 节, 规则 15-0-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_0_3</key>
<configkey>MISRA2008-15_0_3</configkey>
<name><![CDATA[ 不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中 [MISRA2008-15_0_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中 [MISRA2008-15_0_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果程序使用 goto 或 switch 开关语句将控制传递
到 try 或 catch 块中，那么程序是不规范的；然而，
并非所有的编译器会发布一个诊断消息。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则检测不是所有的编译器都会报告的错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* The code is compilable with MSVC 6.0 */
class Exception{};
void f ( int i )
{
    if ( 10 == i )
    {
        goto Label_10;
    }
    switch ( i )
    {
        case 1:
            try
            {
                Label_10: // 违规
                case 2:   // 违规
                    break;
            }
            catch ( Exception e )
            {
            }
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* The example of correct code */
class Exception{};
void f ( int i )
{
    if ( 10 == i )
    {
        goto Label_10;
    }
    switch ( i )
    {
        case 1:   // OK
            try
            {
                  // ... 
            }
            catch ( Exception e )
            {
            }
        case 2:   // OK
            break;
    }
    Label_10:     // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-0-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_1_1</key>
<configkey>MISRA2008-15_1_1</configkey>
<name><![CDATA[ throw 语句的赋值表达式不得自身引起一个异常抛出 [MISRA2008-15_1_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
throw 语句的赋值表达式不得自身引起一个异常抛出 [MISRA2008-15_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果当构造异常对象，或者当初始化此异常对象的
赋值表达式求值的时候抛出一个异常，
那么这就是一个异常，并且优先于
正要被抛出的异常。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class E
{
public:
    E ( )
    {
        throw 10;
    }
};
int foo1()
{
    try
    {
        if ( 0 )
        {
            throw E ( ); // 违规
        }
    }
    catch(...)
    {
    	
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class E
{
public:
    E ( ){ }
};

int foo()
{
    try
    {
        if ( 0 )
        {
            throw E ( ); // OK
        }
    }
    catch(...)
    {
    	
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-1-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_1_2</key>
<configkey>MISRA2008-15_1_2</configkey>
<name><![CDATA[ NULL 不得被显式地抛出 [MISRA2008-15_1_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
NULL 不得被显式地抛出 [MISRA2008-15_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“抛出空 throw(NULL) (相当于 throw(0)) 绝不是空指针常数 
(null-pointer-constant) 的抛出，所以只能被一个整数处理程序捕获。
这可能是不符合开发人员的期望，尤其是如果
该项目只具有指针类型(pointer-to-type)异常的处理程序”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define NULL 0
void foo()
{
    try
    {
        throw ( NULL ); // 违规
    }
    catch ( int i )     // NULL exception handled here
    {
        // ...
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define NULL 0
void foo()
{
    try
    {
        throw ( 0 ); // OK
    }

    catch ( int i ) // NULL exception handled here
    {
        // ...
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-1-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_1_3</key>
<configkey>MISRA2008-15_1_3</configkey>
<name><![CDATA[ 空的抛出 (throw;) 应该只用于 catch 处理程序的复合语句中 [MISRA2008-15_1_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
空的抛出 (throw;) 应该只用于 catch 处理程序的复合语句中 [MISRA2008-15_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“空的抛出重新抛出代表一个异常的对象。
它的使用目的是能够处理跨越两个或多个
处理程序的异常。
然而，语法上，没有任何防止抛出的可能；正在 catch 处理程序
之外被使用，这里没有异常对象重新抛出。这可能导致
执行定义的程序终止。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止实现定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Exception{};
void foo(int a) 
{
    Exception E;
    if(a)
    {
        throw;   // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception{};
void foo(int a) 
{
    Exception E;
    if(a)
    {
        throw E;       // OK
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-1-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_3_1</key>
<configkey>MISRA2008-15_3_1</configkey>
<name><![CDATA[ 应该只能在程序启动之后和终止之前引起异常 [MISRA2008-15_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该只能在程序启动之后和终止之前引起异常 [MISRA2008-15_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在程序开始执行 main 函数体之前，它是在启动
阶段，构造和初始化静态对象。同样，在 main 函数
返回之后，它是在静态对象被销毁的终止阶段。
如果在这两个阶段抛出一个异常，那么它会导致
程序按照一个实现定义的方式终止。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则只检查一层的嵌套函数调用。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“按照实现定义的方式抛出一个在程序启动
或程序结果终止期间的异常。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C
{
public:
    C ( )
    {
        throw ( 0 ); // 违规– 在 main 开始之前抛出
    }
    ~C ( )
    {
        throw ( 0 ); // 违规– 在 main 退出之后抛出
    }
};
C c;

int main( ... )
{ 
	// ...
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

异常不应该在程序启动或终止阶段抛出。  



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_3_2</key>
<configkey>MISRA2008-15_3_2</configkey>
<name><![CDATA[ 应该至少有一个异常处理程序来捕获所有其他未处理的异常 [MISRA2008-15_3_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该至少有一个异常处理程序来捕获所有其他未处理的异常 [MISRA2008-15_3_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个程序抛出一个未处理的异常，
那么它以实现定义的方式终止。特别的，
在终止之前调用栈是否已经展开是实现定义的，
所以任何自动对象的析构函数可能会也可能不会被执行。
通过实施一个“最后的防线捕获所有(last-ditch catch-all)”的规定，
开发人员能够确保程序以一致的方式终止。”
此规则检查 'main' 函数最外面的语句是否包含
捕获所有(catch-all)处理函数的 try 语句。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则检查是否包含捕获所有(catch-all)处理函数的
try 语句直接在 'main' 函数中执行。
无法检测到那些从 'main' 函数调用并实现在函数中的语句。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Exception{};
int main( )
{
    try  // 违规
    { 
        // ...
    }
    catch ( Exception e )
    {
        // ...
    }
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception{};
int main( )
{
    try  // OK
    { 
        // ...
    }
    catch ( Exception e )
    {
        // ...
    }
    catch ( ... )
    {
        // ...
    }
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 15 节, 规则 15-3-2

2. <A HREF="http://cwe.mitre.org/data/definitions/391.html">http://cwe.mitre.org/data/definitions/391.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_3_3</key>
<configkey>MISRA2008-15_3_3</configkey>
<name><![CDATA[ 类的构造函数或析构函数中执行 try 功能模块的处理程序不得引用来自此类或其基础类的非静态成员 [MISRA2008-15_3_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类的构造函数或析构函数中执行 try 功能模块的处理程序不得引用来自此类或其基础类的非静态成员 [MISRA2008-15_3_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在类的构造函数或析构函数中的 try 功能模块的
处理程序中(例如，catch 部分)访问一个类或基类的
非静态(non-static)成员是不允许的。 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“在类的构造函数或析构函数中的 try 功能模块的
处理程序中(例如，catch 部分)访问一个类或基类的
非静态成员是不确定的。例如，如果在创建对象的过程中
抛出一个内存分配异常，那么当处理程序试图去
访问其成员时该对象不存在。 相反，在析构函数中，
该对象可能在异常被处理之前已经成功销毁，
因此不会对处理程序可用。相比之下，静态成员的生命期
大于对象本身的生命期，所以静态成员能够保证
在处理程序访问它时存在。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32_t;
class C
{
    public:
        int32_t x;
        C( )
    try
    {
        // Action that may raise an exception
    }
    catch ( ... )  // Violation
    {
        if ( 0 == x ) // Non-compliant – x may not exist at this point
        {
            // Action dependent on value of x
        }
    }
    ~C ( )
    try
    {
        // Action that may raise an exception
    }
    catch ( ... )  // 违规
    {
	    if ( 0 == x ) // Non-compliant – x may not exist at this point
        {
            // Action dependent on value of x
        }
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在类的构造函数或析构函数中的 try 功能模块的处理程序中
使用类或基类非静态成员。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_3_4_a</key>
<configkey>MISRA2008-15_3_4_a</configkey>
<name><![CDATA[ 代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [MISRA2008-15_3_4_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [MISRA2008-15_3_4_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个程序抛出未处理的异常，那么它会以实现定义
的方式终止。特别是，它是实现定义是否调用栈
在终止之前展开，所以任何自动对象的析构函数
可能会或不会被调用。 如果抛出一个异常
作为一个派生类的对象，那么“兼容类型(compatible type)”
可以是该派生类或者其任何基类。”
如果从 'main' 函数体，或者从没有任何
在异常规范列表上记录异常的函数体中 
抛出一个未处理的异常，那么规则报告违规。
参见: EXCEPT-18



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只检查一层嵌套函数的调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此规则的目的是程序应该捕获
所有预期抛出的异常。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
class B {};

void main ( int i ) throw ( )
{
    try
    {
        if ( i &gt; 10 )
        {
            throw A ( );
        }
        else
        {
            throw B ( ); // 违规
        }
    }
    catch ( A const &amp; )
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {};
class B {};

void main ( int i ) throw ( )
{
    try
    {
        if ( i &gt; 10 )
        {
            throw A ( );
        }
        else
        {
            throw B ( ); // OK
        }
    }
    catch ( A const &amp; )
    {
    }
    catch ( B const &amp; )
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-4

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_3_4_b</key>
<configkey>MISRA2008-15_3_4_b</configkey>
<name><![CDATA[ 代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [MISRA2008-15_3_4_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序 [MISRA2008-15_3_4_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个程序抛出未处理的异常，那么它会以实现定义
的方式终止。特别是，它是实现定义是否调用栈
在终止之前展开，所以任何自动对象的析构函数
可能会或不会被调用。 如果抛出一个异常 
作为一个派生类的对象，那么“兼容类型(compatible type)”
可以是该派生类或者其任何基类。”
如果当一个非本地对象被声明或初始化时 
抛出一个未处理的异常，那么规则报告违规。
参见: EXCEPT-13



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只检查一层嵌套函数的调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此规则的目的是程序应该捕获
所有预期抛出的异常。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B{};
class A {
    int i;
    A ( ) : i(1)
    {
        try
        {
            if ( i &gt; 10 )
            {
                throw A ( );
            }
            else
            {
                throw B ( ); 
            }
        }
        catch ( A const &amp; )
        {
        }
    }
};
A a; // 违规 - unhandled exception of class B



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B{};
class A {
    int i;
    A ( ) : i(1)
    {
        try
        {
            if ( i &gt; 10 )
            {
                throw A ( );
            }
            else
            {
                throw B ( ); 
            }
        }
        catch ( A const &amp; )
        {
        }
        catch ( B const &amp; )
        {
        }
    }
};
A a; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 15 节, 规则 15-3-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_3_5</key>
<configkey>MISRA2008-15_3_5</configkey>
<name><![CDATA[ 类类型的异常应该始终被引用捕获 [MISRA2008-15_3_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类类型的异常应该始终被引用捕获 [MISRA2008-15_3_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个类类型的异常按照值方式捕获，会发生切断（派生关系）。
也就是说，如果是一个派生类的异常对象并且作为基类捕获，
那么只有此基类的函数（包括虚函数）可以被调用。 
此外，任何在派生类中的其他成员数据不能被访问。”
此规则检测按照值方式捕获类或结构类型的异常对象。 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果异常按照引用方式被捕获，不会发生切断（派生关系）。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class ExpBase
{
};
class ExpD1: public ExpBase
{
};
void foo()
{
    try
    {
        throw ExpD1 ( );
        throw ExpBase ( );
    }
    catch ( ExpBase b ) // 违规 - derived type objects will be
    // caught as the base type
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class ExpBase
{
};
class ExpD1: public ExpBase
{
};
void foo()
{
    try
    {
        throw ExpD1 ( );
        throw ExpBase ( );
    }
    catch ( ExpBase &amp;b ) // OK - exceptions caught by reference
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-5

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_3_6</key>
<configkey>MISRA2008-15_3_6</configkey>
<name><![CDATA[ 如果在单独的 try-catch 语句或 try 功能模块中提供多个处理程序给派生类和部分或全部的基类时，这些处理程序应该遵循从最底层的派生类到基类的顺序。 [MISRA2008-15_3_6] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果在单独的 try-catch 语句或 try 功能模块中提供多个处理程序给派生类和部分或全部的基类时，这些处理程序应该遵循从最底层的派生类到基类的顺序。 [MISRA2008-15_3_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在单独的 try-catch 语句或 try 功能模块中 
提供多个处理程序给派生类和部分或全部的基类时，
这些处理程序应该遵循从最底层的派生类到基类的顺序。
当测试来看是否异常的类型匹配一个处理程序的类型，
一个派生类的异常会匹配其基类的处理程序。
如果基类的处理程序在派生类的处理程序之前被找到，
那么就会使用基类的处理程序。派生类的处理程序是不可达的代码
并且不会被执行。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可阻止写入不可达的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B { };
class D: public B { };

void foo()
{

	try
	{
		// ...
	}
	catch ( B &amp;b )
	{
		// ...
	}
	catch ( D &amp;d ) // 违规
	{
		// ...
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B { };
class D: public B { };

void foo()
{
	try
	{
		// ...
	}
	catch ( D &amp;d ) // OK - Derived class caught before base class
	{
		// ...
	}
	catch ( B &amp;b ) // OK - Base class caught after derived class
	{
		// ...
	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-3-6

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_5_1</key>
<configkey>MISRA2008-15_5_1</configkey>
<name><![CDATA[ 类的析构函数不得带有异常退出 [MISRA2008-15_5_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类的析构函数不得带有异常退出 [MISRA2008-15_5_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否从一个析构函数中抛出异常。 
这条规则只是针对 C++ 编程语言。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止从一个析构函数中抛出异常。它可能会导致内存泄漏
和不当的对象析构。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Foo {
public:
    Foo( ) { }
    ~Foo( ) {
        throw;  // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception {};

class Foo {
public:
    Foo( ) { }
    ~Foo( ) {
        try {       // OK 
        } catch (Exception&amp; e) {
            // 捕获所有的异常
        }
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 2 章, 第 8 项

2. <A HREF="http://www.cs.helsinki.fi/u/vihavain/s03/cpp/items/CppStyleRules2.html">http://www.cs.helsinki.fi/u/vihavain/s03/cpp/items/CppStyleRules2.html</A>

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-5-1

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_5_2</key>
<configkey>MISRA2008-15_5_2</configkey>
<name><![CDATA[ 如果一个函数的声明包括一个异常规范，这个函数应该只能抛出所指明类型的异常。 [MISRA2008-15_5_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个函数的声明包括一个异常规范，这个函数应该只能抛出所指明类型的异常。 [MISRA2008-15_5_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果具有一个异常规范声明的函数抛出一个
没有包括在规范中的异常类型，那么 unexpected() 函数
就会被调用。此函数的行为能够被覆盖在整个项目中，
但是默认情况下会导致抛出 std::bad_exception 的异常。
如果 std::bad_exception 没有被列在异常规范中，
那么 terminate() 将会被调用，从而导致 
程序的实现定义终止。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则只检查两层的嵌套函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Exception{};
void foo ( )
{
    throw ( 21 );
}
void goo ( ) throw ( Exception )  // 违规
{
    foo ( );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Exception{};
void foo ( )
{
    throw ( 21 );
}
void goo ( ) throw ( Exception, int ) // OK
{
    foo ( );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 15 节, 规则 15-5-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-15_5_3</key>
<configkey>MISRA2008-15_5_3</configkey>
<name><![CDATA[ terminate() 函数不得被隐式地调用 [MISRA2008-15_5_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
terminate() 函数不得被隐式地调用 [MISRA2008-15_5_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“调用栈是否在调用 terminate() 之前被展开是
实现定义的，所以任何自动对象的析构函数可能被执行，
或者可能不被执行。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止实现定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C 
{
 public:
    C() { throw 1; }
};

void fnExit1 (void)
{
  C c;
  /* ... */
}

void foo()
{
  atexit (fnExit1);  // 违规
  /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C 
{
 public:
    C() 
    {
    	try
    	{ 
    		/* ... */
    		throw 1;
    	}
    	catch(...)
    	{
    		/* ... */
    	} 
    }
};

void fnExit1 (void)
{
  C c;
  /* ... */
}

void foo()
{
  atexit (fnExit1);  // OK
  /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 15 节, 规则 15-5-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_0_1</key>
<configkey>MISRA2008-16_0_1</configkey>
<name><![CDATA[ 文件中的 #include 指示符应该只能在其他预处理指令或注释之前 [MISRA2008-16_0_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
文件中的 #include 指示符应该只能在其他预处理指令或注释之前 [MISRA2008-16_0_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个特别的代码文件中，所有的#include语句
都应该被组织在一起放在靠近文件头的位置。
这个规则表明在一个文件中先于一个#include语句
的只可能是其它的预处理指令或者注释。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

用来在一条#include指令前，阻止可执行代码的位置是重要的。
否则的话，这将会有一种危险：
代码将会试图使用定义在头文件里面的代码项。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo();
int g;
#include "test.h"  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "test.h"  // OK
void foo();
int g;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-1条规则

3. Origin: Misra Guidelines - Rule 87

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_0_2</key>
<configkey>MISRA2008-16_0_2</configkey>
<name><![CDATA[ 应该只能在全局的命名空间中使用 #define 或 #undef 宏 [MISRA2008-16_0_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该只能在全局的命名空间中使用 #define 或 #undef 宏 [MISRA2008-16_0_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

尽管在一个代码文件的任何地方放置 #define 或者
#undef 是合法的，但是把他们放在程序块中是一个误导，
因为这样意味着给那段程序块一个范围限制，
但是本意却不是那样的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int* x ) {
#define CHECKPARAM(p) (p != 0)  // 违规
    if (CHECKPARAM(x)) {
	/* ... */
    }
#undef CHECKPARAM               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define CHECKPARAM(p) (p != 0) // OK- 宏在任何块的外面定义
void foo( int* x ) {
    if (CHECKPARAM(x)) {
        /* ... */
    }
}
#undef CHECKPARAM              // OK- 宏在任何块的外面撤销定义



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6,章 第19部分

2. 来源: Misra指南-第91条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_0_3</key>
<configkey>MISRA2008-16_0_3</configkey>
<name><![CDATA[ 不得使用 #undef [MISRA2008-16_0_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 #undef [MISRA2008-16_0_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#undef通常都是不需要的。它的使用可能
导致混淆或者在代码中使用的时候意味着宏操作。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#undef TEST        /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 #undef.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. 来源: Misra指南- 第92条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
    第6章，第16部分，第16-0-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_0_4</key>
<configkey>MISRA2008-16_0_4</configkey>
<name><![CDATA[ 不得定义类函数宏 [MISRA2008-16_0_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得定义类函数宏 [MISRA2008-16_0_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则在一个类似函数的定义中报告一个违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

尽管宏与函数相比，可以提供一种速度上的优势，
但是函数提供了一种更安全和更稳健的机制。
这对于参数的类型检查是非常适用的，并且在
像函数一样宏里面对潜在地多次估计参数值的
问题的解决也是非常适用的。


同样可参见: CODSTA-03, CODSTA-37, CODSTA-38, CODSTA-39, CODSTA-40



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define SUM(A,B) ((A)+(B))  /* 违规 */

void foo( int x, int y ) {
    /* ... */
    SUM( x, y );
    /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int sum( int a, int b ) {    /* OK*/
    return (a + b);
}

void foo( int x, int y ) {
    /* ... */
    sum( x, y );
    /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. Scott Meyers, "Effective C++: 55中特殊方法提高您的程序设计 Sp", 第三版, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章, 第2项

3. Misra 指南- 第93条规则

4. Ellemtel 编码标准 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 9 函数 - 9.5 联机函数 - 第35条规则

5. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.6章 预处理指令, AV 第29条规则	

6. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第16部分，第16-0-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_0_5</key>
<configkey>MISRA2008-16_0_5</configkey>
<name><![CDATA[ 传递给类函数宏的实参不得包括看起来像预处理指令的符号 [MISRA2008-16_0_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
传递给类函数宏的实参不得包括看起来像预处理指令的符号 [MISRA2008-16_0_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果任何参数看起来像预处理指令，
那么当宏置换发生时，后果是不可预测的。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则仅在一个文件范围内有效。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵从此规则，将会拥有更安全的代码和更好的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MACRO1(x)
#define MACRO2(x, y)

void foo( void ) {
    int i = 0;
    MACRO1( #foo );       /* 违规 */
    MACRO2( i, #foo );    /* 违规 */
    MACRO2( i, "#foo" );  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MACRO1(x) 
#define MACRO2(x, y) 

void foo( void ) {
    int i = 0;
    MACRO1( i );          /* OK */
    MACRO2( i, i );       /* OK  */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第19部分

2. 来源: Misra 指南 - Rule 95

3. MISRA C++:2008 C++语言在关键系统中的使用指南
  第6章，第16部分，第16-0-5条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_0_6</key>
<configkey>MISRA2008-16_0_6</configkey>
<name><![CDATA[ 在类函数宏的定义中，每个参数的实例应该置于括号内，除非它是作为 # 或 ## 的操作数 [MISRA2008-16_0_6] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在类函数宏的定义中，每个参数的实例应该置于括号内，除非它是作为 # 或 ## 的操作数 [MISRA2008-16_0_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果不使用括号，那么当预处理器替代宏到
代码中时运算符的优先级可能不会如预期结果一样，
在一个类似函数宏的定义中，应该将参数用括号
括起来。"
参见: MISRA-096


例外:

如果宏参数在函数体中的 '.', '-&gt;', '::' 之后或在 '::'之前使用，
那么将不会报告违规， 因为在这种情况下使用的括号
使得代码非可编译。例如:
  #define INIT1(member) a-&gt;member = 0 // 没有报告违规
  #define CALL(ns,fn) ns::fn() // 没有报告违规



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的稳定性并确保操作顺序。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

在某些情况下报告一个违规，但括号的使用导致
编译错误。例如:
  #define MTYPE(type, a)  (type *)(a)  // 报告违规
  #define MT(classtype, type) classtype&lt;type&gt;  // 报告违规



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define abs(x) ((x &gt;= 0) ? x : -x)   // 违规

void foo(int a, int b){
    int z = abs(a - b);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define abs(x) (((x) &gt;= 0) ? (x) : -(x))   // OK

void foo(int a, int b){
    int z = abs(a - b);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 19

2. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 16, Rule 16-0-6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_0_7</key>
<configkey>MISRA2008-16_0_7</configkey>
<name><![CDATA[ 未定义的宏标识符不得在 #if 或 #elif 预处理指令中使用，除了作为 defined 运算符的操作数 [MISRA2008-16_0_7] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
未定义的宏标识符不得在 #if 或 #elif 预处理指令中使用，除了作为 defined 运算符的操作数 [MISRA2008-16_0_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果想在一段预处理程序中使用一个标识符，
并且那个标识符没有被定义的话，处理器有时候
不会给与任何警告，仅假设它的值为0.
#ifdef, #ifndef 和defined()语句用来就是用来测试宏
的存在，因此不在以上所说情况的范围之内。

缺点：

1)当前来说，该规则的实现假设服从MISRA 2004 19-11(p. 78)
忠告提供的规则。在使用一个标识符之前，最好考虑
使用一个#ifdef测试语句。 

2) 如果#1后面没有跟随代码的话，由于技术上的原因
以下情况我们不能识别：
预处理的标识符在不同的文件中定义，在另一个文件中访问。
同样，我们不可能检测被给与的标识符被定义为编译命令行选项。

3) 如果宏标识符已经在#define预处理程序中定义了，它不能
定义在较多的嵌套的#if  #elif  #else  #endif指令里面。
在这样的情况下，此规则可能报告假错误。 

4)如果宏标识符定义在复杂的条件语句里面（包含一些分支#elif#else），
我们不能确保分支包含的宏定义是否执行了。
在这样的情况下，此规则可能报告假错误。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵从此规则将会是代码更加安全并且阻止一些难以检查的错误发生。




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#if X 
 /*违规 - X 在这里还没有被定义*/
#endif

#if Y
 /*违规 - Y 在这里还没有被定义*/
#endif

#if X + Y
 /*违规 - X 和 Y在这里还没有被定义*/
#endif

#ifdef X
#define Y 1
#else
#define Y 3
#endif

#if Y  2  // 违规 - 参见第3点
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define X 1

#if X
 /*OK*/
#endif

#ifdef Y
#if Y
 /*正常 - 已经在上面的#ifdef中做了检查 */
#endif
#endif

#ifdef X
#define Y 1
#else
#define Y 3
#endif

#ifdef Y
#if Y  2   // 正常 - 可能的工作区，参看第3点
#endif
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. 来源： Misra 指南 - 第97条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_0_8</key>
<configkey>MISRA2008-16_0_8</configkey>
<name><![CDATA[ 如果符号 # 作为一行的第一个符号出现，那么预处理符号应该紧接着 [MISRA2008-16_0_8] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果符号 # 作为一行的第一个符号出现，那么预处理符号应该紧接着 [MISRA2008-16_0_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当一段源代码被预处理指令排除在外的时候，
每一个排除在外的语句的内容都会被忽略，直到遇到
一个#else, #elif 或者 #endif 指令（由上下文决定）。
如果这些排除在外的指令组织得不好的话，编译器将会
不带警告地忽略掉，这可能带来不幸的后果。
此规则要求，即使是排除在外的代码，所有的预处理指令
应在语句构成上是合法的。编译器在实施这项 ISO 要求上，
不会总是一致的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了错误的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MAX 2

int foo(void)
{
	int x = 0;
	
#ifndef MAX
	x = 1;
#else1              /* 违规 */
	x = MAX;
#endif
	return x;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MAX 2

int foo(void)
{
	int x = 0;
	
#ifndef MAX
	x = 1;
#else              /* OK */
	x = MAX;
#endif
	return x;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-0-8条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_1_1</key>
<configkey>MISRA2008-16_1_1</configkey>
<name><![CDATA[ defined 预处理运算符应该只能用于两个标准形式之一 [MISRA2008-16_1_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
defined 预处理运算符应该只能用于两个标准形式之一 [MISRA2008-16_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

两种仅有的可允许的预处理操作符的定义的形式：
  - defined ( identifier )
  - defined identifier
  其它的形式将会导致未定义的行为。
在一个#if 或者 #elif预处理指令中，产生一个
定义代号同样也会导致未定义的行为，应该避免。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未知的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#if defined X &gt; Y             // 违规
#endif
#define DEFINED defined  
#if DEFINED(X)              // 违规  
#endif


改正:

#if defined X            // OK
#endif
#if defined (X)          // OK
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_1_2</key>
<configkey>MISRA2008-16_1_2</configkey>
<name><![CDATA[ 所有的 #else, #elif 和 #endif 预处理指令应该存在于和 #if 或 #ifdef 指示符相关的相同文件中 [MISRA2008-16_1_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的 #else, #elif 和 #endif 预处理指令应该存在于和 #if 或 #ifdef 指示符相关的相同文件中 [MISRA2008-16_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当语句块的包含和不包含由一系列预处理指令控制时，
如果所有相关的指令不在一个文件里面的话，
可能会引起混淆。此规则要求预处理指令 #if/ifdef/ifndef 的
个数必须与文件中 #endi f的个数相匹配。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提升了良好的代码结构，阻止了一些问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 违规 */
#define A
#ifdef A
#include "file1.h"
#endif
#if 1
#include "file2.h"



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* OK*/
#define A
#ifdef A
#include "file1.h"
#endif
#if 1
#include "file2.h"
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
    第6章，第16部分，第16-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_2_1_a</key>
<configkey>MISRA2008-16_2_1_a</configkey>
<name><![CDATA[ 不得使用宏 [MISRA2008-16_2_1_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用宏 [MISRA2008-16_2_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

宏通常是从 C 语言继承来的一个陈旧的构造。 
使用宏的主要问题是:
- 不是类型安全的
- 是被预处理器扩大了，所以调试它们是不可能的
- 纯粹根据运气创建丑陋问题的程序可以编译


例外:

宏几乎没有必要存在于 C++ 语言中。此规则的例外是:
- #ifdef
- #ifndef
- #if
- #if defined
当被用作 include 防范和条件编译。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可靠性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PI 3.14  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const double PI = 3.14; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范” Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Coding Style", 第 16 条规则

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 31 条规则

3. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_2_1_b</key>
<configkey>MISRA2008-16_2_1_b</configkey>
<name><![CDATA[ #ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [MISRA2008-16_2_1_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
#ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [MISRA2008-16_2_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#ifndef 和 #endif 预处理指令将仅用于
下面的例子中定义那样来防止重复地包含
相同的头文件。

#ifndef Header_filename
#define Header_filename
// 头文件声明...
#endif



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

有条件的代码编译应该保持最小量，
因为他能显著地使测试和维护工作变得不清晰。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifndef MAX                 // 违规

int max = 10;

#endif                      // 违规

int a;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef FOO_H               // OK
#define FOO_H 

int max = 10;
int a;

#endif                      // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 28 条规则

2. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1
3. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_2_1_c</key>
<configkey>MISRA2008-16_2_1_c</configkey>
<name><![CDATA[ 以下的预处理器指令不得使用: #if, #elif, #else, #ifdef, #undef, #pragma [MISRA2008-16_2_1_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
以下的预处理器指令不得使用: #if, #elif, #else, #ifdef, #undef, #pragma [MISRA2008-16_2_1_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只有下列预处理器指令才应该被使用: #ifndef,
#define, #endif, #include



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

限制预处理器的使用的情况是必要的。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#pragma once // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef FOO_H              // OK
#define FOO_H
/* ... */
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 26 条规则

2. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1

3. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_2_2</key>
<configkey>MISRA2008-16_2_2</configkey>
<name><![CDATA[ C++ 宏应该只能用于: 包含保护，类型修饰符，或存储类限定符 [MISRA2008-16_2_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
C++ 宏应该只能用于: 包含保护，类型修饰符，或存储类限定符 [MISRA2008-16_2_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“C++ 宏应该只能用于包含保护(include guards)，类型修饰符，
或存储类限定符。这是唯一允许使用宏的情况。C++ 提供
const 变量和函数模板，它为预处理器提供了一个类型安全
的替代”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

类型修饰符和存储类限定符的列表:
// 类型修饰符:
    const
    volatile
// 存储类限定符:
    auto
    register
    static
    extern
    mutable 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可靠性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PI 3.14         // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define STOR extern     // OK storage class specifier
const double PI = 3.14; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 16 节, 规则 16-2-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_2_3</key>
<configkey>MISRA2008-16_2_3</configkey>
<name><![CDATA[ 应该提供包含保护 [MISRA2008-16_2_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该提供包含保护 [MISRA2008-16_2_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每一个包括文件必须包含一种机制，防止文件被多次 
列入."
多重包含机制应界定为:

#ifndef FILENAME_H
#define FILENAME_H
// 代码
#endif

或

#if !defined(FILENAME_H)
#define FILENAME_H
// 代码
#endif

参见: PFO-07, PFO-08, MISRA2004-19_15



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范可以提高代码可维护性和优化.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file foo.hh
// 违规 - 无多重包含机制存在



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file foo.hh
// 正确
#ifndef FOO_HH
#define FOO_HH
int i;
#endif


参考:

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   出处: 4 源码文件 - 4.4 头文件 - Rule 7

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.6 章节 预处理指令 (Pre-Processing Directives), AV Rule 27

3. MISRA C++:2008 - 在关键系统中使用 C++ 语言的
   指导, 第 6 章节, 16 段, Rule 16-2-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_2_4</key>
<configkey>MISRA2008-16_2_4</configkey>
<name><![CDATA[ 字符 ', ", /* 或 // 不得出现在头文件的名称中 [MISRA2008-16_2_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符 ', ", /* 或 // 不得出现在头文件的名称中 [MISRA2008-16_2_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在头文件的名称预处理标记中 ', ", /* 或 // 字符
用于 &lt; 和 &gt; 分隔符之间或者 ', /* 或 // 字符用于 " 分隔符之间，
那么这是不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "fi'le.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "file.h"  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 16 节, 规则 16-2-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_2_5</key>
<configkey>MISRA2008-16_2_5</configkey>
<name><![CDATA[ 字符 \ 不得出现在头文件的名称中 [MISRA2008-16_2_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符 \ 不得出现在头文件的名称中 [MISRA2008-16_2_5-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在头文件的名称预处理标记中 \ 字符
用于 &lt; 和 &gt; 分隔符之间或者 " 分隔符之间。
请注意，此规则只是一个建议，因为有些环境使用 \ 作为
文件名的分隔符。这些环境的编译器通常都支持
在 #include 指令中使用 / 。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "fi\\le.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "file.h"  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 16 节, 规则 16-2-5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_3_1</key>
<configkey>MISRA2008-16_3_1</configkey>
<name><![CDATA[ 在单个的宏定义中应该最多出现一个 # 或 ## 操作符 [MISRA2008-16_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在单个的宏定义中应该最多出现一个 # 或 ## 操作符 [MISRA2008-16_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有关#和##预处理操作符，赋值的顺序一直有争议。
为了避免这类问题，两个操作符仅仅只有一个
可以出现在单个的宏定义中。
(i.e. 一个#, 或者一个## 或者都没有).



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define TEST1(A,B,C) A # B # C      // 违规 
#define TEST2(A,B,C) A ## B # C      //违规 
#define TEST3(A,B,C) A ## B ## C    // 违规 



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define TESTa(A,B) A # B            // OK
#define TESTb(A,B) A ## B            // OK 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. 来源： Misra 指南 - 第98条规则

3. MISRA C++2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-3-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_3_2</key>
<configkey>MISRA2008-16_3_2</configkey>
<name><![CDATA[ 不得使用 # 和 ## 操作符 [MISRA2008-16_3_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 # 和 ## 操作符 [MISRA2008-16_3_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有关#和##预处理操作符，赋值的顺序一直有争议。
编译器在这些操作符的实现中是不一致的，
因此问了避免这些问题不要使用他们。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来阻止 # 和 ##操作符的不一致的实现。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define stringer( x ) printf( #x "\n" ) /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用# 和 ## 预处理操作符。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第19部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第16部分，第16-3-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-16_6_1</key>
<configkey>MISRA2008-16_6_1</configkey>
<name><![CDATA[ 所有使用 #pragma 指示符应该被注释说明 [MISRA2008-16_6_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有使用 #pragma 指示符应该被注释说明 [MISRA2008-16_6_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有编译指令的使用都需要文档化并加注释。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#pragma TEST            /* Violation */

/* comment in wrong place */

#pragma TEST            /* Violation */

/* comment in wrong place


*/

#pragma TEST            /* Violation */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// OK
#pragma TEST


/* OK */
#pragma TEST 

/* OK - multiline comment

*/
#pragma TEST



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
  第 6 章，第 3 节

2. 起源： Misra 使用指南 - 第 99 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 16 节，第 16-6-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-17_0_1_a</key>
<configkey>MISRA2008-17_0_1_a</configkey>
<name><![CDATA[ 不得定义，重定义或取消定义保留标识符，标准库中的宏和函数 [MISRA2008-17_0_1_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得定义，重定义或取消定义保留标识符，标准库中的宏和函数 [MISRA2008-17_0_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ #undef 一个来自在标准库定义的宏通常是一种错误的习惯。
同样， #define一个C保留字符或者标准库中的任何一个宏、
对象或者函数的C关键字的宏名，也是一种错误的习惯。
例如, 有一些特殊的保留字个函数名，如果它们被重新定义
或者没有定义，他们被用来指定一些未定义的行为，包括
定义 _ _LINE_ _, _ _FILE_ _, _ _DATE_ _, _ _TIME_ _, 
_ _STDC_ _, errno and assert。一般来说， 所有的标识
符开头的下划线字符保留。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则防止未定义行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define __A 1	    // 违规
#define assert 1   // 违规
#undef __AA         //违规
#undef assert       // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要 #define 和 #undef 保留字符



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第20部分

2. 来源: Misra 指南 - 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
  第6章，第17部分，第17-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-17_0_1_b</key>
<configkey>MISRA2008-17_0_1_b</configkey>
<name><![CDATA[ 不得定义，重定义或取消定义保留标识符，标准库中的宏和函数 [MISRA2008-17_0_1_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得定义，重定义或取消定义保留标识符，标准库中的宏和函数 [MISRA2008-17_0_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“#undef 或者#define C保留字是不正确的。”


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

从定义保留字将带来错误和混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define break 1     // 违规
#define continue 1  // 违规
#undef while        // 违规
#undef return       // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要#define or #undef 跟保留字



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第20部分

2. 来源: Misra 指南 - 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南,第6章，第17部分，第17-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-17_0_2</key>
<configkey>MISRA2008-17_0_2</configkey>
<name><![CDATA[ 不得重复使用标准库宏和对象的名称 [MISRA2008-17_0_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得重复使用标准库宏和对象的名称 [MISRA2008-17_0_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"程序员使用新版本的标准库的宏或者对象
的地方(例如 增强功能或者添加检查输入值)，这些
修改过的宏或者对象需要有一个新的命名。
这样做是为了避免这样的混淆：是标准宏或者
对象正在被调用，还是修改过的正在被调用。"
本规则检查下面的保留名称是否被使用：
- 来自C标准库头文件的宏和typedef名称: assert.h,
  complex.h, ctype.h, errno.h, float.h, iso646.h, limits.h, locale.h, math.h,
  setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h, string.h, time.h,
  wchar.h, wctype.h, stdint.h, inttypes.h, fenv.h, stdbool.h, tgmath.h
- 以下划线字符开头的标示符
参见: NAMING-33, MISRA2004-20_2, CODSTA-93



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define NULL ( a &gt; b )     // 违规
#define _NULL ( a &gt; b )    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MY_NULL ( a &gt; b ) // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++ 语言在关键系统中的使用指南
   第 6 章，第 17 节， 规则 17-0-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-17_0_3</key>
<configkey>MISRA2008-17_0_3</configkey>
<name><![CDATA[ 不得覆盖标准库宏和对象的名称 [MISRA2008-17_0_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得覆盖标准库宏和对象的名称 [MISRA2008-17_0_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"程序员使用新版本的标准库的函数的地方
(例如 增强功能或者添加检查输入值)，这些
修改过的函数需要有一个新的命名。 然而，
如果这个功能和原始的一致，它允许重载名称
来添加新的参数类型。 这样确保和名称相关的行为
保持一致。 因此，比如，新版本的开平方根函数
被写入用来检查输入是否为负值，那么这个函数不能
被命名为'sqrt'，而是需要给定一个新的名字。它允许
为在函数库中不存在的类型添加一个新的开平方根函数"
本规则检查下面的保留名字是否被使用：
- 来自C标准库头文件的函数名称： assert.h,
  complex.h, ctype.h, errno.h, float.h, iso646.h, limits.h, locale.h, math.h,
  setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h, string.h, time.h,
  wchar.h, wctype.h, stdint.h, inttypes.h, fenv.h, stdbool.h, tgmath.h
- function names that begin with the underscore character
参见: NAMING-33, MISRA2004-20_2, CODSTA-92



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可预防未定义的行为。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

在静态分析中检查该功能和原始的是否一致是
不可能的。所以， 规则在所有声明的具有保留名称
的函数上报告违规。 用户应该自己检查修改的函数
是否具有相同的功能并且可以重载来自于标准库的函数。
规则同样也不具有例外来允许重载包含在标准库中不存在
类型的函数。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int printf ( int a, int b )        // 违规
{
    return ( ( a &gt; b ) ? a : b );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int my_printf ( int a, int b )     // OK
{
    return ( ( a &gt; b ) ? a : b );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++ 语言在关键系统中的使用指南
   第 6 章， 第 17 节， 规则 17-0-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-17_0_5</key>
<configkey>MISRA2008-17_0_5</configkey>
<name><![CDATA[ 不得使用 setjmp 宏和 longjmp 函数 [MISRA2008-17_0_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 setjmp 宏和 longjmp 函数 [MISRA2008-17_0_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“setjmp 和 longjmp 允许普通的函数调用机制绕过和不能被使用”
当使用函数etjmp or longjmp且文件中出现任何一个头文件: 
setjmp.h, setjmp, or csetjmp，本规则将报出相关违例信息。.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则通过绕过而组织被调用



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;setjmp.h&gt;
jmp_buf mark;              /* Address for long jump to jump to */
int     fperr;             /* Global error number */

void foo( void ) {
    int jmpret;
    jmpret = setjmp( mark );        /* 违规 */
}

void fphandler( int sig, int num ) {
    longjmp( mark, -1 );            /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用宏setjmp 和longjmp函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第122条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第20条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第17部分，第17-0-5条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-18_0_1</key>
<configkey>MISRA2008-18_0_1</configkey>
<name><![CDATA[ 不得使用 C 语言库 [MISRA2008-18_0_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 C 语言库 [MISRA2008-18_0_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一些 C++ 库 (例如 &lt;cstdio&gt;) 也有相应的 C 语言版本
(例如 &lt;stdio.h&gt;)。这条规则规定当 C++ 版本在使用时。 "
检查下列的标准 C 库头文件:
&lt;assert.h&gt;
&lt;ctype.h&gt;
&lt;errno.h&gt;
&lt;float.h&gt;
&lt;iso646.h&gt;
&lt;limits.h&gt;
&lt;locale.h&gt;
&lt;math.h&gt;
&lt;setjmp.h&gt;
&lt;signal.h&gt;
&lt;stdarg.h&gt;
&lt;stddef.h&gt;
&lt;stdio.h&gt;
&lt;stdlib.h&gt;
&lt;string.h&gt;
&lt;time.h&gt;
&lt;wchar.h&gt;
&lt;wctype.h&gt;



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义的和实现定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;cstdio&gt;  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 18 节, 规则 18-0-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-18_0_2</key>
<configkey>MISRA2008-18_0_2</configkey>
<name><![CDATA[ 不得使用来自于 <cstdlib> 库的 atof, atoi 和 atol 库函数 [MISRA2008-18_0_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用来自于 &lt;cstdlib&gt; 库的 atof, atoi 和 atol 库函数 [MISRA2008-18_0_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

来自库&lt;stdlib.h&gt;中的函数 'atof', 'atoi' 和'atol' ，
当字符串不能通过它们来转换的时候，没有确定的行为。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用那些含有没有定义行为的函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
void foo( void ) {
    char *s; double x; int i; long l;
    s = "  -2309.12E-15";    
    x = atof( s );           /* 违规 */
    s = "  -9885 pigs";      
    i = atoi( s );           /* 违规*/
    s = "98854 dollars";     
    l = atol( s );           /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用atof, atoi 和atol 这些函数.


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第20部分

2. 来源: Misra 指南 - 第125条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5章库, AV 第23条规则

4. MISRA C++:2008 C语言在关键系统中的使用指南,第6章，第18部分，第18-0-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-18_0_3</key>
<configkey>MISRA2008-18_0_3</configkey>
<name><![CDATA[ 不得使用来自于 <cstdlib> 库的 abort, exit, getenv 和  system 库函数 [MISRA2008-18_0_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用来自于 &lt;cstdlib&gt; 库的 abort, exit, getenv 和  system 库函数 [MISRA2008-18_0_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许使用来自库stdlib.h，cstdlib或者库stdlib_iso.h
中的 'abort', 'exit', 'getenv' 和 'system' 函数.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用那些没有在嵌入式系统需要的函数



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include  &lt;stdlib.h&gt;
void foo( void ) {
    char *libvar;
    libvar = getenv( "LIB" );  /* 违规 */
    system( "dir" );           /* 违规 */
    abort( );                  /* 违规 */
    exit( 0 );                /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用abort, exit, getenv 和系统函数.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. 来源: Misra 指南 - 第126条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5 章库，, AV 第24条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-0-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-18_0_4</key>
<configkey>MISRA2008-18_0_4</configkey>
<name><![CDATA[ 不得使用 <ctime> 库的时间处理函数 [MISRA2008-18_0_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 &lt;ctime&gt; 库的时间处理函数 [MISRA2008-18_0_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这个库和时钟时间关联。各个方面和执行程序
相关或者不确定，比如时间的格式”。
规则防止列入 &lt;time.h&gt; and &lt;ctime&gt; 头文件。
参见: SECURITY-01



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止不确定行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;time.h&gt;  /* 违规*/



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用time.h 头文件.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. 来源: Misra 指南 - 第127条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.5 章库，, AV 第25条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第18章，第7部分，第18-0-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-18_0_5</key>
<configkey>MISRA2008-18_0_5</configkey>
<name><![CDATA[ 不得使用 <cstring> 库的无限制函数 [MISRA2008-18_0_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 &lt;cstring&gt; 库的无限制函数 [MISRA2008-18_0_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在 &lt;cstring&gt; 库中的 strcpy, strcmp, strcat, strchr, strspn, strcspn, strpbrk, strrchr, strstr,
strtok 和 strlen 函数能够读取或写入超出缓冲区的末尾，
造成不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef char char_t;
#include &lt;cstring&gt;
void fn ( const char_t * pChar )
{
    char_t array [ 10 ];
    strcpy ( array, pChar ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Ideally, a safe string handling library should be used.
Use of bounded functions (e.g. strncpy) is also possible. */
typedef char char_t;
#include &lt;cstring&gt;
void fn ( const char_t * pChar )
{
    char_t array [ 10 ];
    strncpy ( array, pChar, 10 ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 18 节, 规则 18-0-5

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-18_2_1</key>
<configkey>MISRA2008-18_2_1</configkey>
<name><![CDATA[ 不得使用 offsetof 宏 [MISRA2008-18_2_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 offsetof 宏 [MISRA2008-18_2_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当操作数类型不兼容或位字段时使用的时候，
使用这个宏可能导致一些难以确定的行为，”
当宏offsetof被使用或者文件中包含以下任何一个头文件：
stddef.h, stddef, or cstddef.
本规则将会报出违规信息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则预防不确定行为。.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规- The macro offsetof shall not be used. Macro is in line: [10]
#include &lt;stddef.h&gt;

struct S {
    int x, y, z;
    char buffer[ 128 ];
};

int main( ) {
    int i = offsetof( struct S, buffer );
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 offsetof.


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第120条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第18条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-18_4_1</key>
<configkey>MISRA2008-18_4_1</configkey>
<name><![CDATA[ 不得使用动态堆内存分配 [MISRA2008-18_4_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用动态堆内存分配 [MISRA2008-18_4_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“动态内存的使用可能导致存储溢实时失败，
这是不可取的。内置新建和删除操作，除指定版本，
使用动态堆内存。函数 calloc,malloc, realloc 和
free 使用动态对内存。 ”


例外:

该规则允许使用一个新的位置



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“有一些没有指定，为定义的和实现定义的行为
动态内存分配有关联，当然也存在缺陷。
动态堆内存泄露，数据不一致，分配导致内存，
内存耗尽，或一些非确定行为。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
  int * p = new int[10]; // 违规
  /* ... */
  
  delete[] p;            // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用，既没有 'new' 和 'delete'操作符，也没有 'calloc', 'malloc',
'realloc' 和free'函数.
 


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20部分

2. Misra 指南 -第118条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-4-1条规则

4. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.26章 内存应用, AV 第206条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-18_7_1</key>
<configkey>MISRA2008-18_7_1</configkey>
<name><![CDATA[ 不得使用 <csignal> 库的信号处理功能 [MISRA2008-18_7_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 &lt;csignal&gt; 库的信号处理功能 [MISRA2008-18_7_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“信号处理包含实现定义和不确定的行为。”
如果文件中含有以下任意一个头文件signal.h, or csignal.
本规则将报出违规信息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止在信号处理中出现实现定义和不确定的行为的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;signal.h&gt;  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用&lt;signal.h&gt; 头文件。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第123条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第21条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第18部分，第18-7-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-19_3_1</key>
<configkey>MISRA2008-19_3_1</configkey>
<name><![CDATA[ 不得使用 errno 错误标识 [MISRA2008-19_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 errno 错误标识 [MISRA2008-19_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"errno是才的一部分，理论上是有用的，但是实际上
没有通过标准给予明确的定义的。非零值可能会或
不会表明一个出现了问题，因此它不得使用。即使
是那些该errno的行为明确界定的职能，最好先检查
调用函数，而不是依靠使用errno来捕获错误的投入的价值
如果errno指示符被用，文件含有以下头文件：errno.h, errno, cerrno.
本规则报出一个违规信息



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则防止不确定行为



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;errno.h&gt;

int err_check( ) {
    errno = 1;       /* 违规 */
    return (errno);  /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用errno.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第119条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第17条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第19部分，第19-3-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-27_0_1</key>
<configkey>MISRA2008-27_0_1</configkey>
<name><![CDATA[ 不得使用 <cstdio> 库的输入/输出流 [MISRA2008-27_0_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 &lt;cstdio&gt; 库的输入/输出流 [MISRA2008-27_0_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

" I/O流和 I/O文件有相当大的不确定因素，
未定义和实现定义和它们很大的关联。
据推测，他们将不会再嵌入式系统中被使用。
如果 stdio.h中任何一个被用来代码中，
那么与性能相关的问题毫无疑问需要解决的。"
本规则将阻止使用 &lt;stdio.h&gt;, and &lt;cstdio&gt;头文件



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防在使用I/O流和文件带来大量难以确定的问题，
以及I/O流和文件相关的未指定和未执行的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;  /* 违规*/



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用&lt;stdio.h&gt;库。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第20条规则

2. 来源： Misra 指南 - 第124条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.5章 库, AV 第22条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第27部分，第27-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_10_1</key>
<configkey>MISRA2008-2_10_1</configkey>
<name><![CDATA[ 不同的标识符应该是外观上可以清晰区别的 [MISRA2008-2_10_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不同的标识符应该是外观上可以清晰区别的 [MISRA2008-2_10_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“根据用于显示字符集的字体， 即使是
不同的字体，也很可能出现某些字形相同。
这可能导致开发人员将某些标识符和其他相混淆。
为了帮助减少这种可能性，标识符不得用以下的组合
来进行区别:
- 只有大小写混合差异;
- 存在或缺少下划线字符的差异;
- 字母 'O', 和数字 '0' 的互换;
- 字母 'I', 和数字 '1' 的互换;
- 字母 'i', 和数字 '1' 的互换;
- 字母 'i', 和数字 'l' 的互换;
- 字母 'I', 和数字 'l' (el) 的互换;
- 字母 'l' (el), 和数字 '1' 的互换;
- 字母 'S' 和数字 '5' 的互换;
- 字母 'Z' 和数字 '2' 的互换;
- 字母 'n' 和数字 'h' 的互换;
- 字母 'B' 和数字 '8' 的互换;
- 字母序列 'rn' ('n' 紧跟在 'r' 之后)
  和数字 'm' 的互换。”
参见: NAMING-45.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int id1_uint32; // 违规 - interchange Z and 2
short id1_uint3Z;       // 违规 - interchange Z and 2

void id2_foo(            // 违规 - absence underscore
        int id4_paramS,  // 违规 - interchange S and 5
        int id4_param5   // 违规 - interchange S and 5
        ){
    int id3_abc;  // 违规 - mixed case
    int id3_ABC;  // 违规 - mixed case
}

int id6_modern;   // 违规 - interchange rn and m

void id2_foo_(){   // 违规 - presence underscore
    int id5_BO;    // 违规 - interchange B and 8, O and 0
    int id5_80;    // 违规 - interchange B and 8, O and 0
    int id6_modem; // 违规 - interchange rn and m
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int id1_uint32_t; // OK
int id1_uint32_v;         // OK

void id2_foo_1(          // OK
        int id4_param1,  // OK
        int id4_param2   // OK
        ){
    int id3_abc_1;  // OK
    int id3_ABC_2;  // OK
}

int id6_modern;    // OK

void id2_foo_2(){  // OK
    int id5_BO_1;  // OK
    int id5_80_2;  // OK
    int foo_2_id6_modem; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 2 节, 规则 2-10-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_10_2_a</key>
<configkey>MISRA2008-2_10_2_a</configkey>
<name><![CDATA[ 声明在内部范围的标识符不得掩盖声明在外部范围的标识符 [MISRA2008-2_10_2_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
声明在内部范围的标识符不得掩盖声明在外部范围的标识符 [MISRA2008-2_10_2_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏全局变量和全局参数的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

隐藏全局变量或者全局参数的名字
会导致错误或者混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int x;
void foo( ) {
    int x;     /* Violation */ 
    x = 3;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免使用全局变量和全局参数的名字隐藏。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. ISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_10_2_b</key>
<configkey>MISRA2008-2_10_2_b</configkey>
<name><![CDATA[ 声明在内部范围的标识符不得掩盖声明在外部范围的标识符 [MISRA2008-2_10_2_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
声明在内部范围的标识符不得掩盖声明在外部范围的标识符 [MISRA2008-2_10_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要隐藏局部变量的名字。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

局部变量的名字隐藏会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( ) {
    int a;
    {
        int a;    /* Violation */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

避免隐藏局部变量的名字。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 21 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.15 章 声明和定义，第 AV 135 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-2 条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_10_4_a</key>
<configkey>MISRA2008-2_10_4_a</configkey>
<name><![CDATA[ 类，联合体，枚举型名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [MISRA2008-2_10_4_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类，联合体，枚举型名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [MISRA2008-2_10_4_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在一段程序中任何标签的名称都不允许被重用做其它目的。
ISO 9899:1990并没有定义这种行为：一个聚集声明
使用一个不同形式的类型说明符的标签。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

标签的名称的重用会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct stag { int a; };      

void stag(void){}        // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct stag { int a; }; 

void foo(void){}         // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-4 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_10_4_b</key>
<configkey>MISRA2008-2_10_4_b</configkey>
<name><![CDATA[ 类，联合体，枚举型名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [MISRA2008-2_10_4_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类，联合体，枚举型名称 (如果有其他修饰符，也包括) 应该是一个唯一的标识符 [MISRA2008-2_10_4_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“任何标签的名称都不允许被重用来定义一个不同的标签。
ISO 9899:1990并没有定义这种行为：一个聚集声明使用一个
不同形式的类型说明符的标签。要么所有的对该标签的使用都
包含在一个结构体类型说明符里，要么都在一个共用体类型说明符里。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

标签的名称的重用会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct stag { int a; int b; };

void foo1()
{
    union stag  { int a; float b; }; // Violation
}

void foo2(void)
{
    struct stag { int a; };          // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct stag { int a; int b; };

void foo1()
{
    union union_tag  { int a; float b; }; // OK
}

void foo2(void)
{
    struct new_stag { int a; };          // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-4 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_10_5_a</key>
<configkey>MISRA2008-2_10_5_a</configkey>
<name><![CDATA[ 非成员对象或具有静态存储期的函数的标识符名称不得被重复使用 [MISRA2008-2_10_5_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非成员对象或具有静态存储期的函数的标识符名称不得被重复使用 [MISRA2008-2_10_5_a-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个程序里静态对象或者函数标识符不能被重用
来做任何其他目的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

静态标识符的重用会导致错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static float a;
static void foo()
{
int a;    /* Violation */  
int foo;  /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在一个程序里将一个静态标识符重用做任何其它目的。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-5 条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_10_5_b</key>
<configkey>MISRA2008-2_10_5_b</configkey>
<name><![CDATA[ 非成员对象或具有静态存储期的函数的标识符名称不得被重复使用 [MISRA2008-2_10_5_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非成员对象或具有静态存储期的函数的标识符名称不得被重复使用 [MISRA2008-2_10_5_b-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

带有静态存储期的对象或者函数标识符必须是唯一的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

标识符名字的重用会导致错误和混淆。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static float a;
static void foo()
{
static int a ;  /* Violation */
static int foo; /* Violation */  
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not use the same names for different static object or functions.
不要给不同的静态对象或者函数起相同的名字。


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-5 条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_10_6</key>
<configkey>MISRA2008-2_10_6</configkey>
<name><![CDATA[ 如果一个标识符指向一个类型，它不得再指向在同一个范围内的一个对象或函数 [MISRA2008-2_10_6] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个标识符指向一个类型，它不得再指向在同一个范围内的一个对象或函数 [MISRA2008-2_10_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ISO C 定义了数个不同的命名空间。
从技术上来说在各自的命名空间里使用同一个名字来代表
完全不同的项是可以的。然而这种做法是不允许的原因是
它会带来混淆，因此名字不可以重用，
即使是在不同的命名空间里。”
C语言里有4个命名空间
1. 标签名字
2. 结构体，共用体和枚举类型的关键字
3. 结构体和共用体的成员；每个结构体或者共同体作为一个独立的命名空间
4. 所以其他标识符；例如枚举常量，变量，函数，类型定义



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

输出消息仅仅展示了第一个（行）在其它命名空间里
被重用的名字的位置。


例外：

该规则的一个例外是结构体成员的命名，
不同结构体的成员名字可以重用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef struct MyStruct  // tags name space
{
  int Member;            // members name space
} MyStruct;              // Violation - identifiers name space



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef struct MyStruct  // tags name space
{
  int Member;             // members name space
} MyStructObj;            // OK - identifiers name space



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 5 节

2. 来源: Misra 指南 - 第 12 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-10-6 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_13_1</key>
<configkey>MISRA2008-2_13_1</configkey>
<name><![CDATA[ 只得使用那些定义在 ISO/IEC 14882:2003 中的转义序列 [MISRA2008-2_13_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只得使用那些定义在 ISO/IEC 14882:2003 中的转义序列 [MISRA2008-2_13_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只得使用那些定义在 ISO/IEC 14882:2003 中的
转义序列。定义的转义字符 (ISO/IEC 14882:2003) 是:
\n, \t, \v, \b, \r, \f, \a, \\, \?, \', \", \&lt;Octal Number&gt;,
\x&lt;Hexadecimal Number&gt;"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

未定义的转义序列导致未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
void foo( ) {
    printf("ABCD\u1111");     // 违规
    printf("abcd\hgf");       // 违规
    printf("\k");             // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用不符合 ISO / IEC14882:2003 标准中定义的转义序列。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 2 节, 规则 2-13-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_13_2</key>
<configkey>MISRA2008-2_13_2</configkey>
<name><![CDATA[ 不得使用八进制字面量(除了零)和八进制转义序列(除了"\0") [MISRA2008-2_13_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用八进制字面量(除了零)和八进制转义序列(除了"\0") [MISRA2008-2_13_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“任何以 '0' (零)开头的整形常量被视为八进制。
这就存在着危险，例如，在写固定长度的常量的时候。
八进制的换码序列会产生问题，因为一个不经意引入
的十进制数字会中止这个换码顺序并引入
另外一个字符。最好不要使用八进制常量或者换码序列
并且静态地检查是否出现这种情况。
整形常量0（写作一个单个的数字），严格
来说，是一个八进制常量，但是可以视为这个规则的一个特例。
此外\0是唯一允许的八进制换码序列。”


例外：

该规则忽略任何pragma parasoft / codewizard 指令。
该规则忽略任何asm blocks里的数值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码的可读性与可维护性。
该规则防止使用随实现环境不同而不同的数值。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int code1;
    int code2;
    int code3;

    code1 = 052;    /* Violation */
    code2 = 071;    /* Violation */
    code3 = '\100'; /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1() 
{
    int code1;
    int code2;
    int code3;

    code1 = 42;  /* OK */
    code2 = 57;  /* OK */
    code3 = 64;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 7 节

2. 来源: Misra 指南 - 第 19 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.18 章 常量，第 AV 149 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-13-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_13_3</key>
<configkey>MISRA2008-2_13_3</configkey>
<name><![CDATA[ 后缀 "U" 应该适用于所有无符号类型的八进制或十六进制整型字面量 [MISRA2008-2_13_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
后缀 "U" 应该适用于所有无符号类型的八进制或十六进制整型字面量 [MISRA2008-2_13_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整数类型是取决于各种因素的复杂组合
其中包括:
- 常量的大小;
- 整数类型的实现大小;
- 存在的任何后缀;
- 基于数值表示的数字。
例如，值 0x8000 的类型是在一个16位环境的无符号整型，
但在32位环境为（有符号）类型整型。如果重载集包括
一个无符号整型和整型的候选，那么由 0x8000 匹配
的重载依赖于实现的整数大小。添加一个“U”
后缀的值指定它是无符号的。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高易读性和防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned long var = 02;  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned long var = 02U; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 2 节, 规则 2-13-3 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_13_4</key>
<configkey>MISRA2008-2_13_4</configkey>
<name><![CDATA[ 字面量后缀应该是大写 [MISRA2008-2_13_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字面量后缀应该是大写 [MISRA2008-2_13_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

字面量后缀将使用大写字母而不是小写字母。
参见: CODSTA-50



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(long param = 64l)  // 违规
{
	const long a = 64l; // 违规
	
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(long param = 64L)  // OK
{
	const long a = 64L;     // OK
}


参考文献:

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.4 章 Environment, AV 规则 14

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 2 节, 规则 2-13-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_13_5</key>
<configkey>MISRA2008-2_13_5</configkey>
<name><![CDATA[ 不得级联狭义的和广义的字符串字面量 [MISRA2008-2_13_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得级联狭义的和广义的字符串字面量 [MISRA2008-2_13_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

宽和窄的字符串字面量的级联导致不确定的行为。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

wchar_t array[] = "Hello" L"World";    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

wchar_t array[] = L"Hello" L"World";   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 2 节, 规则 2-13-5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_3_1</key>
<configkey>MISRA2008-2_3_1</configkey>
<name><![CDATA[ 不得使用三元字符 [MISRA2008-2_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用三元字符 [MISRA2008-2_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则遇到使用三字母词的时候会报告一个违规信息。
所有在源文件里出现的下列三个字符的序列（称为三字母词序列）将被相应的
单个字符替换：
??= #
??( [
??/ \
??) ]
??' ^
??&lt; {
??! |
??&gt; }
??- ~

如果编译器用开关来忽略三字母词时
需要使用该选项，或者能够确保在
代码中绝不使用两个问号相联。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

三字母词能引起与其它使用两个问号相联的情形的意外的混淆
并导致不可预期的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

??=define TEST 1	/* Violation */
void foo() {
    const char * s = "(Date should be in the form ??-??-??)";	           /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define TEST 1	/* OK */
void foo() {
    const char * s = "(Date should be in the form " "??" "-??" "-??" ")";  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 4 节

2. 来源: Misra 指南 - 第 7 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.4 章 环境，第 AV 11 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-3-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_5_1</key>
<configkey>MISRA2008-2_5_1</configkey>
<name><![CDATA[ 不得使用二元字符 [MISRA2008-2_5_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用二元字符 [MISRA2008-2_5_1-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用下列合体字母&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:
该规则中的合体字母使得简单结构体含义不清。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则增强代码的可读性。


源自：

v7.1


事例：

int a &lt;: 2 :&gt; &lt;: 2 :&gt; = &lt;%&lt;%0,1%&gt;,&lt;%2,3%&gt;%&gt;; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int a[2][2] = { {0,1}, {2,3} };              // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.4 Environment, AV Rule 12

2. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 2, Rule 2-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_7_1</key>
<configkey>MISRA2008-2_7_1</configkey>
<name><![CDATA[ 字符序列 /* 不得被用于 C 语言风格的注释中 [MISRA2008-2_7_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符序列 /* 不得被用于 C 语言风格的注释中 [MISRA2008-2_7_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

C语言不支持注释嵌套即使
有些编译器支持它作为一个语言扩展功能。
注释开始于/*直到遇到第一个*/。
任何出现在一个注释内部的/*都是违反这个规则的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C语言不支持注释嵌套因为它容易导致混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* some comment, end comment marker accidentally omitted

&lt;&lt;New Page&gt;&gt;
Perform_Critical_Safety_Function(X);
/* this comment is not compliant - Violation */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* some comment, end comment marker accidentally omitted */

&lt;&lt;New Page&gt;&gt;
Perform_Critical_Safety_Function(X);
/* this comment is compliant - OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 2 节

2. 起源： Misra 指南 - 第 9 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章，第 2 节，第 2-7-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_7_2</key>
<configkey>MISRA2008-2_7_2</configkey>
<name><![CDATA[ 代码部分不得使用 C 语言风格的注释 "注释掉" [MISRA2008-2_7_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
代码部分不得使用 C 语言风格的注释 "注释掉" [MISRA2008-2_7_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一段代码要求不能被编译时
就通过使用条件编译来实现（例如使用#if
或者#ifdef结构并附加一段注释）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在某些情况下规则会报告错误肯定或者错误否定。
这种情况是由于源代码和注释文本的相似性而引起的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用注释的开始和结束标识符来达到此目的是危险的
因为C语言不支持注释嵌套，任何已经存在于这段代码
中的注释会改变这种效果。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int x = 5;
    /*  Section of code     // Violation
        commented out
    if (x==0){
        x++;
    }
    */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int x = 5;
/* Comment without          // OK
   code within */
#if 0                       
    if (x==0){
        x++;
    }
#endif
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第 6 章，第 2 节

2. 来源: Misra 使用指南 - 第 10 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.14 章注释， 第 AV 127 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-7-2 条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-7-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-2_7_3</key>
<configkey>MISRA2008-2_7_3</configkey>
<name><![CDATA[ 代码部分不得使用 C++ 语言风格的注释 "注释掉" [MISRA2008-2_7_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
代码部分不得使用 C++ 语言风格的注释 "注释掉" [MISRA2008-2_7_3-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一段代码要求不能被编译时
就通过使用条件编译来实现（例如使用#if
或者#ifdef结构并附加一段注释）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在某些情况下规则会报告错误肯定或者错误否定。
这种情况是由于源代码和注释文本的相似性而引起的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用注释的开始和结束标识符来达到此目的是危险的
因为C语言不支持注释嵌套，任何已经存在于这段代码
中的注释会改变这种效果。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int x = 5;
    /*  Section of code     // Violation
        commented out
    if (x==0){
        x++;
    }
    */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int x = 5;
/* Comment without          // OK
   code within */
#if 0                       
    if (x==0){
        x++;
    }
#endif
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第 6 章，第 2 节

2. 来源: Misra 使用指南 - 第 10 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.14 章注释， 第 AV 127 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-7-2 条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 2 节， 第 2-7-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_1_1</key>
<configkey>MISRA2008-3_1_1</configkey>
<name><![CDATA[ 应该尽可能包含在多个不违反单定义规则的编译单元的任何头文件 [MISRA2008-3_1_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该尽可能包含在多个不违反单定义规则的编译单元的任何头文件 [MISRA2008-3_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“头文件应该用来声明对象，函数，内联函数，
函数模板，类型定义(typedef)，宏，类和类模板。
并不得包含或者产生需要占据存储空间的对象或者函数的定义
（或者函数或者对象的片段）。”
参见：MISRA2004-8_5



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

作为头文件，规则检测包含如下扩展名的文件 ".h", ".hh", ".hxx", ".i"
(例如： "file.h", "file.hh", "file.hxx", "file.i").


例外:

在头文件允许下面的定义:
- 内联函数
- 函数模板
- 类模板的静态数据成员
- const 变量（如果它们有内部或没有连接）(C++ 模式)
- 静态 const 变量



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。
通过不在头文件中包含定义，
可以在多个翻译单元包含头文件。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* file.h */
void f1(){}            // 违规
int var;               // 违规
class C {
   void f2();
};
void C::f2() {}        // 违规

/* file.cpp */
#include "file.h"



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* file.h */
void f1();             // OK
extern int var;        // OK
class C {
   void f2();
};
template &lt;typename T&gt;
void f3 ( T ) { }      // OK

/* file.cpp */
#include "file.h"
void f1(){}
int var;
void C::f2() {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章，第 3 节, 第 3-1-1 条规则

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Namespaces and Modules", Rule 61

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.7章 Header Files, AV Rule 39

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_1_2</key>
<configkey>MISRA2008-3_1_2</configkey>
<name><![CDATA[ 函数不得声明在语句块范围内 [MISRA2008-3_1_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不得声明在语句块范围内 [MISRA2008-3_1_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数应该被声明在文件范围内。
在区块范围内声明函数可能会使人混淆，
并且会导致不明确的行为。




</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止产生不确定的行为并提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1( ) {
    void foo2( );  /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo2( );      /* OK */
void foo1( ) {
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. 来源: Misra 指南 - 第 112 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.13 章 函数，第 AV 107 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 3 节， 第 3-1-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_1_3</key>
<configkey>MISRA2008-3_1_3</configkey>
<name><![CDATA[ 当一个数组被声明的时候，其大小应该被显式地指定或通过初始化隐式地定义 [MISRA2008-3_1_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当一个数组被声明的时候，其大小应该被显式地指定或通过初始化隐式地定义 [MISRA2008-3_1_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一个数组被声明为带有外部连接，它的大小应该被明确声明
或者通过初始化来隐含地定义。
虽然声明一个不完整类型的数组并访问其元素是可能的，
但是当数组的大小被明确定义时这样做就
更加安全。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止产生不明确的行为并提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

extern int array2[ ]; /* Violation */
extern int array1[ ]; /* Violation */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int array2[ ] = { 0, 10, 15 };  /* OK */
extern int array1[ 10 ];        /* OK */



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 3 节， 第 3-1-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_3_1</key>
<configkey>MISRA2008-3_3_1</configkey>
<name><![CDATA[ 具有外部链接的对象或函数应该被定义在头文件中 [MISRA2008-3_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
具有外部链接的对象或函数应该被定义在头文件中 [MISRA2008-3_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“放置具有外部链接的对象或函数的声明到 
头文件中，目的是能够从其他翻译单元来访问。
如果外部链接不是必须的，那么该对象或函数应该
要么被声明在一个不具名的命名空间或者声明为 static 静态的。”


例外:

这条规则并不适用于 main，或不具名命名空间的成员。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则减少对象和函数的可见性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
int a1 = 0;   // 违规
void fun(){}  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.h
extern int a1;      // OK
extern void fun();  // OK

// file.cpp
#include "file.h"
int a1 = 0;   // OK
void fun(){}  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 3 节, 规则 3-3-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_3_2</key>
<configkey>MISRA2008-3_3_2</configkey>
<name><![CDATA[ 如果一个函数有内部链接，那么所有的再声明应该包括静态存储类限定符 [MISRA2008-3_3_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个函数有内部链接，那么所有的再声明应该包括静态存储类限定符 [MISRA2008-3_3_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果函数的声明使用了静态 static 关键字，
那么该函数有一个内部链接。 再次声明该函数
不需要 static 关键字，但它仍然有内部链接。
然后，这种隐式方式可能对于开发人员而言不
够清晰。因此加一个 static 关键字使其显示的
声明存在内部链接是一种好的习惯。"
参见： MISRA2004-8_11



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则使代码遵守良好的编程习惯并提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static void f1 ( );
void f1 ( ) { }         // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static void f1 ( );
static void f1 ( ) { }  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 3, Rule 3-3-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_4_1</key>
<configkey>MISRA2008-3_4_1</configkey>
<name><![CDATA[ 声明为一个对象或类型的标识符应该定义在一个模块中，以最小化其可见性 [MISRA2008-3_4_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
声明为一个对象或类型的标识符应该定义在一个模块中，以最小化其可见性 [MISRA2008-3_4_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“变量应该在尽可能小的范围内声明，以改善 
代码的可读性，以便变量不是没有必要分配的。 
当一个变量在一个函数的开头声明却在代码的 
其他地方使用时，并不容易直接看到此变量
的类型。
此外，还有一个风险就是如果一个变量和声明在内部块的
局部变量同名，那么此变量将会无意中被隐藏。

许多局部变量只被用在很少发生的特殊情况中。 
如果一个变量被声明在外层，  
即使它不被使用也将分配内存。此外，当变量
在声明时就被初始化，可以获得比变量在使用时赋值 
更加高效的代码。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止使程序更难理解和维护。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a;      // 违规
    {
        a = 0;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    {
        int a;  // OK
        a = 0;
    }
    int b;      // OK
    if (b&gt;0) {
        b = -1;
    } else {
        b = 1;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范  
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
   出自: 11 Variables - 第 41 条规则

2. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范” Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Coding Style", 第 18 条规则

3. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 3 节, 规则 3-4-1

4. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 6

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_9_1</key>
<configkey>MISRA2008-3_9_1</configkey>
<name><![CDATA[ 作为对象，函数返回类型，或函数参数使用的类型在所有定义和再定义中字符应该相同 [MISRA2008-3_9_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
作为对象，函数返回类型，或函数参数使用的类型在所有定义和再定义中字符应该相同 [MISRA2008-3_9_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果再声明有兼容类型但是字符相同，
可能造成再声明不知道应该指向哪个
声明。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的可读性和可维护性



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int INT;

INT i;        // 违规 
extern int i;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int INT;

INT i;        // OK
extern INT i; 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 3 节, 规则 3-9-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_9_2</key>
<configkey>MISRA2008-3_9_2</configkey>
<name><![CDATA[ 指定大小和符号属性的 typedef 应该用来代替基本数值类型 [MISRA2008-3_9_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指定大小和符号属性的 typedef 应该用来代替基本数值类型 [MISRA2008-3_9_2-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“类型的存储长度可以根据不同的编译器而变化。 如果 
程序员工作在他们知道的一个给定长度时，这样就更安全。”
如果使用基本数值类型(例如， signed char)或者 typedef
的名称不包含任何数字来指示类型的长度(例如， my_int)，
规则报告一个违规信息。
参见: MISRA2004-6_3


例外:

该规则不对下列的情况报告一个违规：
- "main" 函数返回类型
- 外部变量声明
- 布尔和枚举类型
- 位域类型
- 以 'bool' 作为前缀的typedef自定义类型，或者普通字符的typedef自定义类型
  (即使它不包含任何数字)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“该规则可以帮助阐明存储空间的大小，但是因为整型
提升的不对称行为该规则不保证可移植性。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int my_int; /* 违规 - no digits */
static signed char a;      /* 违规 - not typedef */

short int foo(             /* 违规 (for return type) */
        char* p_char,      /* 违规 */
        float&amp; r_float)    /* 违规 */
{
    double h;              /* 违规 */
    const int z = 1;       /* 违规 */
    return 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Exceptions: */
typedef char char_t;            /* OK (plain char) */
typedef unsigned char BOOL;     /* OK (typedef name starts with 'bool' prefix */
struct STRUCT {
        unsigned int i:2;       /* OK (bit-bield type) */
};
bool b;                         /* OK (boolean type) */
enum ENUM { EV };               /* OK (enum type) */
extern signed char a;           /* OK (extern variable) */
int main() { return 0; }        /* OK ("main" return type) */

/* Correct use of typedef: */
typedef signed int my_int32;    /* OK */
typedef signed char int8_t;     /* OK */
typedef short int s16_t;        /* OK */
typedef float&amp; float32ref;      /* OK */
typedef double float64;         /* OK */
typedef const int cs32_t;       /* OK */
s16_t foo(                      /* OK */
        char_t* p_char,         /* OK */
        float32ref r_float)     /* OK */
{
    float64 h;                  /* OK */
    cs32_t z = 1;               /* OK */
    return 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 规则 13

2. MISRA C++:2008  C++ 语言在关键系统中的使用指南
   第 6 章，第 3 节， 规则 3-9-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-3_9_3</key>
<configkey>MISRA2008-3_9_3</configkey>
<name><![CDATA[ 不得使用表示浮点型的原始位 [MISRA2008-3_9_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用表示浮点型的原始位 [MISRA2008-3_9_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不同编译器对于浮点类型指针的存储是
不同的，因此对浮点类型指针的操作绝不能
依赖于它的存储方式，应该使用那些对程序员
隐蔽了存储细节的内置操作符和函数。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在很多情况下，浮点类型的位域将会被标记为语法错误。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免产生由实现方式定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S {
	float f:6; // 违规
};

union U {
	float f:6; // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S {
	int f:6; // OK
};

union U {
	int f:6; // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节
   
2. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，第3-9-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-4_10_1</key>
<configkey>MISRA2008-4_10_1</configkey>
<name><![CDATA[ NULL 不得用作一个整型值 [MISRA2008-4_10_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
NULL 不得用作一个整型值 [MISRA2008-4_10_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在 C++ 中，字面量 0 既是整数类型又是空指针常数
(null-pointer-constant)。为了满足开发人员的期望，NULL 应作为
空指针常数(null-pointer-constant)，0 为整数零。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“作为此规则的一个结果，NULL 被认为包括指针类型。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;cstddef&gt;

void f1( int );

void foo( )
{
	f1( NULL ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void f1( int );

void foo( )
{
	f1( 0 ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 4 节, 规则 4-10-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-4_10_2</key>
<configkey>MISRA2008-4_10_2</configkey>
<name><![CDATA[ 字面量零 (0) 不得用作空指针常量 [MISRA2008-4_10_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字面量零 (0) 不得用作空指针常量 [MISRA2008-4_10_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在 C++ 中，字面量 0 既是整数类型又是空指针常数
(null-pointer-constant)。为了满足开发人员的期望，NULL 应作为
空指针常数(null-pointer-constant)，0 为整数零。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“作为此规则的一个结果，NULL 被认为包括指针类型。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;cstddef&gt;

void f1( int* );

void foo( )
{
	f1( 0 ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;cstddef&gt;

void f1( int* );

void foo( )
{
	f1( NULL ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 4 节, 规则 4-10-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-4_5_1</key>
<configkey>MISRA2008-4_5_1</configkey>
<name><![CDATA[ 布尔类型的表达式不得用作除了赋值运算符 = ，逻辑运算符 &&, ||, ! ，等号运算符 == 和 != ，一元 & 运算符和条件运算符以外的内置运算符的操作数 [MISRA2008-4_5_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
布尔类型的表达式不得用作除了赋值运算符 = ，逻辑运算符 &amp;&amp;, ||, ! ，等号运算符 == 和 != ，一元 &amp; 运算符和条件运算符以外的内置运算符的操作数 [MISRA2008-4_5_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了这些运算符(&amp;&amp;, ||, !, =, ==, !=, ?:)之外，其他
运算符中的有效布尔表达式不能作为操作数参与运算，
一个有效的布尔类型表达式可能是构造的布尔类型
或者是强制转换得到的布尔类型。它的定义如下。
构造的布尔类型值是通过以下运算符得到的：
- 等于运算符(== and !=)
- 逻辑运算符(!, &amp;&amp; and ||)
- 关系运算符(&lt;, &gt;, &lt;= and &gt;=)
强制转换的布尔值可以使用工具实现一个特定
的强制类型来产生。此时布尔类型与特定的
typedef相关联，并且可以用于任何布尔对象。”

如果不是在这些运算符(&amp;&amp;, ||, !, =, ==, !=, ?:)中把有效的
布尔表达式当作操作数进行运算，此规则将给出违规报告：
- 构造的布尔类型值
- 布尔型常量
- 变量、参数或表达式的类型：
  - 布尔类型，
  - 使用typedef定义的布尔，
  - 使用bool声明的枚举变量（忽略case）
    使用bool声明的包含2个枚举常量的枚举体
  - 使用typedef定义的以bool开头的char/short/enum类型（忽略case）
  - 引用以上类型



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高代码的可读性和可维护性。
此规则防止将逻辑运算符和位运算符混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo();
void foo()
{
    int x, y, z;

    z = (x &gt; y) &amp; (goo()); // 违规
    z = x | (goo() != 0);  // 违规
    z = ~(x == y);         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo();
void foo()
{
    int x, y, z;
    int tmp;

    tmp = x &gt; y;
    z = tmp &amp; goo();     // OK

    tmp = goo() != 0;
    z = x | tmp;         // OK

    tmp = x == y;
    z = ~tmp;            // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C：2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra指南-第36条规则 

3.MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第4节，规则4-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-4_5_2</key>
<configkey>MISRA2008-4_5_2</configkey>
<name><![CDATA[ 枚举类型的表达式不得用作除了 [ ], =,  ==, !=, <, <=, >, >=, 和一元 & 运算符以外的内置运算符的操作数 [MISRA2008-4_5_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
枚举类型的表达式不得用作除了 [ ], =,  ==, !=, &lt;, &lt;=, &gt;, &gt;=, 和一元 &amp; 运算符以外的内置运算符的操作数 [MISRA2008-4_5_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"枚举类型的表达式不应该用作除了
[], =, ==, !=, &amp;, 以及关系操作符
 &lt;, &lt;=, &gt;, &gt;= 操作符外的其他内
建操作符。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"枚举被用来定义实际环境的某种抽象代表，
 因此不应该用作算术操作符中。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 不正确代码示例 */
enum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_3, COLOUR_COUNT } colour;
void foo()
{
    if ( ( COLOUR_0 + COLOUR_1 ) == colour ){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* 正确代码示例 */
enum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_3, COLOUR_COUNT } colour;
void foo()
{
    if ( ( COLOUR_0 &lt; colour) &amp;&amp; (COLOUR_3  &gt; colour ) ){} // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 4, Rule 4-5-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-4_5_3</key>
<configkey>MISRA2008-4_5_3</configkey>
<name><![CDATA[ 普通的 char 类型和 wchar_t 型的表达式不得用作除了赋值运算符 = ， 等号运算符 == 和 !=， 一元 & 运算符以外的内置运算符的操作数 [MISRA2008-4_5_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
普通的 char 类型和 wchar_t 型的表达式不得用作除了赋值运算符 = ， 等号运算符 == 和 !=， 一元 &amp; 运算符以外的内置运算符的操作数 [MISRA2008-4_5_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“带有char和wchar_t（简单的）类型的
表达式不能被当做内置的操作数使用，
除了=,  ==, != 和一元 &amp; 运算符”

例外:

特殊的, 如果相关联的约束是可见的，那么下面的
操作符可以使用:
- 二进制 + 运算符可以用来加上一个
  0 到 9 的整数值给‘0’;
- 二进制 – 运算符可以用来减去字符‘0’;
- 关系运算符 &lt;, &lt;=, &gt;, &gt;= 可用于确定
  如果一个字符(或宽字符) 代表一个数字。
  (如果一个字符常量和简单类型的字符变量相比较，
   那么规则不会报告违规)



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“字符数据的处理会产生与开发人员预期
相反的结果。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    char ch = 't';                        // OK
    if ( ( ch &gt;= 'a' ) &amp;&amp; ( ch &lt;= 'z' ) ) // 违规
    {  
    	//...
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    char ch = 't';   // OK
    if ( ch == 't' ) // OK
    {  
    	//...
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 4 节, 规则 4-5-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_10</key>
<configkey>MISRA2008-5_0_10</configkey>
<name><![CDATA[ 如果按位运算符 ~ 和 << 适用于无符号字符型或无符号短整型的操作数，其结果应该立即强制转换成相应的原始类型 [MISRA2008-5_0_10] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果按位运算符 ~ 和 &lt;&lt; 适用于无符号字符型或无符号短整型的操作数，其结果应该立即强制转换成相应的原始类型 [MISRA2008-5_0_10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当(~ 和 &lt;&lt;)操作符应用于小整数类型(如无符号字符或无符号短整型)，
这些运算符对整数进行操作，运算结果的高位是不可预测的。
&lt;&lt;操作符对小整型进行操作也存在类似的问题那么高位被保留。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可避免高位保留。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;

void foo()
{
	uint8_t port = 0x5aU;
	uint8_t result_8;
	uint16_t result_16;
	uint16_t mode;	
	
	result_8 = (~port) &gt;&gt; 4;                                    /* 违规 */
	result_16 = ((port &lt;&lt; 4) &amp; mode) &gt;&gt; 6;                      /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;

void foo()
{
	uint8_t port = 0x5aU;
	uint8_t result_8;
	uint16_t result_16;
	uint16_t mode;	
	
	result_8 = ((uint8_t)(~port)) &gt;&gt; 4 ;                        /* OK */ 
	result_16 = (   (uint16_t) (~(uint16_t)port)    ) &gt;&gt; 4 ;    /* OK */ 
	result_16 = ((uint16_t)((uint16_t)port &lt;&lt; 4) &amp; mode) &gt;&gt; 6;  /* OK */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第10节

2. MISRA C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-0-10条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_11</key>
<configkey>MISRA2008-5_0_11</configkey>
<name><![CDATA[ 普通的 char 类型应该只能用于字符值的存储和使用 [MISRA2008-5_0_11] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
普通的 char 类型应该只能用于字符值的存储和使用 [MISRA2008-5_0_11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“Char类型只能用来存储和使用
字符型值。
仅有的允许适用于Char类型的操作符是
赋值和等号操作符（=，==，！=）。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则使代码具有更好的可读性和更少的混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char a = 65;     /* Violation */
void foo( ) {
    a = 66;     /* Violation */
    a++;        /* Violation */
    if (a &lt; 67) /* Violation */ 
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char a = 'A';     /* OK */
void foo( ) {
    a = 'B';      /* OK */
    if (a == 'C') /* OK */ 
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 5 节， 第 5-0-11 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_12</key>
<configkey>MISRA2008-5_0_12</configkey>
<name><![CDATA[ signed char 和 unsigned char 类型应该只能用于数值的存储和使用 [MISRA2008-5_0_12] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
signed char 和 unsigned char 类型应该只能用于数值的存储和使用 [MISRA2008-5_0_12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有符号和无符号的char类型只能用来存储和使用
数字型值。char类型的符号类型是由实现环境决定的
所以要慎重对待它。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则使代码具有更好的可读性和更少的混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

signed char a = 'A';          /* Violation */
void foo( ) {
    unsigned char a = 'B';    /* Violation */

    if (a == 'C')             /* Violation */
    {
    }
    if (a &lt; 'D')             /* Violation */
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

signed char a = 65;           /* OK */
void foo( ) {
    unsigned char a = 66;     /* OK */
    if (a == 67)              /* OK */
    {
    }
    if (a &lt; 68)               /* OK */
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 6 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 5 节， 第 5-0-12 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_13</key>
<configkey>MISRA2008-5_0_13</configkey>
<name><![CDATA[ if 语句的条件和迭代语句的条件应该是布尔类型 [MISRA2008-5_0_13] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
if 语句的条件和迭代语句的条件应该是布尔类型 [MISRA2008-5_0_13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在 if 语句或循环语句的条件中
使用具有不是布尔类型(bool)的表达式，那么其结果将会
被隐式地转换为布尔类型(bool)”。 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果条件表达式是调用一个转换函数，
此函数转换为名称中包含命名为 'bool' 指针成员的类型定义(typedef)。
规则不报告违规。


例外:

“类型限定序列(type-specifier-seq)声明符形式的条件不需要
有布尔类型(bool)。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“条件表达式应包含一个显式地判断（产生了 bool 类型的结果）
以明确开发人员的意图。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int i;
    if (i){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int i;
    if (i != 0){} // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-0-13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_14</key>
<configkey>MISRA2008-5_0_14</configkey>
<name><![CDATA[ 条件运算符的第一个操作数应该是布尔类型 [MISRA2008-5_0_14] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
条件运算符的第一个操作数应该是布尔类型 [MISRA2008-5_0_14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“条件运算符的第一个操作数应该具有布尔类型。
如果一个表达式不是由布尔类型作为条件运算符
的第一个操作数，那么其结果将是隐式转换为
布尔类型(bool)。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“第一个操作数应包含一个显式地判断（产生了 bool 类型的结果）
以明确开发人员的意图。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i, int j, int k, int l)
{
    i = j ? k : l;               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i, int j, int k, int l)
{
    i = (j != 0) ? k : l;        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 5 节, 规则 5-0-14

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_15</key>
<configkey>MISRA2008-5_0_15</configkey>
<name><![CDATA[ 数组索引应该是指针运算的唯一形式 [MISRA2008-5_0_15] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
数组索引应该是指针运算的唯一形式 [MISRA2008-5_0_15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“数组下标索引是进行指针算术运算的唯一
可接受的方式，因为它更加清楚并且也比指针
操作更易于避免错误。此规则禁止了显式的
指针值的计算。数组下标索引应该只适用于
定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。”


缺点:

在比较复杂的代码中，如果有索引化的
指向数组的指针，此规则可能不能正常检查。
在这种情况下，此规则将会报告假错误。
例如:
void foo( ) {
    int a[10];
    int* p1,* p2,* p3,* p4,* p5;

    p1 = a;  p1[0] = 0;  // 正常
    p2 = p1; p2[0] = 0;  // 正常
    p3 = p2; p3[0] = 0;  // 正常
    p4 = p3; p4[0] = 0;  // 违规 - 假错误
    p5 = p4; p5[0] = 0;  // 违规 - 假错误
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void my_fn(int * p1, int p2[]) {
    int index = 0;
    int * p3;
    int * p4;
    *p1 = 0;

    p1 ++;        /* 违规 - 指针递增*/
    p1 = p1 + 5;  /* 违规 - 指针增加*/
    p1[5] = 0;    /* 违规 - p1不是以数组格式来声明的*/
    p3 = &amp;p1[5];  /* 违规 - p1不是以数组格式来声明的 */
    p2[0] = 0;
    index ++;
    index = index + 5;
    p2[index] = 0; /* OK */
    p4 = &amp;p2[5];   /* OK */
}

void foo() {
    int a1[16];
    int a2[16];
    int a[10];
    int * p;

    my_fn(a1, a2);
    my_fn(&amp;a1[4], &amp;a2[4]);
    p = a;
    *(p+5) = 0; /* 违规 */
    p[5] = 0;   /* OK */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要对没有指向数组的指针做递增或者递减操作。
不要对没有指向数组元素的指针使用数组索引操作。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
  第6章，第5部分，第5-0-15条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_17</key>
<configkey>MISRA2008-5_0_17</configkey>
<name><![CDATA[ 指针之间的减法操作应该只能适用于指向相同数组元素的指针 [MISRA2008-5_0_17] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指针之间的减法操作应该只能适用于指向相同数组元素的指针 [MISRA2008-5_0_17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果两个指针指向或者至少看起来指向相同的数组
对象，指针减法仅适用于结果清晰可辨的对象。
缺点：在比较复杂的代码中，如果对指向数组或者数组
元素的指针使用指针计算，此规则可能不能工作。
在这样的情况下，此规则可能会报道假错误。
例如：
void foo( ) { 
    int a[10], i;
    int* p1,* p2,* p3,* p4,* p5; 

    p1 = a; i = p1 - a;    // OK
    p2 = p1;i = p2 - a;    // OK
    p3 = p2;i = p3 - a;    // OK
    p4 = p3;i = p4 - a;    // 违规 - 假错误
    p5 = p4;i = p5 - a;    // 违规 - 假错误
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则使得代码具有更好的可读性、更少的困惑。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a[] ) {
    int* p1 = 0;
    int* p2;
    int* p3 = a;
    int i;

    i = p1 - p2;   // 违规
    i = p2 - a;    // 违规
    i = p3 - a;    // OK
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要对指向不同数组元素的指针使用指针减法。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-17条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_18</key>
<configkey>MISRA2008-5_0_18</configkey>
<name><![CDATA[ >, >=, <, <不得适用于指针类型的对象，除非它们指向同一个数组 [MISRA2008-5_0_18] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
&gt;, &gt;=, &lt;, &lt;不得适用于指针类型的对象，除非它们指向同一个数组 [MISRA2008-5_0_18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

试图在指针之间做比较操作将会产生未定义的行为。


例外：

两个操作数都是相同类型并且指向同一数组。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对数组末尾的下一个元素的寻址是允许的，
但是访问这个元素是不允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此规则使得代码具有更高的可靠性，给人更少的困惑。”



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

在比较复杂的代码中，对指向同一数组的指针
使用比较操作，此规则可能不能正常工作。
因为在这样的情况下，此规则可能报告假错误。
例如：
void foo( ) {
    int a[10], i;
    int* p1,* p2,* p3,* p4,* p5;

    p1 = a; i = p1 &lt; a;    // 正常
    p2 = p1;i = p2 &lt; a;    // 正常
    p3 = p2;i = p3 &lt; a;    // 正常
    p4 = p3;i = p4 &lt; a;    // 违规 - 假错误
    p5 = p4;i = p5 &lt; a;    // 违规 - 假错误
}



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a[] ) {
    int* p1 = 0;
    int* p2;
    int* p3 = a;
    int i;

    i = p1 &lt; p2;   // 违规
    i = p2 &lt; a;    // 违规
    i = p3 &lt; a;    // 正常
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能对指向不同数组元素的指针做指针比较操作。




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第17部分

2. 来源: Misra 指南 - 第103条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第4.22章指针与引用, AV第171条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-18条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_19_a</key>
<configkey>MISRA2008-5_0_19_a</configkey>
<name><![CDATA[ 对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int * INTPTR;
struct s {
    int *** s3;                  /* 违规 */
};

struct s *** ps3;                /* 违规 */
int ** (***pfunc3)();            /* 违规 */
int *** ( **pfunc4)();           /* 违规 */
void function( int * par1,
    int *** par3,                /* 违规 */
    INTPTR * const * const par5  /* 违规 */
    )              
{
    int *** ptr3;                /* 违规 */
    INTPTR * const * const ptr5 = 0; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明超过两级的间接指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第170条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

4. 来源： Misra 指南 - 第102条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_19_b</key>
<configkey>MISRA2008-5_0_19_b</configkey>
<name><![CDATA[ 对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* apInt[] ;
apInt* rule12;         /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明操过两级的间接指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第170条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

4. 来源： Misra 指南 - 第102条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_19_c</key>
<configkey>MISRA2008-5_0_19_c</configkey>
<name><![CDATA[ 对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。




</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int*** (*rule13)();    /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明操过两级的间接指针。  



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

3. 来源： Misra 指南 - 第102条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_19_d</key>
<configkey>MISRA2008-5_0_19_d</configkey>
<name><![CDATA[ 对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19_d] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的声明应该包含不超过二级的指针间接寻址 [MISRA2008-5_0_19_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数组下标索引是进行指针算术运算的唯一可接受的方式，
因为它更加清楚并且也比指针操作更易于避免错误。
此规则禁止了显式的指针值的计算。数组下标索引应该
只适用于定义为数组类型的对象。任何显式地计算过的
指针值都有无意识地访问非法内存地址的可能性。
指针可能指向超出数组或者结构体的范围，
或者甚至指向一个任意的地址。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

没有指定长度的数组类型被当做指针类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* INTPTR;
void function(int ** par7[])    /* 违规 */
{
}
int*** (*xx5[])() = {0};        /* 违规 */
typedef int INTARR[];
INTARR* (**xx9[])() = {0};      /* 违规 */
int** rule21[] = {0};           /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要声明操过两级的间接指针。  



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第17部分

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第5部分，第5-0-19条规则

3. 来源： Misra 指南 - 第102条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_1_a</key>
<configkey>MISRA2008-5_0_1_a</configkey>
<name><![CDATA[ 表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了少数运算符（特别是函数调用运算符 (), &amp;&amp;, ||, ?: 
和，逗号）中的子表达式被赋值的顺序是未指定并可能变化的。
这意味着子表达式的赋值顺序是不可靠的，尤其不能信赖
副作用发生的顺序。这些在表达式赋值中
该点前面所有的副作用都可以被确定的点
被称作“顺序点”。顺序点和副作用
被描述在ISO 9899:1990[2]的节5.1.2.3,6.3和6.6中。
注意，赋值顺序不能通过使用括号得到解决，
因为这不是一个优先级的问题。
下面说明依赖于顺序的赋值是如何发生的，
并且有助于对该规则的理解。”
“这会得出不同的结果取决于是否b[i]在 i++之前被赋值，反之亦然。
在另一个单独的语句中放置增量语句可以避免该问题。”
参见:MISRA2004-12_4_a, MISRA2004-12_4_b



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止表达式的赋值依赖于编译器的版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) 
{
    int a, b[10];
    a = b[a] + a++; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( )
{
    int a, b[10];
    a = b[a] + a;  // OK
    a++;           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.联合攻击战斗机，飞行器，C++编码规范
  第4.25章节 可移植代码，飞行器 第204条规则

4.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_1_b</key>
<configkey>MISRA2008-5_0_1_b</configkey>
<name><![CDATA[ 表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数参数的赋值顺序是不确定的。这就意味着
如果函数参数包含副作用那么其产生的影响也是不确定的。
一个函数调用可以给出不同的结果取决于
该函数的哪一个参数首先被赋值。
我们可以通过副作用，理解如何访问volatile对象，修改某个对象，
或者调用包含上述操作的某个函数。

该规则检查调用的函数至少有两个参数。
在函数参数赋值期间，如果出现以下情况
   * 读取或修改某易失对象
   * 修改某非易失对象
而该对象在函数的其他参数赋值时，亦被访问
或被修改，此时报告违规。


例外：

只有一层函数调用被检查。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止编写可能在不同编译器产生不同结果的源代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Transmogrify(int,int);
int Bump(int&amp; x) {return ++x;}
void foo()
{
    int count = 5;
    Transmogrify(Bump(count),Bump(count)); // 违规
    Transmogrify(count++,count);           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Transmogrify(int,int);
int Bump(int&amp; x) {return ++x;}
void foo()
{
    int count = 5;
    int temp1 = Bump(count);
    Transmogrify(temp1,Bump(count)); // OK
    Transmogrify(count,count);       // OK
    count++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.Herb Sutter，Andrei Alexandrescu，“C++编码规范”，Addison-Wesley，
     (C) 2005 Pearson教育公司
  章节：“函数和操作符”，第31条规则

4.联合攻击战斗机，飞行器，C++编码规范
   第4.25章节可移植代码，飞行器第204条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_1_c</key>
<configkey>MISRA2008-5_0_1_c</configkey>
<name><![CDATA[ 表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了少数运算符（特别是函数调用运算符 (), &amp;&amp;, ||, ?: 
和, (逗号)）中的子表达式被赋值的顺序是未指定并可能变化的。
这意味着子表达式的赋值顺序是不可靠的，尤其不能信赖
副作用发生的顺序。这些在表达式赋值中
该点前面所有的副作用都可以被确定的点
被称作“顺序点”。顺序点和副作用
被描述在ISO 9899:1990[2]的节5.1.2.3,6.3和6.6中。
注意，赋值顺序不能通过使用括号得到解决，
因为这不是一个优先级的问题。”
“如果一个函数通过函数指针被调用，
那么它将不会依赖于函数标示符和函数参数被赋值的顺序。
p-&gt;task_start_fn(p++);”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止表达式的赋值依赖于编译器版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S {
    void (*task_start_fn)( struct S* );
};

void foo() {
    struct S* p;
    p-&gt;task_start_fn( p++ );   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S {
    void (*task_start_fn)( struct S* );
};

void foo() {
    struct S* p;
    p-&gt;task_start_fn( p );     // OK
    p++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_1_d</key>
<configkey>MISRA2008-5_0_1_d</configkey>
<name><![CDATA[ 表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_d] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了少数运算符（特别是函数调用运算符 (), &amp;&amp;, ||, ?: 
和, (逗号)）中的子表达式被赋值的顺序是未指定并可能变化的。
这意味着子表达式的赋值顺序是不可靠的，尤其不能信赖
副作用发生的顺序。
函数当他们被调用的时候可能有额外的影响（例如修改一些
全局数据）。在表达式使用它之前先调用函数，
生成一个临时变量来赋值，可以避免对赋值优先级的依赖。” 

如果一个表达式被两个函数调用，
其中第一个函数将参数作为一个指针或一个引用，
用于一个非const变量并修改该变量，
而第二个函数使用了与第一个函数相同的变量作为参数，
该规则会报告一个违规。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果一个变量在函数中通过赋值直接地修改
或函数体没有定义在当前的编译单元，规则假设这个变量被修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止表达式的赋值依赖于编译器版本。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int* ptr)
{
    (*ptr)++;
    return 0;
}
int bar(int local_param)
{
    return local_param;
}

void foo_t(int i, int j)
{
    i = foo(&amp;j) + bar(j);    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int* ptr)
{
    (*ptr)++;
    return 0;
}
int bar(int local_param)
{
    return local_param;
}

void foo_t(int i, int j)
{
    int temp = foo(&amp;j);
    i = temp + bar(j);    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.来源：Misra指南-第46条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_1_e</key>
<configkey>MISRA2008-5_0_1_e</configkey>
<name><![CDATA[ 表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_e] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了一些运算符（如：函数调用操作 (), &amp;&amp;, ||, ?: 和, (逗号)）之外，
其它的运算符在子表达式中的赋值顺序是没有被明确规定的而且
还是可以改变的。这意味着子表达式的赋值顺序不可靠，
尤其不能信赖副作用发生的顺序。

在表达式中对参数进行嵌套的赋值将造成额外的副作用。
在表达式中不使用嵌套赋值是避免表达式对赋值顺序产生
依赖性的最好方式。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则避免了表达式的赋值对编译器版本的依赖。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x, int y, int z ) {
    x = y = z / 3;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x, int y, int z ) {
    y = z / 3;  // OK
    x = y;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C:2004 C语言在关键系统中的使用指南 
   第6章，第12部分

2. 来源：Misra指南-第46条规则

3. MISRA C++:2008-C++语言在关键系统中的使用指南，
    第6章，5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_1_f</key>
<configkey>MISRA2008-5_0_1_f</configkey>
<name><![CDATA[ 表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_f] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_f-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在C语言里面提供了关键字volatile，它是一个变量类型修饰符，
用它声明的类型变量的值可以独立的随程序的执行而改变
（例如一个输入寄存器）。如果一个volatile类型变量被访问也
许会改变它的值。C编译器遇到volatile关键字声明的变量，
对访问该变量的代码就不再进行优化。另外，
如果是C程序读取volatile关键字时存在一定副作用
（改变volatile类型变量的值）。通常，存取volatile数据作
为表达式的一部分是必须的，因此这也意味着它可能依赖于
赋值的顺序。在简单的赋值语句里面volatile还是值得推荐的。”
如果在一个表达式里面使用的volatile关键字超过一个时，
本规则将报告一处违规。

参见：MISRA2004-12_2_b



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果多个Volatile类型变量被作为函数调用的入口参数使用时，
本规则将不报错。这种情况将在规则MISRA2004-12_2_b中使用。

    void goo(int, int);
    void foo()
    {
        volatile int v;
        goo(v, v);  // 违规- MISRA2004-12_2_b
    }



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则避免了表达式的赋值对编译器版本的依赖。


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
    volatile int x;
    int y;
    y = x * x;  // 违规
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( )
{
    volatile int x;
    int y;
    y = x;      // OK
    y = y * y;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南  
   第6章，第12部分

2. 来源：Misra 指南 第46条规则

3. MISRA C++:2008 –C++语言在关键系统中的使用指南，
   第6章，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_1_g</key>
<configkey>MISRA2008-5_0_1_g</configkey>
<name><![CDATA[ 表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_g] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
表达式的值在标准允许的任何计算顺序下应该相同 [MISRA2008-5_0_1_g-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

除了一些运算符（如：函数调用操作(),&amp;&amp;,||,?:和, (逗号)）之外，
其它的运算符在子表达式中的赋值顺序是没有被明确规定的
而且还是可以改变的。这意味着子表达式的赋值顺序不可靠，
尤其不能信赖副作用发生的顺序。
当函数被调用时可能会产生额外的影响（例如修改全局变量）。
在表达式使用它之前先调用函数，生成一个临时变量来赋值，
可以避免对赋值优先级的依赖。

当两个函数调用相同的全局变量或静态变量，并且至少
一个函数修改了这个变量，规则将报告一处违规。


例外：

本规则只检查单层调用关系的函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用本规则可以避免表达式赋值对编译器版本的依赖。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int global;

int modify_global()
{
    global++;
    return global;
}
int use_global()
{
    return global;
}

void expr1()
{
    int a = modify_global() + use_global();  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int global;

int modify_global()
{
    global++;
    return global;
}
int use_global()
{
    return global;
}

void expr1()
{
    int a = modify_global();
    a += use_global();           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统的使用指南
   第6章节，第12部分

2. 来源：Misra指南-第46条规则

3. MISRA C++:2008-C++语言在关键系统中的使用指南，
   第6章节，第5部分，第5-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_20</key>
<configkey>MISRA2008-5_0_20</configkey>
<name><![CDATA[ 二进制位运算符的非常量的操作数应该具有相同的原始类型 [MISRA2008-5_0_20] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
二进制位运算符的非常量的操作数应该具有相同的原始类型 [MISRA2008-5_0_20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“非常量的操作数和一个二进制位运算符应具有
相同的基本类型。‘基础类型'定义为描述
将要由评估得到的表达式，如果它不是为了
促进整体的提升。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用相同的基础类型的文件操作是位数
在最后（促进和平衡）所使用的类型，
而不是在表达式的原始类型的位数。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    unsigned char mask = ~(0x10);
    unsigned short ushort;
    ushort ^= mask;         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    unsigned short mask = ~(0x10);
    unsigned short ushort;
    ushort ^= mask;         // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-0-20

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_21</key>
<configkey>MISRA2008-5_0_21</configkey>
<name><![CDATA[ 位运算符应该只能适用于无符号原始类型的操作数 [MISRA2008-5_0_21] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
位运算符应该只能适用于无符号原始类型的操作数 [MISRA2008-5_0_21-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“按位运算 (~, &lt;&lt;, &lt;&lt;=, &gt;&gt;, &gt;&gt;=, &amp;, &amp;=, ^, ^=, | 和 |=) 
在被定义的整数或者枚举常量通常是没有意义的。
另外，如果在一个负数上实施右移，将得到一个”
被定义的执行结果。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以防止不确定的行为发生。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1( )
{
    signed short   s1;
    unsigned short us1, us2;

    us1 = us2 &amp; s1;        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1( )
{
    signed short   s1;
    unsigned short us1, us2;

    us1 = us2 &amp; (unsigned short)s1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-0-21

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_2_a</key>
<configkey>MISRA2008-5_0_2_a</configkey>
<name><![CDATA[ 限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_a-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
当操作符的右操作数是赋值表达式时，通常需要使用括号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
	int a, b;
	b = a = 0;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
	int a, b;
	b = (a = 0);	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节 可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_2_b</key>
<configkey>MISRA2008-5_0_2_b</configkey>
<name><![CDATA[ 限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_b-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。
在复杂的C语言运算规则中，很容易出错，
使用括号可以避免发生这种错误，也有助于我们理解代码。
但是不要使用太多的括号，这样会使代码变得零乱，
并且影响代码的可读性。”
“对于赋值运算符的右侧操作数不是必须使用括号，
除非它的右侧包含一个赋值语句。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

不检查宏的结构体。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
	int a, b;

	b = (a = 0);	// OK
	b = (a + 0);	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
	int a, b;

	b = (a = 0);	// OK
	b = a + 0;	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器 第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_2_c</key>
<configkey>MISRA2008-5_0_2_c</configkey>
<name><![CDATA[ 限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_c-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
对于一元运算符的操作数，本规则要求其不使用圆括号。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) 
{
    int a, b;
    b = a * (-1);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) 
{
    int a, b;
    b = a * -1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_2_d</key>
<configkey>MISRA2008-5_0_2_d</configkey>
<name><![CDATA[ 限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_d] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_d-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
“如果所有的运算符优先级相同，可以使用括号来控制操作数的
运算顺序。部分运算符（例如加法和乘法）在代数上可以结合
但在C语言里并不一定能够结合。同样，整型运算
涉及很多混合类型（有些类型已被某些规则禁止使用），
可能会由于整型提升产生不同类型的运算结果。下面的例子中
对于16位数据加法的执行情况充分证明
加法是不能结合的，并且对于表达式的结构清晰非常重要：”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则在算术运算中增加了安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifdef _MSC_VER
typedef unsigned __int16 uint16;
typedef unsigned __int32 uint32;
#elif __GNUC__
#include &lt;sys/types.h&gt;
typedef u_int16_t uint16;
typedef u_int32_t uint32;
#endif

void fooPlus( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = (a + b) + c; /* 违规- d 等于 9; a + b 超出范围 65536 */ 
}

void fooMultiply( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = (a * b) * c; /* 违规- d 等于 65526; a * b 超出范围 65536 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifdef _MSC_VER
typedef unsigned __int16 uint16;
typedef unsigned __int32 uint32;
#elif __GNUC__
#include &lt;sys/types.h&gt;
typedef u_int16_t uint16;
typedef u_int32_t uint32;
#endif

void fooPlus( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = a + (b + c); /* 正确-d 的值是65545 */
}

void fooMultiply( ) {
    uint16 a = 10;
    uint16 b = 65535;
    uint32 c = 0;
    uint32 d;
    d = a * (b * c); /* 正确- d的值是 655350 */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_2_e</key>
<configkey>MISRA2008-5_0_2_e</configkey>
<name><![CDATA[ 限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_e] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_e-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。
除非某表达式内仅使用一种操作符，否则应使用括号。”
参见: MISRA2004-12_5, CODSTA-90



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

逻辑 &amp;&amp; 和 || 的操作数由 MISRA2004-12_5 规则检查



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a, b;
    b = a * a + a;      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int a, b;
    b = (a * a) + a;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节可移植代码，飞行器 第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_2_f</key>
<configkey>MISRA2008-5_0_2_f</configkey>
<name><![CDATA[ 限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_f] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制依赖 C++ 语言表达式中的运算符优先级规则 [MISRA2008-5_0_2_f-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用括号的表达式的优先级会高于表达式默认的运算顺序，
也会起到强调的作用。在复杂的C语言运算规则中，
很容易出错，使用括号可以避免发生这种错误，
也有助于我们理解代码。但是不要使用太多的括号，
这样会使代码变得零乱，并且影响代码的可读性。”
如果括号嵌套的太多，很可能会违反某个代码解析的限制，
如果发生这种情况，表达式有可能是非常复杂的，应该进行拆分。
此规则检查嵌套的括号层数-如果嵌套层数超过10，就会提示违规信息。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

括号嵌套层数被设置为10，但可以更改。要更改默认的
括号嵌套层数，修改规则(Collector A)的主"Count"表达式，
把"$$ &gt; 9"改为"$$ &gt; N"，N是预设的门限值。
规则头也需要相应的修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
   int a, b,c,d;
   a=(((((((((((b+1)+1)+c)*d)/2)+1)*b)+c)*d)+8)/(b+d))+3; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( )
{
    int a, b,c,d;
    int h;
    h = (((((((((b+1)+1)+c)*d)/2)+1)*b)+c)*d)+8;   // OK
    a =(h*(b+d))+3;                                // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.MISRA-C:2004 C语言在关键系统中的使用指南
  第6章，第12部分

2.联合攻击战斗机，飞行器，C++编码规范
  第4.28章节 可移植代码，飞行器 第213条规则

3.MISRA C++:2008 C++语言在关键系统中的使用指南，
  第6章，第5部分，第5-0-2条规则

4.来源：Misra指南-第47条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_3_a</key>
<configkey>MISRA2008-5_0_3_a</configkey>
<name><![CDATA[ cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
“限制复杂表达式的隐性转换的目的
是要求在一个表达式里的一系列算术运算里，
所有的运算需要按照相同的算术类型来执行。
注意这并不意味着该表达式里所有的操作数都是
相同的数据类型。
表达式u32a + u16b + u16c是合乎要求的-两个加法运算将理论上
按照U32类型来执行。
表达式u16a + u16b + u32c是不合乎要求的-第一次加法运算
理论上是按照U16类型执行的而第二次运算则是U32类型。
这里使用措辞“理论上的”是因为，算术运算执行时所使用的类型
依赖于该系统中整型类型的实际长度。
该规则检查是否使用了复杂表达式的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = u16b + u16a + u32b;          /* Violation */
    u32a = u32b + (u16a + u16b);        /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = u32b + u16b + u16a;          /* OK */
    u32a = u16b + (u16a + u32b);        /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-3条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_3_b</key>
<configkey>MISRA2008-5_0_3_b</configkey>
<name><![CDATA[ cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不应该隐式
转换为不同的基础类型。
基本类型是指可以
从表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。
限制复杂表达式隐式转换的目的是
要求表达式中算术运算按一定的顺序执行，
所有的操作应当以完全一致的运算类型进行。”
规则检查复杂表达式隐式转换是否被使用。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

规则只能检查简单表达式。当表达式太复杂
时规则不能报告违例。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned short u16a,u16b;
    unsigned int u32a;

    u32a = u16b + u16a;                      /*  违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned short u16a,u16b;
    unsigned int u32a;

    u32a = (unsigned int)(u16b + u16a);      /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004C语言在关键系统中的使用指南 
    第6章，第10节

2. MISRA-C++: 2008C++语言在关键系统中的使用指南  
    第6章，第5节，第5-0-3条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_3_c</key>
<configkey>MISRA2008-5_0_3_c</configkey>
<name><![CDATA[ cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
cvalue 表达式不得隐式地转换成不同的原始类型 [MISRA2008-5_0_3_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值不应当被隐式
转换为不同的基础类型。
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。
限制复杂表达式隐式转换的目的是要求表达式
中算术运算按一定的顺序执行，
所有的操作应当以完全一致的运算类型进行。”
规则检查是否使用了复杂表达式的隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

“规则只能检查简单表达式。当表达式太复杂时，
规则无法报告违例。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned short u16a,u16b;
    unsigned int u32a = u16b + u16a;                      /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned short u16a,u16b;
    unsigned int u32a = (unsigned int)(u16b + u16a);      /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004C语言在关键系统中的使用指南
    第6章，第10节

2. MISRA-C++: 2008C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-3条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_4_a</key>
<configkey>MISRA2008-5_0_4_a</configkey>
<name><![CDATA[ 整型的隐式转换不得改变原始类型的符号属性 [MISRA2008-5_0_4_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型的隐式转换不得改变原始类型的符号属性 [MISRA2008-5_0_4_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
该规则检查是否使用了有符号和无符号类型之间的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned int u32a, u32b;
    signed int s32a, s32b;

    s32a = u32a;            /* Violation */
    s32b = s32a + u32a;     /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned int u32a, u32b;
    signed int s32a, s32b;

    s32a = (signed int)u32a;        /* OK */
    s32b = s32a + (signed int)u32b; /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-4条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_4_b</key>
<configkey>MISRA2008-5_0_4_b</configkey>
<name><![CDATA[ 整型的隐式转换不得改变原始类型的符号属性 [MISRA2008-5_0_4_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型的隐式转换不得改变原始类型的符号属性 [MISRA2008-5_0_4_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值不应当隐式
转换为不同的基础类型。
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。”
规则检查变量初始化时是否使用了有符号数和无符号数
之间的隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned int u32a;
    signed int s32a = u32a;                 /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( )
{
    unsigned int u32a;
    signed int s32a = (signed int)u32a;     /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004C语言在关键系统中的使用指南	
    第6章，第10节

2. MISRA-C++: 2008C++语言在关键系统中的使用指南	
    第6章，第5节，第5-0-4条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_5_a</key>
<configkey>MISRA2008-5_0_5_a</configkey>
<name><![CDATA[ 不得有浮点型-整型的隐式转换 [MISRA2008-5_0_5_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得有浮点型-整型的隐式转换 [MISRA2008-5_0_5_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型的表达式的值不应当被隐式转换
为一个不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = f32a;                // 违规
    s32b = f32a;                // 违规
    f32a = f64a;                // 违规
    f64a = f32b + f32a + f64b;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = (unsigned int)f32a;  // OK
    s32b = (signed int)f32a;    // OK
    f32a = (float)f64b;         // OK
    f64a = f64b + f32b + f32a;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004 C语言在关键系统中的使用指南

2. 联合攻击战斗机，飞行器，C++编码规范 
    4.23章节 类型转换， 飞行器第184条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-5条规则

4.MISRA-C++:  2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_5_b</key>
<configkey>MISRA2008-5_0_5_b</configkey>
<name><![CDATA[ 不得有浮点型-整型的隐式转换 [MISRA2008-5_0_5_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得有浮点型-整型的隐式转换 [MISRA2008-5_0_5_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型表达式的值不应当隐式转换
为不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef float float32_t;

void goo_float( ) {
    double f64a;
    float f32a;

    float32_t f32bt = f64a;      // 违规
    unsigned int u32a = f32a;    // 违规
    unsigned short u16a = 1.0;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef float float32_t;

void goo_float( ) {
    double f64a;
    float f32a;

    float32_t f32bt = (float)f64a;             // OK
    unsigned int u32a = (unsigned int)f32a;    // OK
    unsigned short u16a = (unsigned short)1.0; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1．MISRA-C:2004 C语言在关键系统中的使用指南

2．联合攻击战斗机，飞行器，C++编码规范 
     4.23章节 类型转换， 飞行器第184条规则

3．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-5条规则

4．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_5_c</key>
<configkey>MISRA2008-5_0_5_c</configkey>
<name><![CDATA[ 不得有浮点型-整型的隐式转换 [MISRA2008-5_0_5_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得有浮点型-整型的隐式转换 [MISRA2008-5_0_5_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“整型表达式的值不能被隐性地
转换成一个不同的底层类型。
术语“底层类型”定义为：它描述一种类型，该类型
在求一个表达式的值时得到，条件是该表达式
未进行整形提升。”
该规则检查是否使用了整型和浮点类型之间的隐性转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过遵循这种所有的运算都基于一致的（底层）类型
而实现的准则，有可能避免程序员的困惑以及一些与整
型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    float f32a;
    unsigned int u32a;

    f32a = u32a;                /* Violation */
    f32a = f32a + u32a;         /* Violation */
    f32a = u32a + 2.5f;         /* Violation */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    float f32a;
    unsigned int u32a;

    f32a = (float)u32a;         /* OK */
    f32a = f32a + (float)u32a;  /* OK */
    f32a = (float)u32a + 2.5f;  /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 10 节

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   ，第 6 章，第 5 节， 第5-0-5条规则

3. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_6_a</key>
<configkey>MISRA2008-5_0_6_a</configkey>
<name><![CDATA[ 整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型表达式的值不能隐式转换
为不同的基本类型。
术语underlying type（基本类型）是指可以从表达式
的运算中获得的运算类型，并且是该表达式
不经过整型提升。
整型提升描述了一个依靠算术运算对（有符号或无符号）
int或long整型操作数进行操作的过程。
其他整型操作数（如：char, short, bit-field 和 enum）
通常在算术运算前转换为int或无符号int类型。
整数常量表达式的基础类型
会根据它的大小和正负决定。”
规则检测是否存在长宽类型向窄类型隐式转换。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果所有的操作都由一致的潜在类型
执行，可以避免程序员的困惑
和关于整型提升的危险。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned char u8a;
    unsigned short u16a;
    unsigned int u32a;

    u16a = u32a;        /* 违规*/
    u8a  = u32a;        /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Conv1_int( ) {
    unsigned char u8a;
    unsigned short u16a;
    unsigned int u32a;

    u16a = (unsigned short)u32a;       /* OK */
    u8a  = (unsigned char)u32a;        /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004C语言在关键系统的使用指南 
    第 6 章，第 10 节

2. MISRA-C++: 2008C++语言在关键系统的使用指南 
    第 6 章，第 5 节，第 5-0-6 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_6_b</key>
<configkey>MISRA2008-5_0_6_b</configkey>
<name><![CDATA[ 整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型的表达式的值不应当被隐式转换
为一个不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = f32a;                // 违规
    s32b = f32a;                // 违规
    f32a = f64a;                // 违规
    f64a = f32b + f32a + f64b;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned short goo_float( ) {
    double f64a, f64b;
    float f32a, f32b;
    unsigned int u32a, u32b;
    signed int s32a,s32b;

    u32b = (unsigned int)f32a;  // OK
    s32b = (signed int)f32a;    // OK
    f32a = (float)f64b;         // OK
    f64a = f64b + f32b + f32a;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C: 2004 C语言在关键系统中的使用指南

2. 联合攻击战斗机，飞行器，C++编码规范 
    4.23章节 类型转换， 飞行器第184条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-5条规则

4.MISRA-C++:  2008 C++语言在关键系统中的使用指南
    第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_6_c</key>
<configkey>MISRA2008-5_0_6_c</configkey>
<name><![CDATA[ 整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型或浮点型的隐式转换不得减少原始类型的长度 [MISRA2008-5_0_6_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个float类型表达式的值不应当隐式转换
为不同的类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果所有的操作都由
一致的潜在类型执行，可以避免程序员的困惑
和与整型提升相关的危险。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef float float32_t;

void goo_float( ) {
    double f64a;
    float f32a;

    float32_t f32bt = f64a;      // 违规
    unsigned int u32a = f32a;    // 违规
    unsigned short u16a = 1.0;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef float float32_t;

void goo_float( ) {
    double f64a;
    float f32a;

    float32_t f32bt = (float)f64a;             // OK
    unsigned int u32a = (unsigned int)f32a;    // OK
    unsigned short u16a = (unsigned short)1.0; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1．MISRA-C:2004 C语言在关键系统中的使用指南

2．联合攻击战斗机，飞行器，C++编码规范 
     4.23章节 类型转换， 飞行器第184条规则

3．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-5条规则

4．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-6条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_7_a</key>
<configkey>MISRA2008-5_0_7_a</configkey>
<name><![CDATA[ cvalue 表达式不得有显式地浮点型-整型转换 [MISRA2008-5_0_7_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
cvalue 表达式不得有显式地浮点型-整型转换 [MISRA2008-5_0_7_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个复杂整型表达式被强制转换为不同符号类型或比
基础类型表达式要长的类型时，
规则报告违例。
“复杂表达式这一术语定义为除下列条件外的任何表达式：
	-一个常量表达式
	-一个lvalue（例如一个对象）
	-函数的返回值
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则预防了和开发者预期不一致的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction()
{
    unsigned int ui1, ui2;
    signed int si1, si2;
    unsigned short us1, us2;
    double d;
	
    ui1 = (unsigned int)(si1 + si2); /* 违规-有符号类型强制转换成无符号类型 */
    si1 = (signed int)(ui1 / ui2);   /* 违规-有符号类型强制转换成无符号类型 */
    ui1 = (unsigned int)(us1 - us2); /* 违规-有符号类型强制转换成无符号类型 */
    d = (double)(ui1 * ui2);         /* 违规-有符号类型强制转换成无符号类型 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction()
{
    unsigned int ui1, ui2;
    signed int si1, si2;
    unsigned short us1, us2;
    double d;
	
    ui1 = (unsigned int)si1 + (unsigned int)si2; /* OK */
    si1 = (signed int)ui1 / (signed int)ui2;     /* OK */
    ui1 = (unsigned int)us1 - (unsigned int)us2; /* OK */
    d = (double)ui1 * (double)ui2;               /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1．MISRA-C: 2004 C语言在关键系统中的使用指南
     第6章，第10节

2．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-7条规则

3．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-8条规则

4．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-9条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_7_b</key>
<configkey>MISRA2008-5_0_7_b</configkey>
<name><![CDATA[ cvalue 表达式不得有显式地浮点型-整型转换 [MISRA2008-5_0_7_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
cvalue 表达式不得有显式地浮点型-整型转换 [MISRA2008-5_0_7_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果强制转换被用到任何复杂表达式上，
须严格限制强制转换类型。
复杂表达式的转换经常引起
混淆，因此应谨慎使用之。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免了数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef float           float32_t;
typedef double          float64_t;
typedef long double     float128_t;

void goo( ) {
    float128_t f128a, f128b;
    float64_t f64a, f64b;
    float32_t f32a, f32b;

    (float64_t)(f32a + f32b);   /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef float           float32_t;
typedef double          float64_t;
typedef long double     float128_t;

void goo( ) {
    float128_t f128a, f128b;
    float64_t f64a, f64b;
    float32_t f32a, f32b;

    (float32_t)(f64a + f64b);  /* 正确-强制转换成短float类型*/
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1．MISRA-C:2004 C语言在关键系统中的使用指南
     第6章，第10节

2．MISRA-C++:2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_8</key>
<configkey>MISRA2008-5_0_8</configkey>
<name><![CDATA[ 整型或浮点型的显式转换不得增加 cvalue 表达式的原始类型的长度 [MISRA2008-5_0_8] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型或浮点型的显式转换不得增加 cvalue 表达式的原始类型的长度 [MISRA2008-5_0_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个复杂整型表达式被强制转换为不同符号类型或比
基础类型表达式要长的类型时，
规则报告违例。
“复杂表达式这一术语定义为除下列条件外的任何表达式：
	-一个常量表达式
	-一个lvalue（例如一个对象）
	-函数的返回值
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则预防了和开发者预期不一致的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction()
{
    unsigned int ui1, ui2;
    signed int si1, si2;
    unsigned short us1, us2;
    double d;
	
    ui1 = (unsigned int)(si1 + si2); /* 违规-有符号类型强制转换成无符号类型 */
    si1 = (signed int)(ui1 / ui2);   /* 违规-有符号类型强制转换成无符号类型 */
    ui1 = (unsigned int)(us1 - us2); /* 违规-有符号类型强制转换成无符号类型 */
    d = (double)(ui1 * ui2);         /* 违规-有符号类型强制转换成无符号类型 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction()
{
    unsigned int ui1, ui2;
    signed int si1, si2;
    unsigned short us1, us2;
    double d;
	
    ui1 = (unsigned int)si1 + (unsigned int)si2; /* OK */
    si1 = (signed int)ui1 / (signed int)ui2;     /* OK */
    ui1 = (unsigned int)us1 - (unsigned int)us2; /* OK */
    d = (double)ui1 * (double)ui2;               /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1．MISRA-C: 2004 C语言在关键系统中的使用指南
     第6章，第10节

2．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-7条规则

3．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-8条规则

4．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-9条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_0_9</key>
<configkey>MISRA2008-5_0_9</configkey>
<name><![CDATA[ 整型或浮点型的显式转换不得增加 cvalue 表达式的原始类型的长度 [MISRA2008-5_0_9] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型或浮点型的显式转换不得增加 cvalue 表达式的原始类型的长度 [MISRA2008-5_0_9-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在一个复杂整型表达式被强制转换为不同符号类型或比
基础类型表达式要长的类型时，
规则报告违例。
“复杂表达式这一术语定义为除下列条件外的任何表达式：
	-一个常量表达式
	-一个lvalue（例如一个对象）
	-函数的返回值
基本类型是指可以从
表达式的运算中获得的运算类型，并且是该表达式不经过
整形提升。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则预防了和开发者预期不一致的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void myFunction()
{
    unsigned int ui1, ui2;
    signed int si1, si2;
    unsigned short us1, us2;
    double d;
	
    ui1 = (unsigned int)(si1 + si2); /* 违规-有符号类型强制转换成无符号类型 */
    si1 = (signed int)(ui1 / ui2);   /* 违规-有符号类型强制转换成无符号类型 */
    ui1 = (unsigned int)(us1 - us2); /* 违规-有符号类型强制转换成无符号类型 */
    d = (double)(ui1 * ui2);         /* 违规-有符号类型强制转换成无符号类型 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void myFunction()
{
    unsigned int ui1, ui2;
    signed int si1, si2;
    unsigned short us1, us2;
    double d;
	
    ui1 = (unsigned int)si1 + (unsigned int)si2; /* OK */
    si1 = (signed int)ui1 / (signed int)ui2;     /* OK */
    ui1 = (unsigned int)us1 - (unsigned int)us2; /* OK */
    d = (double)ui1 * (double)ui2;               /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1．MISRA-C: 2004 C语言在关键系统中的使用指南
     第6章，第10节

2．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-7条规则

3．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-8条规则

4．MISRA-C++: 2008 C++语言在关键系统中的使用指南
     第6章，第5节，第5-0-9条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_14_1</key>
<configkey>MISRA2008-5_14_1</configkey>
<name><![CDATA[ 逻辑运算符 && 或 || 的右边操作数不得包含副作用 [MISRA2008-5_14_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑运算符 &amp;&amp; 或 || 的右边操作数不得包含副作用 [MISRA2008-5_14_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

含副作用，而且这些副作用
依赖于其他子表达式的值，有可能发生也有可能
不发生。可能导致这一问题的运算符包括&amp;&amp;和||，
在这两种运算符中，对右边操作数的赋值要受到
左边操作数值的条件限制。有可能引起副
作用的操作包括：访问volatile类型
对象，修改某个对象，修改某个文件，或调用某个
执行了上述某个操作的函数等。这些操作可能改
变调用函数的运行环境状态。”
参见：MISRA2004-12_2_a, MISRA2004-12_4_b



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则只能检查三层嵌套级别的函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果开发者信赖一个副作用的发生，
使用本规则可以避免对右操作数进行有条件赋值造成的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int i;
    int j;
    if ((j == i) || (0 == i++)) ; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int i;
    int j;
    if ((j == i) || (0 == i)) i++; // OK
}


参考文献：

1. MISRA-C:2004 C语言在关键系统的使用指南 
   第6章，第12部分

2. 来源：Misra指南-第33条规则

3. 联合攻击战斗机，飞行器，C++编程规范
   4.21章节操作符，飞行器第157条规则

4. MISRA C++:2008-C++语言在关键系统中的使用指南，
   第6章，第5部分，第5-14-1条规则

5. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_18_1</key>
<configkey>MISRA2008-5_18_1</configkey>
<name><![CDATA[ 不得使用逗号操作符 [MISRA2008-5_18_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用逗号操作符 [MISRA2008-5_18_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“使用逗号运算符会降低代码的可读性, 
可以通过其他方法实现逗号运算符的功能。”
参见 misra-042



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高代码的可读性和可维护性.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = 0, y = 0;           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = 0;
    y = 0;                 // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
   第6章，第12节

2. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，规则5-18-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_1</key>
<configkey>MISRA2008-5_2_1</configkey>
<name><![CDATA[ 逻辑运算符 && 或 || 的每个操作数应该都是后缀表达式 [MISRA2008-5_2_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逻辑运算符 &amp;&amp; 或 || 的每个操作数应该都是后缀表达式 [MISRA2008-5_2_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当单标签、常量或者函数调用没有加上
括号，该规则将报告一个违规。
"加括号对于代码的可读性和确保代码
按照程序员所设计逻辑运行非常重要。"
See also: MISRA2004-12_1_e, MISRA2004-12_5


例外：

"如果表达式仅由逻辑操作符 '&amp;&amp;' 或仅由逻
辑操作符 '||' 组成, 则不需括号。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"这个规则的效果是需要有适当的括号运算。" 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || y &amp;&amp; z );         // 违规
    if ( x &amp;&amp; !y );             // 违规
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int x, int y, int z )
{
    if ( x || ( y &amp;&amp; z ) );         // OK
    if ( x &amp;&amp; ( !y ) );             // OK
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 5, Rule 5-2-1

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.21 Operators, AV Rule 158

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_10</key>
<configkey>MISRA2008-5_2_10</configkey>
<name><![CDATA[ 递加 (++) 和递减 (--) 运算符不得在表达式中和其他运算符混合使用 [MISRA2008-5_2_10] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
递加 (++) 和递减 (--) 运算符不得在表达式中和其他运算符混合使用 [MISRA2008-5_2_10-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“此规则的目的是说明，当使用递增或递减运算
符时，递增或递减操作应该是语句完成的唯一附加功能.
此规则建议在使用++和--运算符时不要与其他 
数学运算符混合起来使用因为：
 - 影响代码的可读性
 - 对在声明中没有明确定义的函数行为产生额外
   的影响
I建议单独使用++和--运算符比较
安全。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性。 
降低由于额外影响导致函数潜在的
不确定行为的危险



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int x, y;
    x = --y + x++;  /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int x, y;
    --y;            /* OK */
    x = y + x;
    x++;            /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 联合攻击战斗机，飞行器，C++编码规范，
    第4.25章，飞行器第204条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南，
    第6章，第12节，第5-2-10条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_11</key>
<configkey>MISRA2008-5_2_11</configkey>
<name><![CDATA[ 逗号运算符, && 运算符和 || 运算符不得被重载 [MISRA2008-5_2_11] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逗号运算符, &amp;&amp; 运算符和 || 运算符不得被重载 [MISRA2008-5_2_11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“内建的 &amp;&amp;, || 或者, （逗号） 会受到编译器的特殊处理。
如果用户重载它们，他们会变成具有特殊语义的普通功能，
并且这是一个肯定会引入隐蔽的缺陷和脆弱性的方式。"
此规则用于检测用户重载运算符 &amp;&amp;, || 或者 ,（逗号）时。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

重载这些操作符将改变编译器读取表达式语义 
的方式，造成不可预知的程序行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( int i ) : _i( i ) {}
    ~A( );

    int value( ) { return _i; }
private:
    int _i;
};

int operator&amp;&amp;( A&amp; lhs, A&amp; rhs ) {              // 违规
    return lhs.value( ) &amp;&amp; rhs.value( );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要重载运算符 &amp;&amp;, || 或者 ,（逗号）。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范” Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Functions and Operators", 第30条规则

2. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: “操作符”， 第7项

3. 联合攻击战斗机， 飞行器， C++ 编码规范
   章节 4.21 操作符, AV 第159条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第5节, 规则5-2-11

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_12</key>
<configkey>MISRA2008-5_2_12</configkey>
<name><![CDATA[ 作为函数实参传递的数组类型标识符不得退化为一个指针 [MISRA2008-5_2_12] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
作为函数实参传递的数组类型标识符不得退化为一个指针 [MISRA2008-5_2_12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一个具有数组类型的变量退化为一个指针时，它的边界都将丢失。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果设计需要不同长度的数组，那么应该
使用一个类来封装数组对象从而确保能够维持
数组的维数。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32_t;

void f1( int32_t p[ 10 ] );
void f2( int32_t *p );

void b ()
{
    int32_t a[ 10 ];
   
    f1( a ); // 违规
    f2( a ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int32_t;

void f1( int32_t ( &amp;p )[ 10 ] );

void b ()
{
    int32_t a[ 10 ];
    f1( a );          // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-2-12

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_2</key>
<configkey>MISRA2008-5_2_2</configkey>
<name><![CDATA[ 指向虚基类的指针应该只能通过 dynamic_cast 的方式强制类型转换为指向派生类的指针 [MISRA2008-5_2_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指向虚基类的指针应该只能通过 dynamic_cast 的方式强制类型转换为指向派生类的指针 [MISRA2008-5_2_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“由于继承的虚拟性不属于其基类型，
因此其衍生类对象的规划，通过虚拟基
类型的指针，在编译时是未知的。”
“采用除dynamic_cast外的其它方式进
行从虚拟基类型到衍生类的类型转换会
引起未定义的行为。”
参见：OOP-29，OOP-49



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止未定义行为的发生。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// The code is not compilable with all compilers
class B { 
public:
	virtual int foo();
};
class D: public virtual B {
public:
	virtual int foo(){}
};
void fun(){
    D d;
    B *pB = &amp;d;
    D *pD = static_cast&lt;D*&gt;(pB);  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B { 
public:
	virtual int foo();
};
class D: public virtual B {
public:
	virtual int foo(){}
};
void fun(){
    D d;
    B *pB = &amp;d;
    D *pD = dynamic_cast&lt;D*&gt;(pB);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.23章 类型转换，AV规则第179条

2.MISRA C++:2008 - 在关键系统中使用C++语言的准则
  第6章，第5节，第5-2-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_3</key>
<configkey>MISRA2008-5_2_3</configkey>
<name><![CDATA[ 从基类到派生类的强制类型转换不得在多态类型上进行 [MISRA2008-5_2_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
从基类到派生类的强制类型转换不得在多态类型上进行 [MISRA2008-5_2_3-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“下向类型转换指一个类类型转换为其衍生类的行为。
多台现象是接口和层次结构实现的强抽象。显式类型转
换会旁路抽象层，造成更高层级的相关性耦合。”
“从基类型到衍生类的类型转换是危险的，除非提供一
种多态机制类确保该类型转换是合法的。”
参见：OOP-29，OOP-50



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止非法类型转换并确保抽象层不会被旁路掉。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B
{
    public:
    virtual int foo( );
};

class D : public B
{
    public:
    int foo( );
};
 
void main( )
{
    B *b;
    D *d;
    d = (D*) b; // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止将指向基类型的指针转换为指向其衍生类的
指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - 在关键系统中使用C++语言的准则
第6章，第5节，第5-2-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_4</key>
<configkey>MISRA2008-5_2_4</configkey>
<name><![CDATA[ 不得使用 C 语言风格的强制类型转换(除 void 强制类型转换)和函数符号式强制类型转换(除了显式的构造函数调用) [MISRA2008-5_2_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 C 语言风格的强制类型转换(除 void 强制类型转换)和函数符号式强制类型转换(除了显式的构造函数调用) [MISRA2008-5_2_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“C语言风格 (强制转换符号), 不调用转换构造函数的
函数符号式强制转换能够执行不相关类型之间的
强制转换。” 


例外:

“C语言风格的强制类型转换为 void 可能用于表示
非 void 函数调用的返回值将会被忽略。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C++ 语言的强制类型转换比 C 语言强制转换更具体
并且更容易查找和阅读。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {
public:
    Base( );
    virtual ~Base( );
};

class Derived : public Base {
public:
    Derived( );
    ~Derived( );
};

void foo( ) {
    Base *pB;
    Derived *pD2 = (Derived *) pB;     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    Base( );
    virtual ~Base( );
};

class Derived : public Base {
public:
    Derived( );
    ~Derived( );
};

void foo( ) {
    Base *pB;
    Derived *pD1 = dynamic_cast&lt;Derived*&gt;( pB );   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-2-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_5</key>
<configkey>MISRA2008-5_2_5</configkey>
<name><![CDATA[ 强制类型转换不得从指针或引用类型中移除任何 const 或 volatile 的修饰 [MISRA2008-5_2_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
强制类型转换不得从指针或引用类型中移除任何 const 或 volatile 的修饰 [MISRA2008-5_2_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“任何试图通过强制转换来删除与地址类型
相关的限定符都违反了类型限定的原则。
注意，这里提到的限定不同于可能应用在指针本身的任何限定。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止了未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned short uint16_t;
void foo( ) 
{
    uint16_t *pi, **ppi;
    uint16_t * const * pcpi;  /*指针指向常量指针*/
    const uint16_t * * ppci;  /*指向常量指针的指针 */
    const uint16_t * pci;     /* 指向常量指针 */
    volatile uint16_t * pvi;  /* 指向变量指针 */

    pi = (uint16_t *)pci;     /* 违规*/
    pi = (uint16_t *)pvi;     /* 违规 */
    ppi = (uint16_t * *)pcpi; /* 违规*/
    ppi = (uint16_t * *)ppci; /* 违规*/
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能把'const'或'volatile'类型地址指针强制转换成
'non-const'或'non-volatile'类型。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

2. MISRA C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-2-5条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_6</key>
<configkey>MISRA2008-5_2_6</configkey>
<name><![CDATA[ 强制类型转换不得转换指向函数的指针为任何其他类型的指针，包括指向函数的指针 [MISRA2008-5_2_6] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
强制类型转换不得转换指向函数的指针为任何其他类型的指针，包括指向函数的指针 [MISRA2008-5_2_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个函数指针转换为一个非函数指针类型的导致了
未定义行为的发生. 如果一个函数调用被用来
使用一个函数指针转换结果的指针，未定义的行为可能会出现.”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以阻止未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void f ( int )
{
    reinterpret_cast&lt; void (*)( ) &gt;( &amp;f ); // 违规
    reinterpret_cast&lt; void * &gt;( &amp;f );      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要把一个指向函数的指针转换为其他类型的指针类型。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-2-6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_7</key>
<configkey>MISRA2008-5_2_7</configkey>
<name><![CDATA[ 一个指针类型的对象不得直接或间接地被转换为无关的指针类型 [MISRA2008-5_2_7] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个指针类型的对象不得直接或间接地被转换为无关的指针类型 [MISRA2008-5_2_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个指向对象类型的指针和一个指向不同类型对象的指针之间不能执行强制转换。
如果新指针类型需要严格对齐，这种转换可能无效。
指针类型可以如下分类：
-指向对象指针
-指向函数指针
-指向void类型指针
-空指针常量(数值0强制转换成void类型*)”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则不检查const或volatile类型的指针。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不正确的指针校准。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
    unsigned int* ui;
    signed char*  sc;

    /* Examples of incorrect code */
    ui = (unsigned int*) sc;          /* 违规 */
    ui = (unsigned int*) &amp;sc;         /* 违规*/
}


修复 ：

typedef unsigned int uint32_t;
void foo( )
{
    unsigned int* ui;
    uint32_t*  ui_t;

    /* Examples of correct code */ 
    ui = (unsigned int*) ui_t;         /* OK */
    ui = (unsigned int* const) ui_t;   /* OK */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

2. 来源：Misra指南第45条规则

3. MISRA C++:2008 c++语言在关键系统中的使用指南，
    第6章，第5节，第5-2-7条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_8</key>
<configkey>MISRA2008-5_2_8</configkey>
<name><![CDATA[ 整数类型的对象或指向 void 类型的指针的对象不得被转换为指针类型的对象 [MISRA2008-5_2_8] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整数类型的对象或指向 void 类型的指针的对象不得被转换为指针类型的对象 [MISRA2008-5_2_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个整型或指针为空的对象不能转换
为一个指针类型的对象”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

一般来说，从整型或指针为空的类型转化为
对象的指针会导致不可预料的结果。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S
{
    int i;
    int j;
};

void f ( void * v, int i )
{
    S * s1 = reinterpret_cast&lt; S * &gt;( v ); // 违规
    S * s2 = reinterpret_cast&lt; S * &gt;( i ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要转换一个整型或指针为空的对象
为一个指针类型的对象



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-2-8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_2_9</key>
<configkey>MISRA2008-5_2_9</configkey>
<name><![CDATA[ 强制类型转换不得转换一个指针类型为整型 [MISRA2008-5_2_9] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
强制类型转换不得转换一个指针类型为整型 [MISRA2008-5_2_9-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“将指针转换成指向整形的指针时，需要定义整型大小，此数值由实现方式决定。
指针和整数类型之间的强制转换应尽可能避免，
但有时寻址内存映射寄存器或其他硬件特定性能可能不可避免。”


例外：

规则允许强制转换成UINT_PTR或者INT_PTR类型。
这些类型是整数类型，分别给32位和64位Windows指针扩展大小。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止未定义或由实现方式定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int* pi;
    int i;
    i = (int) pi;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能把指针强制转换成非指针。




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第11节

2. Misra指南第45条规则

3. Ellemtel编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3</A>
   出自：18可移植代码-18.3类型转换- Port. Rec. 7

4. <A HREF="http://msdn2.microsoft.com/en-gb/library/aa489560.aspx">http://msdn2.microsoft.com/en-gb/library/aa489560.aspx</A>

5. <A HREF="http://www.codeproject.com/system/64BitOSAndPortingIssues.asp">http://www.codeproject.com/system/64BitOSAndPortingIssues.asp</A>

6. 联合攻击战斗机，飞行器，C++编码规范
    4.24章节流量控制结构，飞行器第128条规则

7. MISRA C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-2-9条规则

8. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_3_1</key>
<configkey>MISRA2008-5_3_1</configkey>
<name><![CDATA[ ! 运算符, 逻辑 && 或逻辑 || 运算符的每个操作数应该都是布尔类型 [MISRA2008-5_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
! 运算符, 逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型 [MISRA2008-5_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这些操作符使用布尔以外的其他类型作为操作数是
没有多大意义（或者目的）。这条规则用于检测这种使用情况，
这往往是因为逻辑运算符 (&amp;&amp;, || 和 !)
很容易地与位运算符 (&amp;, | 和 ~)相混淆。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。
规则可防止逻辑运算符和位运算符之间的混乱。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* examples of incorrect code */
void foo(int a, int b, int c, int d, int* ptr)
{
    if ( 1 &amp;&amp; ( c &lt; d ) ) {}        // 违规
    if ( ( a &lt; b ) &amp;&amp; ( c + d ) ){} // 违规
    if ( a || ( c + d ) ) {}        // 违规
    if ( !ptr ) {}                  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* examples of correct code */
void foo(int a, int b, int c, int d)
{
    if ( ( a &lt; b ) &amp;&amp; ( c &lt; d ) ){}   // OK
    if ( ( a == b ) || ( c != d ) ){} // OK
    if ( !false ) {}                  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
Chapter 6, Section 5, Rule 5-3-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_3_2</key>
<configkey>MISRA2008-5_3_2</configkey>
<name><![CDATA[ 一元减法运算符不得适用于其原始类型是无符号型的表达式 [MISRA2008-5_3_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一元减法运算符不得适用于其原始类型是无符号型的表达式 [MISRA2008-5_3_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对无符号整型或者无符号长整型表达式
进行一元减法运算是没有意义的。
有时对一个小的无符号整型操作数进行一元
减法运算整形提升后会得到一个有意义的
整型值，但这并不是好的编程习惯。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止整型提升时产生不可预期的结果。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    unsigned char  ui1;
    signed short si2;
    si2 = -ui1;                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    unsigned char  ui1;
    signed short si2;
    si2 = -(signed short) ui1;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C：2004 C语言在关键系统中的使用指南，
    第6章，第12节

2. 来源：Misra 指南 - 第39条规则

3. 联合攻击战斗机，飞行器，C++编码规范，
   第4.21章，飞行器第165条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南，
   第6章，第5节，第5-3-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_3_3</key>
<configkey>MISRA2008-5_3_3</configkey>
<name><![CDATA[  一元 & 运算符不得被重载 [MISRA2008-5_3_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
 一元 &amp; 运算符不得被重载 [MISRA2008-5_3_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在完整类型包含用户声明的操作符 &amp; 时，
取不完整类型对象的地址将导致不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
    A * operator &amp; ( );   // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要重载一元 '&amp;' 运算符



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-3-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_3_4</key>
<configkey>MISRA2008-5_3_4</configkey>
<name><![CDATA[ sizeof 运算符的操作数求值不得包含副作用 [MISRA2008-5_3_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
sizeof 运算符的操作数求值不得包含副作用 [MISRA2008-5_3_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在C语言编程中的一个可能错误是评估一个表达式和预期表达式 
的时候申请使用sizeof 操作符。 可是表达式
却无法被评估: sizeof只能作用于表达式类型。 
为了避免这类错误， sizeof 不能用于包含副作用的表达式。"
"这个操作引起的副作用是访问了不稳定的对象,
如修改一个对象, 修改一个文件, 或者调用一个函数这些
会导致调用函数执行环境变化的操作方法。"



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只能检测三层函数调用。


例外:

操作数形如 sizeof(i)  i 变量是允许的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止由 sizeof 引起的错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int glob;

int fun_with_se(){
    glob++; // side-effect
    return glob;
}

void foo1(int i){
    int j, k, l, m;
    j = sizeof(k = 2);         // 违规 - k is not set to 2
    l = sizeof(i++);           // 违规 - i is not incremented
    m = sizeof(fun_with_se()); // 违规 - glob is not incremented
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int fun_without_se(){
    // no side-effect
    return 1;
}

void foo1(int i){
    int j, k, l, m, n, o;
    volatile int vol;
    k = 2;
    j = sizeof(k);                // OK
    i++;
    l = sizeof(i);                // OK
    // examples of correct code
    m = sizeof(fun_without_se()); // OK
    n = sizeof(int);              // OK
    o = sizeof(vol);              // OK - volatile objects are permitted
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
    Chapter 6, Section 12

2. Origin: Misra Guidelines - Rule 40

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.21 Operators, AV Rule 166

4. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 5, Rule 5-3-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-5_8_1</key>
<configkey>MISRA2008-5_8_1</configkey>
<name><![CDATA[ 移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间 [MISRA2008-5_8_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间 [MISRA2008-5_8_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“例如，左移或右移运算符的左操作数是一个
16位整数， 那么移位数必须是一个
0~15之间的数字常量。

现在有很多方法可以遵循此规则，最简单的办法
就是保证右操作数是常量（它的值可以通过静态分析来
检查）。对于无符号整型必须保证操作数是 
非负数，此时只要检查上限值就可以（使用运行时检测
或通过代码检查）。否则上限值和下限值都必须被检查。”
此规则规定数据类型大小：字符型8bit，短整型16bit，
整型32bit，长整型64bit。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性和易理解性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
void foo( uint16_t p ) 
{
   uint8_t u8a;

   u8a = (uint8_t) (u8a &lt;&lt; 9); /* 违规 */
   u8a = (uint8_t) (u8a &lt;&lt; p); /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
void foo( uint16_t p )
{
   uint8_t u8a;
   uint16_t u16a;
 
   u16a = (uint16_t) ((uint16_t) u8a &lt;&lt; 9); /* OK */

   if (p &gt;= 0 &amp;&amp; p &lt;= 8) {
     u8a = (uint8_t) (u8a &lt;&lt; p); /* OK - p range checked */
   }

   u8a = (uint8_t) (u8a &lt;&lt; 4); /* OK - constant value in range */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.  MISRA-C:2004 C语言在关键系统中的使用指南，
     第6章，第12节

2. 联合攻击战斗机，飞行器，C++编码规范，
    第4.21章，飞行器第164条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南，
    第6章，第5节，第5-8-1条规则 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_2_1</key>
<configkey>MISRA2008-6_2_1</configkey>
<name><![CDATA[ 赋值运算符不得被用于子表达式 [MISRA2008-6_2_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
赋值运算符不得被用于子表达式 [MISRA2008-6_2_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止给布尔表达式赋值.
阻止对布尔表达式的操作数使用简单或复合的赋值运算符.
但是，变量还是可以被赋以布尔值的.
如果需要对布尔表达式的操作数赋值，则必须单独在操作数外面赋值.
这样做可避免混淆"="和"==",并帮助错误的静态检测.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

表达式被认为是布尔表达式有两种原因,一
种是表达式所在的位置应该是布尔值,
另一种是它使用的操作符会产生布尔值.布尔值在下面情况下出现:
—If 语言的控制表达式
—迭代语句的控制表达式
—条件运算符？的第一个操作数


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止混淆 "=" 和 "==".


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x = y);                // Violation
    if ((x &gt; y) &amp;&amp; (x = 4));  // Violation
    if (!(x = y));                // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    int x;
    int y;
    int z;
    z = !(x == y);               // OK
    if ((x &gt; y) &amp;&amp; (x == 4)); // OK
    if (!(x == y));               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Misra 指南 -第35条规则

2. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第13部分

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.21操作章节, AV 第160条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南l
    第六章节,第六部分,第6-2-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_2_2</key>
<configkey>MISRA2008-6_2_2</configkey>
<name><![CDATA[ 浮点表达式不得直接或间接地作为相等或不相等的判定 [MISRA2008-6_2_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
浮点表达式不得直接或间接地作为相等或不相等的判定 [MISRA2008-6_2_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不可以测试浮点数等值或不等值.浮点数比较推荐的方法是写一个库函数,
用来执行比较操作.库函数应该考虑到浮点粒度（FLT_EPSILON）和被比较值的数量级.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

等值和不等值的间接测试同样是问题,在Misra标准中是不允许的,但此规则不能检查出:
if ( ( x &lt;= y ) &amp;&amp; ( x &gt;= y ) )
{
  /* ... */ 
}



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

浮点类型的内在属性是等值比较一般都不为真,即便预期为真.
此外,在运行前无法预测比较的结果,甚至每次执行的结果会不一样.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    float x, y;

    if (x == y);      // Violation
    if (x == 0.0f);   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( float epsilon ) {
    float x, y;

    if (x - epsilon &lt;= y &amp;&amp; y &lt;= x + epsilon);  // OK
    if (-epsilon &lt;= x &amp;&amp; x &lt;= epsilon);         // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第13部分

2. Misra 指南 - 第50条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第4.25 公式章节, AV 第202条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
    第六章节,第六部分,第6-2-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_2_3</key>
<configkey>MISRA2008-6_2_3</configkey>
<name><![CDATA[ 预处理之前，空语句应该只能独自地出现在一行上；它可能后接一个注释，但是紧接空语句的第一个字符应该是空格 [MISRA2008-6_2_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
预处理之前，空语句应该只能独自地出现在一行上；它可能后接一个注释，但是紧接空语句的第一个字符应该是空格 [MISRA2008-6_2_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一般情况下,不要包含空语句。空语句在使用时应该自成一行。
Null语句之前应该有空格符.作为行首空格。空语句后如果有注释,
至少应该用一个空格符隔开。
为了增加代码可读性,必须使用空格符隔开空语句和其后的注释。
也可以参考:MISRA-054。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则使能静态检测工具，当空语句和其他字符出现在一行时，
一般表示编程错误，这时候会发出警告。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{

/* Violation */ ;
;/* Violation */

}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void goo()
{
/* OK */
;
; /* OK */
;   /* OK */  
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分
   
2. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第6部分,第6-2-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_3_1</key>
<configkey>MISRA2008-6_3_1</configkey>
<name><![CDATA[ 构成 switch, while, do  while 或者 for 语句体的语句应该是一个复合语句 [MISRA2008-6_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
构成 switch, while, do  while 或者 for 语句体的语句应该是一个复合语句 [MISRA2008-6_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

组成switch语句或者while 语句、do...while语句或者for语句的主体的应该是复杂语句，
甚至是包含简单语句的复杂语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x ) {
    int i;

    switch(i)             // Violation
    ;

    for (i=0; i&lt; 10; i++) // Violation 
        foo( x );
    while (1)             // Violation
        foo( x );

    do                    // Violation
    foo( x );
    while(1);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x ) {
    int i;

    switch(i)             // OK
    {
    }

    for (i=0; i&lt; 10; i++) // OK
            {foo( x );}
    while (1)             // OK
        {foo( x );}

    do                    // OK
        {foo( x );}
    while(1);
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Misra 指南-第59条规则

3.Ellemtel 编码规范
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    from: 6 Style - 6.4 Flow Control Statements - Rec. 25

4.联合攻击战斗机, 飞行器 C++ 编码规范
   第4.9设计章节,AV第59条规则

5.MISRA-C++:2008 C++语言在关键系统中的使用指南
  第六章节,第六部分,第6-4-1规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_1</key>
<configkey>MISRA2008-6_4_1</configkey>
<name><![CDATA[ if (条件) 结构应该后接一个复合语句。 else 关键字必须后接一个复合语句，或者另外的 if 语句 [MISRA2008-6_4_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
if (条件) 结构应该后接一个复合语句。 else 关键字必须后接一个复合语句，或者另外的 if 语句 [MISRA2008-6_4_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

if语句结构应该是一个复杂语句.
else关键字后面应该是一个复杂语句或者是另外一个if语句.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高了代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x, int y )
{
    int i, j;
    if(x &gt; 0)      // Violation
        x = i;
    else if(y &gt; 0) // Violation
        y = i;
    else
        y = j;     // Violation
        x = j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x, int y )
{
    int i, j;
    if(x &gt; 0)      // OK
    {
        x = i;
    }
    else if(y &gt; 0) // OK
    {
        y = i;
    }
    else
    {
        y = j;     // OK
        x = j;
    }
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.Misra 指南-第59条规则

3. Ellemtel 编码规范
    <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
    from: 6 Style - 6.4 Flow Control Statements - Rec. 25

4.联合攻击战斗机, 飞行器 C++ 编码规范
   第4.9设计章节,AV第59条规则

5. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第六部分,第6-4-1规则示例

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_2</key>
<configkey>MISRA2008-6_4_2</configkey>
<name><![CDATA[ 所有的 if ... else if 结构应该由 else 子句结束 [MISRA2008-6_4_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的 if ... else if 结构应该由 else 子句结束 [MISRA2008-6_4_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"这条规则适用于任何一个 'if' 语句是否都由一个或多个
'else-if' 语句结尾； 最后的 'else-if' 应该紧跟着一个 'else'
语句。 在一个简单的 'if' 语句中，那么应该包括 'else' 
语句。
对最后 'else' 语句的需求是防御性的编程。 
其中 'else' 语句应该要么有合适的操作或包含
一个为什么没有操作合理的注释。"
参见: CODSTA-23



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

确保合适的数据流、提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a)
{
    if(a &gt; 0)
    {
    }
    else if (a &gt; 10)   // Violation
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a)
{
    if(a &gt; 0)
    {
    }
    else if (a &gt; 10)   // OK
    {
    }
    else
    {
        // comment or action
    }
}


参考文献:

1.MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节,第14部分

2.来源: Misra 指南 - 第 60条规则

3.联合攻击战斗机, 飞行器, C++ 编码规范
   第4.24 控制流结构章节, AV 第 192条规范

4.MISRA-C++:2008 C++语言在关键系统中的使用指南
   第六章节,第6部分,第6-4-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_3_a</key>
<configkey>MISRA2008-6_4_3_a</configkey>
<name><![CDATA[ switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“case作用域或者default作用域，作为switch语句的主体部分，
应该混合出现。所有case分支和default分支应该是有相同的作用域。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a, int b ) {
    switch(a) {
    case 1:
        {
            case 6:     /* 违规 */
            ;
            default:    /* 违规 */
            break;
        }
        break;
    case 2:
        if (b == 1) {
             case 3:      /* 违规 */
             break;
        }
        break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

删除嵌套的'case'和'default'语句.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第15部分

2. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章，第6部分，第6-4-3条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章，第6部分，第6-4-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_3_b</key>
<configkey>MISRA2008-6_4_3_b</configkey>
<name><![CDATA[ switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“无条件的throw或break语句应终止一切非空的
switch语句。如果一个开发人员没有在switch语句
的结尾处添加break语句，然后控制流“属于”
下面其他的switch语句，虽然这有时是故意的，
往往是一个错误。为确保这种错误可以发现，
在每一个switch语句应该添加一个break语句，
或者如果switch语句是一个复合语句，则在
复合语句的最后声明处添加break语句。特别的
情况是否存在，如果switch语句是空的，当这些要求
一组语句，这组语句要求相同的语句被创建.”




</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以防止不可预料的程序行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 违规
            i = 4;
            break;
            i++;
        case 1 :         // 违规
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
        case 2 :         // 违规
            {
                i = 3;
            }
        default:         // 违规
            i = 8;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // OK
            i = 4;
            i++;
            break;
        case 1 :         // OK
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
            break;
        case 2 :         // OK
            {
                i = 3;
                break;
            }
        case 3 :         // OK - empty case
        default:         // OK
            i = 8;
            throw;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-5

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_3_c</key>
<configkey>MISRA2008-6_4_3_c</configkey>
<name><![CDATA[ switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在switch语句中最后一句应是default语句。
对最后一句是default语句的要求是种预防性的编程习惯。
这一句也应采取合适的动作，或者包含一个合适的
评论作为不采取动作的原因。”


例外:

“如果switch语句的条件是枚举类型，并且所有的
枚举器被罗列在CASE的标签中，然后default语句
没有被要求作为与枚举相关联的规则，这种规则是为了
确保枚举被分配的值不超出了枚举器所设定的范围。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了 'switch' 语句的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Colours { RED, BLUE, GREEN } colour;

void foo(int i)
{
	switch( i )              // 违规
	{
		case 0:
			break;
		case 1:
		case 2:
			break;
	}

	switch( colour )         // 违规
	{
		case RED:
			break;
		case GREEN:
			break;
			
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum Colours { RED, BLUE, GREEN } colour;

void foo(int i)
{
	switch( i )              // OK
	{
		case 0:
			break;
		case 1:
		case 2:
			break;
		default:
			break;
	}

	switch( colour )         // OK
	{
		case RED:
			break;
		case BLUE:
			break;
		case GREEN:
			break;

	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-6

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_3_d</key>
<configkey>MISRA2008-6_4_3_d</configkey>
<name><![CDATA[ switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_d] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_d-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

switch条件中不能出现有效的布尔类型值。
本规则禁止使用以下产生布尔类型值的运算符：
a) 等号运算符 (== and !=)
b) 逻辑运算符 (!, &amp;&amp; and ||)
c) 关系运算符 (&lt;, &gt;, &lt;= and &gt;=)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则可以阻止在switch条件中使用布尔数值.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i)
{
    switch(i == 0)           // 违规
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(int i) 
{
    switch(i)                   //通过
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章，第15部分

2. 来源: Misra 指南—第63条规则

3. 联合攻击战斗机, 飞行器
   第4.24章Chapter 4.24 Flow Control Structures, AV 第195条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_3_e</key>
<configkey>MISRA2008-6_4_3_e</configkey>
<name><![CDATA[ switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_e] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句应该是一个格式规范的 switch 语句 [MISRA2008-6_4_3_e-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个switch语句应当至少含有一个case子句。
另见: OPT-21, OPT-22, CODSTA-54



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提供可维护性的switch语句.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* 违规 */ 
    {
        default:
            ;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* OK */ 
    {
      case 1:
      {
      }
      default:
            ;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6条长，第15部分

2. 来源: Misra 指南 - 第64条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-8条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_4</key>
<configkey>MISRA2008-6_4_4</configkey>
<name><![CDATA[ switch-标签应该只能用在当紧接着的复合语句是 switch 语句体的时候 [MISRA2008-6_4_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch-标签应该只能用在当紧接着的复合语句是 switch 语句体的时候 [MISRA2008-6_4_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“case作用域或者default作用域，作为switch语句的主体部分，
应该混合出现。所有case分支和default分支应该是有相同的作用域。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int a, int b ) {
    switch(a) {
    case 1:
        {
            case 6:     /* 违规 */
            ;
            default:    /* 违规 */
            break;
        }
        break;
    case 2:
        if (b == 1) {
             case 3:      /* 违规 */
             break;
        }
        break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

删除嵌套的'case'和'default'语句.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第15部分

2. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章，第6部分，第6-4-3条规则

3. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第6章，第6部分，第6-4-4条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_5</key>
<configkey>MISRA2008-6_4_5</configkey>
<name><![CDATA[ 无条件的 throw 或 break 语句应该结束任何非空的 switch-子句 [MISRA2008-6_4_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
无条件的 throw 或 break 语句应该结束任何非空的 switch-子句 [MISRA2008-6_4_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“无条件的throw或break语句应终止一切非空的
switch语句。如果一个开发人员没有在switch语句
的结尾处添加break语句，然后控制流“属于”
下面其他的switch语句，虽然这有时是故意的，
往往是一个错误。为确保这种错误可以发现，
在每一个switch语句应该添加一个break语句，
或者如果switch语句是一个复合语句，则在
复合语句的最后声明处添加break语句。特别的
情况是否存在，如果switch语句是空的，当这些要求
一组语句，这组语句要求相同的语句被创建.”




</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以防止不可预料的程序行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // 违规
            i = 4;
            break;
            i++;
        case 1 :         // 违规
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
        case 2 :         // 违规
            {
                i = 3;
            }
        default:         // 违规
            i = 8;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int i )
{
    switch( i )
    {
        case 0 :         // OK
            i = 4;
            i++;
            break;
        case 1 :         // OK
            i = 7;
            if (i &gt; 0)
            {
                i = 5;
                break;
            }
            break;
        case 2 :         // OK
            {
                i = 3;
                break;
            }
        case 3 :         // OK - empty case
        default:         // OK
            i = 8;
            throw;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-5

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_6</key>
<configkey>MISRA2008-6_4_6</configkey>
<name><![CDATA[ switch 语句的最后子句应该是 default-子句 [MISRA2008-6_4_6] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句的最后子句应该是 default-子句 [MISRA2008-6_4_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在switch语句中最后一句应是default语句。
对最后一句是default语句的要求是种预防性的编程习惯。
这一句也应采取合适的动作，或者包含一个合适的
评论作为不采取动作的原因。”


例外:

“如果switch语句的条件是枚举类型，并且所有的
枚举器被罗列在CASE的标签中，然后default语句
没有被要求作为与枚举相关联的规则，这种规则是为了
确保枚举被分配的值不超出了枚举器所设定的范围。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了 'switch' 语句的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Colours { RED, BLUE, GREEN } colour;

void foo(int i)
{
	switch( i )              // 违规
	{
		case 0:
			break;
		case 1:
		case 2:
			break;
	}

	switch( colour )         // 违规
	{
		case RED:
			break;
		case GREEN:
			break;
			
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum Colours { RED, BLUE, GREEN } colour;

void foo(int i)
{
	switch( i )              // OK
	{
		case 0:
			break;
		case 1:
		case 2:
			break;
		default:
			break;
	}

	switch( colour )         // OK
	{
		case RED:
			break;
		case BLUE:
			break;
		case GREEN:
			break;

	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-6

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 6 节, 规则 6-4-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_7</key>
<configkey>MISRA2008-6_4_7</configkey>
<name><![CDATA[ switch 语句的条件不得含有布尔类型 [MISRA2008-6_4_7] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
switch 语句的条件不得含有布尔类型 [MISRA2008-6_4_7-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

switch条件中不能出现有效的布尔类型值。
本规则禁止使用以下产生布尔类型值的运算符：
a) 等号运算符 (== and !=)
b) 逻辑运算符 (!, &amp;&amp; and ||)
c) 关系运算符 (&lt;, &gt;, &lt;= and &gt;=)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则可以阻止在switch条件中使用布尔数值.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i)
{
    switch(i == 0)           // 违规
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(int i) 
{
    switch(i)                   //通过
    {
        case 0 : break;
        default:;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章，第15部分

2. 来源: Misra 指南—第63条规则

3. 联合攻击战斗机, 飞行器
   第4.24章Chapter 4.24 Flow Control Structures, AV 第195条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-7条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_4_8</key>
<configkey>MISRA2008-6_4_8</configkey>
<name><![CDATA[ 每个 switch 语句应该至少有一个 case-子句 [MISRA2008-6_4_8] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每个 switch 语句应该至少有一个 case-子句 [MISRA2008-6_4_8-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每个switch语句应当至少含有一个case子句。
另见: OPT-21, OPT-22, CODSTA-54



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提供可维护性的switch语句.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* 违规 */ 
    {
        default:
            ;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int i) 
{
    switch(i)      /* OK */ 
    {
      case 1:
      {
      }
      default:
            ;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6条长，第15部分

2. 来源: Misra 指南 - 第64条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-3条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南, 第6章，第6部分，第6-4-8条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_5_1</key>
<configkey>MISRA2008-6_5_1</configkey>
<name><![CDATA[ for 循环应该包含一个没有浮动类型的单一的循环计数器 [MISRA2008-6_5_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
for 循环应该包含一个没有浮动类型的单一的循环计数器 [MISRA2008-6_5_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“for 循环没有准确的循环计数器只是一个 while 循环。
如果这是期望的行为，则 while 循环更为合适。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改.
循环控制变量是任何出现在 for 初始化语句，
条件或表达式中的变量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于确保确定性循环终止。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int x = 0;
    int y;
    y = 0;
    for (x = 0; x &lt; y; x = y++){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo3()
{
    int x = 0;
    int y;
    y = 0;
    x = 0;
    while(x &lt; y) // OK
    {
        x = y++;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_5_2</key>
<configkey>MISRA2008-6_5_2</configkey>
<name><![CDATA[ 如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 <=, <, > or >= 的操作数 [MISRA2008-6_5_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=, &lt;, &gt; or &gt;= 的操作数 [MISRA2008-6_5_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当循环计数器不是使用  -- 或 ++ 运算符来修改，
那么不得使用 == 和 != 来判断，因为循环终止可能不会发生， 
这可能与开发人员的预期不符。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改。
循环控制变量是任何出现在 for 初始化语句，
条件或表达式中的变量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于确保确定性循环终止。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int i;
    for ( i = 1; i != 10; i += 2 ){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int i;
    for ( i = 1; i &lt;= 10; i += 2 ){} // OK
    for ( i = 1; i != 10; ++i ){}    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_5_3</key>
<configkey>MISRA2008-6_5_3</configkey>
<name><![CDATA[ 循环计数器不得在判定条件或循环体语句中被修改 [MISRA2008-6_5_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
循环计数器不得在判定条件或循环体语句中被修改 [MISRA2008-6_5_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

数字变量作为for循环的循环计数不要在循环体内部被修改.
但是，循环中其它代表逻辑值的循环控制变量可以被改变,
比如,for循环中检查指明动作完成的标志变量,



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防循环体中循环计数改变导致的错误和混淆.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int i;
    for ( i = 0; i &lt; 5; i++ ) {
        i = i + 3;                  /* Violation */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {    
    int i;
    for ( i = 0; i &lt; 5; i = i + 3 ) {} /* OK */
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第六章节、第13部分

2. 来源: Misra 指南

3. J联合攻击战斗机, 飞行器, C++ 编码标准
   第 4.24 控制流结构章节, AV 第 201条规则

4. MISRA-C++:2008 C++语言在关键系统中的使用指南
   第 六章节, 第 6部分, 第6-5-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_5_4</key>
<configkey>MISRA2008-6_5_4</configkey>
<name><![CDATA[ 循环计数器应该被 --, ++, -=n, 或 +=n; 之一修改；这里的 n 在整个循环期间保持不变 [MISRA2008-6_5_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
循环计数器应该被 --, ++, -=n, 或 +=n; 之一修改；这里的 n 在整个循环期间保持不变 [MISRA2008-6_5_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“循环计数器应该被以下之一修改: --, ++, -=n, 或 +=n;
这里的 n 在整个循环期间保持不变”。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改.
循环控制变量是任何出现在 for 初始化语句，
条件或表达式中的变量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于确保确定性循环终止。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int x;
    for ( x = 0; x &lt; 10; x = x + 1 ){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    int x;
    for ( x = 0; x &lt; 10; ++x ){} // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_5_5</key>
<configkey>MISRA2008-6_5_5</configkey>
<name><![CDATA[ 循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改 [MISRA2008-6_5_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改 [MISRA2008-6_5_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“除了循环计数器以外的循环控制变量不得
在判定条件或者表达式中被修改。
循环控制变量是任何出现在 for 始化语句，
判定条件或表达式中的变量。
循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改。
循环控制变量要么是循环计数器，要么是用于提前终止
循环的标识。如果这些在判定条件或表达式中不被修改，
那么代码更容易理解。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则假定变量或参数可能会通过传递
其非 const 指针或引用到外部函数而被修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

bool test(int x);
void foo(int x, bool flag)
{
    for ( x = 0; x &lt; 10; flag = test(++x) ) {}  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

bool test(int x);
void foo(int x, bool flag)
{
    for ( x = 0; x &lt; 10; ++x ) // OK
    {
        flag = test(x);   
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_5_6</key>
<configkey>MISRA2008-6_5_6</configkey>
<name><![CDATA[ 在循环体语句中被修改的非循环计数器的循环控制变量应该是布尔类型的 [MISRA2008-6_5_6] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在循环体语句中被修改的非循环计数器的循环控制变量应该是布尔类型的 [MISRA2008-6_5_6-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在循环体语句中被修改的循环计数器以外的循环控制变量
应该是布尔类型的。
循环控制变量是任何出现在 for 始化语句，
判定条件或表达式中的变量。
循环计数器是一个循环控制变量，即:
- 初始化在，或先于，for 初始化语句：并且
- 在条件中相关运算符的操作数：并且
- 在表达式中被修改。
循环控制变量通常用于提前终止一个 for 循环。
如果使用布尔值来实现这个目的，
那么代码更容易理解。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则假定变量或参数可能会通过传递
其非 const 指针或引用到外部函数而被修改。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int x, unsigned int u8a, bool flag)
{
    for ( x = 0; ( x &lt; 10 ) &amp;&amp; ( u8a != 3U ); ++x )
    {
        u8a = 5;                         // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int x, unsigned int u8a, bool flag)
{
    for ( x = 0; ( x &lt; 10 ) &amp;&amp; flag; ++x )
    {
        u8a = 5;                         // OK
        flag = u8a != 3U;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 6 节, 规则 6-5-6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_6_1</key>
<configkey>MISRA2008-6_6_1</configkey>
<name><![CDATA[ 任何 goto 语句引用的标签应该被声明在相同的块中，或在关闭 goto 语句的块中 [MISRA2008-6_6_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
任何 goto 语句引用的标签应该被声明在相同的块中，或在关闭 goto 语句的块中 [MISRA2008-6_6_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"任何被 goto 语句使用的标签应该被声明在 goto 
语句所在的同一个 block 中，或者在一个包围 goto 
语句的 block 中。 随意使用 goto 可能导致程序极易导
致出现程序超级难以理解，分析，并且对于 C++ 也可
能导致程序未预期的行为。然而，很多情况下彻底禁止
 goto 就要求引入一些 flags 以确保正确控制流
程，但这些 flags 不如 goto 那样使程序更加
清晰。因此在那些不会对开发人员产生完全相反
的语义的地方严格使用 goto 语句是被允许的。
在一个嵌套的 block 中使用 goto 语句是不允许的，
因为它容易导致高度复杂的执行流程。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防未预期的行为



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void f1 ( )
{
	int j = 0;
	goto L1;
	
	for ( j = 0; j &lt; 10 ; ++j )
	{
		/* ... */
		L1: 				// 违规
			j;
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void f1 ( )
{
	int j = 0;
	goto L1;
	
	for ( j = 0; j &lt; 10 ; ++j )
	{
		/* ... */
	}

	L1: 					// OK
		j;

}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 6, Rule 6-6-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_6_2</key>
<configkey>MISRA2008-6_6_2</configkey>
<name><![CDATA[ goto 语句应该跳转到稍后在相同的函数体中声明的标签 [MISRA2008-6_6_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
goto 语句应该跳转到稍后在相同的函数体中声明的标签 [MISRA2008-6_6_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不严格的使用 goto 语句极易导致出现程序超
级难以理解，分析，并且对于 C++ 也可能导致
程序未预期的行为。然而，很多情况下彻底禁止
 goto 就要求引入一些 flags 以确保正确控制流
程，但这些 flags 不如 goto 那样使程序更加
清晰。因此在那些不会对开发人员产生完全相反
的语义的地方严格使用 goto 语句是被允许的。
"向后"跳转是禁止的。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防未预期的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int j)
{
    L1:
    ++j;
    goto L1; // 违规 - 向回跳转
    ++j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int j)
{
    ++j;
    goto L1; // OK -  向前跳转
    ++j;
    L1:
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 6, Rule 6-6-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_6_3</key>
<configkey>MISRA2008-6_6_3</configkey>
<name><![CDATA[ continue 语句应该只能被用于一个格式规范的 for 循环中 [MISRA2008-6_6_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
continue 语句应该只能被用于一个格式规范的 for 循环中 [MISRA2008-6_6_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"continue 语句的反复使用容易导致代码的复
杂度。 这种复杂性可能降低被测代码的测试
效率。 要求的测试可能不能达到由于控制流
的依赖性。"


例外:

如果 'continue' 语句被用在 'for' 循环中，该规则不会报告违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则降低代码的复杂度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
	int x = 0;
	int y;
	y = 10;
	
        while(x &lt; y)
	{
          x++;

	  /* ... */
	  continue;             // 违规

	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

在 'for' 循环之外，不要使用 'continue' 语句。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 6, Rule 6-6-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_6_4</key>
<configkey>MISRA2008-6_6_4</configkey>
<name><![CDATA[ 对于任何迭代语句不得有超过一个用于循环终止的 break 或 goto 语句 [MISRA2008-6_6_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对于任何迭代语句不得有超过一个用于循环终止的 break 或 goto 语句 [MISRA2008-6_6_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"对于任何循环语句中不应该超过
一个 break 或 goto 语句。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"在循环语句中限制退出语句的个数是一种良Restricting the number of exits from a loop is done in the interests of good
好结构的编程。在一个循环块中存在一个 break structured programming. One break or goto statement is acceptable in a loop
或 goto 语句是可接受的。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a;

    for (a = 0; a &lt; 10; a++) { // 违规
        if (a == 5) {
            break;
        }
        if (a == 7) {
            break;
        }
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int a;

    for (a = 0; a &lt; 10; a++) { // OK
        if (a == 5 || a == 7) {
            break;
        }
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 6, Rule 6-6-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-6_6_5</key>
<configkey>MISRA2008-6_6_5</configkey>
<name><![CDATA[ 一个函数应该在函数末尾有单一的出口点 [MISRA2008-6_6_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个函数应该在函数末尾有单一的出口点 [MISRA2008-6_6_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数应该有单一的出口.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则包括函数调用出口、终止,标准库的出口.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

帮助编写安全、易读的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int i)
{
    if (i == 0) {
        return 0;        // Violation	
    } else if (i == 1) {
        return 1;        // Violation
    } else {
        return 2;        // Violation
    }
}

int foo2(int a) {  
    int result;
    if (a &gt; 0) {
        return result;  // Violation
    } 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int i)
{
	int result = 0;
    if (i == 0) {
        result = 0;
    } else if (i == 1) {
    	result = 1;
    } else {
    	result = 2;
    }
    return result;   // OK
}


参考文献:

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第六章节,第14部分

2. 来源: Misra 指南-第82条规则

3. 联合攻击战斗机, 飞行器, C++ 编码规范
  第4-13功能章节,AV第113条规则

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_1_1</key>
<configkey>MISRA2008-7_1_1</configkey>
<name><![CDATA[ 一个不被修改的变量应该使用 const 限定 [MISRA2008-7_1_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个不被修改的变量应该使用 const 限定 [MISRA2008-7_1_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否用户声明参数或局部变量为 const。 
不可变的值更容易理解，跟踪和定位原因，因此 
只要在合理的情况下多用常量而不是变量，当定义一个值的时候 
使 const 作为默认的选择:
参见: CODSTA-CPP-43, MISRA2004-16_7



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对于指针类型的参数和变量， cost 修饰符
应该适用于指针，而不是指向的对象。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这样是安全的，它是在编译时检查，而且与 C++ 的
类型系统相集成。它还可以防止今后修订
无意地修改被调用函数的数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>
int foo1(int param1,          // 违规
         int* param2,         // 违规
         const int* param3)   // 违规- const is applied to the
                              // pointed object, not to the pointer
{
    int var1 = 0;             // 违规
    return  param1 + *param2 + *param3 + var1;
}

int foo2(int param1,          // OK - param1 is modified
         int* param2,         // OK - param2 is modified
         const int* param3)   // OK - param3 is modified
{
    int var1 = 0;             // OK - var1 is modified
    param1++;
    param2++;
    param3++;
    var1 = param1 + *param2 + *param3;
    return var1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// Fixed violations - const added
int foo1(const int param1,          // OK
         int* const param2,         // OK - const is applied to the pointer
         const int* const param3)   // OK - const is applied to the pointed
                                    // object and to the pointer
{
    const int var1 = 0;             // OK
    return  param1 + *param2 + *param3 + var1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范”, Addison-Wesley, 
  (C) 2005 Pearson Education, Inc., 章节: “编码风格”, 第15条规则

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第7节, 规则7-1-1

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_1_2_a</key>
<configkey>MISRA2008-7_1_2_a</configkey>
<name><![CDATA[ 如果函数的指针参数对应的对象不被修改，那么应该被声明为指针常量 [MISRA2008-7_1_2_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数的指针参数对应的对象不被修改，那么应该被声明为指针常量 [MISRA2008-7_1_2_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在函数原型中的指针参数，如果不用来修改地址参数就应该被声明为指向常量的指针。
既然被保护的是对象，这个常量的限制应该应用于指针指向的对象而不是指针本身。”
参见: CODSTA-14, CODSTA-CPP-43, CODSTA-CPP-53, MISRA-104, 



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

可能已经是参数声明为指向常量的指针的重载函数。
然后改变参数的类型为指向常量的指针会使得
代码不可编译。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
此规则可用来阻止无意的修改数据，并在函数接口定义上，提高准确性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int function(int* ptr)       // 违规
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int function(const int* ptr) // OK
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55种提高程序设计的特殊的途径 ", 
   第三版, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章，第3项

2. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

3.  联合攻击战斗机, 飞行器, C++ 编码标准
   第4.13章函数， AV 第118条规则

4. 来源: Misra 指南- 第81条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-1-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_1_2_b</key>
<configkey>MISRA2008-7_1_2_b</configkey>
<name><![CDATA[ 如果函数的引用参数对应的对象不被修改，那么应该被声明为引用常量 [MISRA2008-7_1_2_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数的引用参数对应的对象不被修改，那么应该被声明为引用常量 [MISRA2008-7_1_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否用户声明引用参数为 const 引用。
当用户的函数不会修改其所引用的参数时，用户 
应该使用 const 来防止当函数返回时变量意外 
的修改。
参见: CODSTA-CPP-03, CODSTA-CPP-38, CODSTA-CPP-44, 
          MISRA-104, MISRA2004-16_7, OPT-21



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

声明不会被修改的参数为 const 引用而不是引用 
提高了可读性。它也防止将来修订会意外的 
改变调用函数的数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct Foo {
    int x;
    int y;
};

int Bar( Foo &amp;f ) {  // 违规
    return f.x;
}

int FooBar( Foo &amp;f ) { // OK
    return f.x++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct Foo {
    int x;
    int y;
};

int Bar( const Foo &amp;f ) {  // OK
    return f.x;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第1章, 第3项

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第7节, 规则 7-1-2

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_1_2_c</key>
<configkey>MISRA2008-7_1_2_c</configkey>
<name><![CDATA[ 如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [MISRA2008-7_1_2_c] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针 [MISRA2008-7_1_2_c-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if a parameter in a function prototype is declared
as typedef to pointer to non-const object and the pointer is not used to modify
the addressed object. Then the type of parameter could be changed to typedef
to pointer to const object.
参见: CODSTA-14, CODSTA-CPP-43, CODSTA-CPP-53, MISRA-104



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

It is not sufficient to add 'const' identifier before typedef's
name in a function declaration, because it is applied to pointer
not to pointed object.
There can already be overloaded function with parameter declared as typedef
to pointer to const. Then changing the type of parameter to typedef to pointer
to const will make the code non-compilable.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents unintentional change of data and improves precision in the
definition of the function interface.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int* PINT;
typedef const int* CINT;

int function1(PINT ptr)        // 违规
{
    return (*ptr) + 1;
}

int function2(const PINT ptr)  // 违规
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int* PINT;
typedef const int* CINT;

int function1(CINT ptr)        // OK
{
    return (*ptr) + 1;
}

int function2(const CINT ptr)  // OK
{
    return (*ptr) + 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 3

2. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 16

3. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.13 Function, AV Rule 118

4. Origin: Misra Guidelines - Rule 81

5. MISRA C++:2008 Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 7, Rule 7-1-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_3_1</key>
<configkey>MISRA2008-7_3_1</configkey>
<name><![CDATA[ 全局的命名空间应该只能包含 main，命名空间的声明和外部的 "C" 声明 [MISRA2008-7_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
全局的命名空间应该只能包含 main，命名空间的声明和外部的 "C" 声明 [MISRA2008-7_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测命名空间外的全局变量，
类，和全局函数的使用。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用命名空间外的全局变量，类，和全局函数。
一个文件中的所有数据和函数都应该在一个或多个
命名空间的内部。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int var = 0;        // 违规

void globalfoo( ) { // 违规
}

class A {           // 违规
    int i;
    void foo( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace name1 {
    int var = 0;        // OK

    void globalfoo( ) { // OK
    }

    class A {           // OK
        int i;
        void foo();
    };
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机， 飞行器 C++ 编码规范
   章节 4.11 命名空间, AV 第98条规则

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章, 第7节, 规则7-3-1

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

4. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_3_2</key>
<configkey>MISRA2008-7_3_2</configkey>
<name><![CDATA[ 标识符 main 不得用于除全局 main 函数以外的函数 [MISRA2008-7_3_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标识符 main 不得用于除全局 main 函数以外的函数 [MISRA2008-7_3_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"main (或等价的函数) 通常用作程序入口并且是在整
个命名空间中的唯一的标志符。main 用作其他函数可
能不符合开发人员预期。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace
{
    int main ( ){} // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int main ( ){}     // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 7, Rule 7-3-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_3_3</key>
<configkey>MISRA2008-7_3_3</configkey>
<name><![CDATA[ 在头文件中不得有不具名命名空间 [MISRA2008-7_3_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在头文件中不得有不具名命名空间 [MISRA2008-7_3_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不具名的命名空间在每个翻译单元中将是独一无二的。
任何出现在头文件的不具名的命名空间中的声明
将适用于每个翻译单元中的不同实体，
这些可能不符合开发人员的期望。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.hpp
namespace // 违规
{
    extern int x;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在头文件中定义不具名的命名空间。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则  7-3-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_3_4</key>
<configkey>MISRA2008-7_3_4</configkey>
<name><![CDATA[ 不得使用 using-指示符 [MISRA2008-7_3_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 using-指示符 [MISRA2008-7_3_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“using 指示符在名称查找过程的搜索范围集中
添加额外的范围，这些范围所有标识符变得可见，
增加编译器查找标识符的可能性不符合开发人员
的期望。
using 声明或完全合格的名称限制了名称集为
只有明确指定的名称，以及其他更安全的选项。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32_t;
namespace NS1
{
    int32_t i1;
    int32_t j1;
    int32_t k1;
}
using namespace NS1; // 违规

void f ()
{
    ++j1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int32_t;
namespace NS1
{
    int32_t i1;
    int32_t j1;
    int32_t k1;
}
using NS1::j1;      // OK

void f ()
{
    ++j1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-3-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_3_5</key>
<configkey>MISRA2008-7_3_5</configkey>
<name><![CDATA[ 在同一个命名空间中标识符的多重声明不得跨越该标识符的 using-声明 [MISRA2008-7_3_5] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在同一个命名空间中标识符的多重声明不得跨越该标识符的 using-声明 [MISRA2008-7_3_5-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“由一个 using 声明引入的标识符集不包括
任何可能在命名空间的后续添加的声明。
任何后续的声明将不会通过 using 声明被找到，
这可能并不符合开发人员的期望。” 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止意外的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

namespace NS
{
    void foo( unsigned short );
}

using NS::foo;

namespace NS
{
    void foo( unsigned int );  // 违规
}

void some()
{
    foo( 0U );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace NS
{
    void foo( unsigned short );
}

namespace NS
{
    void foo( unsigned int );  // OK
}

using NS::foo;

void some()
{
    foo( 0U );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-3-5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_4_1</key>
<configkey>MISRA2008-7_4_1</configkey>
<name><![CDATA[ 所有汇编程序的使用应该被注释说明 [MISRA2008-7_4_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有汇编程序的使用应该被注释说明 [MISRA2008-7_4_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“所有汇编程序的使用应该注释说明。 汇编语言代码
是实现定义的，因此是不可移植的。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果在 'asm' 指令的同一行或其直接的前一行
有注释，那么此规则认为汇编程序的使用已经
注释说明。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规在含有 'asm' 指令的行
void foo( void )
{
   asm ( "NOP" );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( void )
{
   // OK - 在 'asm' 指令之前的注释 
   asm ( "NOP" );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-4-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_4_2</key>
<configkey>MISRA2008-7_4_2</configkey>
<name><![CDATA[ 汇编指令应该只能使用 asm 声明来引入 [MISRA2008-7_4_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
汇编指令应该只能使用 asm 声明来引入 [MISRA2008-7_4_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“asm 声明是对所有 C++ 都实现有效，允许
使用一致的机制。然而，asm 的参数
仍然是实现定义的。”
如果找到 '#pragma asm', '#pragma endasm' 
或同 "asm" 格式不一样的汇编指令，那么规则报告一个违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的一致性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    #pragma asm      // 违规
        "NOP";
    #pragma endasm   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    asm ( "NOP" ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-4-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_4_3</key>
<configkey>MISRA2008-7_4_3</configkey>
<name><![CDATA[ 汇编语言应该被封装和隔离 [MISRA2008-7_4_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
汇编语言应该被封装和隔离 [MISRA2008-7_4_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果需要汇编语言指令建议把它们用
如下方式封装和隔离(a)汇编语言函数
(b)C语言函数或者(c)宏。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* compilable by cl.exe g++*/
void asmCall( ) {      /* Violation */
    int g = 0;

    #ifdef _MSC_VER
        __asm {
            mov eax, 01h
            int 10h
        }
    #elif __GNUC__
        __asm (
            "mov %eax, 0x01\n\t"
            "int $0x10"
        );
    #endif
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void asmCall( ) {       /* OK */
    #ifdef _MSC_VER
        __asm {
            mov eax, 01h
            int 10h
        }
    #elif __GNUC__
         __asm (
            "mov %eax, 0x01\n\t"
            "int $0x10"
        );
    #endif
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 2 节

2. Misra 使用指南 - 第 3 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南,
   第 6 章，第 7 节， 第7-4-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_5_1</key>
<configkey>MISRA2008-7_5_1</configkey>
<name><![CDATA[ 函数不得返回一个指向定义在函数中自动变量的引用或指针(包括参数) [MISRA2008-7_5_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不得返回一个指向定义在函数中自动变量的引用或指针(包括参数) [MISRA2008-7_5_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“函数不得返回一个引用或指针给定义在函数中
的自动变量(包括参数).”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“自动变量在函数调用结束时销毁。
返回一个引用或指针给这种变量允许
在它析构之后被使用，导致不确定的行为。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* foo( ) {
    int i;
    return &amp;i; // 违规
}

int&amp; bar( ) {
    int i;
    return i;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( ) {
    int i = 0;
    return i;  // OK
}

int bar( ) {
    int i = 0;
    return i;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_5_2</key>
<configkey>MISRA2008-7_5_2</configkey>
<name><![CDATA[ 具有自动存储方式的对象的地址不得被赋值给在第一个对象已不复存在之后还持续存在的对象 [MISRA2008-7_5_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
具有自动存储方式的对象的地址不得被赋值给在第一个对象已不复存在之后还持续存在的对象 [MISRA2008-7_5_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果一个局部变量的地址被赋值给另外一个大范围的
局部变量，或者一个静态变量，或者从一个函数中返回，
然后包含这个地址的变量的生存周期可能超过最初变量的
生存周期（它的地址变得无效）。
例如:
int * foo( void ) {
    int local_auto;
    return (&amp;local_auto);
}”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止数据的丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* global;
int* foo() {
    int iLocal;
    static int* siLocal;

    siLocal = &amp;iLocal;       // 违规
    global = &amp;iLocal;        // 违规
    return &amp;iLocal;          // 违规
}
void goo() {
    int* piLocal;
    {
        int iiLocal;
        piLocal = &amp;iiLocal;  // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要将局部变量的地址赋值给全局变量、静态变量或者函数的返回值。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
    第6章，第17部分

2. 来源: Misra 指南 - 第106条规则

3. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.22章 指针与引用, AV 第173条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-5-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_5_3</key>
<configkey>MISRA2008-7_5_3</configkey>
<name><![CDATA[ 函数不得返回一个指向通过引用或 const 引用传递参数的引用或指针 [MISRA2008-7_5_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不得返回一个指向通过引用或 const 引用传递参数的引用或指针 [MISRA2008-7_5_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“函数不得返回一个引用或指针给通过引用
或 const 引用传递的参数。引用参数是否是
一个临时对象或一个参数的引用是实现定义
的行为。如果此实现使用本地副本（临时对象），
那么当函数换回的时候，它将被销毁。任何试图
在其析构之后使用该对象将会导致不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止非确定性的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* foo2 ( int&amp; x )
{
    return ( &amp;x );     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要返回一个引用或指针给通过引用
或 const 引用传递的参数。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-5-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-7_5_4</key>
<configkey>MISRA2008-7_5_4</configkey>
<name><![CDATA[ 函数不得调用它们本身，无论是直接或间接 [MISRA2008-7_5_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不得调用它们本身，无论是直接或间接 [MISRA2008-7_5_4-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数不应该直接或者间接地调用自己。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这个规则用来检测直接递归调用或者简单地
间接地递归调用（多达三层嵌套函数调用）。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

阻止使用递归函数调用.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int l ) {
    int x = l;

    if (l &gt; 0) {
        foo( x - 1 );   /* 违规 */
    }
}

void foo3( int );

void foo4( int i ) {
    if (i &gt; 0) {
        foo3( (int) i / 2 );  /* 违规 */
    }
}

void foo3( int i ) {
    int x = i;

    if (i &gt; 0) {
        foo4( x - i );  /* 违规 */
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1( ) {          /* Ok */
    /* 空的 */
}

void foo2( );           /* Ok */

void foo3( ) {
    foo2( );            /* Ok */
}

void foo7( int );

void foo4( int i ) {
    foo7( i );    /* Ok - 不能检测复杂地间接地递归调用 */
}

void foo5( int i ) {
    foo4( i );    /* Ok -不能检测复杂地间接地递归调用*/
}

void foo6( int i ) {
    foo5( i );    /* Ok - 不能检测复杂地间接地递归调用 */
}

void foo7( int i ) {
    if (i &gt; 0) {
        foo6( i - 5 );  /* Ok - 不能检测复杂地间接地递归调用 */
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源：Misra 指南 - 第70条规则

3. 联合攻击战斗机，飞行器，C++ 编码标准
   第4.13章函数，AV 第119条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第7部分，第7-5-4条规则

5. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 1

6. HIS Source Code Metriken, version 1.3.1
Metrik "ap_cg_cycle"

7. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-8_0_1</key>
<configkey>MISRA2008-8_0_1</configkey>
<name><![CDATA[ 初始声明列表或成员声明列表应该分别由单一的初始声明或成员声明组成 [MISRA2008-8_0_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
初始声明列表或成员声明列表应该分别由单一的初始声明或成员声明组成 [MISRA2008-8_0_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“每个变量都要在单独的声明语句中被声明”
当指针和访问指示符在同一个语句中用于多个声明时，
确定变量的类型变得很混乱。 
参见: FORMAT-29



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止混乱和增强源代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( )
{
    int* a, b;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) 
{
    int* a;      // OK
    int b;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
   出自: 11 Variables - 规则 39, 6 Style - 6.5 Pointers and References - Rec. 26

2. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 8 节, 规则 8-0-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-8_3_1</key>
<configkey>MISRA2008-8_3_1</configkey>
<name><![CDATA[ 在覆盖的虚函数中的参数应该使用同他们所覆盖的函数一样缺省的实参，否则不得指定任何缺省实参 [MISRA2008-8_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在覆盖的虚函数中的参数应该使用同他们所覆盖的函数一样缺省的实参，否则不得指定任何缺省实参 [MISRA2008-8_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“虚拟函数是被动态约束的，但是默认参数却为静态约束。
这意味着您可能会使用基类型中的默认参数调用衍生类中的
虚拟函数。”
本规则能检测出将继承的虚拟函数被重定义为不同的默认参
数值的情况。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则不检测一下情况：
-具有模板参数的函数
-默认参数值为非常数
-具有复杂表达式的默认参数值



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能预防对默认传递的参数进行错误解释的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base
{
public:
    virtual void func(int i = 1);
};

class Derived: public Base
{
public:
    virtual void func(int i = 0);  // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base
{
    public:
        virtual void func1(int i = 1);
        virtual void func2(int i = 1);
};

class Derived: public Base
{
    public:
        virtual void func1(int i);      // OK
        virtual void func2(int i = 1);  // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   第6章，第37项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“继承与面向对象的设计”，第38项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第95条

4.MISRA C++：2008 - 在关键系统中使用C++语言的准则
  第6章，第8节，第8-3-1条规则

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-8_4_1</key>
<configkey>MISRA2008-8_4_1</configkey>
<name><![CDATA[ 函数不得使用省略符号定义 [MISRA2008-8_4_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不得使用省略符号定义 [MISRA2008-8_4_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用有可变数量参数的函数



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以防止很多潜在的问题



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int x, ...)   // 违规
{  
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用有可变数量参数的函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Misra 指南 - 第 69 条规则

2. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   从: 9 Functions - 9.1 Function Arguments - 第 31 条规则 

3. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   "Type Safety" 章， 第 98 条规则

4. Scott Meyers and Martin Klaus, "Examining C++ Program Analyzers", 
   Dr. Dobbs' Journal, the February 1997, 
   "Implementation" 章， 第 23 项
   <A HREF="http://www.aristeia.com/ddjpaper1_frames.html">http://www.aristeia.com/ddjpaper1_frames.html</A>

5. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.13 章 Function， AV 第 108 条规则

6. MISRA C++:2008 C++ 语言在关键系统中的使用指南，
   第 6 章， 第 8 节， 第 8-4-1 条规则 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-8_4_2</key>
<configkey>MISRA2008-8_4_2</configkey>
<name><![CDATA[ 用于参数的标识符在函数的重声明中应该和声明中的相同 [MISRA2008-8_4_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
用于参数的标识符在函数的重声明中应该和声明中的相同 [MISRA2008-8_4_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果参数名已经给与了，那么在声明
和定义的时候也要用一样的参数名。
 


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则用来提高代码的可读性和清晰度。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b);  
void foo(int x, int y ) {}  /* 违规 */



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b);    /* OK */
void foo(int a, int b) {}

/* 正确代码示例 */
void foo1();               /* OK */
void foo2(int  , int   );  /* OK */
void foo2(int x, int y ) {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 来源: Misra指南 - 第74条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第8部分，第8-4-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-8_4_3</key>
<configkey>MISRA2008-8_4_3</configkey>
<name><![CDATA[ 非 void 返回类型函数的所有退出路径应该有显式表达式的返回语句 [MISRA2008-8_4_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非 void 返回类型函数的所有退出路径应该有显式表达式的返回语句 [MISRA2008-8_4_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对于返回值是非空类型的函数，它的所有退出
路径都应该有一个表达式明确地给出返回值。
缺了这个表达式，将会导致未定义的行为
（并且编译器可能不能指出这个错误）。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

"goto" 语句被认为是一个退出点。
该规则不跟踪数据流。它假定在条件语句中
每条路径应该根据条件可独立访问的。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则阻止了不可预测的函数行为。



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

此规则将跳出"while", "for", 和"catch"语句段。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo1(int x){ // 违规 
                 //在第二重if语句，没有返回
    if (x==0) {
        if (x==0) {
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // 违规 
                 // 在switch语句中，没有default语句的返回值
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
    }
}

int foo3(int x){ // 违规 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo1(int x){ // OK
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int foo2(int x){ // OK
    switch(x){
        case 0: return 1;
        case 1: return 1;
        case 2: return 1;
        default: return 1;
    }
}

int foo3(int x){ // OK
    return 0;
}

int foo4(int x){ // OK
    if (x==0) {
        return 0;
    }
    return 0;
}

int foo5(int x){ // Ok
    if (x==0) {
        if (x==0) {
            return 0;
        } else {
            return 0;
        }
    } else {
        switch(x){
            case 0: return 1;
            case 1: return 1;
            case 2: return 1;
            default: return 1;
        }
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第6章，第16部分

2. 联合攻击战斗机, 飞行器, C++ 编码标准
   第4.13章函数，AV 第114条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   第6章，第8部分，第8-4-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-8_5_1</key>
<configkey>MISRA2008-8_5_1</configkey>
<name><![CDATA[ 所有变量在被使用之前应该有一个定义的值 [MISRA2008-8_5_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有变量在被使用之前应该有一个定义的值 [MISRA2008-8_5_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“这个规则的意图是在变量读取之前，所有的变量
要先被赋值。 变量并不一定需要在初始化声明时
被赋值。 理想的静态检查应该检查任何有可能被
利用又没有被赋值的自动变量。”
参见: INIT-06, INIT-10, INIT-14, BD-PB-NOTINIT



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这条规则假设通过传递的一个常量定指到外部函数，
局部变量有可能会被初始化。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止从未初始化的变量中读取。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int b;          // 违规      
    b++; 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int b = 0;     // OK 
    b++;        
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 1 章, 第 4 项

2. Misra 指南 - 第 30 条规则

3. Ellemtel 编码规范
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
   出自: 第 11 Variables - 第 40 条规则

4. 联合攻击战斗机， 飞行器， C++ 编码规范
    第 4.16 章 Initialization， AV 第 142 条规则

5. MISRA C++:2008 C++ 语言在关键系统中的使用指南，
   第 6 章， 第 8 节， 第 8-5-1 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-8_5_2</key>
<configkey>MISRA2008-8_5_2</configkey>
<name><![CDATA[ 括号应该被用于指明和匹配在数组和结构体的非零初始化中的结构 [MISRA2008-8_5_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
括号应该被用于指明和匹配在数组和结构体的非零初始化中的结构 [MISRA2008-8_5_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“ISO C要求有数组的初始化列表，结构体和共用体类型要被
包括在唯一的一对大括号里（虽然不这么做的后果并不明确）。
这里给出的规则进一步要求使用
额外的大括号来指示结构体嵌套。
数组或者结构体的零初始化只允许在顶层进行。
数组或者结构体的非零初始化
要求对每一个元素有一个明确地初始化程序。”



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则只检查多达三层括号嵌套初始化。


例外：

“数组或者结构体的所有元素可以通过仅给第一个元素一个
明确的初始化量而被初始化（为0或者空）。如果选择了
这个初始化方法那么第一个元素应该被初始化
为0（或者空），而且不需要使用大括号嵌套。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“该规则强制要求程序员明确地考虑并证实复杂数据类型
的元素被初始化的顺序。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int y[3][2] = { 1, 2, 3, 4, 5, 6 }; // Violation

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, 2}; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int y[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // OK

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, { 2 }}; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 9 节

2. 来源: Misra 指南 - 第 31 条规则

3. 联合攻击战斗机, 飞行器， C++ 编码标准
   第 4.16 章 初始化，第 AV 144 条规则

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 8 节， 第 8-5-2 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-8_5_3</key>
<configkey>MISRA2008-8_5_3</configkey>
<name><![CDATA[ 在枚举成员列表中，不得使用 = 结构显式地初始化除第一个以外的成员，除非所有项目都显式地被初始化 [MISRA2008-8_5_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在枚举成员列表中，不得使用 = 结构显式地初始化除第一个以外的成员，除非所有项目都显式地被初始化 [MISRA2008-8_5_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在枚举数列表里，“=”不应该被用来
明确地初始化第一个成员之外的其他成员，
除非所有的元素都被明确地初始化。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

帮助避免错误和混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum TEST { /* Violation */
    X = 1,
    Y,
    Z = 3,
};

enum TEST2 { /* Violation */
    X2,
    Y2 = 2,
    Z2,
};

enum TEST3 { /* Violation */
    X3,
    Y3,
    Z3 = 3,
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum TEST { /* OK */
    X,
    Y,
    Z,
};

enum TEST2 { /* OK */
    X2 = 1,
    Y2,
    Z2,
};

enum TEST3 { /* OK */
    X3 = 1,
    Y3 = 2,
    Z3 = 3,
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 9 节

2. 来源: Misra 指南 - 第 32 条规则

3. MISRA C++:2008 C++语言在关键系统中的使用指南
   ， 第 6 章， 第 8 节， 第 8-5-3 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-9_3_1</key>
<configkey>MISRA2008-9_3_1</configkey>
<name><![CDATA[ const 成员函数不得返回指向类数据成员的非 const 指针或引用 [MISRA2008-9_3_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
const 成员函数不得返回指向类数据成员的非 const 指针或引用 [MISRA2008-9_3_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一个对象声明为 const 类的类型时，只有 const 成员
函数可以调用该对象。const 成员函数的共同期望是
对象的状态不会在调用函数的时候被修改。
然而，从一个 const 函数返回一个指向类数据的
非 const 指针或引用，则会允许修改对象的
概念性状态。”。
参见: CODSTA-CPP-06, OOP-12, OOP-36



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

指向类数据的句柄是:
- 指向成员变量/成员函数的引用
- 指向成员变量/成员函数的指针
- 在构造函数中指向数据分配或在析构函数中指向数据释放的指针/引用
静态变量不被视为类数据。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止暴露对象的内部状态给客户，所以他们不会 
失控地修改对象的状态。增强数据封装 
是一种面向对象编程的基石。提高代码的可维护性。
帮助 const 函数操作 const。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test
{
    public:
        Test(int &amp; p) : _i(p)
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        int* GetI1() const
        {
            return &amp;_i; // 违规
        }
    protected:
        int&amp; GetI2() const
        {
            return _i; // 违规
        }
        int * GetI3() const
        {
            return _k; // 违规
        }
    private:
        int &amp; _i;
        int * _k;
};
class Child: public Test
{
    public:
        Child() : Test(z)
        {
        }
        void foo() const
        {
            GetI2() = 0; // Modification of possibly-const object
            *(GetI3()) = 0; // Modification of possibly-const object
        }
    private:
        int z;
};
void bar()
{
    const Child c;
    *(c.GetI1()) = 0; // Modification of possibly-const object
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test
{
    public:
        Test(int &amp; p) : _i(p)
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        const int* GetI1() const
        {
            return &amp;_i; // OK
        }
    protected:
        const int&amp; GetI2() const
        {
            return _i; // OK
        }
        const int * GetI3() const
        {
            return _k; // OK
        }
    private:
        int &amp; _i;
        int * _k;
};
class Child: public Test
{
    public:
        Child() : Test(z)
        {
        }
        void foo() const
        {
            // GetI2() = 0; // Not compilable - can't modify const object
            // *(GetI3()) = 0; // Not compilable - can't modify const object
        }
    private:
        int z;
};
void bar()
{
    const Child c;
    // *(c.GetI1()) = 0; // Not compilable - can't modify const object
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范" Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Class Design and Inheritance", 第 42 条规则

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 5, Item 28

3. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 29 项

4. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 7 节, 规则 9-3-1

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-9_3_2_a</key>
<configkey>MISRA2008-9_3_2_a</configkey>
<name><![CDATA[ 受保护(Protected)的成员函数不得返回指向类数据的非 const 句柄(指针或引用) [MISRA2008-9_3_2_a] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
受保护(Protected)的成员函数不得返回指向类数据的非 const 句柄(指针或引用) [MISRA2008-9_3_2_a-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"通过实施与成员函数类接口的实现，保留更
多在对象状态如何修改和协助允许在不影响调
用端的情况来维护类的控制. 返回的类数据句
柄允许调用端在不使用任何的接口情况下，而
对对象的状态做变更."
此规则会在受保护的成员函数返回非常量引用 
或指向私有类数据的指针时报违规.
参见: CODSTA-CPP-06, CODSTA-CPP-77, OOP-36



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

类数据句柄是指:
- 指向成员变量/成员函数的引用
- 指向成员变量/成员函数的指针
- 指向在构造函数分配或在析构函数释放的数据的指针/引用
静态变量不列为类数据.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则改善封装和避免数据不在类设计的方式下进行 
变更.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test
{
    public:
        Test()
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
    protected:
        int* GetI1()
        {
            return &amp;_i; // 违规
        }
        int&amp; GetI2()
        {
            return _i; // 违规
        }
        int * GetI3()
        {
            return _k; // 违规
        }
    private:
        int _i;
        int * _k;
};
class Child: public Test
{
    public:
        void foo()
        {
            *(GetI1()) = 0; // Encapsulation broken - possible to change private class data
            GetI2() = 0; // Encapsulation broken - possible to change private class data
            *(GetI3()) = 0; // Encapsulation broken - possible to change private class data
        }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test
{
    public:
        Test()
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
    protected:
        const int* GetI1()
        {
            return &amp;_i; // OK
        }
        const int&amp; GetI2()
        {
            return _i; // OK
        }
        const int * GetI3()
        {
            return _k; // OK
        }
    private:
        int _i;
        int * _k;
};
class Child: public Test
{
    public:
        void foo()
        {
            // *(GetI1()) = 0; // Not compilable - not possible to change private class data
            // GetI2() = 0; // Not compilable - not possible to change private class data
            // *(GetI3()) = 0; // Not compilable - not possible to change private class data
        }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 30 项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 29 项

3. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 5 章节, 第 28 项

4. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Class Design and Inheritance", 第 42 条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
    第 6 章节, 第 9 部分, 第 9-3-2 规则

6. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-9_3_2_b</key>
<configkey>MISRA2008-9_3_2_b</configkey>
<name><![CDATA[ Public 成员函数不得返回指向类数据的非 const 句柄(指针或引用) [MISRA2008-9_3_2_b] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Public 成员函数不得返回指向类数据的非 const 句柄(指针或引用) [MISRA2008-9_3_2_b-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"通过实施与成员函数类接口的实现，保留更
多在对象状态如何修改和协助允许在不影响调
用端的情况来维护类的控制. 返回的类数据句
柄允许调用端在不使用任何的接口情况下，而
对对象的状态做变更."
此规则会在受公共成员函数返回非常量引用 
或指向私有/受保护的类数据的指针时报违规.
参见: CODSTA-CPP-06, CODSTA-CPP-77, OOP-12



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

类数据句柄是指:
- 指向成员变量/成员函数的引用
- 指向成员变量/成员函数的指针
- 指向在构造函数分配或在析构函数释放的数据的指针/引用
静态变量不列为类数据.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则改善封装和避免数据不在类设计的方式下进行 
变更.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test
{
    public:
        Test()
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        int* GetI1()
        {
            return &amp;_i; // 违规
        }
        int&amp; GetI2()
        {
            return _i; // 违规
        }
        int * GetI3()
        {
            return _k; // 违规
        }
    private:
        int _i;
        int * _k;
};
void foo()
{
    Test t;
    *(t.GetI1()) = 0; // Encapsulation broken - possible to change private class data
    t.GetI2() = 0; // Encapsulation broken - possible to change private class data
    *(t.GetI3()) = 0; // Encapsulation broken - possible to change private class data
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test
{
    public:
        Test()
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        const int* GetI1()
        {
            return &amp;_i; // OK
        }
        const int&amp; GetI2()
        {
            return _i; // OK
        }
        const int * GetI3()
        {
            return _k; // OK
        }
    private:
        int _i;
        int * _k;
};
void foo()
{
    Test t;
    // *(t.GetI1()) = 0; // Not compilable - not possible to change private class data
    // t.GetI2() = 0; // Not compilable - not possible to change private class data
    // *(t.GetI3()) = 0; // Not compilable - not possible to change private class data
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 30 项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 29 项

3. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 5 章节, 第 28 项

4. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Class Design and Inheritance", 第 42 条规则

5. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 7 Classes - 7.8 Member Function Return Types - Rule 29

6. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章节, 第 9 部分, 第 9-3-2 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-9_3_3</key>
<configkey>MISRA2008-9_3_3</configkey>
<name><![CDATA[ 如果一个成员函数可以是 static 的那么就应该定义为 static，否则如果它可以是 const 那么它应该被定义为 const [MISRA2008-9_3_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个成员函数可以是 static 的那么就应该定义为 static，否则如果它可以是 const 那么它应该被定义为 const [MISRA2008-9_3_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"声明一个 static 或者 const 成员函数限制它存取
非静态的数据成员。"
参见: CODSTA-CPP-54



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则预防无意的修改数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
    int foo1 ()         //违规 - can be static
    {
        return m_s;
    }
    int foo2 ()         //违规 - can be const
    {
        return m_i;
    }
    
private:
    int m_i;
    static int m_s;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
public:
    static int foo1 ()        // OK
    {
        return m_s;
    }
    int foo2 () const         // OK
    {
        return m_i;
    }
    
private:
    int m_i;
    static int m_s;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2008 C++语言在关键系统中的使用指南
   第6章, 第9部分 , 第9-3-3条规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-9_5_1</key>
<configkey>MISRA2008-9_5_1</configkey>
<name><![CDATA[ 不得使用联合体(union) [MISRA2008-9_5_1] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用联合体(union) [MISRA2008-9_5_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

即使内存因为某些原因被重新使用，
这种操作还是存在数据可能被误解危险。
因此，这个规则禁止任何原因的结构体类型的使用。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则在每一个共同体声明的时候报告一个违规的消息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则阻止了未定义的行为和错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

union U {        违规 
    int _i;
    char _buf[ sizeof( int ) ];
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用共同体。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. MISRA-C2004 C语言在关键系统中的使用指南
   第6章，第18部分

2. Herb Sutter, Andrei Alexandrescu, C++编码标准, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   类型安全章节，第97条规则

3. 来源： Misra 指南 - 第109条规则

4. J联合攻击战斗机, 飞行器, C++ 编码标准
   第4.20章 共同体和位域, AV 第153条规则
   
5. MISRA C++2008 C++语言在关键系统中的使用指南，第6章，第9部分，第9-5-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-9_6_2</key>
<configkey>MISRA2008-9_6_2</configkey>
<name><![CDATA[ 位域应该是布尔类型或者显式地 unsigned 或 signed 整型 [MISRA2008-9_6_2] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
位域应该是布尔类型或者显式地 unsigned 或 signed 整型 [MISRA2008-9_6_2-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"位域要么为 bool 类型或者显示声明为 unsigned 
 或 signed 整型，通过使用 int 实现因为 int 类
型的位域可以为 signed 或 unsigned. wchar_t 作
i为位域类型被 ISO/IEC 14882:2003 禁止。"




</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防未定义行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 不正确的代码 */
struct S 
{
    char c : 2;            // 违规
    short f : 3;           // 违规
    int : 0;               // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* 正确代码 */
struct S
{
    unsigned char c : 2;    // OK
    signed short f : 3;     // OK
    unsigned int : 0;       // OK
    bool b : 4              // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 9, Rule 9-6-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-9_6_3</key>
<configkey>MISRA2008-9_6_3</configkey>
<name><![CDATA[ 位域不得有枚举类型 [MISRA2008-9_6_3] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
位域不得有枚举类型 [MISRA2008-9_6_3-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在枚举中使用位域是被 ISO/IEC 14882:2003 明令
禁止的，因为其不允许显示的对 signed 或者 unsigned
 类型使用下标表示。因此不可能确定一个精确的位数表
示枚举中的所有值。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防未定义行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Color{RED, BLUE, BLACK};

struct S
{
    Color n : 2;       // 违规
    /* ... */
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S
{
    unsigned int n: 2 // OK
    /* ... */
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - Guidelines for the use of the C++ language in critical systems
Chapter 6, Section 9, Rule 9-6-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MISRA2008-9_6_4</key>
<configkey>MISRA2008-9_6_4</configkey>
<name><![CDATA[ 由 signed 整型命名的位域应该有超过一位的长度 [MISRA2008-9_6_4] ]]></name>
<tag>misra2008</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
由 signed 整型命名的位域应该有超过一位的长度 [MISRA2008-9_6_4-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“由 signed 整型命名的位域应该有超过一位的长度。
一个位长度表示的值可能不符合开发人员的预期。
任何长度的匿名有符号位域是被允许的。
”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则只对明确有符号类型报告违规



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止潜在缺陷和错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct MyStruct 
{
    signed int si01 : 1;    // 违规
    signed int si02 : 1;    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct MyStruct 
{
    signed int si01 : 2;    // OK
    signed int : 1;         // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 9 节, 规则 9-6-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-01</key>
<configkey>MRM-01</configkey>
<name><![CDATA[ 由于函数参数的评估顺序尚未定义，禁止在函数参数表中进行资源分配 [MRM-01] ]]></name>
<tag>mrm</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
由于函数参数的评估顺序尚未定义，禁止在函数参数表中进行资源分配 [MRM-01-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“确保所有的资源均属于其相应的对象。在资源声明的语句中
显示地进行资源分配（如使用new）立即将该分配的资源赋予其
管理对象（如，shared_ptr）；否则，由于函数参数的评估顺序
未定义，将导致资源泄漏。”
该规则禁止在函数参数表中进行的资源分配。
参见：MRM-02



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“这样的代码是不安全的。C++标准给予编译器极大的余地来调
整函数的两个参数中构建的两个语句。在特殊情况下，编译器可
以交换这两条语句的执行顺序：内存分配（由new运算符调用）
可以先对这两个对象进行，然后再调用这两者的构造函数。这就
很有可能造成泄漏，因为如果两者之一的构造函数抛出了一个异
常，则另一个对象的内存将永远不会被释放掉。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;boost/shared_ptr.hpp&gt;
using boost::shared_ptr;

void Fun2( shared_ptr&lt;int&gt; p1, shared_ptr&lt;int&gt; p2 );

void goo( ) {
    Fun2( shared_ptr&lt;int&gt;( new int ), shared_ptr&lt;int&gt;( new int ) ); // Violation
}


修复措施：

#include &lt;boost/shared_ptr.hpp&gt;
using boost::shared_ptr;

void Fun2( shared_ptr&lt;int&gt; p1, shared_ptr&lt;int&gt; p2 );

void goo( ) {
    shared_ptr&lt;int&gt; p1( new int );
    shared_ptr&lt;int&gt; p2( new int );
    Fun2( p1, p2 );      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutte，Andrei Alexandrescu，《C++编码规范》
   Addison-Wesley，(C)2005 Pearson Education, Inc.,
   章节：“设计风格”，第13条规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-02</key>
<configkey>MRM-02</configkey>
<name><![CDATA[ 不要在一条语句中分配多个资源 [MRM-02] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在一条语句中分配多个资源 [MRM-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"确认所有资源都被对象拥有。在每一条语句里明确的使用资源分配函数 
(如，new），并立即把这个分配的资源赋给管理资源的对象（如，shared_ptr）。 
按照建议在每一个对象里的代码语句里执行明确的资源分配（如，new），
并立即把这个分配的资源赋给拥有资源的对象（如，shared_ptr）。" 
这条规范不允许在一个单独的语句里分配多个资源。
参见: MRM-01



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"内存分配（调用new操作符）可以首先对两个对象来进行， 
然后再去尝试调用两个构造体函数。这样可以有效的避免内存 
泄露的问题，应为如果一个构造函数调用产生了异常，另一个 
对象的内存将得不到释放。 " 


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;boost/shared_ptr.hpp&gt;

using boost::shared_ptr;

class Sport{};

void smartPointer( ) {
    shared_ptr&lt;Sport&gt; sport1( new Sport ), sport2( new Sport );  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;boost/shared_ptr.hpp&gt;

using boost::shared_ptr;

class Sport{};

void smartPointer( ) {
    shared_ptr&lt;Sport&gt; sport1( new Sport );       // OK
    shared_ptr&lt;Sport&gt; sport2( new Sport );       // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Design Style", Rule 13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-04</key>
<configkey>MRM-04</configkey>
<name><![CDATA[ 所有的类应该包含赋值操作符或适当的注释 [MRM-04] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的类应该包含赋值操作符或适当的注释 [MRM-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"确保你的类对象提供了赋值操作符，或者提供注释。 
有如下的选择来确保规则：
 -  如果赋值操作对您的类型没有意义，通过申明赋值操作来禁止复制，
      表明是私有没有实现的函数 
  - 如果赋值操作有警告，但是使用的编译器可以正确赋值，那么就自己实现 
      这个函数，并标为非私有的 
 - 如果赋值操作有意义，并且默认的行为时对的，使用直接的和编译器版本有 
      关的注释，这样您的代码的阅读者可以知道你没有遗忘其中的一个选项 "
注释可以包含字符串 "assignment operator" which is checked insensitive.
参考: CODSTA-CPP-02, CODSTA-CPP-21, CODSTA-CPP-24, MRM-05, MRM-37, MRM-40,
          MRM-47, OOP-27, OOP-30, OOP-34



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免使用有编译器自己生成的赋值操作。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A   // Violation
{
};

class B   // Violation
{
};

class C : public B   // Violation
{
};

class D   // Violation
{
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A              // OK
{
public:
    A&amp; operator=(const A&amp; a)
    {
        /* ... */
        return *this;
    }
};

class B              // OK
{
private:
    // copying disabled
    B&amp; operator=(const B&amp; b);
};

class C : public B   // OK
{
    // copying disabled
    // private assignment operator in a base class
};

class D              // OK
{
    // class uses compiler-generated assignment operator
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Construction, Destruction, and Copying", Rule 53

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-05</key>
<configkey>MRM-05</configkey>
<name><![CDATA[ 所有的类必须包含拷贝构造函数或适当的注释 [MRM-05] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有的类必须包含拷贝构造函数或适当的注释 [MRM-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"确保你的类对象提供了赋值操作符，或者提供注释。 
有如下的选择来确保规则：
 -  如果赋值操作对您的类型没有意义，通过申明赋值操作来禁止复制，
      表明是私有没有实现的函数 
  - 如果赋值操作有警告，但是使用的编译器可以正确赋值，那么就自己实现 
      这个函数，并标为非私有的 
 - 如果赋值操作有意义，并且默认的行为时对的，使用直接的和编译器版本有 
      关的注释，这样您的代码的阅读者可以知道你没有遗忘其中的一个选项 "
注释可以包含字符串 "assignment operator" which is checked insensitive.
注释可以包含字符串 "copy constructor" which is checked insensitive.
参考: CODSTA-CPP-19, MRM-04, MRM-38, MRM-40, MRM-48, OOP-27, OOP-30, OOP-34



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免使用有编译器自己生成的赋值操作。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A   // Violation
{
};

class B   // Violation
{
};

class C : public B   // Violation
{
};

class D   // Violation
{
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A              // OK
{
public:
    A(const A&amp; a){}
};

class B              // OK
{
private:
	// copying disabled
	B(const B&amp; b);
};

class C : public B   // OK
{
	// copying disabled
	// private copy constructor in a base class
};

class D              // OK
{
	// class uses compiler-generated copy constructor
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Construction, Destruction, and Copying", Rule 53

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-06</key>
<configkey>MRM-06</configkey>
<name><![CDATA[ 对new/malloc以及delete/free的对应调用应保证相同的形式 [MRM-06] ]]></name>
<tag>mrm</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对new/malloc以及delete/free的对应调用应保证相同的形式 [MRM-06-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对相应的new/malloc以及delete/free的调用应使用相对应的形式。
本规则检查对new、delete、malloc以及free的调用以确保对他们
的调用采用了相对应的形式；如果您同时调用new以及free( )则将
报告出冲突。如果您未采用相同的形式来调用对应的new、delete、
malloc以及free，则将导致析构函数调用的次数错误。
参见：MRM-08，MRM-09，MRM-10，MRM-11，MRM-30



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
如果在同一函数中对同一个变量用了两种不兼容的方法分配内存，
也将触发本规则。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用不对应的方法调用'new/malloc'以及'delete/free'。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
void foo( ) {
    char* ptr1 = (char*) malloc( 19 );
    char* ptr2 = new char[ 10 ];
    delete ptr1;                     // Violation
    free( ptr2 );                    // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
void foo( ) {
    char* ptr1 = (char*) malloc( 19 );
    char* ptr2 = new char[ 10 ];
    free( ptr1 );                    // OK
    delete[] ptr2;                   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-07</key>
<configkey>MRM-07</configkey>
<name><![CDATA[ 不能对非 POD 使用 memcpy 或 memcmp [MRM-07] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能对非 POD 使用 memcpy 或 memcmp [MRM-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不要使用memcpy或memcmp来拷贝或比较结构化的对象，而只能操作原始的内存。 
Memcpy和memcmp违反了类型系统。对隐含的信息使用memcpy是严重的违规，并且 
经常会导致内存和资源的泄露，崩溃，或者是无法预知的行为。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则改进了代码的安全性和稳定性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;memory.h&gt;
class A {
    int *p;
};

class B {
    int *p;
};

void foo( ) {
    A p1;
    B p2;
    memcpy( &amp;p1, &amp;p2, sizeof( p1 ) );    // Violation
}


修改:

Memcpy and memcmp should not be used.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Type Safety", Rule 96

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-08</key>
<configkey>MRM-08</configkey>
<name><![CDATA[ 禁止对含有构造函数的对象调用malloc/realloc [MRM-08] ]]></name>
<tag>mrm</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对含有构造函数的对象调用malloc/realloc [MRM-08-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止对含有构造函数的对象调用malloc/realloc。
参见：MRM-06，MRM-09，MRM-10，MRM-11，MRM-30



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则确保所有的成员变量都经过初始化。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
class A {
public:
    A( );
};

void foo( ) {
    A* a = (A*) malloc( sizeof( A ) );  // Violation
    a    = (A*) malloc( sizeof( A ) );  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
class A {
public:
    A( );
};

void foo( ) {
    A* a = new A( );    // OK
    a    = new A( );    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-09</key>
<configkey>MRM-09</configkey>
<name><![CDATA[ 始终分配一个新值给指向已释放内存的表达式 [MRM-09] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
始终分配一个新值给指向已释放内存的表达式 [MRM-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有的指针应该在 delete 语句后立即赋值一个0
或者是有效的地址。
如果在 delete 删除之后直接在一个表达式中使用
而没有对这个表达式赋值，本规则报告一个违规。 
只有在当在赋值中使用同在 delete 语句完全相同的
表达式时，本规则才不会报告违规。
参见: MRM-10, MRM-11, MRM-31



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则只检查复杂的表达式。简单的参数和变量
是通过规则 MRM-10 和 MRM-11 检查。


例外:

如果在析构函数中一个表达式包含非静态成员变量 
和不包含全局变量作为 delete 的操作数。
本条规则不报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止访问指针或已删除的对象的引用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct S {
    int* p;
    int* q;
};

void foo(S* s){
    s-&gt;p = new int;
    s-&gt;q = new int(5);
    //....
    delete s-&gt;p;	// Violation - set deleted pointer in next expression
    delete s-&gt;q;	// Violation - set deleted pointer in next expression
    s-&gt;p = 0;
    s-&gt;q = new int(10);
    //...
    delete s-&gt;q;	// Violation - set deleted pointer in next expression
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
struct S {
    int* p;
    int* q;
};

void foo(S* s){
    s-&gt;p = new int;
    s-&gt;q = new int(5);
    //....
    delete s-&gt;p;	// OK
    s-&gt;p = 0;
    delete s-&gt;q;	// OK
    s-&gt;q = new int(10);
    //...
    delete s-&gt;q;	// OK
    s-&gt;q = 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 16 Memory Allocation - Rec. 59

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-10</key>
<configkey>MRM-10</configkey>
<name><![CDATA[ 始终分配一个新值给指向已释放内存的全局或成员变量 [MRM-10] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
始终分配一个新值给指向已释放内存的全局或成员变量 [MRM-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有的指针应该在 delete 语句后立即赋值一个0
或者是有效的地址。
如果在 delete 删除之后直接在一个全局或成员变量中使用
而没有对这个表达式赋值，本规则报告一个违规。 
参见: MRM-09, MRM-11, MRM-31



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果在析构函数中在非静态成员变量上使用 delete，
本条规则不报告违规。
如果在宏内部的 delete 语句之前使用一个语句，
有些在 MSVC 编译器上可能不会报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止访问指针或已删除的对象的引用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* p;
int* q;
void foo(){
    p = new int;
    q = new int(5);
    //....
    delete p;	// Violation - set deleted pointer in next expression
    delete q;	// Violation - set deleted pointer in next expression
    p = 0;
    q = new int(10);
    //...
    delete q;    // Violation - set deleted pointer to 0
}

class A {
public:
    A();
    ~A();
    void clear();
    int* ptr;
};

A::A(){
    ptr = new int(10);
}

void A::clear(){
    delete ptr;    // Violation - set deleted pointer to 0
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int* p;
int* q;
void foo(){
    p = new int;
    q = new int(5);
    //....
    delete p;	// OK
    p = 0;
    delete q;	// OK
    q = new int(10);
    //...
    delete q;	// OK
    q = 0;
}

class A {
public:
    A();
    ~A();
    void clear();
    int* ptr;
};

A::A(){
    ptr = new int(10);
}

A::~A(){
    delete ptr;    // OK - exception
}

void A::clear(){
    delete ptr;    // OK
    ptr = 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 16 Memory Allocation - Rec. 59

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-11</key>
<configkey>MRM-11</configkey>
<name><![CDATA[ 始终分配一个新值给指向已释放内存的参数或本地变量 [MRM-11] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
始终分配一个新值给指向已释放内存的参数或本地变量 [MRM-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有指针都必须在delete语句后立即赋值一个0或者是有效的地址。
如果在 delete 删除之后直接在一个本地变量中使用
而没有对这个变量赋值，本规则报告一个违规。 
参考: MRM-09, MRM-10, MRM-31



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果 delete 是函数中的最后一个语句
(忽略其他 delete 和返回语句)，本条规则不报告违规。
如果在宏内部的 delete 语句之前使用一个语句，
有些在 MSVC 编译器上可能不会报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用已经释放了的对象的指针。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int* p){
    p = new int;
    int* q = new int(5);
    //....
    delete p;	// Violation - set deleted pointer in next expression
    delete q;	// Violation - set deleted pointer in next expression
    p = 0;
    q = new int(10);
    //...
    return;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int* p){
    p = new int;
    int* q = new int(5);
    //....
    delete p;	// OK
    p = 0;
    delete q;	// OK
    q = new int(10);
    //...
    delete q;	// OK
    return;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 16 Memory Allocation - Rec. 59

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-12</key>
<configkey>MRM-12</configkey>
<name><![CDATA[ 在编写 new 和 delete 函数时应该固守常规 [MRM-12] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在编写 new 和 delete 函数时应该固守常规 [MRM-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"对于操作符delete，情况更加简单。您所要记住的是C++保证了在删除空 
指针时，总是安全的，所以你需要尊重这个C++语法的保证。 
这个函数的成员版本同样非常简单，除非你确信你要检查被删除对象的大小。 
假设你的类的操作符new传入了错误的"wrong"大小到::operator new, 
那么你就必须要传入"wrongly sized" 删除请求道::operator delete. "
参考: MRM-13



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

保证你的'delete'函数的行为是和默认的操作符delete一致的。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
#include &lt;cstddef&gt;

class Base {
public:
    static void* operator new( size_t size ) throw( std::bad_alloc );
    static void operator delete( void* rawMemory, size_t size ) throw( );
};

void Base::operator delete( void* rawMemory, size_t size ) throw( ) {   // Violation
    if (rawMemory == 0) return;
    // deallocate the memory pointed to by rawMemory;
    return;
}

void operator delete( void* rawMemory ) throw( ) {                      // Violation
    // deallocate the memory pointed to by rawMemory;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
#include &lt;cstddef&gt;

class Base {
public:
    static void* operator new( size_t size ) throw( std::bad_alloc );
    static void operator delete( void* rawMemory, size_t size ) throw( );
};


void Base::operator delete( void* rawMemory, size_t size ) throw( ) {   // OK
    if (rawMemory == 0) return; 
    if (size != sizeof( Base )) { 
        ::operator delete( rawMemory );
        return;
    }
    // deallocate the memory pointed to by rawMemory;
    return;
}

void operator delete( void* rawMemory ) throw( ) {                      // OK
    if (rawMemory == 0) return; 
    
    // deallocate the memory pointed to by rawMemory;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 8, Item 51

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-13</key>
<configkey>MRM-13</configkey>
<name><![CDATA[ 在编写 new 函数时应该固守常规 [MRM-13] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在编写 new 函数时应该固守常规 [MRM-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当你写操作符new时，这条规则用来检查代码以确保你的使用和默认的操作符new 
一致。"在实际当中，这意味着获得了正确的返回值，当可用内存不足时调用了 
错误处理函数，并且在当没有内存时记录请求。 

比较奇怪的是，C++test要求操作符new返回一个合法的指针，即使是只有0个byte 
的申请时。在这种情况下，可以用下面的伪代码来表示0个byte的操作符new的申请：

void * operator new(std::size_t size) throw(std::bad_alloc)
{ // your operator new might
  using namespace std; // take additional params

  if (size == 0) { // handle 0-byte requests
     size = 1;     // by treating them as
  }                // 1-byte requests

/* ... */
}

比如在一个类里面使用操作符new，这个函数的行为就会变成对象的大小- 
不是太大就是太小。由于继承性的原因，可能出现这样的情况：在一个基类 
里面的操作符new会被一个继承类来调用分配内存：

class Base {
 public:
    static void * operator new(std::size_t size) throw(std::bad_alloc);
 ...
};

class Derived: public Base // Derived doesn't declare
{ ... }; // operator new

Derived *p = new Derived; // calls Base::operator new!

如果基类的操作符new不是设计成这样的话--而且很有肯能就是这样的情况-- 
最好的针对这种情况的处理方式就是不要使用"wrong"的大小来用操作符 
new申请内存, 如下面的代码：
void * Base::operator new(std::size_t size) throw(std::bad_alloc)
{
   if (size != sizeof(Base))       // if size is "wrong,"
      return ::operator new(size); // have standard operator
                                   // new handle the request
   ... 
}
参考: MRM-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

当你在使用new时不遵守传统的写法时，你可能会让看你代码的人对 
操作符new和delete产生疑惑。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
class A {
public:
    A( );
    void* operator new(size_t size) {           // Violation
        // missing ifs checking proper memory allocation
        return (int *)(new int);
    };
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
class A {
public:
    A( );
    void* operator new(size_t size) {           // OK
        if (size !=sizeof(A) ) {
            return ::operator new(size);
        }

        if (size==0) { 
            size=1; 
        }

        return (int *)(new int);
    };
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 8, Item 51

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., Chapter: "Memory Management", Item 8

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-14</key>
<configkey>MRM-14</configkey>
<name><![CDATA[ 如果一个类定义了 new 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new 操作符重载 [MRM-14] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个类定义了 new 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new 操作符重载 [MRM-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果一个类定义了new操作符的任何重载，就应该提供 plain,  
in-place,和 non-throwing 所有三种标准形式的 new 操作符重载. 
如果没有的话，它们就会被隐藏，导致使用你的类的用户无法使用。"
参考: MRM-17, MRM-16, MRM-15, MRM-32



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免隐藏操作符new的其他重载。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;new&gt;
class MyClass            // Violation - in-place new only
{          
public:
    static void * operator new( size_t count, void * object );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;new&gt;
class MyClass         // OK - all three operators overloaded
{         
public:
    static void * operator new( size_t count );                             
    static void * operator new( size_t count, std::nothrow_t nt ) throw( ); 
    static void * operator new( size_t count, void * object );              
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Class Design and Inheritance", Rule 46

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-15</key>
<configkey>MRM-15</configkey>
<name><![CDATA[ 如果一个类定义了 new[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new[] 操作符重载 [MRM-15] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个类定义了 new[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new[] 操作符重载 [MRM-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果一个类定义了new[]操作符的任何重载，就应该提供 plain,  
in-place,和 non-throwing 所有三种标准形式的 new 操作符重载. 
如果没有的话，它们就会被隐藏，导致使用你的类的用户无法使用。"
参考: MRM-17, MRM-16, MRM-14



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免隐藏操作符new[]的其他重载。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;new&gt;
class MyClass            // Violation - in-place new only
{          
public:
    static void * operator new[]( size_t count, void * object );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;new&gt;
class MyClass         // OK - all three operators overloaded
{         
public:
    static void * operator new[]( size_t count );                             
    static void * operator new[]( size_t count, std::nothrow_t nt ) throw( ); 
    static void * operator new[]( size_t count, void * object );              
};


参考:

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Class Design and Inheritance", Rule 46

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-16</key>
<configkey>MRM-16</configkey>
<name><![CDATA[ 如果一个类定义了 delete 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 delete 操作符重载 [MRM-16] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个类定义了 delete 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 delete 操作符重载 [MRM-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果一个类定义了delete操作符的任何重载，就应该提供 plain,  
in-place,和 non-throwing 所有三种标准形式的 new 操作符重载. 
如果没有的话，它们就会被隐藏，导致使用你的类的用户无法使用。"
参考: MRM-17, MRM-15, MRM-14



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免隐藏操作符delete的其他重载。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;new&gt;
class MyClass    // Violation 
{												       
public:
	static void operator delete(void* _Ptr) throw( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;new&gt;
class MyClass1   // OK
{																
public:
	static void operator delete(void* _Ptr) throw( );
	static void operator delete(void* _Ptr, const std::nothrow_t&amp;) throw( );
	static void operator delete(void*, void*) throw( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Class Design and Inheritance", Rule 46

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-17</key>
<configkey>MRM-17</configkey>
<name><![CDATA[ 如果一个类定义了 delete[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 delete[] 操作符重载 [MRM-17] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个类定义了 delete[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 delete[] 操作符重载 [MRM-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果一个类定义了delete[]操作符的任何重载，就应该提供 plain,  
in-place,和 non-throwing 所有三种标准形式的 new 操作符重载. 
如果没有的话，它们就会被隐藏，导致使用你的类的用户无法使用。"
参考: MRM-16, MRM-15, MRM-14



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免隐藏操作符delete[]的其他重载。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;new&gt;
class MyClass    // Violation 
{												       
public:
	static void operator delete[](void* _Ptr) throw( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;new&gt;
class MyClass1   // OK
{																
public:
	static void operator delete[](void* _Ptr) throw( );
	static void operator delete[](void* _Ptr, const std::nothrow_t&amp;) throw( );
	static void operator delete[](void*, void*) throw( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Class Design and Inheritance", Rule 46

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-18</key>
<configkey>MRM-18</configkey>
<name><![CDATA[ 不要在分配内存后期望其他操作随后会帮助释放内存 [MRM-18] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在分配内存后期望其他操作随后会帮助释放内存 [MRM-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
描述:

如果在全局函数里通过new分配了局部内存，那么它需要 
在这个函数里被删除。
参考: MRM-20, MRM-19



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助确保所以分配的内存被正确的清除了。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int *var = new int( );  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int *var = new int( );  // OK
    delete var;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 16 Memory Allocation - Rec. 58

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-19</key>
<configkey>MRM-19</configkey>
<name><![CDATA[ 不要在分配内存后期望其他操作随后会帮助释放内存 [MRM-19] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在分配内存后期望其他操作随后会帮助释放内存 [MRM-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果在类里通过new分配了局部内存，那么它需要在析构函数里来 
通过delete删除。
参考: MRM-20, MRM-18



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

This rule helps to ensure that all allocated memory is being cleaned
up properly.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
private:
    int* var;
public:
    A( ) {
        var = new int( );   // Violation
    }
    ~A( ) {}
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
private:
    int* var;
public:
    A( ) {
        var = new int( );   // OK
    }
    ~A( ) {
        delete var;
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 16 Memory Allocation - Rec. 58

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-20</key>
<configkey>MRM-20</configkey>
<name><![CDATA[ 不要在分配内存后期望其他操作随后会帮助释放内存 [MRM-20] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在分配内存后期望其他操作随后会帮助释放内存 [MRM-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果在类里通过new分配了局部内存，那么相应的必须定义 
一个析构函数。
参考: MRM-19, MRM-18



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则帮助确保所以分配的内存被正确的清除了。  



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
private:
    int* var;
public:
    A( ) {
        var = new int( );   // Violation
    }
};


修改:

class A {
private:
    int* var;
public:
    A( ) {
        var = new int( );   // OK
    }
    ~A( ) {
        delete var;
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 16 Memory Allocation - Rec. 58

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-21</key>
<configkey>MRM-21</configkey>
<name><![CDATA[ 使用对象来管理资源 [MRM-21] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用对象来管理资源 [MRM-21-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"auto_ptr和TR1::shared_ptr都在它们的内部析构函数里面使用了delete操作符 
而不是delete[]。这就意味着使用auto_ptr和TR1::shared_ptr来动态分配数组 
是一个很差的选择(...)。如果你仍然觉得使用auto_ptr和TR1::shared_ptr来分 
分配数组时不错的话，看看boost吧。在那里你可以找到boost::scoped_array和 
boost::shared_array类来提供你所希望的行为。使用对象来管理资源这条规则建议 
如果你要手动释放资源（如，使用delete而不是在资源管理类里），你很可能犯错。
参考: MRM-22



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则通过鼓励使用RAII对象，来在它们的构造函数里分配资源，在析构函数里释放资源， 
来避免资源的泄露。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;boost/scoped_array.hpp&gt;
#include &lt;memory&gt;

void myFunction () {
        std::auto_ptr&lt;int&gt; pInv(new int[100]);                // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;boost/scoped_array.hpp&gt;
#include &lt;memory&gt;

void myFunction()
{
    boost::scoped_array&lt;int&gt; pFeatureButtons( new int[22] );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., Chapter 3, Item 13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-22</key>
<configkey>MRM-22</configkey>
<name><![CDATA[ 使用对象来管理资源 [MRM-22] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用对象来管理资源 [MRM-22-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"为了确保一个函数返回的资源始终会被释放，我们需要把这个资源 
放到类的内部，这个类的析构函数在离开控制范围后会自动释放这个资源，
事实上，这只是这条规则背后的一个原因：通过把资源放到类里，我们可以 
使用C++的自动析构函数来确认资源得到释放。事实上，使用类来管理资源 
的概念进场被称作Resource Acquisition Is Initialization (RAII), 
因为，一般我们都需要申请一个资源，然后在同一语句来初始化一个资源管理 
对象。有时，申请资源是由资源管理对象来进行的，而不是我们直接初始化资 
源. 但有些时候，在资源被申请的时候，每个资源就会立即被资源管理对象来 
管理，如：auto_ptr, shared_ptr."
参考: MRM-21



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免资源泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;boost/tr1/memory.hpp&gt;
using namespace std;
using namespace tr1;

class Investment {};

Investment* createInvestment()
{
    Investment * ptr = new Investment();
    return ptr;
};

void myFunction()
{
   Investment *pInv = createInvestment();                // Violation
}


修改:

#include &lt;boost/tr1/memory.hpp&gt;
using namespace std;
using namespace tr1;

class Investment {};

Investment* createInvestment()
{
    Investment * ptr = new Investment();
    return ptr;
};

void myFunction()
{
   std::auto_ptr&lt;Investment&gt; pInv(createInvestment());  // OK
   shared_ptr&lt;Investment&gt; pInv2(createInvestment());   // OK
} 



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., Chapter 3, Item 13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-23</key>
<configkey>MRM-23</configkey>
<name><![CDATA[ 禁止返回函数范围内的new运算符初始化的解引用本地指针 [MRM-23] ]]></name>
<tag>mrm</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止返回函数范围内的new运算符初始化的解引用本地指针 [MRM-23-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

禁止函数返回对局部对象的引用或者由函数中的new运算符初始
化的解引用指针。本规则能检查到函数返回了对局部对象的引用
或解引用指针。
参见：MRM-24



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

返回对局部对象的引用或由被调函数中的new运算符初始化的解
引用指针可能会导致内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A(int xval, int yval) : _x(xval), _y(yval) {}
    friend A&amp; operator+(const A&amp; p1, const A&amp; p2);
private:
    int _x, _y;
};

A&amp; operator+(const A&amp; p1, const A&amp; p2) {
    A *result = new A(p1._x + p2._x, p1._y + p2._y);
    return *result;             // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A(int xval, int yval) : _x(xval), _y(yval) {}
    friend A operator+(const A&amp; p1, const A&amp; p2);
private:
    int _x, _y;
};

A operator+(const A&amp; p1, const A&amp; p2) {
    A result = A(p1._x + p2._x, p1._y + p2._y);
    	
    return result;              // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scoot Meyers，《高效C++：改善程序及设计的50种特定方法》，
  第二版，Addison-Wesley，
  (C)2005 Pearson Education, Inc., 
  章节：“类与函数：实现”，第31项

2.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.13章节 函数，AV规则第112条

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-24</key>
<configkey>MRM-24</configkey>
<name><![CDATA[ 禁止返回对局部对象的引用 [MRM-24] ]]></name>
<tag>mrm</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止返回对局部对象的引用 [MRM-24-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“禁止函数返回局部变量的指针或引用。如果函数返回了
局部变量的引用或指针，那么当使用该引用或指针时，其
引用的内存块已经被释放掉了。不同的编译器可能会也可
能不会给出相应的警告。
”参见：MRM-23, PB-40, MISRA2004-17_6



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

返回对局部对象的引用或由被调函数中的new运算符初始化
的解引用指针可能会导致内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* foo( ) {
    int i;
    return &amp;i; // Violation
}
int&amp; bar( ) {
    int i;
    return i;  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( ) {
    int i = 0;
    return i;  // OK
}
int bar( ) {
    int i = 0;
    return i;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#9.4">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#9.4</A>
  论坛：9 函数 - 9.4返回类型以及值 -第34条规则

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“类与函数：实现”，第31项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.13章 函数，AV规则第111条

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-25</key>
<configkey>MRM-25</configkey>
<name><![CDATA[ 以独立语句将 newed 对象置入智能指针 [MRM-25] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
以独立语句将 newed 对象置入智能指针 [MRM-25-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"以独立语句将 newed 对象置入智能指针。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免在异常抛出时发生的微妙的资源泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;boost/tr1/memory.hpp&gt;

class Widget {
public:
    Widget( ){}
    ~Widget( ){}
    void f( void );
    int priority( void );
    void processWidget( std::tr1::shared_ptr&lt;Widget&gt;pw, int priority );
};

void Widget::f( void ) {
    processWidget(
        std::tr1::shared_ptr&lt;Widget&gt;( new Widget ), priority( ) ); // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;boost/tr1/memory.hpp&gt;

class Widget {
public:
    Widget( ){}
    ~Widget( ){}
    void f( void );
    int priority( void );
    void processWidget( std::tr1::shared_ptr&lt;Widget&gt;pw, int priority );
};

void Widget::f( void ) {
    std::tr1::shared_ptr &lt;Widget&gt; pw( new Widget );
    processWidget( pw,priority( ) );                     // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., Chapter 3, Item 17

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-26</key>
<configkey>MRM-26</configkey>
<name><![CDATA[ 如果写了一个 new 操作符应该写一个 delete 操作符 [MRM-26] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果写了一个 new 操作符应该写一个 delete 操作符 [MRM-26-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则保证，如果你自己写操作符new，你也必须要相应的写操作符 
delete。如果你在写new的时候同时也写了delete，你要保证new和delete 
使用同样的假设和前提。
参考: MRM-27



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

同时成对的写操作符new和delete将有助于避免内存泄露和内存崩溃。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
class A {        // Violation
public:
    A( ) {}
    void* operator new(size_t size);
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
class A {        // OK
public:
    A( ) {}
    void* operator new(size_t size);
    void operator delete( void* );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., Chapter: "Memory Management", Item 10

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-27</key>
<configkey>MRM-27</configkey>
<name><![CDATA[ 如果写了一个 new[] 操作符应该写一个 delete[] 操作符 [MRM-27] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果写了一个 new[] 操作符应该写一个 delete[] 操作符 [MRM-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则保证，如果你自己写操作符new[]，你也必须要相应的写操作符 
delete。如果你在写new的时候同时也写了delete[]，你要保证new[]和delete[] 
使用同样的假设和前提。
See also: MRM-26



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

同时成对的写操作符new[]和delete[]将有助于避免内存泄露和内存崩溃。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
class A {        // Violation
public:
    A( ) {}
    void* operator new[](size_t size);
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
class A {        // OK
public:
    A( ) {}
    void* operator new[](size_t size);
    void operator delete[]( void* );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 50 Specific Ways to Improve
Your Programs and Design", Second Edition, Addison-Wesley,
(C) 2005 Pearson Education, Inc., Chapter: "Memory Management", Item 10

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-28</key>
<configkey>MRM-28</configkey>
<name><![CDATA[ 始终同时提供 new 和 delete 操作符 [MRM-28] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
始终同时提供 new 和 delete 操作符 [MRM-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每一个类的操作符new的重载都必须要配有一个相应的操作符delete的重载。
同样的原则适用于数组形式的new[]和delete[]. 

一个释放函数的申明必须和一个分配函数的申明相对应，如果它们有相同的参数 
和参数类型。

这条规则的原因是如果new表达式分配了内存，但后来创建对象的初始化通过异常 
的抛出而终止，并且可以找到一个相应的释放内存的函数，释放内存的函数就会被 
调用来释放在构造体里申请的资源。如果相应的释放函数没有存在的话，就可能会 
造成内存泄露。 

参考: MRM-26, MRM-29


例外:

non-placement的释放内存函数申明，并且有2个参数，第二个参数 
符合std::size_t的类型。 
non-placement的分配内存函数，并且只有一个参数。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则45 Herb Sutter &amp; Andrei Alexandrescu 
"C++ Coding Standards"的描述已经被修改以适应C++标准。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免当操作符new重载失败时的内存泄露。保证相对应的new和delete 
操作符有同样的假定前提。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;new&gt;
class MemoryPool;
class A {
public:
    void * operator new(std::size_t);                 // Violation
    void * operator new(std::size_t, MemoryPool&amp;);    // Violation
    void * operator new(std::size_t, float*);         // Violation
    void operator delete(void*, std::size_t, float*);
};


修改:

#include &lt;new&gt;
class MemoryPool;
class A {
public:
    void * operator new(std::size_t);              // OK
    void * operator new(std::size_t, MemoryPool&amp;); // OK
    void * operator new(std::size_t, float*);      // OK
    void operator delete(void*);
    void operator delete(void*, MemoryPool&amp;);
    void operator delete(void*, float*);
};

class B {
public:
    // non-placement allocation function
    void * operator new(std::size_t);              // OK
    // non-placement deallocation function
    void operator delete(void*, std::size_t);
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ISO/IEC 14882:2003(E) C++ standard
Sections 5.3.4, 3.7.3

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Class Design and Inheritance", Rule 45

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-29</key>
<configkey>MRM-29</configkey>
<name><![CDATA[ 始终同时提供 new[] 和 delete[] 操作符 [MRM-29] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
始终同时提供 new[] 和 delete[] 操作符 [MRM-29-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每一个类的操作符new的重载都必须要配有一个相应的操作符delete的重载。
同样的原则适用于数组形式的new[]和delete[]. 

一个释放函数的申明必须和一个分配函数的申明相对应，如果它们有相同的参数 
和参数类型。

这条规则的原因是如果new表达式分配了内存，但后来创建对象的初始化通过异常 
的抛出而终止，并且可以找到一个相应的释放内存的函数，释放内存的函数就会被 
调用来释放在构造体里申请的资源。如果相应的释放函数没有存在的话，就可能会 
造成内存泄露。 

参考: MRM-26, MRM-29


例外:

non-placement的释放内存函数申明，并且有2个参数，第二个参数 
符合std::size_t的类型。 
non-placement的分配内存函数，并且只有一个参数。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则45 Herb Sutter &amp; Andrei Alexandrescu 
"C++ Coding Standards"的描述已经被修改以适应C++标准。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免当操作符new重载失败时的内存泄露。保证相对应的new和delete 
操作符有同样的假定前提。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;new&gt;
class MemoryPool;
class A {
public:
    void * operator new[](std::size_t);                 // Violation
    void * operator new[](std::size_t, MemoryPool&amp;);    // Violation
    void * operator new[](std::size_t, float*);         // Violation
    void operator delete[](void*, std::size_t, float*);
};


修改:

#include &lt;new&gt;
class MemoryPool;
class A {
public:
    void * operator new[](std::size_t);              // OK
    void * operator new[](std::size_t, MemoryPool&amp;); // OK
    void * operator new[](std::size_t, float*);      // OK
    void operator delete[](void*);
    void operator delete[](void*, MemoryPool&amp;);
    void operator delete[](void*, float*);
};

class B {
public:
    // non-placement allocation function
    void * operator new[](std::size_t);              // OK
    // non-placement deallocation function
    void operator delete[](void*, std::size_t);
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ISO/IEC 14882:2003(E) C++ standard
Sections 5.3.4, 3.7.3

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "Class Design and Inheritance", Rule 45

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-30</key>
<configkey>MRM-30</configkey>
<name><![CDATA[ 使用声明进行内存分配，而不是 new 或者 malloc [MRM-30] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用声明进行内存分配，而不是 new 或者 malloc [MRM-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果在一个函数内 new/delete 使用在一个指针上, 使用声明
进行内存分配的替代。
参见： MRM-06, MRM-08, MRM-09, MRM-10, MRM-11



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

使用者需要意识到，因为这条规则可能增加安全漏洞
这并不是一个最好的方法对于堆栈短小的设备。
在微型系统中堆栈大小是非常重要的。在堆栈上不应该声明
数组对于系统是非常重要的
这样形式的代码提高了缓冲区
溢位攻击。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码效率并预防内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string&gt;
using std::string;

void foo( ) {
    string* pStr = new string();  //违规

    // some operation on pStr
    delete pStr;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string&gt;
using std::string;

void foo( ) {
    string pStr = "something";    // OK

    // some operation on pStr
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft 推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-31</key>
<configkey>MRM-31</configkey>
<name><![CDATA[ 释放的内存在任何情况下都不能访问。析构函数不能人工调用 [MRM-31] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
释放的内存在任何情况下都不能访问。析构函数不能人工调用 [MRM-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"There are three major kinds of invalid objects:
- Destroyed objects: Typical examples are automatic objects that have gone out
  of scope and deleted heap-based objects.
- Semantically invalidated objects: Typical examples include dangling pointers
  to deleted objects (e.g., a pointer p after a delete p;) and invalidated 
  iterators. It is generally undefined and unsafe to do anything except assign
  another valid value to an invalidated object.
- Objects that were never valid.
Be aware of object lifetimes and validity. Never dereference an invalid iterator
or pointer. Don't make assumptions about what delete does and doesn't do; 
freed memory is freed, and shouldn't be subsequently accessed under
any circumstances. Don't try to play with object lifetime by calling
the destructor manually (e.g. obj.~T())."

The rule reports violations on the use of pointers to deleted objects
and on explicit calls of destructors.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule checks only simple cases (use of variables, parameters, 
a[b], a.b, a-&gt;b, or *a expressions after they were deleted).
The rule does not check a flow. It assumes that pointer to deleted object
is used if between 'delete' and an use of that pointer there is no
'case', 'default', 'break', 'return', 'throw', 'goto', exit(), abort().



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents writing unsafe and error prone code.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
	A();
    ~A();
};

void foo1( ) {
    A obj;
    obj.~A( );        // Violation
}

char* foo2( ) {	
    char * a = new char;
    delete a;
    return a;         // Violation
};

char* foo3(char * ptr){
    char * a = new char;
    if(a &gt; ptr){
        delete a;
        (*a)++;       // Violation
    } else {
    	(*a)++;       // OK
    }
    a = ptr + 1;
	return a;     // OK
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Don't use invalid objects.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Type Safety", Rule 99

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.10 Classes, AV Rule 70.1

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-32</key>
<configkey>MRM-32</configkey>
<name><![CDATA[ 避免隐藏全局new运算符 [MRM-32] ]]></name>
<tag>mrm</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐藏全局new运算符 [MRM-32-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则能检测出全局new运算符被其它new运算符隐藏的情况。
通过在类中声明一个名为“operator new”的函数，你在无意中
已经阻断了对“new”运算符的“正常”形式的访问。
参见：MRM-14



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果你隐藏了全局new运算符，那么你也使得正常的new运算符
的功能对于你的代码维护人员不可用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;

void ErrorHandler() {};
class A {        // Violation
public:
    void* operator new(size_t size, void (*pehf)()) {
        return new int[size];
    }
    void operator delete(void *A) {
        delete A;
    }
};

template&lt;class T&gt; class D {    // Violation
public:
    void* operator new(size_t size, T (*pehf)()) {
        return new int[size];
    }
    void operator delete(void *d) {
        delete d;
    }
};

void foo() {
    D&lt;void&gt; *a = new (ErrorHandler) D&lt;void&gt;;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;

void ErrorHandler() {};
class B {        // OK
public:
    void* operator new(size_t size, void (*pehf)()) {
        return new int[size];
    }
    void* operator new(size_t size) {
        return new int[size];
    }
    void operator delete(void *A) {
        delete A;
    }
};

class C {        // OK
public:
    void* operator new(size_t size, void (*pehf)()) {
        return new int[size];
    }
    void* operator new(size_t size, int aa=0) {
        return new int[size];
    }
    void operator delete(void *A) {
        delete A;
    }
};

template&lt;class T&gt; class E {	// OK
public:
    void* operator new(size_t size, T (*pehf)()) {
        return new int[size];
    }
    void* operator new(size_t size) {
        return new int[size];
    }
    void operator delete(void *e) {
        delete e;
    }
};

template&lt;class T&gt; class F {	// OK
public:
    void* operator new(size_t size, T (*pehf)()) {
        return new int[size];
    }
    void* operator new(size_t size, int aa=0) {
        return new int[size];
    }
    void operator delete(void *f) {
        delete f;
    }
};

void foo() {
    E&lt;void&gt; *a = new (ErrorHandler) E&lt;void&gt;;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
   第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   章节：“内存管理”第9项

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-33</key>
<configkey>MRM-33</configkey>
<name><![CDATA[ 在析构函数中对指针成员调用delete [MRM-33] ]]></name>
<tag>mrm</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在析构函数中对指针成员调用delete [MRM-33-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“进行动态内存分配的类会在构造函数中使用'new'
来分配内存并且在后面在析构函数中使用delete来释放
内存。在析构函数中删除指针失败往往不会有明显的外
部迹象。反而，其自身将表现为隐蔽的内存泄漏。”
本规则将检测任意成员函数中的'new'运算符分配的
指针成员在析构函数中没有相应的'delete'运算符与
之对应。
参见：MRM-42



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

指针成员可以在析构函数所调用的函数中进行删除。本规
则仅能检测两级的嵌套函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能预防当前代码以及后续升级代码发生内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
    A( );
    ~A( );
    void init();
private:
    int* ptr1;  // Violation
    int* ptr2;  // Violation
    int* ptr3;  // Violation
    int* ptr4;  // OK - null pointer
};

A::A() : ptr1(new int), ptr4(0){
	ptr3 = new int;
	init();
}

void A::init(){
	ptr2 = new int;
}

A::~A(){
	// any delete
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
public:
    A( );
    ~A( );
    void init();
    void freeMem();
private:
    int* ptr1;  // OK
    int* ptr2;  // OK
    int* ptr3;  // OK
    int* ptr4;  // OK - null pointer
};

A::A() : ptr1(new int), ptr4(0){
	ptr3 = new int;
	init();
}

void A::init(){
	ptr2 = new int;
}

void A::freeMem(){
	delete ptr1;
	delete ptr2;
}

A::~A(){
	freeMem();
	delete ptr3;
	delete ptr4; // not necessary
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
   第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   章节：“内存管理”，第6项

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-34</key>
<configkey>MRM-34</configkey>
<name><![CDATA[ 检查 new 的返回值 [MRM-34] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
检查 new 的返回值 [MRM-34-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则提醒你是否检查 new 的返回值。
"到1993为止, C++ 要求操作符 new 返回空值当它不能
分配到需求的内存。操作符 new 是立即会抛出
一个 bad_alloc 异常， 但是很多 C++ 在编译器开始支持修改
规范之前编写的。 C++ 标准化委员会不
想放弃 test-for-null 代码库，因此他们为操作符 new 提供
替换形式提出传统的 failure-yields-null 形态。这些
形态叫做 "nothrow" 形态，在某种程度上他们利用 nothrow 对象
（在头部声明 &lt;new&gt;）在使用 new 的点上。"



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

new 的结果是通过直接调用函数或者 returned 语句获得，规则不会报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

当内存没分配，预防出现空指针。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;new&gt;
void foo()
{
    char *pc;
    pc = new char[10*10*10];      // Violation
    pc[0] = 'x';
    delete[] pc;
    int *p;
    if(p){
        /*code here*/ 
    }
    p = new int;                  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;new&gt;
void foo()
{
    char *pc;
    try{
        pc = new char[10*10*10];   // OK
    }catch(std::bad_alloc&amp;){}
    pc[0] = 'x';
    delete[] pc;
    int *p = new int;              // OK
    if(p){
        /*code here*/
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第8章, 第49项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 章节: "Memory Management", 第7项

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-35</key>
<configkey>MRM-35</configkey>
<name><![CDATA[ 释放非数组内存时 delete 不能使用括号([]) [MRM-35] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
释放非数组内存时 delete 不能使用括号([]) [MRM-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用相同的模式在对应的 new 和 delete。
规则会检查对应的new 和 delete 确保
它们使用相同的模式；当你使用 new 和 delete[]时
规则会报告一个违规。 如果你不使用
相同模式对应的 new 和 delete，
可以称为一个不正确的析构函数。
参见： MRM-36



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用不同形式的  'new' 和 'delete' 的调用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( ) {}
};

void foo( ) {
    A *a = new A;
    delete[] a;        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A( ) {}
};

void foo( ) {
    A *a = new A;
    delete a;          // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第3章, 第4项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 章节： "Memory Management", 第5项

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-36</key>
<configkey>MRM-36</configkey>
<name><![CDATA[ 释放数组内存时 delete 必须使用括号([]) [MRM-36] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
释放数组内存时 delete 必须使用括号([]) [MRM-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用相同的模式在对应的 new 和 delete。
规则会检查对应的new 和 delete 确保
they use the same form; it reports a violation if you call
new[] but forget to use [] when calling delete. If you do
not use the same form in corresponding calls to new and delete, 
an incorrect number of destructors may be called.
参见： MRM-35



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用不同形式的  'new' 和 'delete' 的调用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A( ) {}
};

void foo( ) {
    A *a = new A[100];
    delete a;              // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A( ) {}
};

void foo( ) {
    A *a = new A[100];
    delete[] a;            // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第3章, 第4项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., Chapter: "Memory Management", Item 5

3. Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 16 Memory Allocation - Rule 51

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-37</key>
<configkey>MRM-37</configkey>
<name><![CDATA[ 为动态分配内存的类定义了赋值运算符 [MRM-37] ]]></name>
<tag>mrm</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
为动态分配内存的类定义了赋值运算符 [MRM-37-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检测使用'new'分配数据成员或者使用'delete'释放数据成员的类
是否显示地定义了经典的复制运算符。经典赋值运算符将返回类的引用类型并
且取该类的常量引用。
“复制不会像其它运算符那样被继承。如果复制运算符未被显示定义，那么将
自动为进行定义。
如果你进行了以下赋值'b=a'；（此处‘a’与‘b’都为指针）此处无法调
用客户定义的运算符=，因此C++将生成并调用默认的赋值运算符进行替代。
默认的赋值运算符将按成员进行成员'a'向成员'b'的赋值，对于指针而
言既逐位复制。这种处理方法至少有两个问题。
第一，内存'b'原始指向的内存区域未被删除；
因此，该片区域永久丢失。这是内存泄漏发生的典型示例。
第二，'a'和'b'都包含指向同一字符串的指针。
当两者之一被释放时，其析构函数将会删除另一指针仍然指向的内存区域。”
参见：CODSTA-CPP-02，CODSTA-CPP-21，CODSTA-CPP-24，MRM-04，MRM-38，
MRM-40，MRM-47，OOP-27，OOP-30，OOP-34


例外：

本规则不会报告基类型中含有赋值运算符的情况，因为这种情况阻止了类中隐式
的分配运算符的使用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“逐位复制仅对含有主类型成员数据进行。其结果之一就是逐位复制是对具有指
针类型的成员数据进行的。如果某个对象管理该指针成员指向的对象实例的分配
这将很有可能会导致问题：无论是对管理对象多次调用析构函数还是试图使用该
释放的对象。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class MyClass { // Violation
public:
    MyClass( );
    ~MyClass( ) { delete p; }
private:
    int *p;
};

MyClass::MyClass( ) {
    p = new int;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass { // OK
public:
    MyClass( );
    MyClass&amp; operator=( const MyClass&amp; );
    ~MyClass( ) { delete p; }
private:
    int *p;
};

MyClass::MyClass( ) {
    p = new int;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
  论坛：7 类 - 7.5赋值运算符 - 第27条规则

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“构造函数，析构函数以及赋值运算符”，第11项

3.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“构造，析构以及复制”，第53条规则

4.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第76条
   Chapter 4.10 Classes, AV Rule 76

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-38</key>
<configkey>MRM-38</configkey>
<name><![CDATA[ 为动态分配内存的类声明复制构造函数 [MRM-38] ]]></name>
<tag>mrm</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
为动态分配内存的类声明复制构造函数 [MRM-38-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检测使用'new'分配数据成员或'delete'释放数据成员的类是否
显示定义了复制构造函数。
参见：CODSTA-CPP-19，MRM-05，MRM-37，MRM-40，MRM-48，OOP-27，OOP-30，OOP-34


例外：

本规则不会报告基类型中有复制构造函数的情况，因为这种情况会阻止使用
隐式声明的复制构造函数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“推荐复制构造函数避免相同类型的对象初始化另一对象的不可预知情况。
如果某个对象管理堆中的对象的分配以及释放（管理对象含有一个指向该类
的构造函数创建的对象的指针），那么复制操作将仅对指针的值进行。这可
会对同一对象（该堆中）调用两次析构函数，可能会造成运行时错误”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class MyClass{ // Violation
public:
    MyClass();
    ~MyClass(){ delete p; }
private:
    int *p;
};

MyClass::MyClass() {
    p = new int;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass{ // OK
public:
    MyClass();
    MyClass(MyClass&amp;);
    ~MyClass(){ delete p; }
private:
    int *p;
};

MyClass::MyClass() {
    p = new int;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
  论坛：7 类 - 7.5 构造函数和析构函数 - 第25规则

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc., 
  章节：“构造函数，析构函数以及赋值运算符”第11项

3.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)Pearson Education, Inc.,
  章节：“构造，析构以及复制”第53条规则

4.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第76条

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-39</key>
<configkey>MRM-39</configkey>
<name><![CDATA[ 在调用fopen函数的附近提供文件打开错误的错误处理机制 [MRM-39] ]]></name>
<tag>mrm</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在调用fopen函数的附近提供文件打开错误的错误处理机制 [MRM-39-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在调用fopen函数附近提供文件打开相关的错误处理机制。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则预防在出现IO错误的情况下访问文件（FILE）指针
导致程序崩溃的问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int foo(int c)
{
    FILE* data = fopen("data.txt", "r"); // Violation

    do {
        c = getc(data);
        /* ... */
    } while (c != EOF);

    FILE* data2;
    data2 = fopen("data2.txt", "r");    // Violation

    do {
        c = getc(data2);
       /* ... */
    } while (c != EOF);

    if (!data2)
    {
        /* ... */
        return 0;
    }
    return 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int foo(int c) 
{
    FILE* data = fopen("data.txt", "r");   // OK

    if (data) {
        do {
            c = getc(data);
            /* ... */
        } while (c != EOF);
    } else {
        printf( "File opening error" );
        return 0;
    }

    FILE* data2;
    data2 = fopen("data2.txt", "r");

    if (!data2) {                           // OK
        printf( "File opening error" );
        return 0;
    } else {
        do {
            c = getc(data2);
            /* ... */
        } while (c != EOF);
    }	
    return 1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://cwe.mitre.org/data/definitions/391.html">http://cwe.mitre.org/data/definitions/391.html</A>

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-40</key>
<configkey>MRM-40</configkey>
<name><![CDATA[ 拷贝和析构必须一致 [MRM-40] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
拷贝和析构必须一致 [MRM-40-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果你定义了拷贝构造函数，拷贝分配操作符，析构函数中的任何一个，
那么你需要定义它们之间的一个或者所有。"
参见: CODSTA-CPP-02, CODSTA-CPP-19, CODSTA-CPP-21, CODSTA-CPP-24, MRM-04,
          MRM-05, MRM-37, MRM-38, MRM-47, MRM-48, OOP-27, OOP-30, OOP-34


例外:

"当任何一个特殊的函数被声明是私有的或者虚函数，
没有特殊的意义，
这种情况是个例外。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免产生内存管理问题。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {       // 违规 - 缺少拷贝构造函数
public:
    A( ) {}

    A&amp; operator=( const A&amp; f ) {
        return *this;
    }

    ~A( ) {}
};

class B {       // 违规 - 缺少拷贝分配操作符
public:
    B( ) {}

    B( B&amp; ) {}

    ~B( ) {}
};

class C {       // 违规 - 缺少析构函数
public:
    C( ) {}

    C( C&amp; ) {}

    C&amp; operator=( const C&amp; f ) {
        return *this;
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {       // OK - 拷贝构造函数,拷贝分配操作符和析构函数
public:
    A( ) {}

    A( A&amp; ) {}

    A&amp; operator=( const A&amp; f ) {
        return *this;
    }

    ~A( ) {}
};

class B {  // OK 没有定义拷贝构造函数,拷贝分配操作符和析构函数
};

class C {  // OK - 拷贝构造函数,拷贝分配操作符和析构函数
public:
    C( ) {}

    C( C&amp; ) {}

    C&amp; operator=( const C&amp; f ) {
        return *this;
    }

    ~C( ) {}
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Construction, Destruction, and Copying", Rule 52

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-41</key>
<configkey>MRM-41</configkey>
<name><![CDATA[ 复制构造函数应复制所有的数据成员以及基类型 [MRM-41] ]]></name>
<tag>mrm</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
复制构造函数应复制所有的数据成员以及基类型 [MRM-41-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类可能含有很多数据成员以及存在于继承的层次结构中。
因此复制构造函数必须复制所有的成员，包括其中的基类
型。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
确保在复制对象时能够正确地处理数据成员以及基类型。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base
{
	public:
		Base();
		Base (int x) : base_member (x) { }
		Base (const Base&amp; rhs) : base_member (rhs.base_member) {}
	private:
		int base_member;
};

class Derived : public Base
{
	public:
		Derived (int x, int y, int z) : Base (x),
		derived_member_1 (y),
		derived_member_2 (z) { }
		
		Derived(const Derived&amp; rhs)  // Violation
		{
		}
	
	private:
		int derived_member_1;
		int derived_member_2;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base
{
	public:
		Base();
		Base (int x) : base_member (x) { }
		Base (const Base&amp; rhs) : base_member (rhs.base_member) {}
	private:
		int base_member;
};

class Derived : public Base
{
	public:
		Derived (int x, int y, int z) : Base (x),
		derived_member_1 (y),
		derived_member_2 (z) { }
		
		Derived(const Derived&amp; rhs) : Base(rhs),             // OK
		derived_member_1 (rhs.derived_member_1),
		derived_member_2 (rhs.derived_member_2) 
		{
		}
	
	private:
		int derived_member_1;
		int derived_member_2;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
   第4.10章 类，AV规则第77条

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-42</key>
<configkey>MRM-42</configkey>
<name><![CDATA[ 在析构函数中调用fclose()函数来关闭用于打开文件的指针成员 [MRM-42] ]]></name>
<tag>mrm</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在析构函数中调用fclose()函数来关闭用于打开文件的指针成员 [MRM-42-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则报告在构造函数中使用指针成员打开文件并且
该文件在析构函数中未被关闭的违规。
参见：MRM-33



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防资源泄漏，尤其是在出现错误的情况下。
在析构函数中释放资源为资源管理提供了一种便捷的方法，
尤其针对一些例外情况。而且，如果存在某个资源泄漏的可
能性，那么该资源应该在自动清除该资源的析构函数的类中
被包裹起来。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class File_ptr
{ 
	public:
		File_ptr (const char *n, const char * a) 
		{ 
			p = fopen(n,a); 
		}
		
		
		~File_ptr ()                  // Violation
		{
		}

	private:
		FILE *p;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
using namespace std;

class File_ptr
{ 
	public:
		File_ptr (const char *n, const char * a) 
		{ 
			p = fopen(n,a); 
		}
		
		
		~File_ptr ()            // OK
		{
			if (p)
			{
				fclose(p);
			}
		}

	private:
		FILE *p;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
   第4.10章 类， AV规则第79条

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-43</key>
<configkey>MRM-43</configkey>
<name><![CDATA[ 赋值运算符必须对所有成员，包括基类型中的成员进行赋值 [MRM-43] ]]></name>
<tag>mrm</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
赋值运算符必须对所有成员，包括基类型中的成员进行赋值 [MRM-43-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在继承的层次结构中，某个特定类可能含有很多数据成员。
因此，其赋值运算符必须对所有的成员，包括基类型中的成
员赋值。
本规则报告未调用基类型赋值运算符或者基类型的成员变量
未在衍生类的赋值运算符中进行赋值的违规。
参见：INIT-11



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在operator=function中对所有成员变量进行赋值以预防数
据崩溃。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef unsigned int int32;

class Base
{
public:
    Base (int32 x) : base_member (x) {}
    Base &amp;operator=(const Base&amp; rhs)
    {
        if (this != &amp;rhs)
        {
            base_member = rhs.base_member;
        }
        else
        {
        }
        return *this;
    }
private:
    int32 base_member;
};


class Derived : public Base
{
public:
    Derived (int32 x, int32 y, int32 z) : Base (x),
        derived_member_1 (y),
        derived_member_2 (z) {}
    Derived&amp; operator=(const Derived&amp; rhs)           // Violation
    {
        if (this != &amp;rhs)
        {
            derived_member_1 = rhs.derived_member_1;
            derived_member_2 = rhs.derived_member_2;
        }
        else
        {
        }
        return *this;
    }
private:
    int32 derived_member_1;
    int32 derived_member_2;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned int int32;

class Base
{
public:
    Base (int32 x) : base_member (x) {}
    Base &amp;operator=(const Base&amp; rhs)
    {
        if (this != &amp;rhs)
        {
            base_member = rhs.base_member;
        }
        else
        {
        }
        return *this;
    }
private:
    int32 base_member;
};


class Derived : public Base
{
public:
    Derived (int32 x, int32 y, int32 z) : Base (x),
        derived_member_1 (y),
        derived_member_2 (z) {}
    Derived&amp; operator=(const Derived&amp; rhs)
    {
        if (this != &amp;rhs) // Check for self-assignment
        {
            Base::operator=(rhs);                            // OK
            derived_member_1 = rhs.derived_member_1;
            derived_member_2 = rhs.derived_member_2;
        }
        else
        {
        }
        return *this;
    }
private:
    int32 derived_member_1;
    int32 derived_member_2;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
   第4.10章 类，AV规则第83条

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-44</key>
<configkey>MRM-44</configkey>
<name><![CDATA[ 避免传递自动变量的地址给住调函数空间 [MRM-44] ]]></name>
<tag>mrm</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免传递自动变量的地址给住调函数空间 [MRM-44-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则报告自动变量的地址通过主调函数对分配的区域
进行赋值而传递给函数的违规。

例如：
    void foo( int *a[] )
    {
       int r;
       a[1] = &amp;r;
    }

在上述例子中，局部变量'r'的地址被传递给数组的第
二个元素并传递给了函数'foo'。
这种情况可能会造成在返回的数组中包含一个指向生命
v周期已经结束的变量的指针。
参见：MISRA2004-17_6，OOP-12，OOP-36，MRM-24



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能预防造成代码错误的可能性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int *a[])
{
    int n;
    a[1] = &amp;n;    // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>
n禁止传递自动变量的地址到主调函数空间。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-45</key>
<configkey>MRM-45</configkey>
<name><![CDATA[ 不要在指针类型上使用 sizeof 来指定由 'malloc'，'calloc' 或 'realloc' 函数分配的内存大小 [MRM-45] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在指针类型上使用 sizeof 来指定由 'malloc'，'calloc' 或 'realloc' 函数分配的内存大小 [MRM-45-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则会报告一个违规当有如下函数时：
'malloc', 'calloc', or 'realloc' 用来分配内存并且
所在内存大小的计算是通过指针指向类型而非实际的类型
使用指向类型的指针代替
实际的类型来作为所占内存的大小会使sizeof操作符返回指针的
类型(在32位平台上是4)。
参见: PB-32



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免不正确的内存分配。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;

typedef struct Str
{
   int m1;
   int m2;
}*pS;
   
void foo(int n) 
{
   pS var = (pS) malloc(n * sizeof(pS));  // 违规
   free(var);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;

typedef struct Str
{
   int m1;
   int m2;
}*pS;
   
void foo(int n) 
{
   pS var = (pS) malloc(n * sizeof(Str));  // OK
   free(var);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

2. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-131
   <A HREF="http://cwe.mitre.org/top25/#CWE-131">http://cwe.mitre.org/top25/#CWE-131</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-46</key>
<configkey>MRM-46</configkey>
<name><![CDATA[ 不要使用 calloc, malloc, realloc 和 free 函数 [MRM-46] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用 calloc, malloc, realloc 和 free 函数 [MRM-46-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在C语言中，malloc，realloc和free用来在堆上动态分配内存。
在C++语言中当使用new和delete操作符
可能会导致冲突。"
这条规则不允许在C++中使用calloc，malloc，realloc和free。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免或者降低了下面的风险：
"- 调用delete为每个指向malloc/realloc分配资源的相关指针， 
- 调用malloc/realloc为有构造函数的类对象，
- 调用free使用任何new分配的资源"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;malloc.h&gt;
void foo( ) {
    char* string;
    char* string2;

    string = (char *) malloc( 10 );             /* 违规 */
    string2 = (char*) realloc( string, 12 );    /* 违规 */  
    free( string );                             /* 违规 */
    free( string2 );                            /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用calloc，malloc，realloc和free。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 16 Memory Allocation - Rule 50

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., Chapter: "Shifting from C to C++", Item 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-47</key>
<configkey>MRM-47</configkey>
<name><![CDATA[ 包含至少一个非静态成员变量的类应该声明赋值操作符或包含适当的注释 [MRM-47] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
包含至少一个非静态成员变量的类应该声明赋值操作符或包含适当的注释 [MRM-47-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

包含至少一个非静态成员变量类型的类应该包含
赋值操作符。当编译器关于这部分操作是正确时，
它应该被注释。注释应该包括
字符串"assignment operator"。
参见: CODSTA-CPP-02, CODSTA-CPP-21, CODSTA-CPP-24, MRM-04, MRM-37,
MRM-40, MRM-48, OOP-27, OOP-30, OOP-34



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免偶然使用编译器自动产生的分配符。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A   // 违规
{
private:
    int* ptr;
};

class B   // 违规
{
private:
    int var;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A   // OK
{
public:
	A&amp; operator=(const A&amp;);
private:
    int* ptr;
};

class B   // OK
{
	// 编译器产生的分配符
private:
    int var;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>MRM-48</key>
<configkey>MRM-48</configkey>
<name><![CDATA[ 包含至少一个非静态成员变量的类应该声明拷贝构造函数或包含适当的注释 [MRM-48] ]]></name>
<tag>mrm</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
包含至少一个非静态成员变量的类应该声明拷贝构造函数或包含适当的注释 [MRM-48-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

具有至少一个非静态成员变量的类应该声明
拷贝构造函数。 当编译器生成的拷贝构造函数
的版本的行为是正确的它应该被注释。 注释应该
包含字符串 "拷贝构造函数" 并且检查不敏感。
参见: CODSTA-CPP-19, MRM-05, MRM-38, MRM-40, MRM-47, OOP-27, OOP-30, OOP-34



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止意外使用编译器生成的拷贝构造函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A   // 违规
{
public:
    A();
private:
    int* ptr;
};

class B   // 违规
{
private:
    int var;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A   // OK
{
public:
    A();
    A(const A&amp;);
private:
    int* ptr;
};

class B   // OK
{
	// 编译器生成的拷贝构造函数
private:
    int var;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-01</key>
<configkey>NAMING-HN-01</configkey>
<name><![CDATA[ 应该使用匈牙利命名法的数组变量和参数 [NAMING-HN-01] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该使用匈牙利命名法的数组变量和参数 [NAMING-HN-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

针对数据变量和参数应该使用"rg"前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

const int kiMAX=10;

float fTmp[kiMAX];        // 违规

void foo()
{
    int iTab[10];         // 违规
    int iTab2[kiMAX];     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int kiMAX=10;

float rgfTmp[kiMAX];      // OK

void foo()
{
    int rgiTab[10];       // OK
    int rgiTab2[kiMAX];   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-02</key>
<configkey>NAMING-HN-02</configkey>
<name><![CDATA[ 应该使用匈牙利命名法的布尔类型 [NAMING-HN-02] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应该使用匈牙利命名法的布尔类型 [NAMING-HN-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

布尔变量使用前缀"b".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

bool g_bmyVar;                                  // 违规
bool g_MyVariable;                              // 违规
static const bool g_skMyVariable = true;        // 违规
class A {
    bool m_MyVariable;                          // 违规
    static const bool m_skMyVariable = true;    // 违规
    void foo( bool MyParam ) {                  // 违规
        bool MyVariable;                        // 违规
        static const bool skMyVariable = true;  // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

bool g_bMyVar;                                  // OK
bool g_bMyVariable;                             // OK
static const bool g_skbMyVariable = true;       // OK
class A {
    bool m_bMyVariable;                         // OK
    static const bool m_skbMyVariable = true;   // OK
    void foo( bool bMyParam ) {                 // OK
        bool bMyVariable;                       // OK
        static const bool skbMyVariable = true; // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-03</key>
<configkey>NAMING-HN-03</configkey>
<name><![CDATA[ 布尔型指针、数组或引用类型应使用匈牙利命名法 [NAMING-HN-03] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
布尔型指针、数组或引用类型应使用匈牙利命名法 [NAMING-HN-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

布尔型指针、数组或引用类型应使用前缀"b".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

bool* g_pbmyVar;                                  // 违规
bool* g_pMyVariable;                              // 违规
static const bool* g_spkMyVariable;               // 违规
class A {
    bool* m_pMyVariable;                          // 违规
    static const bool* m_spkMyVariable;           // 违规
    void foo( bool* pMyParam ) {                  // 违规
        bool* pMyVariable;                        // 违规
        static const bool* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

bool* g_pbMyVar;                                  // OK
bool* g_pbMyVariable;                             // OK
static const bool* g_spkbMyVariable;              // OK
class A {
    bool* m_pbMyVariable;                         // OK
    static const bool* m_spkbMyVariable;          // OK
    void foo( bool* pbMyParam ) {                 // OK
        bool* pbMyVariable;                       // OK
        static const bool* spkbMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-04</key>
<configkey>NAMING-HN-04</configkey>
<name><![CDATA[ 字节类型应该使用匈牙利命名法 [NAMING-HN-04] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字节类型应该使用匈牙利命名法 [NAMING-HN-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于unsigned char变量和参数是用前缀"by"或者"y".
对于char或者signed char变量和参数使用前缀"c".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char g_cmyVar;                                  // 违规
char g_MyVariable;                              // 违规
static const char g_skMyVariable = 'a';         // 违规
class A {
    char m_MyVariable;                          // 违规
    static const char m_skMyVariable = 'a';     // 违规
    void foo( char MyParam ) {                  // 违规
        char MyVariable;                        // 违规
        static const char skMyVariable = 'a';   // 违规
    }
};

unsigned char g_bymyVar2;                                // 违规
unsigned char g_MyVariable2;                             // 违规
static const unsigned char g_skMyVariable2 = 0;          // 违规
class B {
    unsigned char m_MyVariable;                          // 违规
    static const unsigned char m_skMyVariable = 0;       // 违规
    void foo( unsigned char MyParam ) {                  // 违规
        unsigned char MyVariable;                        // 违规
        static const unsigned char skMyVariable = 0;     // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char g_cMyVar;                                  // OK
char g_cMyVariable;                             // OK
static const char g_skcMyVariable = 'a';        // OK
class A {
    char m_cMyVariable;                         // OK
    static const char m_skcMyVariable = 'a';    // OK
    void foo( char cMyParam ) {                 // OK
        char cMyVariable;                       // OK
        static const char skcMyVariable = 'a';  // OK
    }
};

unsigned char g_byMyVar2;                                 // OK
unsigned char g_byMyVariable2;                            // OK
static const unsigned char g_skbyMyVariable2 = 0;         // OK
class B {
    unsigned char m_byMyVariable;                         // OK
    static const unsigned char m_skbyMyVariable = 0;      // OK
    void foo( unsigned char byMyParam ) {                 // OK
        unsigned char byMyVariable;                       // OK
        static const unsigned char skbyMyVariable = 0;    // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-05</key>
<configkey>NAMING-HN-05</configkey>
<name><![CDATA[ 字节指针、数组或引用类型应使用匈牙利命名法 [NAMING-HN-05] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字节指针、数组或引用类型应使用匈牙利命名法 [NAMING-HN-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于unsigned char pointer, array, or reference variables and parameters应该使用前缀
"by"或"y". 对于char or signed char pointer, array, or reference 
variables and parameters 应该使用前缀"c".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char* g_pcmyVar;                            // 违规
char* g_pMyVariable;                        // 违规
static const char* g_spkMyVariable;         // 违规
class A {
    char* m_pMyVariable;                    // 违规
    static const char* m_spkMyVariable;     // 违规
    void foo( char* pMyParam ) {            // 违规
        char* pMyVariable;                  // 违规
        static const char* spkMyVariable;   // 违规
    }
};

unsigned char* g_pbymyVar2;                          // 违规
unsigned char* g_pMyVariable2;                       // 违规
static const unsigned char* g_spkMyVariable2;        // 违规
class B {
    unsigned char* m_pMyVariable;                    // 违规
    static const unsigned char* m_spkMyVariable;     // 违规
    void foo( unsigned char* pMyParam ) {            // 违规
        unsigned char* pMyVariable;                  // 违规
        static const unsigned char* spkMyVariable;   // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char* g_pcMyVar;                            // OK
char* g_pcMyVariable;                       // OK
static const char* g_spkcMyVariable;        // OK
class A {
    char* m_pcMyVariable;                   // OK
    static const char* m_spkcMyVariable;    // OK
    void foo( char* pcMyParam ) {           // OK
        char* pcMyVariable;                 // OK
        static const char* spkcMyVariable;  // OK
    }
};

unsigned char* g_pbyMyVar2;                             // OK
unsigned char* g_pbyMyVariable2;                        // OK
static const unsigned char* g_spkbyMyVariable2;         // OK
class B {
    unsigned char* m_pbyMyVariable;                     // OK
    static const unsigned char* m_spkbyMyVariable;      // OK
    void foo( unsigned char* pbyMyParam ) {             // OK
        unsigned char* pbyMyVariable;                   // OK
        static const unsigned char* spkbyMyVariable;    // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-06</key>
<configkey>NAMING-HN-06</configkey>
<name><![CDATA[ 字符(char)类型应该使用匈牙利命名法 [NAMING-HN-06] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符(char)类型应该使用匈牙利命名法 [NAMING-HN-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

char型变量和参数是用前缀"c".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char g_cmyVar;                                  // 违规
char g_MyVariable;                              // 违规
static const char g_skMyVariable = 'a';         // 违规
class A {
    char m_MyVariable;                          // 违规
    static const char m_skMyVariable = 'a';     // 违规
    void foo( char MyParam ) {                  // 违规
        char MyVariable;                        // 违规
        static const char skMyVariable = 'a';   // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char g_cMyVar;                                  // OK
char g_cMyVariable;                             // OK
static const char g_skcMyVariable = 'a';        // OK
class A {
    char m_cMyVariable;                         // OK
    static const char m_skcMyVariable = 'a';    // OK
    void foo( char cMyParam ) {                 // OK
        char cMyVariable;                       // OK
        static const char skcMyVariable = 'a';  // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-07</key>
<configkey>NAMING-HN-07</configkey>
<name><![CDATA[ 字符(char)类型数组应该使用匈牙利命名法 [NAMING-HN-07] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符(char)类型数组应该使用匈牙利命名法 [NAMING-HN-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于一些老式空字符串结尾的变量或者参数使用前缀"sz".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char g_szmyVar[1];                                 // 违规
char g_MyVariable[1];                              // 违规
static const char g_skMyVariable[1] = {0};         // 违规
class B {
    char m_MyVariable[1];                          // 违规
    static const char m_skMyVariable[1];           // 违规
    void foo( char MyParam[1] ) {                  // 违规
        char MyVariable[1];                        // 违规
        static const char skMyVariable[1] = {0};   // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char g_szMyVar[1];                                  // OK
char g_szMyVariable[1];                             // OK
static const char g_skszMyVariable[1] = {0};        // OK
class A {
    char m_szMyVariable[1];                         // OK
    static const char m_skszMyVariable[1];          // OK
    void foo( char szMyParam[1] ) {                 // OK
        char szMyVariable[1];                       // OK
        static const char skszMyVariable[1] = {0};  // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-08</key>
<configkey>NAMING-HN-08</configkey>
<name><![CDATA[ 指针，数组或字符(char)类型数组的引用应该使用匈牙利命名法 [NAMING-HN-08] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指针，数组或字符(char)类型数组的引用应该使用匈牙利命名法 [NAMING-HN-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

指针，数组或字符(char)类型数组的引用的变量和参数应该
使用前缀"sz".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char (*g_pszmyVar)[1];                                 // 违规
char (*g_pMyVariable)[1];                              // 违规
static const char (*g_spkMyVariable)[1];               // 违规
class B {
    char (*m_pMyVariable)[1];                          // 违规
    static const char (*m_spkMyVariable)[1];           // 违规
    void foo( char (*pMyParam)[1] ) {                  // 违规
        char (*pMyVariable)[1];                        // 违规
        static const char (*spkMyVariable)[1];         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char (*g_pszMyVar)[1];                                  // OK
char (*g_pszMyVariable)[1];                             // OK
static const char (*g_spkszMyVariable)[1];              // OK
class A {
    char (*m_pszMyVariable)[1];                         // OK
    static const char (*m_spkszMyVariable)[1];          // OK
    void foo( char (*pszMyParam)[1] ) {                 // OK
        char (*pszMyVariable)[1];                       // OK
        static const char (*spkszMyVariable)[1];        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-09</key>
<configkey>NAMING-HN-09</configkey>
<name><![CDATA[ 字符(char)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-09] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符(char)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

针对指针、数组、引用类型的变量或参数使用前缀"c".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char* g_pcmyVar;                                  // 违规
char* g_pMyVariable;                              // 违规
static const char* g_spkMyVariable;               // 违规
class B {
    char* m_pMyVariable;                          // 违规
    static const char* m_spkMyVariable;           // 违规
    void foo( char* pMyParam ) {                  // 违规
        char* pMyVariable;                        // 违规
        static const char* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char* g_pcMyVar;                                  // OK
char* g_pcMyVariable;                             // OK
static const char* g_spkcMyVariable;              // OK
class A {
    char* m_pcMyVariable;                         // OK
    static const char* m_spkcMyVariable;          // OK
    void foo( char* pcMyParam ) {                 // OK
        char* pcMyVariable;                       // OK
        static const char* spkcMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-10</key>
<configkey>NAMING-HN-10</configkey>
<name><![CDATA[ 字符(char)指针或引用类型应该使用匈牙利命名法 [NAMING-HN-10] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符(char)指针或引用类型应该使用匈牙利命名法 [NAMING-HN-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

针对指针型或者引用型的变量或参数使用前缀"c".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

char* g_cmyVar;                                  // 违规
char* g_MyVariable;                              // 违规
static const char* g_skMyVariable;               // 违规
class A {
    char* m_MyVariable;                          // 违规
    static const char* m_skMyVariable;           // 违规
    void foo( char* MyParam ) {                  // 违规
        char* MyVariable;                        // 违规
        static const char* skMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

char* g_cMyVar;                                  // OK
char* g_cMyVariable;                             // OK
static const char* g_skcMyVariable;              // OK
class A {
    char* m_cMyVariable;                         // OK
    static const char* m_skcMyVariable;          // OK
    void foo( char* cMyParam ) {                 // OK
        char* cMyVariable;                       // OK
        static const char* skcMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-11</key>
<configkey>NAMING-HN-11</configkey>
<name><![CDATA[ 常量参数应该使用匈牙利命名法 [NAMING-HN-11] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
常量参数应该使用匈牙利命名法 [NAMING-HN-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

constant参数应该使用前缀"k".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( const unsigned char ucLabel )      // 违规
{
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( const unsigned char kucLabel )     // OK
{
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-12</key>
<configkey>NAMING-HN-12</configkey>
<name><![CDATA[ 双精度浮点类型应该使用匈牙利命名法 [NAMING-HN-12] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
双精度浮点类型应该使用匈牙利命名法 [NAMING-HN-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

双精度浮点类型应该使用前缀"d".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

double g_dmyVar;                                  // 违规
double g_MyVariable;                              // 违规
static const double g_skMyVariable = 0.0;         // 违规
class B {
    double m_MyVariable;                          // 违规
    static const double m_skMyVariable;           // 违规
    void foo( double MyParam ) {                  // 违规
        double MyVariable;                        // 违规
        static const double skMyVariable = 0.0;   // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

double g_dMyVar;                                  // OK
double g_dMyVariable;                             // OK
static const double g_skdMyVariable = 0.0;        // OK
class A {
    double m_dMyVariable;                         // OK
    static const double m_skdMyVariable;          // OK
    void foo( double dMyParam ) {                 // OK
        double dMyVariable;                       // OK
        static const double skdMyVariable = 0.0;  // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-13</key>
<configkey>NAMING-HN-13</configkey>
<name><![CDATA[ 双精度浮点指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-13] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
双精度浮点指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

双精度浮点指针，数组或引用类型应该
使用前缀"d".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

double* g_pdmyVar;                                  // 违规
double* g_pMyVariable;                              // 违规
static const double* g_spkMyVariable;               // 违规
class B {
    double* m_pMyVariable;                          // 违规
    static const double* m_spkMyVariable;           // 违规
    void foo( double* pMyParam ) {                  // 违规
        double* pMyVariable;                        // 违规
        static const double* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

double* g_pdMyVar;                                  // OK
double* g_pdMyVariable;                             // OK
static const double* g_spkdMyVariable;              // OK
class A {
    double* m_pdMyVariable;                         // OK
    static const double* m_spkdMyVariable;          // OK
    void foo( double* pdMyParam ) {                 // OK
        double* pdMyVariable;                       // OK
        static const double* spkdMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-14</key>
<configkey>NAMING-HN-14</configkey>
<name><![CDATA[ 双字(dword)类型应该使用匈牙利命名法 [NAMING-HN-14] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
双字(dword)类型应该使用匈牙利命名法 [NAMING-HN-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于unsigned long int变量和参数使用前缀"dw".
对于signed long int或 long int变量和参数使用前缀"li".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

long g_limyVar;                                 // 违规
long g_MyVariable;                              // 违规
static const long g_skMyVariable = 0;           // 违规
class A {
    long m_MyVariable;                          // 违规
    static const long m_skMyVariable;           // 违规
    void foo( long MyParam ) {                  // 违规
        long MyVariable;                        // 违规
        static const long skMyVariable = 0;     // 违规
    }
};

unsigned long g_dwmyVar2;                                // 违规
unsigned long g_MyVariable2;                             // 违规
static const unsigned long g_skMyVariable2 = 0;          // 违规
class B {
    unsigned long m_MyVariable;                          // 违规
    static const unsigned long m_skMyVariable;           // 违规
    void foo( unsigned long MyParam ) {                  // 违规
        unsigned long MyVariable;                        // 违规
        static const unsigned long skMyVariable = 0;     // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

long g_liMyVar;                                 // OK
long g_liMyVariable;                            // OK
static const long g_skliMyVariable = 0;         // OK
class A {
    long m_liMyVariable;                        // OK
    static const long m_skliMyVariable;         // OK
    void foo( long liMyParam ) {                // OK
        long liMyVariable;                      // OK
        static const long skliMyVariable = 0;   // OK
    }
};

unsigned long g_dwMyVar2;                                // OK
unsigned long g_dwMyVariable2;                           // OK
static const unsigned long g_skdwMyVariable2 = 0;        // OK
class B {
    unsigned long m_dwMyVariable;                        // OK
    static const unsigned long m_skdwMyVariable;         // OK
    void foo( unsigned long dwMyParam ) {                // OK
        unsigned long dwMyVariable;                      // OK
        static const unsigned long skdwMyVariable = 0;   // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-15</key>
<configkey>NAMING-HN-15</configkey>
<name><![CDATA[ 双字(dword)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-15] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
双字(dword)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对于unsigned long int型指针，数组或引用类型的变量和参数应该使用前缀
"dw".对于signed long int或long int型指针,数组或引用类型的
的变量和参数应该使用前缀"li".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

long* g_plimyVar;                                   // 违规
long* g_pMyVariable;                                // 违规
static const long* g_spkMyVariable;                 // 违规
class A {
    long* m_pMyVariable;                            // 违规
    static const long* m_spkMyVariable;             // 违规
    void foo( long* pMyParam ) {                    // 违规
        long* pMyVariable;                          // 违规
        static const long* spkMyVariable;           // 违规
    }
};

unsigned long* g_pdwmyVar2;                         // 违规
unsigned long* g_pMyVariable2;                      // 违规
static const unsigned long* g_spkMyVariable2;       // 违规
class B {
    unsigned long* m_pMyVariable;                   // 违规
    static const unsigned long* m_spkMyVariable;    // 违规
    void foo( unsigned long* pMyParam ) {           // 违规
        unsigned long* pMyVariable;                 // 违规
        static const unsigned long* spkMyVariable;  // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

long* g_pliMyVar;                                      // OK
long* g_pliMyVariable;                                 // OK
static const long* g_spkliMyVariable;                  // OK
class A {
    long* m_pliMyVariable;                             // OK
    static const long* m_spkliMyVariable;              // OK
    void foo( long* pliMyParam ) {                     // OK
        long* pliMyVariable;                           // OK
        static const long* spkliMyVariable;            // OK
    }
};

unsigned long* g_pdwMyVar2;                            // OK
unsigned long* g_pdwMyVariable2;                       // OK
static const unsigned long* g_spkdwMyVariable2;        // OK
class B {
    unsigned long* m_pdwMyVariable;                    // OK
    static const unsigned long* m_spkdwMyVariable;     // OK
    void foo( unsigned long* pdwMyParam ) {            // OK
        unsigned long* pdwMyVariable;                  // OK
        static const unsigned long* spkdwMyVariable;   // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-16</key>
<configkey>NAMING-HN-16</configkey>
<name><![CDATA[ 动态分配的数组应该使用匈牙利命名法 [NAMING-HN-16] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
动态分配的数组应该使用匈牙利命名法 [NAMING-HN-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

动态分配数组应使用 "prg" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

const int kiMAX=10;

int *iGrade = new int [kiMAX];           // 违规

void foo()
{
	int *p=new int;
	int *iNote = new int[kiMAX];     // 违规
	int *iMark;                      // 违规
	iMark = new int[10];         
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int kiMAX=10;

int *prgiGrade = new int [kiMAX];        // OK

void foo()
{
	int *p=new int;
	int *prgiNote = new int[kiMAX];  // OK
	int *prgiMark;                   // OK
	prgiMark = new int[10];         
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-17</key>
<configkey>NAMING-HN-17</configkey>
<name><![CDATA[ 浮点类型应该使用匈牙利命名法 [NAMING-HN-17] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
浮点类型应该使用匈牙利命名法 [NAMING-HN-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

浮动指针变量和参数使用 "f" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

float g_fmyVar;                                  // 违规
float g_MyVariable;                              // 违规
static const float g_skMyVariable = 0.0;         // 违规
class B {
    float m_MyVariable;                          // 违规
    static const float m_skMyVariable;           // 违规
    void foo( float MyParam ) {                  // 违规
        float MyVariable;                        // 违规
        static const float skMyVariable = 0.0;   // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

float g_fMyVar;                                  // OK
float g_fMyVariable;                             // OK
static const float g_skfMyVariable = 0.0;        // OK
class A {
    float m_fMyVariable;                         // OK
    static const float m_skfMyVariable;          // OK
    void foo( float fMyParam ) {                 // OK
        float fMyVariable;                       // OK
        static const float skfMyVariable = 0.0;  // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-18</key>
<configkey>NAMING-HN-18</configkey>
<name><![CDATA[ 浮点指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-18] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
浮点指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

浮动指针, 数组, 或者引用 
变量和参数使用 "f" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

float* g_pfmyVar;                                  // 违规
float* g_pMyVariable;                              // 违规
static const float* g_spkMyVariable;               // 违规
class B {
    float* m_pMyVariable;                          // 违规
    static const float* m_spkMyVariable;           // 违规
    void foo( float* pMyParam ) {                  // 违规
        float* pMyVariable;                        // 违规
        static const float* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

float* g_pfMyVar;                                  // OK
float* g_pfMyVariable;                             // OK
static const float* g_spkfMyVariable;              // OK
class A {
    float* m_pfMyVariable;                         // OK
    static const float* m_spkfMyVariable;          // OK
    void foo( float* pfMyParam ) {                 // OK
        float* pfMyVariable;                       // OK
        static const float* spkfMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-19</key>
<configkey>NAMING-HN-19</configkey>
<name><![CDATA[ 类声明应该使用匈牙利命名法 [NAMING-HN-19] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类声明应该使用匈牙利命名法 [NAMING-HN-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类声明使用 "C" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Figure  // 违规
{
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class CFigure  // OK
{
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-20</key>
<configkey>NAMING-HN-20</configkey>
<name><![CDATA[ 结构体的声明应该使用匈牙利命名法 [NAMING-HN-20] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构体的声明应该使用匈牙利命名法 [NAMING-HN-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

结构体声明使用 "S" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性 .



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct Figure  // 违规
{
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct SFigure  // OK
{
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-21</key>
<configkey>NAMING-HN-21</configkey>
<name><![CDATA[ ifstream 类型的变量和参数应该使用匈牙利命名法 [NAMING-HN-21] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
ifstream 类型的变量和参数应该使用匈牙利命名法 [NAMING-HN-21-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

ifstream 类型变量和参数使用 "if" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高易读性和和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;fstream&gt;
using namespace std;

ifstream NameFile;          // 违规

void foo( ) {
    ifstream Filename;      // 违规
    ifstream *pFilename;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;fstream&gt;
using namespace std;

ifstream ifNameFile;        // OK 

void foo( ) {
    ifstream ifFilename;    // OK
    ifstream *pifFilename;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-22</key>
<configkey>NAMING-HN-22</configkey>
<name><![CDATA[ 整数(int)类型应该使用匈牙利命名法 [NAMING-HN-22] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整数(int)类型应该使用匈牙利命名法 [NAMING-HN-22-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

整型变量和参数使用 "i" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int g_imyVar;                                  // 违规
int g_MyVariable;                              // 违规
static const int g_skMyVariable = 0;           // 违规
class A {
    int m_MyVariable;                          // 违规
    static const int m_skMyVariable;           // 违规
    void foo( int MyParam ) {                  // 违规
        int MyVariable;                        // 违规
        static const int skMyVariable = 0;     // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int g_iMyVar;                                 // OK
int g_iMyVariable;                            // OK
static const int g_skiMyVariable = 0;         // OK
class A {
    int m_iMyVariable;                        // OK
    static const int m_skiMyVariable;         // OK
    void foo( int iMyParam ) {                // OK
        int iMyVariable;                      // OK
        static const int skiMyVariable = 0;   // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-23</key>
<configkey>NAMING-HN-23</configkey>
<name><![CDATA[ 整数(int)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-23] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整数(int)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-23-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

整型指针,数组,引用变量和参数使用 "i" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* g_pimyVar;                                  // 违规
int* g_pMyVariable;                              // 违规
static const int* g_spkMyVariable;               // 违规
class A {
    int* m_pMyVariable;                          // 违规
    static const int* m_spkMyVariable;           // 违规
    void foo( int* pMyParam ) {                  // 违规
        int* pMyVariable;                        // 违规
        static const int* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int* g_piMyVar;                                 // OK
int* g_piMyVariable;                            // OK
static const int* g_spkiMyVariable;             // OK
class A {
    int* m_piMyVariable;                        // OK
    static const int* m_spkiMyVariable;         // OK
    void foo( int* piMyParam ) {                // OK
        int* piMyVariable;                      // OK
        static const int* spkiMyVariable;       // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-24</key>
<configkey>NAMING-HN-24</configkey>
<name><![CDATA[ istream 类型的参数和变量应该使用匈牙利命名法 [NAMING-HN-24] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
istream 类型的参数和变量应该使用匈牙利命名法 [NAMING-HN-24-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

istream 类型参数和变量使用 "is" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;istream&gt;
using namespace std;

void foo( istream &amp;rIn )    // 违规
{
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;istream&gt;
using namespace std;

void foo( istream &amp;risIn )    // OK 
{
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-25</key>
<configkey>NAMING-HN-25</configkey>
<name><![CDATA[ 长整型应该使用匈牙利命名法 [NAMING-HN-25] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
长整型应该使用匈牙利命名法 [NAMING-HN-25-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

长整型变量和参数使用 "li" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

long int g_limyVar;                                 // 违规
long int g_MyVariable;                              // 违规
static const long int g_skMyVariable = 0;           // 违规
class B {
    long int m_MyVariable;                          // 违规
    static const long int m_skMyVariable;           // 违规
    void foo( long int MyParam ) {                  // 违规
        long int MyVariable;                        // 违规
        static const long int skMyVariable = 0;     // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

long int g_liMyVar;                                 // OK
long int g_liMyVariable;                            // OK
static const long int g_skliMyVariable = 0;         // OK
class A {
    long int m_liMyVariable;                        // OK
    static const long int m_skliMyVariable;         // OK
    void foo( long int liMyParam ) {                // OK
        long int liMyVariable;                      // OK
        static const long int skliMyVariable = 0;   // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-26</key>
<configkey>NAMING-HN-26</configkey>
<name><![CDATA[ 长双精度浮点类型应该使用匈牙利命名法 [NAMING-HN-26] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
长双精度浮点类型应该使用匈牙利命名法 [NAMING-HN-26-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

长双精度浮点指针 
变量和参数使用 "ld" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

long double g_ldmyVar;                                 // 违规
long double g_MyVariable;                              // 违规
static const long double g_skMyVariable = 0.0;         // 违规
class B {
    long double m_MyVariable;                          // 违规
    static const long double m_skMyVariable;           // 违规
    void foo( long double MyParam ) {                  // 违规
        long double MyVariable;                        // 违规
        static const long double skMyVariable = 0.0;   // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

long double g_ldMyVar;                                  // OK
long double g_ldMyVariable;                             // OK
static const long double g_skldMyVariable = 0.0;        // OK
class A {
    long double m_ldMyVariable;                         // OK
    static const long double m_skldMyVariable;          // OK
    void foo( long double ldMyParam ) {                 // OK
        long double ldMyVariable;                       // OK
        static const long double skldMyVariable = 0.0;  // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-27</key>
<configkey>NAMING-HN-27</configkey>
<name><![CDATA[ 长双精度浮点指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-27] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
长双精度浮点指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

长双精度浮点指针, 数组,
或者引用变量和参数使用 "ld" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提供可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

long double* g_pldmyVar;                                 // 违规
long double* g_pMyVariable;                              // 违规
static const long double* g_spkMyVariable;               // 违规
class B {
    long double* m_pMyVariable;                          // 违规
    static const long double* m_spkMyVariable;           // 违规
    void foo( long double* pMyParam ) {                  // 违规
        long double* pMyVariable;                        // 违规
        static const long double* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

long double* g_pldMyVar;                                  // OK
long double* g_pldMyVariable;                             // OK
static const long double* g_spkldMyVariable;              // OK
class A {
    long double* m_pldMyVariable;                         // OK
    static const long double* m_spkldMyVariable;          // OK
    void foo( long double* pldMyParam ) {                 // OK
        long double* pldMyVariable;                       // OK
        static const long double* spkldMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-28</key>
<configkey>NAMING-HN-28</configkey>
<name><![CDATA[ 长整型指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-28] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
长整型指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

长整型指针, 数组, 引用 
变量和参数使用 "li" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

long int* g_plimyVar;                                 // 违规
long int* g_pMyVariable;                              // 违规
static const long int* g_spkMyVariable;               // 违规
class B {
    long int* m_pMyVariable;                          // 违规
    static const long int* m_spkMyVariable;           // 违规
    void foo( long int* pMyParam ) {                  // 违规
        long int* pMyVariable;                        // 违规
        static const long int* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

long int* g_pliMyVar;                                 // OK
long int* g_pliMyVariable;                            // OK
static const long int* g_spkliMyVariable;             // OK
class A {
    long int* m_pliMyVariable;                        // OK
    static const long int* m_spkliMyVariable;         // OK
    void foo( long int* pliMyParam ) {                // OK
        long int* pliMyVariable;                      // OK
        static const long int* spkliMyVariable;       // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-29</key>
<configkey>NAMING-HN-29</configkey>
<name><![CDATA[ 成员变量应该使用匈牙利命名法 [NAMING-HN-29] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
成员变量应该使用匈牙利命名法 [NAMING-HN-29-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

成员变量使用 "m_" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可维护性和可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class CSample
{
    int iSize;     // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class CSample
{
    int m_iSize;   // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-30</key>
<configkey>NAMING-HN-30</configkey>
<name><![CDATA[ 整数(int)类型应该使用匈牙利命名法 [NAMING-HN-30] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整数(int)类型应该使用匈牙利命名法 [NAMING-HN-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

整型变量和参数使用 "n" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int g_nmyVar;                                  // 违规
int g_MyVariable;                              // 违规
static const int g_skMyVariable = 0;           // 违规
class A {
    int m_MyVariable;                          // 违规
    static const int m_skMyVariable;           // 违规
    void foo( int MyParam ) {                  // 违规
        int MyVariable;                        // 违规
        static const int skMyVariable = 0;     // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int g_nMyVar;                                 // OK
int g_nMyVariable;                            // OK
static const int g_sknMyVariable = 0;         // OK
class A {
    int m_nMyVariable;                        // OK
    static const int m_sknMyVariable;         // OK
    void foo( int nMyParam ) {                // OK
        int nMyVariable;                      // OK
        static const int sknMyVariable = 0;   // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-31</key>
<configkey>NAMING-HN-31</configkey>
<name><![CDATA[ 整型(int)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-31] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型(int)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

整型指针, 数组, 或者引用变量和参数使用 "n" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* g_pnmyVar;                                  // 违规
int* g_pMyVariable;                              // 违规
static const int* g_spkMyVariable;               // 违规
class A {
    int* m_pMyVariable;                          // 违规
    static const int* m_spkMyVariable;           // 违规
    void foo( int* pMyParam ) {                  // 违规
        int* pMyVariable;                        // 违规
        static const int* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int* g_pnMyVar;                                 // OK
int* g_pnMyVariable;                            // OK
static const int* g_spknMyVariable;             // OK
class A {
    int* m_pnMyVariable;                        // OK
    static const int* m_spknMyVariable;         // OK
    void foo( int* pnMyParam ) {                // OK
        int* pnMyVariable;                      // OK
        static const int* spknMyVariable;       // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-32</key>
<configkey>NAMING-HN-32</configkey>
<name><![CDATA[ ofstream 类型的参数和变量应该使用匈牙利命名法 [NAMING-HN-32] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
ofstream 类型的参数和变量应该使用匈牙利命名法 [NAMING-HN-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

ofstream 类型参数和变量使用 "of" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;fstream&gt;
using namespace std;

ofstream NameFile;          // 违规

void foo( ofstream &amp;rIn ) { // 违规
    ofstream Filename;      // 违规
    ofstream *pFilename;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;fstream&gt;
using namespace std;

ofstream ofNameFile;        // OK

void foo( ofstream &amp;rofIn ) { // OK
    ofstream ofFilename;    // OK
    ofstream *pofFilename;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-33</key>
<configkey>NAMING-HN-33</configkey>
<name><![CDATA[ ostream 类型的参数和变量应该使用匈牙利命名法 [NAMING-HN-33] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
ostream 类型的参数和变量应该使用匈牙利命名法 [NAMING-HN-33-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

ostream 类型参数和变量使用  "os" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;fstream&gt;
using namespace std;

void foo(ostream &amp;rOut)         // 违规
{
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;fstream&gt;
using namespace std;

void foo(ostream &amp;rosOut)      // OK
{
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-34</key>
<configkey>NAMING-HN-34</configkey>
<name><![CDATA[ 指针应该使用匈牙利命名法 [NAMING-HN-34] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指针应该使用匈牙利命名法 [NAMING-HN-34-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

指针使用 "p" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提供可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

const int kiMAX=10;

int *iGrade;                     // 违规

void foo()
{
    int *iMark;                  // 违规
    char * cLetter = 0;          // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int kiMAX=10;

int *piGrade;                    // OK

void foo()
{
    int *piMark;                 // OK
    char * pcLetter = 0;         // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-35</key>
<configkey>NAMING-HN-35</configkey>
<name><![CDATA[ 引用参数应该使用匈牙利命名法 [NAMING-HN-35] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
引用参数应该使用匈牙利命名法 [NAMING-HN-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

引用参数使用 "r" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(const unsigned char &amp;kucLabel)      // 违规
{
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(const unsigned char &amp;rkucLabel)    // OK
{
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-36</key>
<configkey>NAMING-HN-36</configkey>
<name><![CDATA[ 短整型应该使用匈牙利命名法 [NAMING-HN-36] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
短整型应该使用匈牙利命名法 [NAMING-HN-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

短整型变量和参数使用 "si" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可独行和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

short int g_simyVar;                                 // 违规
short int g_MyVariable;                              // 违规
static const short int g_skMyVariable = 0;           // 违规
class B {
    short int m_MyVariable;                          // 违规
    static const short int m_skMyVariable;           // 违规
    void foo( short int MyParam ) {                  // 违规
        short int MyVariable;                        // 违规
        static const short int skMyVariable = 0;     // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

short int g_siMyVar;                                 // OK
short int g_siMyVariable;                            // OK
static const short int g_sksiMyVariable = 0;         // OK
class A {
    short int m_siMyVariable;                        // OK
    static const short int m_sksiMyVariable;         // OK
    void foo( short int siMyParam ) {                // OK
        short int siMyVariable;                      // OK
        static const short int sksiMyVariable = 0;   // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-37</key>
<configkey>NAMING-HN-37</configkey>
<name><![CDATA[ 短整型指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-37] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
短整型指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-37-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

短整型指针, 数组, 或者引用 
变量和参数使用 "si" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

short int* g_psimyVar;                                 // 违规
short int* g_pMyVariable;                              // 违规
static const short int* g_spkMyVariable;               // 违规
class B {
    short int* m_pMyVariable;                          // 违规
    static const short int* m_spkMyVariable;           // 违规
    void foo( short int* pMyParam ) {                  // 违规
        short int* pMyVariable;                        // 违规
        static const short int* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

short int* g_psiMyVar;                                 // OK
short int* g_psiMyVariable;                            // OK
static const short int* g_spksiMyVariable;             // OK
class A {
    short int* m_psiMyVariable;                        // OK
    static const short int* m_spksiMyVariable;         // OK
    void foo( short int* psiMyParam ) {                // OK
        short int* psiMyVariable;                      // OK
        static const short int* spksiMyVariable;       // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-38</key>
<configkey>NAMING-HN-38</configkey>
<name><![CDATA[ 静态变量应该使用匈牙利命名法 [NAMING-HN-38] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
静态变量应该使用匈牙利命名法 [NAMING-HN-38-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

静态变量使用 "s" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static int g_iMark;   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static int g_siMark;   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-39</key>
<configkey>NAMING-HN-39</configkey>
<name><![CDATA[ 字符串类型应该使用匈牙利命名法 [NAMING-HN-39] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符串类型应该使用匈牙利命名法 [NAMING-HN-39-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

字符变量和参数使用 "str" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

string g_strmyVar;                                // 违规
string g_MyVariable;                              // 违规
static const string g_skMyVariable;               // 违规
class A {
    string m_MyVariable;                          // 违规
    static const string m_skMyVariable;           // 违规
    void foo( string MyParam ) {                  // 违规
        string MyVariable;                        // 违规
        static const string skMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

string g_strMyVar;                                  // OK
string g_strMyVariable;                             // OK
static const string g_skstrMyVariable;              // OK
class A {
    string m_strMyVariable;                         // OK
    static const string m_skstrMyVariable;          // OK
    void foo( string strMyParam ) {                 // OK
        string strMyVariable;                       // OK
        static const string skstrMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-40</key>
<configkey>NAMING-HN-40</configkey>
<name><![CDATA[ 字符串指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-40] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符串指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-40-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

字符串指针, array, 引用
变量和参数使用 "str" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

string* g_pstrmyVar;                                // 违规
string* g_pMyVariable;                              // 违规
static const string* g_spkMyVariable;               // 违规
class A {
    string* m_pMyVariable;                          // 违规
    static const string* m_spkMyVariable;           // 违规
    void foo( string* pMyParam ) {                  // 违规
        string* pMyVariable;                        // 违规
        static const string* spkMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

string* g_pstrMyVar;                                  // OK
string* g_pstrMyVariable;                             // OK
static const string* g_spkstrMyVariable;              // OK
class A {
    string* m_pstrMyVariable;                         // OK
    static const string* m_spkstrMyVariable;          // OK
    void foo( string* pstrMyParam ) {                 // OK
        string* pstrMyVariable;                       // OK
        static const string* spkstrMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-41</key>
<configkey>NAMING-HN-41</configkey>
<name><![CDATA[ 无符号类型应该使用匈牙利命名法 [NAMING-HN-41] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
无符号类型应该使用匈牙利命名法 [NAMING-HN-41-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

无符号类型使用 "u" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

unsigned int g_iSize;            // 违规

void foo(unsigned char cLabel)   // 违规
{
    unsigned short siStudents;   // 违规
}

class CSample
{
    unsigned int m_iStudent;     // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

unsigned int g_uiSize;           // OK

void foo(unsigned char ucLabel)  // OK
{
    unsigned short usiStudents;  // OK
}

class CSample
{
    unsigned int m_uiStudent;    // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-42</key>
<configkey>NAMING-HN-42</configkey>
<name><![CDATA[ void 指针类型应该使用匈牙利命名法 [NAMING-HN-42] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
void 指针类型应该使用匈牙利命名法 [NAMING-HN-42-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

空指针变量和参数使用 "v" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void* g_pvmy;                                     // 违规
void* g_pMyVariable;                              // 违规
static const void* g_skpMyVariable;               // 违规
class A {
    void* m_pMyVariable;                          // 违规
    static const void* m_skpMyVariable;           // 违规
    void foo( void* pMyParam ) {                  // 违规
        void* pMyVariable;                        // 违规
        static const void* skpMyVariable;         // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void* g_pvMyV;                                    // OK
void* g_pvMyVariable;                             // OK
static const void* g_skpvMyVariable;              // OK
class A {
    void* m_pvMyVariable;                         // OK
    static const void* m_skpvMyVariable;          // OK
    void foo( void* pvMyParam ) {                 // OK
        void* pvMyVariable;                       // OK
        static const void* skpvMyVariable;        // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-43</key>
<configkey>NAMING-HN-43</configkey>
<name><![CDATA[ 字(word)类型匈牙利命名法 [NAMING-HN-43] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字(word)类型匈牙利命名法 [NAMING-HN-43-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

无符号整型变量和参数使用 "w" 前缀.
有符号整型或整型变量和参数使用 "i" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int g_imyVar;                                  // 违规
int g_MyVariable;                              // 违规
static const int g_skMyVariable = 0;           // 违规
class A {
    int m_MyVariable;                          // 违规
    static const int m_skMyVariable;           // 违规
    void foo( int MyParam ) {                  // 违规
        int MyVariable;                        // 违规
        static const int skMyVariable = 0;     // 违规
    }
};

unsigned int g_wmyVar2;                                 // 违规
unsigned int g_MyVariable2;                             // 违规
static const unsigned int g_skMyVariable2 = 0;          // 违规
class B {
    unsigned int m_MyVariable;                          // 违规
    static const unsigned int m_skMyVariable;           // 违规
    void foo( unsigned int MyParam ) {                  // 违规
        unsigned int MyVariable;                        // 违规
        static const unsigned int skMyVariable = 0;     // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int g_iMyVar;                                 // OK
int g_iMyVariable;                            // OK
static const int g_skiMyVariable = 0;         // OK
class A {
    int m_iMyVariable;                        // OK
    static const int m_skiMyVariable;         // OK
    void foo( int iMyParam ) {                // OK
        int iMyVariable;                      // OK
        static const int skiMyVariable = 0;   // OK
    }
};

unsigned int g_wMyVar2;                                // OK
unsigned int g_wMyVariable2;                           // OK
static const unsigned int g_skwMyVariable2 = 0;        // OK
class B {
    unsigned int m_wMyVariable;                        // OK
    static const unsigned int m_skwMyVariable;         // OK
    void foo( unsigned int wMyParam ) {                // OK
        unsigned int wMyVariable;                      // OK
        static const unsigned int skwMyVariable = 0;   // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-HN-44</key>
<configkey>NAMING-HN-44</configkey>
<name><![CDATA[ 字(word)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-44] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字(word)指针，数组或引用类型应该使用匈牙利命名法 [NAMING-HN-44-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

无符号整型指针, 数组, 或者引用变量和参数使用
"w" 前缀. 有符号整型或者整型指针, array, 引用变量
和参数使用 "i" 前缀.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* g_pimyVar;                                   // 违规
int* g_pMyVariable;                              // 违规
static const int* g_spkMyVariable;         // 违规
class A {
    int* m_pMyVariable;                         // 违规
    static const int* m_spkMyVariable;    // 违规
    void foo( int* pMyParam ) {              // 违规
        int* pMyVariable;                         // 违规
        static const int* spkMyVariable;    // 违规
    }
};

unsigned int* g_pwmyVar2;                                 // 违规
unsigned int* g_pMyVariable2;                             // 违规
static const unsigned int* g_spkMyVariable2;        // 违规
class B {
    unsigned int* m_pMyVariable;                          // 违规
    static const unsigned int* m_spkMyVariable;      // 违规
    void foo( unsigned int* pMyParam ) {                // 违规
        unsigned int* pMyVariable;                           // 违规
        static const unsigned int* spkMyVariable;      // 违规
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int* g_piMyVar;                                  // OK
int* g_piMyVariable;                            // OK
static const int* g_spkiMyVariable;       // OK
class A {
    int* m_piMyVariable;                        // OK
    static const int* m_spkiMyVariable;   // OK
    void foo( int* piMyParam ) {             // OK
        int* piMyVariable;                        // OK
        static const int* spkiMyVariable;   // OK
    }
};

unsigned int* g_pwMyVar2;                                // OK
unsigned int* g_pwMyVariable2;                          // OK
static const unsigned int* g_spkwMyVariable2;      // OK
class B {
    unsigned int* m_pwMyVariable;                        // OK
    static const unsigned int* m_spkwMyVariable;   // OK
    void foo( unsigned int* pwMyParam ) {             // OK
        unsigned int* pwMyVariable;                        // OK
        static const unsigned int* spkwMyVariable;   // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://web.mst.edu/~cpp/common/hungarian.html">http://web.mst.edu/~cpp/common/hungarian.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-01</key>
<configkey>NAMING-01</configkey>
<name><![CDATA[ 所有使用 "#define" 定义的常量必须使用大写 [NAMING-01] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有使用 "#define" 定义的常量必须使用大写 [NAMING-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查所有 "#define" 常量都是大写的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这个规范会更容易识别常量
并支持未来的维护工作。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define max_value 255 // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MAX_VALUE 255 // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-02</key>
<configkey>NAMING-02</configkey>
<name><![CDATA[ 在枚举型列表中，列表内的成员应该为大写而列表的名字或标签应该为小写 [NAMING-02] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在枚举型列表中，列表内的成员应该为大写而列表的名字或标签应该为小写 [NAMING-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在枚举列表中，列表成员(元素)应大写。
列表名称或标签应该小写。 列表中的成员
相对于常量，只有编译器会做定义。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

因为枚举成员都相当于一个定义的产量， 
允许继续使用常量的命名规范.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum Color {    // 违规
    red,        // 违规
    blue,       // 违规
    green       // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum color {    // OK
    RED,        // OK
    BLUE,       // OK
    GREEN       // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards R-18

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-03</key>
<configkey>NAMING-03</configkey>
<name><![CDATA[ 文件名应使用小写字母 [NAMING-03] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
文件名应使用小写字母 [NAMING-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

文件名应该使用小写字母。 
文件名小写应始终贯穿整个开发过程。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以确定标准文件名。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// filename: Test.c   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// filename: test.c   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Motorola Coding Standards G-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-04</key>
<configkey>NAMING-04</configkey>
<name><![CDATA[ 带有全局前缀的名字仅能用作全局变量 [NAMING-04] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
带有全局前缀的名字仅能用作全局变量 [NAMING-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对局部变量使用全局前缀会对代码的可读性受阻。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使代码更清晰。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{  
    int theVar = 0; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int theVar = 0; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-05</key>
<configkey>NAMING-05</configkey>
<name><![CDATA[ 局部变量名应以小写字母开头 [NAMING-05] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
局部变量名应以小写字母开头 [NAMING-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

局部变量名称应该用适当的小写字母。 
这样通过规范的变量外观，就能很容易的区分 
常量和自定义变量了。
参见: NAMING-06, NAMING-07, NAMING-34, NAMING-35



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以提高代码的易读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int Count;    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    int count;     // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   From: 5 Assigning Names - Rule 13

2. Motorola Coding Standards R-20

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-06</key>
<configkey>NAMING-06</configkey>
<name><![CDATA[ 全局变量名应以小写字母开头 [NAMING-06] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
全局变量名应以小写字母开头 [NAMING-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

全局变量应以小写字母开头。 
这样通过标准的变量外观， 
程序员就能很容易地区分 
常量和用户自定义了。
常见: NAMING-05, NAMING-07, NAMING-34, NAMING-35



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以提高代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int Count;    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int count;      // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 5 Assigning Names - Rule 13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-07</key>
<configkey>NAMING-07</configkey>
<name><![CDATA[ 成员变量名应以小写字母开头 [NAMING-07] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
成员变量名应以小写字母开头 [NAMING-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

成员变量名应以小写字母开头。
这样通过标准的变量外观， 
程序员就能很容易地区分 
常量和用户自定义了。
参见: NAMING-05, NAMING-06, NAMING-34, NAMING-35



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以提供代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
    int Count;    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
    int count;     // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 5 Assigning Names - Rule 13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-08</key>
<configkey>NAMING-08</configkey>
<name><![CDATA[ 所有布尔类型变量必须以字母 'b' 开头 [NAMING-08] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有布尔类型变量必须以字母 'b' 开头 [NAMING-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所以布尔类型变量应以 'b' 开头。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以提供代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    bool Var; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    bool bVar; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-09</key>
<configkey>NAMING-09</configkey>
<name><![CDATA[ 类，结构，联合，枚举和自定义类型(typedef)的名字必须以大写字母开头 [NAMING-09] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类，结构，联合，枚举和自定义类型(typedef)的名字必须以大写字母开头 [NAMING-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类，结构，联合，枚举和自定义（typedef）的名字 
必须以大写字母开头。
参见: NAMING-10, NAMING-11, NAMING-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class myClass{}; // 违规
struct myStruct{}; // 违规
union myUnion{}; // 违规
enum myEnum{ val1, val2 }; // 违规
typedef int myInt; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass{}; // OK
struct MyStruct{}; // OK
union MyUnion{}; // OK
enum MyEnum{ val1, val2 }; // OK
typedef int MyInt; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-10</key>
<configkey>NAMING-10</configkey>
<name><![CDATA[ 抽象数据类型，结构体，自定义类型(typedef)，枚举类型的名字必须以大写字母开头 [NAMING-10] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
抽象数据类型，结构体，自定义类型(typedef)，枚举类型的名字必须以大写字母开头 [NAMING-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"类，结构，联合，枚举和自定义类型(typedef)的名字必须以大写字母开头。
 一个类/结构/联合如果没有任何公共的或被保护的成员数据时
被认为是一个抽象的数据类型。"
参见: NAMING-09, NAMING-11, NAMING-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class   myClass   {};               // 违规
struct  myStruct  {};               // 违规
union   myUnion   {};               // 违规
enum    myEnum    { val1, val2 };   // 违规
typedef int       myInt;            // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class   MyClass   {};               // OK
struct  MyStruct  {};               // OK
union   MyUnion   {};               // OK
enum    MyEnum    { val1, val2 };   // OK
typedef int       MyInt;            // OK

class myClass{   // OK - no abstract data type
public:
    void foo();
};

enum {           // OK - unnamed type
    E1, E2
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
From: 5 Assigning Names - Rule 14

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-11</key>
<configkey>NAMING-11</configkey>
<name><![CDATA[ 枚举类型名称应以大写字母开头并以后缀 '_t' 结尾 [NAMING-11] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
枚举类型名称应以大写字母开头并以后缀 '_t' 结尾 [NAMING-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果一个枚举类型的命名不是以大写字母开头
或者不是以 '_t'结尾的规则就会报告错误。
参见o: NAMING-09, NAMING-10, NAMING-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum possibleColors1_t { RED, BLUE, GREEN };     // 违规
enum PossibleColors2   { YELLOW, BLACK, WHITE }; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum PossibleColors1_t { RED, BLUE, GREEN };     // OK
enum PossibleColors2_t { YELLOW, BLACK, WHITE }; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-12</key>
<configkey>NAMING-12</configkey>
<name><![CDATA[ 结构类型名称应以大写字母开头并以后缀 '_t' 结尾 [NAMING-12] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构类型名称应以大写字母开头并以后缀 '_t' 结尾 [NAMING-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果一个结构类型的命名不是以大写字母开头
或者不是以 '_t'结尾的规则就会报告错误。
参见: NAMING-09, NAMING-10, NAMING-11



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct Str1    // 违规
{ 
   int i;
};     
struct str2_t  // 违规
{ 
   int i;
}; 



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct Str1_t    // OK
{
   int i;
};
struct Str2_t    // OK
{
   int i;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-13</key>
<configkey>NAMING-13</configkey>
<name><![CDATA[ 常量名以小写字母 'c' 开头 [NAMING-13] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
常量名以小写字母 'c' 开头 [NAMING-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

常量名要以小写字母 'c'开头。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

const int Foo = 0;	// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int cFoo = 0;	// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-14</key>
<configkey>NAMING-14</configkey>
<name><![CDATA[ 类的数据成员名以 'its' 开头 [NAMING-14] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类的数据成员名以 'its' 开头 [NAMING-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类的数据成员名要以 'its'开头。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Foo {
private:
	int bar;	// 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Foo {
private:
	int itsBar;	// OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

 ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-15</key>
<configkey>NAMING-15</configkey>
<name><![CDATA[ 双精类型变量名以小写字母 'd' 开头 [NAMING-15] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
双精类型变量名以小写字母 'd' 开头 [NAMING-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有双精度变量名以小写字母'd'开头。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    double Var;	  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
    double dVar;   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-16</key>
<configkey>NAMING-16</configkey>
<name><![CDATA[ 浮点类型变量名以小写字母 'f' 开头 [NAMING-16] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
浮点类型变量名以小写字母 'f' 开头 [NAMING-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有浮点类型变量名都要以小写字母 'f'开头。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   float Var;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   float fVar;	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-17</key>
<configkey>NAMING-17</configkey>
<name><![CDATA[ 所有函数名字以大写字母开头 [NAMING-17] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有函数名字以大写字母开头 [NAMING-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有函数名都要以大写字母开头。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo();	// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void Foo();	// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-18</key>
<configkey>NAMING-18</configkey>
<name><![CDATA[ 全局变量名以 'the' 开头 [NAMING-18] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
全局变量名以 'the' 开头 [NAMING-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所以全局变量命名都应该用 'the'开头。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int global_var;	  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int theWindows; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-19</key>
<configkey>NAMING-19</configkey>
<name><![CDATA[ 所有整型变量以小写字母 'i' 开头 [NAMING-19] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有整型变量以小写字母 'i' 开头 [NAMING-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有的整型变量应该以 'i'开头.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
  int Var;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
  int iVar;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-20</key>
<configkey>NAMING-20</configkey>
<name><![CDATA[ 以 'is' 开头的函数必须返回布尔值 [NAMING-20] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
以 'is' 开头的函数必须返回布尔值 [NAMING-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则检查函数是否以'is_'或'is[A-Z]'开头返回布尔
值.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

以 'bool' 开头是布尔类型公认的
类型定义格式(忽略大小写)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

改善可读性和阐明返回值的意义.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int  isPositive(int x)	 // 违规
{        
    return x &gt; 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

bool isPositive(int x)   // OK
{  
    return x &gt; 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-21</key>
<configkey>NAMING-21</configkey>
<name><![CDATA[ 所有长整型变量名以 'li' 开头 [NAMING-21] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有长整型变量名以 'li' 开头 [NAMING-21-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有长整型变量应该以 'li' 开头.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   long int Var;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
   long int liVar;	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-22</key>
<configkey>NAMING-22</configkey>
<name><![CDATA[ 指针类型变量名以字母 'p' 为前缀 [NAMING-22] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指针类型变量名以字母 'p' 为前缀 [NAMING-22-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一个指针变量类型应该有一个 'p' 字符前缀. 
代码的易读更好并且错误能够避免增加
一个前缀式类型给一个变量.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int *Foo;	// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int *pFoo;	// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-23</key>
<configkey>NAMING-23</configkey>
<name><![CDATA[ 所有短整型变量以字母 'si' 开头 [NAMING-23] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有短整型变量以字母 'si' 开头 [NAMING-23-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有短整型变量应该以 'si' 开头.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
  short int Var;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
  short int siVar;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-24</key>
<configkey>NAMING-24</configkey>
<name><![CDATA[ 所有有符号字符变量以小写字母 'c' 开头 [NAMING-24] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有有符号字符变量以小写字母 'c' 开头 [NAMING-24-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有有符号的字符变量应该以 'c' 开头.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
    signed char Var;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   signed char cVar;	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-25</key>
<configkey>NAMING-25</configkey>
<name><![CDATA[ 所有有尾字符串的变量名以 'sz' 开头 [NAMING-25] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有有尾字符串的变量名以 'sz' 开头 [NAMING-25-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有终止字符的字符串变量应该以 'sz' 开头.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
  char Var[] = "\n"; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
  char szVar[] = "\n";  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-26</key>
<configkey>NAMING-26</configkey>
<name><![CDATA[ 所有无符号字符类型变量名以 'uc' 开头 [NAMING-26] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有无符号字符类型变量名以 'uc' 开头 [NAMING-26-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有的无符号字符类型变量应该以 'uc' 开头.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   unsigned char Var;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   unsigned char ucVar;	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-27</key>
<configkey>NAMING-27</configkey>
<name><![CDATA[ 所有无符号整型变量以 'ui' 开头 [NAMING-27] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有无符号整型变量以 'ui' 开头 [NAMING-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有无符号整型变量应该以 'ui' 开头.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
  unsigned int Var;    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
  unsigned int uiVar;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-28</key>
<configkey>NAMING-28</configkey>
<name><![CDATA[ 结构和联合的成员名字使用小写字母 [NAMING-28] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
结构和联合的成员名字使用小写字母 [NAMING-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有的结构和联合成员必须是适当的小写字母. 这个规范 
使得结构和联合成员容易去识别.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使代码更易读



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

struct date_foo2 { 
    int datemonth;
    int DateDay;    // 违规
    int Dateyear;   // 违规  
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct date_foo1 {
    int dateMonth;
    int dateDay;    // OK
    int dateYear;   // OK
};


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

摩托罗拉编码归规范 第19条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-29</key>
<configkey>NAMING-29</configkey>
<name><![CDATA[ 所有自定义类型的名字应以 "_t" 结尾 [NAMING-29] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有自定义类型的名字应以 "_t" 结尾 [NAMING-29-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有的自定义类型必须附加上一个下划线并跟随 
一个小写字母 't'. 本约定将使用户识别自定义类型的数据更容易 
并支持未来的维护工作.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

增强代码的易读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class MyClass {
   int count;
};
typedef MyClass My;	// 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass {
	int count;
};
typedef MyClass My_t;	// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

摩托罗拉编码规范 第17条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-30</key>
<configkey>NAMING-30</configkey>
<name><![CDATA[ 确保在 C 语言中实现文件始终具有文件扩展名 ".c" [NAMING-30] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保在 C 语言中实现文件始终具有文件扩展名 ".c" [NAMING-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

执行文件使用在 C 语言上并且不含有 '.c' 扩展名
规则会报告出违规.
参见: NAMING-38, NAMING-41



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该文件是任意的,被 #include 加载到源文件的文件除外.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增进源代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.c90    // 违规
void foo( ) {}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.c      // OK
void foo( ) {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

摩托罗拉编码规范 第12条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-31</key>
<configkey>NAMING-31</configkey>
<name><![CDATA[ 不要使用字母的大小写区分数据类型 [NAMING-31] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用字母的大小写区分数据类型 [NAMING-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不要使用字母的大小写
区分数据类型."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守规则增加代码的安全性和可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int MyInt; // 违规
typedef int myInt; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int MyInt;  // OK
typedef int myInt2; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 5 Assigning Names - Rec. 14

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-32</key>
<configkey>NAMING-32</configkey>
<name><![CDATA[ 包含在类中的头文件应采用 <类名> 加扩展名的格式 [NAMING-32] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
包含在类中的头文件应采用 &lt;类名&gt; 加扩展名的格式 [NAMING-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"包含在类中的头文件应采用 &lt;类名&gt; 加扩展名的格式
在源代码中使用同样的方式不管是大写字符或者小写字母.
因为类的命名一般都是遵循在同一字符文件中的一个约定
当命名头文件包含文件时使用同样的字符命名规则命名是
个很好的方法."
这条规则报告一个违规当一个头文件声明时多于一个class或
or一个头文件的命名(extension除外)和它里面所包含的类名字
不一样时.
参见: PFO-03



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

头文件声明成为任意文件是通过 '#include.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用基于文件的工具容易定位类的定义.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
#include "MyClass1.hh"
#include "MyClass2.hh"

// MyClass1.hh
class MyClass{   // 违规
    int i;
};

// MyClass2.hh
class MyClass1{  // 违规
    int i;
};

class MyClass2{
    int i;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cpp
#include "MyClass1.hh"

// MyClass1.hh
class MyClass1{  // OK
    int i;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
出自: 4 Source Code in Files - 4.2 Naming Files - 第7条记录

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-33</key>
<configkey>NAMING-33</configkey>
<name><![CDATA[ 标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头 [NAMING-33] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头 [NAMING-33-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不要使用以一个或两个下划线 (`_' or `__') 开头的命名."
参见: CODSTA-92, CODSTA-93



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规范预防了不确定的行为.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void _foo( );  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( );   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 5 Assigning Names - 第 16 规则

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.9 章节 Style, AV 第 47 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-34</key>
<configkey>NAMING-34</configkey>
<name><![CDATA[ 全局函数名必须以小写字母开头 [NAMING-34] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
全局函数名必须以小写字母开头 [NAMING-34-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

全局函数名称应该以小写字符开头.
参见: NAMING-05, NAMING-06, NAMING-07, NAMING-35



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善易读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void Foo( ) {}   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {}    // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
出自: 5 Assigning Names - 第13条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-35</key>
<configkey>NAMING-35</configkey>
<name><![CDATA[ 成员函数名必须以小写字母开头 [NAMING-35] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
成员函数名必须以小写字母开头 [NAMING-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

成员函数命名应该以小写字符开始.
参见: NAMING-05, NAMING-06, NAMING-07, NAMING-34



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
    void Foo( ) {}   // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
    void foo( ) {}   // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
出自: 5 Assigning Names - 第13条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-36</key>
<configkey>NAMING-36</configkey>
<name><![CDATA[ 函数声明中的参数名必须与函数定义中的参数名字一致 [NAMING-36] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数声明中的参数名必须与函数定义中的参数名字一致 [NAMING-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果标识符给定任何参数，则该标识符用于声明
和定义应该是相同的."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1( int a, int b );           // 违规
void foo1( int x, int y ) {}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1( int a, int b );           // OK
void foo1( int a, int b ) {}

void foo2( int, int );                // OK
void foo2( int x, int y ) {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
出自: 9 Function - 9.3 Formal Arguments - 第32条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-37</key>
<configkey>NAMING-37</configkey>
<name><![CDATA[ 确保在 C++ 中包含文件始终具有扩展名 ".hh" [NAMING-37] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保在 C++ 中包含文件始终具有扩展名 ".hh" [NAMING-37-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果头文件使用在 C++ 语言中并且不包含 '.hh' 扩展
,规则会报告出违规.
参见: NAMING-38, NAMING-41



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

头文件声明成为任意文件是通过 '#include'.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增加源代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
#include "file.hpp"

// file.hpp                 // 违规
extern int i;         



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cpp
#include "file.hh"

// file.hh                  // OK
extern int i;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#4.1">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#4.1</A>
出自: 4 Source Code in Files - 4.1 Structure of Code - 第1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-38</key>
<configkey>NAMING-38</configkey>
<name><![CDATA[ 确保在 C++ 中实现文件始终具有文件扩展名 ".cc" [NAMING-38] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保在 C++ 中实现文件始终具有文件扩展名 ".cc" [NAMING-38-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

执行文件使用在 C++ 语言并且没有 '.cc' 扩展
规则会报出违规.
参见: NAMING-37, NAMING-41



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

头文件声明成为任意文件是通过 '#include.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增加源代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp    // 违规
void foo( ) {}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cc      // OK
void foo( ) {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#4.1">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#4.1</A>
出自: 4 Source Code in Files - 4.1 Structure of Code - 第2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-39</key>
<configkey>NAMING-39</configkey>
<name><![CDATA[ 内联定义文件的扩展名必须为 ".icc" [NAMING-39] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
内联定义文件的扩展名必须为 ".icc" [NAMING-39-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"内联定义文件 - 文件包括定义内联的函数 -
应该有文件扩展名 ".icc"."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则增加源代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp                            // 违规
inline int sum( int a, int b ) {
    return a + b;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.icc                             // OK
inline int sum( int a, int b ) {
    return a + b;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#4.1">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#4.1</A>
出自: 4 Source Code in Files - 4.1 Structure of Code - 第3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-40</key>
<configkey>NAMING-40</configkey>
<name><![CDATA[ 类，结构，命名空间，枚举或自定义类型(typedef)的名字中，只有第一个字母可以大写 [NAMING-40] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类，结构，命名空间，枚举或自定义类型(typedef)的名字中，只有第一个字母可以大写 [NAMING-40-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

类, 结构体, 命名空间, 枚举, 或由 typedef
创建的类型命名应以大写字母开头.
其余的字母都为小写.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果想排除缩写名称的检查，则可以在
此规范里的 python 脚本 checkNamingConvention() 方法中
的 abb_table 数组添加缩写字符串 如 abb_table = ["RGB", "IBM"]


例外:

在 typedef 类型名的第一个字母可以为小写如果 typedef 对象是类成员或
当它用来替代基本类型.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规范提高可读性与维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class sample_Class   // 违规
{
   // ...
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Sample_class   // OK
{
   // ...
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 50 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-41</key>
<configkey>NAMING-41</configkey>
<name><![CDATA[ 确保头文件应该始终具有扩展名 '.h' [NAMING-41] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保头文件应该始终具有扩展名 '.h' [NAMING-41-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检查源码当的头文件不是以
".h" 文件扩展名为后缀时报告违规。
参见: PREPROC-08, NAMING-37, NAMING-38



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

头文件声明成为任意文件是通过 '#include.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规范提高了代码的可读性与维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
#include "file.hpp"

// file.hpp                 // 违规
extern int i;         



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cpp
#include "file.h"

// file.h                   // OK
extern int i;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 53 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-42</key>
<configkey>NAMING-42</configkey>
<name><![CDATA[ 常量和枚举(enum)类型的标识符必须是小写 [NAMING-42] ]]></name>
<tag>naming</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
常量和枚举(enum)类型的标识符必须是小写 [NAMING-42-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

常量和枚举应为小写.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

尽管在常量和枚举中使用大写是
允许的, 仍有可能第三方库会替
换常量 / 枚举名为宏替换过程的
一部分 (宏通常也是以大写字母来呈现).



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

const int Max_pressure = 100;    // 违规
enum Switch_position {Up, down}; // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const int max_pressure = 100;     // OK
enum Switch_position {up, down};  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 52 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-43</key>
<configkey>NAMING-43</configkey>
<name><![CDATA[ 源文件的扩展名必须为 ".cpp" [NAMING-43] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
源文件的扩展名必须为 ".cpp" [NAMING-43-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果文件后缀名不是 ".h" (为头文件所用) 则
应该是 ".cpp" (实现文件).
此规范侦测如果文件后缀名不是 ".cpp" 和 ".h".
".cpp" 应为实现文件所用而
".h" 是给头文件使用 (规则 NAMING-41).
参见: NAMING-41



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规范只对 C++ 代码检测.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性与维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

//file.cc          // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

//file.cpp        // OK   



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 54 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-44</key>
<configkey>NAMING-44</configkey>
<name><![CDATA[ 在函数和变量名中包含的字母应该全部以小写字母组成 [NAMING-44] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在函数和变量名中包含的字母应该全部以小写字母组成 [NAMING-44-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在函数和变量名中包含的字母应该全部以
小写字母组成.


例外:

构造函数和解构造函数.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高可读性与维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Sample_class
{
public:
    int Some_function();      // 违规
private:
    int Some_variable;        // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Sample_class
{
public:
    int some_function();      // OK
private:
    int some_variable;        // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 51 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-45</key>
<configkey>NAMING-45</configkey>
<name><![CDATA[ 不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字 [NAMING-45] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字 [NAMING-45-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

标识符将相同如果:
- 只有大小写的混合
- 下划线字符存在与否
- 只有字母 'O', 和数字 '0' 或字符 'D' 交换
- 只有字母 'I', 和数字 '1' 或字符 'l' 交换
- 只有字母 'S' 和数字 '5' 交换
- 只有字母 'Z' 和数字 '2' 交换
- 只有字母 'n' 和字符 'h' 交换.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int paramS, int param5);   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int param1, int param2);   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.9 章节 Style, AV 第 48 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-46</key>
<configkey>NAMING-46</configkey>
<name><![CDATA[ 字符 ', ", /* 或 // 不得出现在头文件的名称中 [NAMING-46] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符 ', ", /* 或 // 不得出现在头文件的名称中 [NAMING-46-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在头文件的名称预处理标记中 ', ", /* 或 // 字符
用于 &lt; 和 &gt; 分隔符之间或者 ', /* 或 // 字符用于 " 分隔符之间，
那么这是不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "fi'le.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "file.h"  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 16 节, 规则 16-2-4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-47</key>
<configkey>NAMING-47</configkey>
<name><![CDATA[ 不同的标识符应该是外观上可以清晰区别的 [NAMING-47] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不同的标识符应该是外观上可以清晰区别的 [NAMING-47-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“根据用于显示字符集的字体， 即使是
不同的字体，也很可能出现某些字形相同。
这可能导致开发人员将某些标识符和其他相混淆。
为了帮助减少这种可能性，标识符不得用以下的组合
来进行区别:
- 只有大小写混合差异;
- 存在或缺少下划线字符的差异;
- 字母 'O', 和数字 '0' 的互换;
- 字母 'I', 和数字 '1' 的互换;
- 字母 'i', 和数字 '1' 的互换;
- 字母 'i', 和数字 'l' 的互换;
- 字母 'I', 和数字 'l' (el) 的互换;
- 字母 'l' (el), 和数字 '1' 的互换;
- 字母 'S' 和数字 '5' 的互换;
- 字母 'Z' 和数字 '2' 的互换;
- 字母 'n' 和数字 'h' 的互换;
- 字母 'B' 和数字 '8' 的互换;
- 字母序列 'rn' ('n' 紧跟在 'r' 之后)
  和数字 'm' 的互换。”
参见: NAMING-45.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则提高了代码的可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int id1_uint32; // 违规 - interchange Z and 2
short id1_uint3Z;       // 违规 - interchange Z and 2

void id2_foo(            // 违规 - absence underscore
        int id4_paramS,  // 违规 - interchange S and 5
        int id4_param5   // 违规 - interchange S and 5
        ){
    int id3_abc;  // 违规 - mixed case
    int id3_ABC;  // 违规 - mixed case
}

int id6_modern;   // 违规 - interchange rn and m

void id2_foo_(){   // 违规 - presence underscore
    int id5_BO;    // 违规 - interchange B and 8, O and 0
    int id5_80;    // 违规 - interchange B and 8, O and 0
    int id6_modem; // 违规 - interchange rn and m
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int id1_uint32_t; // OK
int id1_uint32_v;         // OK

void id2_foo_1(          // OK
        int id4_param1,  // OK
        int id4_param2   // OK
        ){
    int id3_abc_1;  // OK
    int id3_ABC_2;  // OK
}

int id6_modern;    // OK

void id2_foo_2(){  // OK
    int id5_BO_1;  // OK
    int id5_80_2;  // OK
    int foo_2_id6_modem; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 2 节, 规则 2-10-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>NAMING-48</key>
<configkey>NAMING-48</configkey>
<name><![CDATA[ 字符 \ 不得出现在头文件的名称中 [NAMING-48] ]]></name>
<tag>naming</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
字符 \ 不得出现在头文件的名称中 [NAMING-48-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果在头文件的名称预处理标记中 \ 字符
用于 &lt; 和 &gt; 分隔符之间或者 " 分隔符之间。
请注意，此规则只是一个建议，因为有些环境使用 \ 作为
文件名的分隔符。这些环境的编译器通常都支持
在 #include 指令中使用 / 。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "fi\\le.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "file.h"  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 16 节, 规则 16-2-5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-01</key>
<configkey>OOP-01</configkey>
<name><![CDATA[ 基类的拷贝构造函数应该是使用一个泛型指针作为参数的 protected 或 public 类型 [OOP-01] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
基类的拷贝构造函数应该是使用一个泛型指针作为参数的 protected 或 public 类型 [OOP-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"对象切片不是好的. (...) 
为达到避免切片的目标，有更好的方式可以进行
and delivers more value to boot. 一般惯用的解决方案
是将基类的拷贝构造函数设为protected"
参见: OOP-02


例外:

"有些设计也许需要将基类中的拷贝构造函数设置成
 public. 在这种情况下, 以(泛型)指针传递比引用
传递更加适合. 指针传递有比较少切片的弱点和不需
要的临时构造."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则避免切片对象的使用.
"对象切片是自动的, 不可见的, 而且有可能
对多态性设计的使用造成困扰"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
    A(A&amp;);  // 违规 - copy constructor in public section 
            //             without smart pointer as parameter 
};

class B
{
private:
   B(B &amp;); // 违规  - copy constructor in private section  
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;memory&gt;
using namespace std;

class C
{
public:
    C(auto_ptr&lt;C&gt;); // OK
};

class D
{
protected:
    D(D&amp;);         // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Construction, Destruction, and Copying", 第 54 条规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-02</key>
<configkey>OOP-02</configkey>
<name><![CDATA[ 避免使用切片，基类中应该使用克隆而非拷贝 [OOP-02] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用切片，基类中应该使用克隆而非拷贝 [OOP-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

对象切片非良好的编码习惯. 
"对象切片是自动且不可见的. 在基类中, 应该考虑
禁用拷贝构造函数和拷贝赋值运算符. 
如果调用端需要做多态 (complete, deep)拷贝反而
应该提供虚克隆成员函数."
 
拷贝构造函数的基类如下:

class A    
{
public:
    A* Clone() const
    {
      A* p = DoClone();
      assert(typeid(p) == typeid(this));
      return p;
    }
protected:
    A(A&amp;);
    virtual A* DoClone() const = 0;
};

这规则检测:
I) 如果有保护拷贝构造函数
II) 如果 'DoClone' 函数:
- 受保护的
- 常量的
- 是纯虚的
- 返回指针到基类
III) 如果 'Clone' 函数:
- 是公共的
- 是常量的
- 返回指针到基类
- 有被 'DoClone'函数初始化的局部变量
- 如上包含断言
参见: OOP-01



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免使用对象切片.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;assert.h&gt;
#include &lt;typeinfo&gt;
#include &lt;memory&gt;
using namespace std;

class A      // 违规 - function Clone defined incorrectly
{

public:
    A* Clone() const
    {
      A* p = 0;
      return p;
    }
protected:
    A(A&amp;);
    virtual A* DoClone() const = 0;
};

class B      // 违规 - no DoClone function
{

protected:
    B(B&amp;);
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;assert.h&gt;
#include &lt;typeinfo&gt;
#include &lt;memory&gt;
using namespace std;

class C      // OK
{

public:
    C* Clone() const
    {
      C* p = DoClone();
      assert(typeid(p) == typeid(this));
      return p;
    }
protected:
    C(C&amp;);
    virtual C* DoClone() const = 0;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
章节: "Construction, Destruction, and Copying", 第 54 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-03</key>
<configkey>OOP-03</configkey>
<name><![CDATA[ 类不能多次继承其它类，除非是虚拟继承 [OOP-03] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类不能多次继承其它类，除非是虚拟继承 [OOP-03-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“多重继承比单次继承复杂。它能造成新的模糊不清的
问题，并且可能需要虚拟继承。当您在处理一个基类型
衍生类具有多条路径的继承层次结构的时候，您都会遇
到是否需要对基类型中的数据成员为每条路径进行冗余
复制的问题.”
参见：OOP-07，OOP-06，OOP-05，OOP-04



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
“多重继承仅仅意味着从多个基类型进行集成，但是在
具有更高级的基类型的层次结构中发现多重继承（MI）
就不正常了。这种情况可能导致被称作“致命的多重继
承菱形（deadly MI diamond）”(..)的问题。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class PreBase {};
class Base: public PreBase {};
class Empty {};
class Intermediate: public Base, public Empty  {};
class NonEmpty: public PreBase {};

class MyClass:public Intermediate, public NonEmpty, public Empty{}; // Violation
class MyClass2:public Intermediate, protected Empty {};             // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class PreBase {};
class Base: public virtual PreBase {};
class Empty {};
class Intermediate: public virtual Base, public virtual Empty  {};
class NonEmpty: public virtual PreBase {};

class MyClass: public Intermediate, public NonEmpty, public Empty {};  // OK
class MyClass2: public Intermediate, protected Empty {};               // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
   第三版，Addison-Wesley，
   (C)2005 Pearson Education, Inc.,第6章，第40项

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-04</key>
<configkey>OOP-04</configkey>
<name><![CDATA[ 不要从多于一个基类中派生出相同名字的函数 [OOP-04] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要从多于一个基类中派生出相同名字的函数 [OOP-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"首先查找的是当 MI进入设计范围,
从多于一个基类继承相同的名字变得
可能.(如, function, typedef, 等等.)"
此规则检查在父类里存在的字段或方法
不会在子类中用相同名字重复定义.
参见: OOP-07, OOP-06, OOP-05, OOP-03



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可以检查代码里非单一定义的可能性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class BaseOne {
public:
    int field;
};

class BaseTwo {
public:
    int field;
    void foo( );
};

class BaseThree {
public:
    void foo( );
};

class MyClassOne: public BaseOne, public BaseTwo {};    // 违规

class MyClassTwo: public BaseTwo, public BaseThree {};  // 违规

class MyClassThree: public virtual BaseOne, public virtual BaseThree {};// OK



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class BaseOne {
public:
    int field;
};

class BaseTwo {
public:
    int field;
    void foo();
};

class BaseThree {
public:
    void foo();
};

class MyClassOne: public virtual BaseOne, public virtual BaseTwo {};    // OK

class MyClassTwo: public virtual BaseTwo, public virtual BaseThree {};  // OK

class MyClassThree: public virtual BaseOne, public virtual BaseThree {};// OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., 第 6 章节, 第 40 项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-05</key>
<configkey>OOP-05</configkey>
<name><![CDATA[ 禁止使用多重继承 [OOP-05] ]]></name>
<tag>oop</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用多重继承 [OOP-05-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用多重继承会导致奇异的类层次结构并且降低
代码的灵活性。因为在C++中可能含有任意数量
的某个类型的实例，这有可能是对某个仅能使用
一次的类的直接继承（参见下述示例）。本规则
能检查出您的代码中是否使用了多重继承
参见：OOP-07，OOP-06，OOP-04，OOP-03



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升代码的清晰度和可维护性。遵循本规则能够
预防从如“致命菱形”的多个对象中的一个继承
类的时候引起的不确定性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
class B {};
class C : public A, public B {}; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B {};
class A : public B {}; // OK
class C : public B {}; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers
《更高效的C++：改善程序及设计的35种特定方法》
章节：效率，第24项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-06</key>
<configkey>OOP-06</configkey>
<name><![CDATA[ 对于多重继承使用虚公共基类 [OOP-06] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对于多重继承使用虚公共基类 [OOP-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"虚基类经常需要多重继承. 没有虚基 
类，派生类如果有多个路径的继承基类 
，该基类的数据成员将被复制在每个派 
生类对象，每一个派生类和基类路径之 
间都有一份拷贝.这种复制几乎没有什 
么程序员想要，让基类虚拟消除了复制 
的情况.虚基类可能会招致自己的问题 
.但，由于虚基类的实现经常使用指针 
指向虚基类，以避免复制，和一个或更
多的指针能在你的对象存储."
参见: OOP-07, OOP-05, OOP-04, OOP-03



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可以保护没有虚多重继承.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
class B : public A {};
class C : public A {};
class D : public  B, public C {};  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {};
class B : virtual public A {};
class C : virtual public A {};
class D : public  B, public C {};  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers,
"More Effective C++: 35 New Ways to Improve Your Programs and Designs"
章节: Efficiency, 第 24 项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-07</key>
<configkey>OOP-07</configkey>
<name><![CDATA[ 注意对未抽象接口的类进行多重继承 [OOP-07] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
注意对未抽象接口的类进行多重继承 [OOP-07-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“注意对未抽象接口的类进行多重继承。
使用多重继承的设计具有很好的表意性，
但是却很容易引发错误并且难以修正。特
别而言，对于使用多重继承的设计而言，
其状态管理是有其困难的。”
参见：OOP-06，OOP-05，OOP-04，OOP-03



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则仅允许一个直接非接口的父类型。
使用接口类意味着无成员变量的类以及所
有成员函数都是完全虚拟的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“避免抽象接口中的状态简化整个层次结
构的设计”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    void foo1( );
};

class B {
public:
    void foo2( );
};

class C: public A, public B {   // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    void foo1( );
};

class B {
public:
    virtual void foo2( ) = 0;
};

class C: public A, public B {   // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter，Andrei Alexandrescu，《C++编码规范》
   Addison-Wesley，(C)2005 Pearson Education, Inc.
   章节：“类设计及继承”，第36条规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-08</key>
<configkey>OOP-08</configkey>
<name><![CDATA[ 禁止构造函数直接访问全局数据 [OOP-08] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止构造函数直接访问全局数据 [OOP-08-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

构造函数直接访问全局数据是很危险的，因为
当“其它”静态对象在进行初始化的时候，该
全局数据可能还不存在。
本规则能检查出您是否使用了构造函数直接访
问全局数据。
参见：OOP-09，OOP-10


例外：

在构造函数中可以使用全局常量。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在不同的编译单元中进行定义的静态对象初始
化顺序的定义未在C++语言定义中进行定义。
因此，在构造函数中访问全局数据可能造成读
取尚未初始化的对象。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int globalVar;
class A {
public:
    A( ) {              // Violation
        b = globalVar;
    }
private:
    int b;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止构造函数使用全局数据。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel编码规范
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
第7章：类 - 7.5 构造函数和析构函数 - 第33条规定

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-09</key>
<configkey>OOP-09</configkey>
<name><![CDATA[ 避免在析构函数中使用全局对象 [OOP-09] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在析构函数中使用全局对象 [OOP-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免在析构函数里使用全局变量.
使用全局变量代表违反一个面向对象编 
程基本原则，也就是封装数据的违规.
参见: OOP-08, OOP-10



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则预防在析构函数里使用全局变量.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int globalVar = 0;

class A {
public:
    ~A( ) {             // 违规
        globalVar--;
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在析构函数里使用全局变量.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
from: 7 Classes - 7.5 Constructors and Destructors - Rec. 33

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-10</key>
<configkey>OOP-10</configkey>
<name><![CDATA[ 避免在成员函数中使用全局数据 [OOP-10] ]]></name>
<tag>oop</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在成员函数中使用全局数据 [OOP-10-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免在成员函数中使用全局数据。
“全局应用可能会破坏封装以及继承重用。
而且全局应用的问题可能很难完全地删除，
因此，全局应用应该尽量避免使用。”
本规则仅适合于C++编程语言。
参见：OOP-08，OOP-09



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用全局应用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int globalVar = 1;
class A {
public:
    void foo( ) {       // Violation
        memberVar = globalVar;
    }
private:
    int memberVar;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止成员函数使用全局变量。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Mark Schroeder 《面向对象度量指标的使用指南》
IT Professional，11月/12月号，1999，第33页

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-11</key>
<configkey>OOP-11</configkey>
<name><![CDATA[ 避免使用友元(friend)机制 [OOP-11] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用友元(friend)机制 [OOP-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用友元函数通常是不合适的接口警讯.
不要使用友元，是修正接口最好的方法.
使用友元机制会破坏数据隐藏或封装.
参见: CODSTA-CPP-52



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则检测是否使用友元机制.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( );
class A {
    friend int foo( );  // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( );
class A {}; // OK - No friend functions



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-12</key>
<configkey>OOP-12</configkey>
<name><![CDATA[ 受保护(Protected)的成员函数不得返回指向私有类数据的非 const 句柄(指针或引用) [OOP-12] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
受保护(Protected)的成员函数不得返回指向私有类数据的非 const 句柄(指针或引用) [OOP-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"通过实施与成员函数类接口的实现，保留更
多在对象状态如何修改和协助允许在不影响调
用端的情况来维护类的控制. 返回的类数据句
柄允许调用端在不使用任何的接口情况下，而
对对象的状态做变更."
此规则会在受保护的成员函数返回非常量引用 
或指向私有类数据的指针时报违规.
参见: CODSTA-CPP-06, CODSTA-CPP-77, OOP-36



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

类数据句柄是指:
- 指向成员变量/成员函数的引用
- 指向成员变量/成员函数的指针
- 指向在构造函数分配或在析构函数释放的数据的指针/引用
静态变量不列为类数据.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则改善封装和避免数据不在类设计的方式下进行 
变更.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test
{
    public:
        Test()
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
    protected:
        int* GetI1()
        {
            return &amp;_i; // 违规
        }
        int&amp; GetI2()
        {
            return _i; // 违规
        }
        int * GetI3()
        {
            return _k; // 违规
        }
    private:
        int _i;
        int * _k;
};
class Child: public Test
{
    public:
        void foo()
        {
            *(GetI1()) = 0; // Encapsulation broken - possible to change private class data
            GetI2() = 0; // Encapsulation broken - possible to change private class data
            *(GetI3()) = 0; // Encapsulation broken - possible to change private class data
        }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test
{
    public:
        Test()
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
    protected:
        const int* GetI1()
        {
            return &amp;_i; // OK
        }
        const int&amp; GetI2()
        {
            return _i; // OK
        }
        const int * GetI3()
        {
            return _k; // OK
        }
    private:
        int _i;
        int * _k;
};
class Child: public Test
{
    public:
        void foo()
        {
            // *(GetI1()) = 0; // Not compilable - not possible to change private class data
            // GetI2() = 0; // Not compilable - not possible to change private class data
            // *(GetI3()) = 0; // Not compilable - not possible to change private class data
        }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 30 项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 29 项

3. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 5 章节, 第 28 项

4. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Class Design and Inheritance", 第 42 条规则

5. MISRA C++:2008 C++语言在关键系统中的使用指南
    第 6 章节, 第 9 部分, 第 9-3-2 规则

6. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-13</key>
<configkey>OOP-13</configkey>
<name><![CDATA[ 禁止对继承的虚拟函数重定义为不同的默认参数值 [OOP-13] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对继承的虚拟函数重定义为不同的默认参数值 [OOP-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“虚拟函数是被动态约束的，但是默认参数却为静态约束。
这意味着您可能会使用基类型中的默认参数调用衍生类中的
虚拟函数。”
本规则能检测出将继承的虚拟函数被重定义为不同的默认参
数值的情况。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则不检测一下情况：
-具有模板参数的函数
-默认参数值为非常数
-具有复杂表达式的默认参数值



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能预防对默认传递的参数进行错误解释的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base
{
public:
    virtual void func(int i = 1);
};

class Derived: public Base
{
public:
    virtual void func(int i = 0);  // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base
{
    public:
        virtual void func1(int i = 1);
        virtual void func2(int i = 1);
};

class Derived: public Base
{
    public:
        virtual void func1(int i);      // OK
        virtual void func2(int i = 1);  // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   第6章，第37项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“继承与面向对象的设计”，第38项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第95条

4.MISRA C++：2008 - 在关键系统中使用C++语言的准则
  第6章，第8节，第8-3-1条规则

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-14</key>
<configkey>OOP-14</configkey>
<name><![CDATA[ 使用组合 composition 而非使用私有继承 [OOP-14] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用组合 composition 而非使用私有继承 [OOP-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"尽可能的使用组合，而在必须的时候再去使用私有继承. 那
何时算必须的呢？主要是有受保护的成员和/或虚函数的这种情况
，虽然也有特殊的情况就是当对内存空间的关注将倾向私有继
承.(...) 它仅适用在你处理的类中没有数据时. 这种类没有
非静态数据成员；没有虚函数(因为该函数的存在添加 vptr到
每一个对象 — 参考 Item 7)；和没有虚基类(因为该基类也
会引发超出空间大小)."
参见: OOP-37



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"私有继承不是在软件设计阶段需要考虑的事，反而需要在实现
阶段关注. 而且仅在某些特殊情况下有效."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class BaseEmpty {};

class BaseWithOnlyStaticData
{
    public:
        static int sd;
};

class BaseWithNonVirtualFunction
{
    public:
        int foo();
};

class Derived1: private BaseEmpty                        // 违规
{
    public:
        int v;
};

class Derived2: private BaseWithOnlyStaticData      // 违规
{
    public:
        int v;
};

class Derived3: private BaseWithNonVirtualFunction // 违规
{
    public:
        int v;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class BaseEmpty {};

class BaseWithNonStaticData
{
    public:
        int sd;
};

class BaseWithVirtualFunction
{
    public:
        virtual int foo();
};

class Intermediate: public virtual BaseEmpty {};

class Derived4: private BaseWithNonStaticData     // OK
{
    public:
        int v;
};

class Derived5: private Intermediate                     // OK
{
    public:
        int v;
};

class Derived6: private BaseWithVirtualFunction     // OK
{
    public:
        int v;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., 第 6 章节, 第 39 项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-15</key>
<configkey>OOP-15</configkey>
<name><![CDATA[ 禁止改变虚拟函数的默认参数 [OOP-15] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止改变虚拟函数的默认参数 [OOP-15-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当覆盖一个虚拟函数时，应保留其可替换性；
特别需要观察其基类型中函数的前置及后置条件。
不要改变虚拟函数的默认参数。最好显式地将其
重定义为虚拟函数。注意隐藏的基类型的重载。”
参见：TEMPL-06，OOP-17



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止对默认传递的值的错误解释。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A 
{
    public: 
        virtual void foo( float x = 1 );
};

class B:public A
{
    void foo( float x = 2);  // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
    public: 
        virtual void foo( float x = 1 );
};

class B:public A
{
    void foo( float x = 1);  // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter，Andrei Alexandrescu，《C++编码规范》
   Addison-Wesley，(C)2005 Pearson Education. Inc.,
   章节：“类设计及继承”第38条规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-16</key>
<configkey>OOP-16</configkey>
<name><![CDATA[ 避免调用构造函数和析构函数中的虚拟函数 [OOP-16] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免调用构造函数和析构函数中的虚拟函数 [OOP-16-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在构造函数和析构函数中，虚拟函数并不体现出
“虚拟”的特征。当在执行构造函数时调用，虚
拟函数将总是表现为构造函数的类型。这一事实
也同样适用于析构函数。更进一步而言，构造函
数对一个纯虚拟函数的调用将造成未定义行为。

因此，总的而言，在构造函数和析构函数中调用
虚拟函数是很容易引发错误的，并且可能引起从
内存泄漏到程序崩溃等一系列问题。

在这些情况下使用不同方式调用虚拟函数很大程
度上包括对后置构造函数调用的需求：
-为代码中的客户端记录需求
-在第一次调用成员函数的时候调用后置构造函数
-使用工厂函数以确保正确的初始化顺序



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提升代码的可靠性以及可维护性，并可能查找出
应用程序中的运行时缺陷。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {
public:
    Base( ) {
    	init_Base( );          // Violation
    }
    virtual void init_Base( );
};

class Derived : public Base {
    Derived* derived;
public:
    Derived( ) {
    	init_Base( );           // Violation
    	init_Derived1( );       // Violation
    	this-&gt;init_Derived2( ); // Violation
    }
    virtual void init_Derived1( );
    virtual void init_Derived2( );
};

void Base::init_Base(){}
void Derived::init_Derived1( ) {}
void Derived::init_Derived2( ) {}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    Base( ) {
    	Base::init_Base( );        // OK
    }
    virtual void init_Base( );
};

class Derived : public Base {
    Derived* derived;
public:
    Derived( ) {
    	Base::init_Base( );        // OK
    	Derived::init_Derived1( ); // OK
    	derived-&gt;init_Derived2( ); // OK
    }
    virtual void init_Derived1( );
    virtual void init_Derived2( );
};

void Base::init_Base(){}
void Derived::init_Derived1( ) {}
void Derived::init_Derived2( ) {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)2005 Pearson Education. Inc.,
  章节：“构造，析构及拷贝”，第49条规则

2.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  第2章，第9项

3.Scott Meyers与Martin Klaus，《检查C++程序分析器》
  Dr. Dobbs' Journal，1997 1月号，
  章节：“构造函数/析构函数/赋值”，第13项
  <A HREF="http://www.aristeia.com/ddjpaper1_frames.html">http://www.aristeia.com/ddjpaper1_frames.html</A>

4.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第71.1条

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-17</key>
<configkey>OOP-17</configkey>
<name><![CDATA[ 采用命名空间声明来重新定义重载函数 [OOP-17] ]]></name>
<tag>oop</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
采用命名空间声明来重新定义重载函数 [OOP-17-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当心在基类中不注意地隐藏的重载.
如果基类里的重载应该设为可见，在
派生类里写 using定义来重定义它们"
参见: OOP-15, TEMPL-06


例外:

此规则检查最近的基类.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则避免基类中隐藏的重载.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public: 
    virtual void foo( float x );
    virtual void foo( float x, float y );
};

class B : public A {    // 违规
public:
    void foo( float x );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public: 
    virtual void foo( float x );
    virtual void foo( float x, float y );
};

class B : public A {    // OK
public:
    void foo( float x );
    using A::foo;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Class Design and Inheritance", 第 38 条规则

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 6 章节, 第 33 项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-18</key>
<configkey>OOP-18</configkey>
<name><![CDATA[ 避免"public"数据成员 [OOP-18] ]]></name>
<tag>oop</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免"public"数据成员 [OOP-18-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则能检测出"public"数据成员被不受信任代码
访问的情况。
参见：OOP-19



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则会跳过'static const'变量的检查。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
防止使用"public"数据成员。公有数据成员
可以被任何用户代码直接访问。
使用公有存取成员函数返回数据能防止未经
授权的访问。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    int iData;      // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
private:
    int iData;      // OK
public:
    const int accessiData( ); 
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
  摘自：第7章 类 - 7.1与访问权限相关的考虑 - 第22条规则

2.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)2005 Pearson Education. Inc.,
  章节：“类设计及继承”，第41条规则

3.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,  第4章，第22项

4.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“类和函数：设计与声明”，第20项

5.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第67条

6. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-19</key>
<configkey>OOP-19</configkey>
<name><![CDATA[ 避免'protected'数据成员 [OOP-19] ]]></name>
<tag>oop</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免'protected'数据成员 [OOP-19-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查"protected"数据成员的用法。
参见：OOP-18



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则将跳过对'static const'变量的检查。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用"protected"数据成员。保护数据
成员，当在其类中不可访问时，能被使用继承
的不受信任类直接访问。使用保护存取成员函
数能防止未经授权的访问。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
protected:
    int iProtectedData;  // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
private:
    int iPrivateData;
protected:
    const int accessData();  // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C) 2005 Pearson Education, Inc.
  第4章，第22项

2.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C) 2005 Pearson Education, Inc.
  章节：“类设计及继承”，第41条规则

3.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
  摘自：第7章 类 - 7.1 与访问权限相关的考虑 - 第22条规则

4.JOINT STRIKE FIGHTER， AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第67条

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-20</key>
<configkey>OOP-20</configkey>
<name><![CDATA[ 避免不不必要的从继承类到基类的显式类型转换 [OOP-20] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免不不必要的从继承类到基类的显式类型转换 [OOP-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免不不必要的从继承类到基类的显式类型转换。
本规则将检查你的代码是否有不必要的类型转换。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

显式地进行到基类型的类型的向上强制转换是不必
要的。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base { /* ... */ };
class Derived : public Base { /* ... */ };
void Func() {
   Derived *d = new Derived();
   Base *b = (Base *)d;		// Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base { /* ... */ };
class Derived : public Base { /* ... */ };
void Func() {
   Derived *d = new Derived();
   Base *b = d;			// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
第4.23章 类型转换，AV规则第181条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-21</key>
<configkey>OOP-21</configkey>
<name><![CDATA[ 如果子类型实现了虚拟函数，则应使用虚拟关键词 [OOP-21] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果子类型实现了虚拟函数，则应使用虚拟关键词 [OOP-21-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

任何时候使用虚拟关键词来在子类型中实现虚拟
函数都会使代码变得更易读，因为读者不必从基
类型中参考查看相关函数是否是虚拟的。本规则
能检查为使用虚拟关键词在子类型中实现虚拟函
数的情况。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

深层继承层次结构的直觉行为以及可读性，在使
用基类型中的虚拟函数时会在所有的集成类中维
持虚拟。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    virtual int foo( );
};

class B : public A {
public:
    int foo( );         // Violation
};

int B::foo() {
    return 5;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    virtual int foo( );
};

class B : public A {
public:
    virtual int foo( );         // OK
};

int B::foo() {
  return 5;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Herb Sutter，Andrei Alexandrescu，《C++编码规范》
  Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“类设计及继承”，第38条规则

2.MISRA C++：2008 - 在关键系统中使用C++语言的准则
  第6章，第10节，第10-3-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-22</key>
<configkey>OOP-22</configkey>
<name><![CDATA[ 在含有虚拟函数的基类型中使用的类应定义虚拟析构函数 [OOP-22] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在含有虚拟函数的基类型中使用的类应定义虚拟析构函数 [OOP-22-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有用作基类型并且含有虚拟函数的类
必须定义相应的虚拟析构函数。如果某
类含有虚拟函数但却没有虚拟析构函数
被用作了基类型，那么当使用指向该类
的指针时将会发生意外情况。如果将这
样的指针赋值给一个衍生类的实例并且
对该指针进行了删除操作，那么将仅调
用该基类型的析构函数。如果程序的运
行与否取决于该衍生类的析构函数，那
么该程序将无法运行。
参见：OOP-23，OOP-24，OOP-31



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

为了防止数据崩溃应定义一个虚拟析构
函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base            // Violation
{
    public:
        virtual void foo( );
        ~Base( );
};

class Derived : public Base{};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base           // OK
{
    public:
        virtual void foo( );
        virtual ~Base( );
};

class Derived : public Base{};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Ellemtel编码规范
  <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
 摘自：第7章 类 - 7.5 构造函数和析构函数 - 第26条规则

2.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第78条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-23</key>
<configkey>OOP-23</configkey>
<name><![CDATA[ 如果类中含有虚拟函数，那么它也应该包含虚拟析构函数 [OOP-23] ]]></name>
<tag>oop</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果类中含有虚拟函数，那么它也应该包含虚拟析构函数 [OOP-23-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在含有虚拟函数的类中声明虚拟析构函数将导致
编译器为每个类都从继承对象中调用析构函数。
本规则将检查您是否未为虚拟函数编写虚拟析构
函数。
参见：OOP-22，OOP-24，OOP-31



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止衍生类中的内存泄漏。含有虚拟函数的类倾
向于用作基类型，因此其应包含虚拟析构函数以
保证在通过指向该基类型的指针引用其衍生对象
时能调用相应的析构函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A        // Violation
{	
    public:
        ~A( );
        virtual int foo( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A         // OK
{	
    public:
        virtual ~A( );
        virtual int foo( );
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
第2章，第7项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-24</key>
<configkey>OOP-24</configkey>
<name><![CDATA[ 在基类型中将析构函数设置为虚拟 [OOP-24] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在基类型中将析构函数设置为虚拟 [OOP-24-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则验证基类型中的析构函数是否是虚拟的。
将析构函数定义为虚拟将通知编译器必须检查其
删除的对象以判断从何处开始调用析构函数。
参见：OOP-22，OOP-23，OOP-31



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止在基类型中使用非虚拟的析构函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class BaseB
{
    public:
        BaseB() {}
        ~BaseB() {}  // Violation
};

class Derived : public BaseB
{
    public:
        Derived() {};
        ~Derived() {};
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class BaseA 
{
    public:
        BaseA() {}
        virtual ~BaseA() {}    // OK
};

class Derived : public BaseA 
{
    public:
        Derived() {};
        ~Derived() {};
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,  第2章，第7项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
  章节：“构造函数，析构函数以及赋值运算符”，第14项

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-25</key>
<configkey>OOP-25</configkey>
<name><![CDATA[ 避免把虚函数声明为内联函数 [OOP-25] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免把虚函数声明为内联函数 [OOP-25-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

大多数的编译器实施虚拟表格 (virtual tables, vtbl) 来实
现虚函数. 每一个类应有1个 vtbl. 它应被保存在某个位
置. 它是根据编译器来决定的，但有些实现是将 vtbl 放
在包含最初定义的非内联和非纯虚函数的对象文件里.
如果所有的虚函数都是内联的，则编译器没有地方可以存放 vtbl
- 它会使用类的虚拟性来存放所有对象.
这将增加对象文件的大小.
最简单的方案就是不要内联虚函数.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在接口里定义的内联析构函数是允许的.
接口类的意思是指那些没有成员变量和所有
的成员函数(除了析构函数)是纯虚的类.
"所有析构函数的调用都是静态的，除了初
始化外. 如果不内联基类的虚析构函数的话
,我们无法充分利用. 如果这层级很深而且有
很多的对象消失, 会有很大的不同"


例外:

这条规则不会报告在模板函数里的违规.
编译器一定要知道模板函数的函数体. 它可以
将使用到的实例化和把实现放在每个对象里.
因此,移除内联并没有帮助，因为虚拟表格仍
然将使用到的放在每个对象里.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"类的vtbl的大小和类里声明的虚函数的数量
是成比例的 (包含那些从基类继承过来的).
每个类里应该只有一个虚拟表格，所以虚拟表
格需要的空间大小通常就没什么意义，但如果
你有大量的类或在每个类里有大量的虚函数，
你也许会发现 vtbls不经意的用完你的内存空间.
如果所有在类里的虚函数都定义为内联，大多数的
实现会依每个对象生成一个类的副本. 以大型的系
统来说，将导致程序包含数百甚至数千类的副本



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
   A(int i) : _i( i ) {}
   virtual ~A( ) {}         // 违规

private:
   int _i;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
public:
    A( int i ) : _i( i ) {}
    virtual ~A( );          // OK

private:
    int _i;
};

A::~A() { }



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: "Efficiency", 第 24 项

2. Josée Lajoie and Stanley Lippman, "Standard C++ Programming:
   Virtual Functions and Inlining", September 2000

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-26</key>
<configkey>OOP-26</configkey>
<name><![CDATA[ 禁止把指向派生类中对象的指针转化为指向虚基类的对象的指针 [OOP-26] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止把指向派生类中对象的指针转化为指向虚基类的对象的指针 [OOP-26-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"禁止把指向派生类中对象的指针转化为指向虚
基类的对象的指针."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则避免指向虚基类的指针转换.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {}; 
class Derived: virtual Base {};

void foo( ) {
    Base *b = 0;
    Derived *d = 0;
    b = (Base*) d;    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要把指向派生类中对象的指针转化为指向虚基
类的对象的指针.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Ellemtel 编码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 13 Type Conversions - 第 45 条规则

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-27</key>
<configkey>OOP-27</configkey>
<name><![CDATA[ 为带有引用成员或常量成员的类声明拷贝赋值操作符 [OOP-27] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
为带有引用成员或常量成员的类声明拷贝赋值操作符 [OOP-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果你要支持在包含引用成员的类里进行赋值，
你必须自己声明拷贝赋值操作符. 在有常量成员的
类里，编译器的动作是一样的. 修改常量成员是不
合法的，所以编译器不确定如何在背后生成的赋值
函数里处理它们. 最终，编译器拒绝了从声明私有拷
贝赋值操作符的基类中继承的派生类中隐式拷贝赋值
操作符. 终于，编译器生成给派生类的拷贝赋值操作
符也应处理基类的部分，但在这情况下，派生类一定
也就没有权限调用成员函数."
参见: CODSTA-CPP-02, CODSTA-CPP-21, CODSTA-CPP-24, MRM-04, MRM-37, MRM-40,
          MRM-47, OOP-30, OOP-34



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

支持在包含引用成员或常量成员间的赋值
操作.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Sample {                            // 违规
public:
    Sample( const int value );
    const int s;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Sample {                               // OK
public:
    Sample( const int value );  
    Sample&amp; operator=( Sample&amp; );
    const int s;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., 第 2 章节, 第 5 项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-28</key>
<configkey>OOP-28</configkey>
<name><![CDATA[ 不要把一个类的指针转换为另一个类的指针，除非前者是继承自后者的 [OOP-28] ]]></name>
<tag>oop</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要把一个类的指针转换为另一个类的指针，除非前者是继承自后者的 [OOP-28-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检测一个类的指针转换到另一个不是从第二个类 
继承过来的类.
如此 "不正确" 的向下转换可能导致野指针和其他问题.
使用虚函数调用来替代.
参见: MISRA2004-11_4



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则避免内存和数据损坏. 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {}; 
class B {}; 
class D : public B {}; 

void main( )
{ 
    A *a; 
    B *b; 
    D *d; 
    b = (B*) a; // 违规 
    d = (D*) b; // 违规 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {}; 
class B {}; 
class D : public B {}; 

void main( )
{ 
    A *a; 
    B *b; 
    D *d; 
    b = (B*) d; // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-29</key>
<configkey>OOP-29</configkey>
<name><![CDATA[ 指向抽象类的指针不能被转换为指向继承于该类的子类的指针 [OOP-29] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指向抽象类的指针不能被转换为指向继承于该类的子类的指针 [OOP-29-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则将报告将指向抽象类的指针强制转换为指向继承于
该类的子类的指针的违规。
参见：OOP-49，OOP-50



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止非法类型转换并确保抽象层未被旁路掉。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B
{
    public:
    virtual int foo( ) = 0;
};

class D : public B
{
    public:
    int foo( );
};
 
void main( )
{
    B *b;
    D *d;
    d = (D*) b; // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止将指向抽象类的指针强制转换为指向继承
于该类的子类的指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-30</key>
<configkey>OOP-30</configkey>
<name><![CDATA[ 未在类中声明复制构造函数以及拷贝赋值运算符为私有，而在特殊设计的基类型中进行声明 [OOP-30] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
未在类中声明复制构造函数以及拷贝赋值运算符为私有，而在特殊设计的基类型中进行声明 [OOP-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“通过在经特殊设计能防止复制的基类型中声明复制
析构函数以及拷贝赋值运算符能将连接时错误上移至
编译时错误（这是有好处的，尽早发现错误比晚期发
现错误更好）。
这样的做法是管用的，因为编译器会试图为试图拷贝
类对象的类生成复制构造函数以及拷贝赋值运算符 -
即使是成员或友元函数”
参见：CODSTA-CPP-02，CODSTA-CPP-19，CODSTA-CPP-21，
         CODSTA-CPP-24，MRM-04，MRM-05，MRM-37，MRM-38，
         MRM-40，MRM-47，MRM-48，OOP-27，OOP-34



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“编译器生成的这些函数会试图调用与其基类型对应
的函数，这些调用将会被拒绝，因为在基类型中复制
操作是私有的”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class HomeForSale {
    public:
        HomeForSale();
    private:
        HomeForSale(const HomeForSale&amp;);            // Violation
        HomeForSale&amp; operator=(const HomeForSale&amp;);  // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Uncopyable {
    protected: 
        Uncopyable() {} 
        ~Uncopyable() {} 
    private:
        Uncopyable(const Uncopyable&amp;);              // OK
        Uncopyable&amp; operator=(const Uncopyable&amp;);   // OK
};

class HomeForSale2 : private Uncopyable { };    



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  第2章，第6项

2.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第68条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-31</key>
<configkey>OOP-31</configkey>
<name><![CDATA[ 将基类型的析构函数设置为共有且虚拟的，或保护及非虚拟的 [OOP-31] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
将基类型的析构函数设置为共有且虚拟的，或保护及非虚拟的 [OOP-31-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果允许通过指向基类型的指针进行删除，
那么积累性中的析构函数必须是公有且虚拟的。
否则，其应具有非保护和非虚拟的属性。”
参见：OOP-22，OOP-23，OOP-24


例外：

基类型无虚拟函数并不应有多态的应用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能预防删除时对指向衍生类的基类型指针
的未定义行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {
public:
    virtual int foo();
    ~Base();  // Violation
};
class Derived : public Base {};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    virtual int foo();
protected:
    ~Base();  // OK
};
class Derived : public Base {};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
Herb Sutter，Andrei Alexandrescu，《C++编码规范》
Addison-Wesley，(C)2005 Pearson Education, Inc.
章节：“构造，析构以及复制”，第50条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-32</key>
<configkey>OOP-32</configkey>
<name><![CDATA[ 禁止对继承的非虚拟函数进行重定义 [OOP-32] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对继承的非虚拟函数进行重定义 [OOP-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“非虚拟函数是静态约束的。从本质上讲，非虚拟函数
会隐藏起相应的基类型版本。因此，某个特定的衍生类
对象将表现为一个基类型对象或者一个取决于其访问方
式的衍生类对象 - 通过基类型指针/引用或者衍生类的
指针/引用。为了避免出现具有二元性的行为，禁止对非
虚拟函数进行重定义。”
参见：OOP-33



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
本规则报告无模板参数的函数的违规。
OOP-33规则报告具有模板参数的函数的违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止对调用函数的错误解释。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base
{
    public:
        void func1(void) {};
        void func2(int x) {};
        void func3(int x) {};
};

class Derived: public Base
{
    public:
        void func1(void) {};    // Violation
        void func2(int x) {};   // Violation
        void func3(int x) {};   // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base
{
    public:
        virtual void func1(void) {};
        virtual void func2(int x) {};
        void func3(int x) {};
};

class Derived: public Base
{
    public:
        virtual void func1(void) {};    // OK
        virtual void func2(int x) {};   // OK
        void func3_renamed(int x) {};   // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  第6章，第36项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  章节：“继承与面向对象的设计”，第37项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章，类，AV规则第94条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-33</key>
<configkey>OOP-33</configkey>
<name><![CDATA[ 禁止对含有模板参数的继承非虚拟函数进行重定义 [OOP-33] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对含有模板参数的继承非虚拟函数进行重定义 [OOP-33-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“非虚拟函数是静态约束的。从本质上讲，非虚拟函数
会隐藏其相应的基类型版本。因此，某个特定的衍生类
对象可能表现为一个基类型对象或者取决于其访问方式
的衍生类对象 - 通过基类型指针/引用或者衍生类指针/引用。
为了避免这种具有二义性的行为，禁止对虚拟函数进行
重定义。”
参见：OOP-32



</PRE>
<STRONG>
注意
</STRONG>
<PRE>
本规则报告具有模板参数的函数的违规。
OOP-32规则报告无模板参数的函数的违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则预防对调用函数进行错误解释。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template &lt;class T&gt; class Base
{
    public:
        void foo1(T i) {}
        void foo2(T i) {}
        void foo3(T i) {}
};

template &lt;class T&gt; class Derived : public Base &lt;T&gt;
{
    public:
        void foo1(int i) {} // Violation
        void foo2(T i) {}   // Violation
        void foo3(T i) {}   // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

template &lt;class T&gt; class Base
{
    public:
        virtual void foo1(T i) {}
        virtual void foo2(T i) {}
        void foo3(T i) {}
};

template &lt;class T&gt; class Derived : public Base &lt;T&gt;
{
    public:
        virtual void foo1(int i) {} // OK
        virtual void foo2(T i) {}   // OK
        void foo3_renamed(T i) {}   // OK
};


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  第6章，第36项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
  章节：“继承与面向对象的设计”，第37项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第94条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-34</key>
<configkey>OOP-34</configkey>
<name><![CDATA[ 在运算符=中检查自身赋值操作 [OOP-34] ]]></name>
<tag>oop</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在运算符=中检查自身赋值操作 [OOP-34-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

本规则检查代码中赋值运算符中使用的别名。不对
=运算符的自身赋值进行检查会释放资源，而这些资
源在分配新资源过程中可能会被用到。
参见：CODSTA-CPP-02，CODSTA-CPP-21，CODSTA-CPP-24，
      MRM-04，MRM-37，MRM-40，MRM-47，OOP-27，OOP-30



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

检查自身赋值的情况可能帮助您节省很多在实现赋值时
不得不做的工作。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A  {
public:
    A( ) { }
    A&amp; operator=( A&amp; a ) {  // Violation
        return *this;
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A  {
public:
    A( ) { }
    A&amp; operator=( A&amp; a ) {  // OK
        if (&amp;a != this) {
            // ...
        }
        return *this;
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的55种特定方法》
  第三版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   第2章，第11项

2.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education, Inc.,
   章节：“构造函数，析构函数以及赋值运算符”，第17项

3.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第81条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-35</key>
<configkey>OOP-35</configkey>
<name><![CDATA[ 避免继承层次结构向下的类型转换 [OOP-35] ]]></name>
<tag>oop</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免继承层次结构向下的类型转换 [OOP-35-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免对继承的层次结构进行向下类型转换。
本规则检查出从基类型指针到子类型指针的类型转换。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

允许继承的层次结构向下的类型转换会造成维护性方面
的问题，并且对基类型进行的下向类型转化是非法的。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {};
class Derived: public Base {};
class Derived2: public Derived {};

void foo() {
    Base *pb;
    Derived *pd = (Derived *) pb;       // Violation

    Base *pb2;
    Derived *pd2 = (Derived2 *) pb2;    // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {};
void foo() {
    Base *pb0;
    Base *pd0 = (Base *) pb0;           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.Scott Meyers，《高效C++：改善程序及设计的50种特定方法》
  第二版，Addison-Wesley，(C)2005 Pearson Education. Inc.,
   章节：“继承与面向对象的设计”，第39项

2.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.23章 类型转换，AV规则第178条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-36</key>
<configkey>OOP-36</configkey>
<name><![CDATA[ Public 成员函数不得返回指向 private/protected 类数据的非 const 句柄(引用或指针) [OOP-36] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Public 成员函数不得返回指向 private/protected 类数据的非 const 句柄(引用或指针) [OOP-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"通过实施与成员函数类接口的实现，保留更
多在对象状态如何修改和协助允许在不影响调
用端的情况来维护类的控制. 返回的类数据句
柄允许调用端在不使用任何的接口情况下，而
对对象的状态做变更."
此规则会在受公共成员函数返回非常量引用 
或指向私有/受保护的类数据的指针时报违规.
参见: CODSTA-CPP-06, CODSTA-CPP-77, OOP-12



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

类数据句柄是指:
- 指向成员变量/成员函数的引用
- 指向成员变量/成员函数的指针
- 指向在构造函数分配或在析构函数释放的数据的指针/引用
静态变量不列为类数据.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则改善封装和避免数据不在类设计的方式下进行 
变更.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Test
{
    public:
        Test()
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        int* GetI1()
        {
            return &amp;_i; // 违规
        }
        int&amp; GetI2()
        {
            return _i; // 违规
        }
        int * GetI3()
        {
            return _k; // 违规
        }
    private:
        int _i;
        int * _k;
};
void foo()
{
    Test t;
    *(t.GetI1()) = 0; // Encapsulation broken - possible to change private class data
    t.GetI2() = 0; // Encapsulation broken - possible to change private class data
    *(t.GetI3()) = 0; // Encapsulation broken - possible to change private class data
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Test
{
    public:
        Test()
        {
            _k = new int; // makes data pointed by _k a "class-data"
        }
        const int* GetI1()
        {
            return &amp;_i; // OK
        }
        const int&amp; GetI2()
        {
            return _i; // OK
        }
        const int * GetI3()
        {
            return _k; // OK
        }
    private:
        int _i;
        int * _k;
};
void foo()
{
    Test t;
    // *(t.GetI1()) = 0; // Not compilable - not possible to change private class data
    // t.GetI2() = 0; // Not compilable - not possible to change private class data
    // *(t.GetI3()) = 0; // Not compilable - not possible to change private class data
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 30 项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Implementation", 第 29 项

3. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 5 章节, 第 28 项

4. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Class Design and Inheritance", 第 42 条规则

5. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 7 Classes - 7.8 Member Function Return Types - Rule 29

6. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章节, 第 9 部分, 第 9-3-2 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-37</key>
<configkey>OOP-37</configkey>
<name><![CDATA[ 不使用继承的时候，最好使用复合关系 [OOP-37] ]]></name>
<tag>oop</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不使用继承的时候，最好使用复合关系 [OOP-37-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

我们在C++语言里表达接近最好的关联就是继承，
它仅在没有等效较弱的替代方式时是恰当的.
"如果你能将类的关系单独的用组合的方式表达，
你则应该使用."
你应避免使用继承，除非你必须:
- 覆写虚函数
- 存取受保护的成员
参见: OOP-14



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规范提升较好的灵活性，编译期的隔离，可以有 
较短的编译时间和更少的问题.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Base {
public:
    virtual int virtualFoo( );
    int publicData;
protected:
    int protectedData;
};

class DerivedA : public Base {  // 违规
public:
    virtual int moo();
};

class DerivedB : public Base {  // 违规
public:
    virtual int virtualMoo( ) {
        publicData = 0;
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Base {
public:
    virtual int virtualFoo( );
    int publicData;
protected:
    int protectedData;
};

class DerivedA : public Base {  // OK
public:
    virtual int virtualFoo( );
};

class DerivedB : public Base {  // OK
public:
    int virtualMoo( ) {
        return protectedData;
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
章节: "Class Design and Inheritance", 第 34 条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-38</key>
<configkey>OOP-38</configkey>
<name><![CDATA[ 如果调用了某个类的析构函数并且该类含有虚拟函数，那么该类也应该含有虚拟析构函数 [OOP-38] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果调用了某个类的析构函数并且该类含有虚拟函数，那么该类也应该含有虚拟析构函数 [OOP-38-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在含有虚拟函数的类中定义虚拟析构函数会造成
编译器为其继承的对象中的每个类都调用析构函
数的情形。如果莫个类含有虚拟函数，没有虚拟
析构函数，并且调用了类的析构函数，那么本规
则将报告违规信息。
参见：OOP-23



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防衍生类中的内存泄漏。具有虚拟函数的类倾
向于用作基类型，因此其应含有虚拟析构函数以
确保当通过指向基类型的指针来引用衍生对象时
能够调用该析构函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A        
{	
    public:
        ~A( );              // Violation
        virtual int foo( );
};

void foo1(A* a)
{
    delete a;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A         
{	
    public:
        virtual ~A( );      // OK
        virtual int foo( );
};

void foo1(A* a)
{
    delete a;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐。

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-39</key>
<configkey>OOP-39</configkey>
<name><![CDATA[ 有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明 [OOP-39] ]]></name>
<tag>oop</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明 [OOP-39-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有状态的虚拟类应该在每个访问该类的衍生类中进行
显式地声明。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“在层次结构（使用该类）的每个级别上显式地声明
有状态的虚拟类，值得指出的是，不应对独占使用虚
拟类中的数据作出任何的假设。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class AA {};
class BB : virtual AA {};
class CC : virtual AA {};
class DD : BB{};          // Violation
class EE : CC{};          // Violation
class FF : DD{};          // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class AA {};
class BB : virtual AA {};
class CC : virtual AA {};
class DD : BB, virtual AA {};     // OK
class EE : CC, virtual AA {};     // OK
class FF : DD, EE, virtual AA {}; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范 
   第4.10章 类，AV规则第88.1条

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-40</key>
<configkey>OOP-40</configkey>
<name><![CDATA[ 层次结构应该基于抽象类 [OOP-40] ]]></name>
<tag>oop</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
层次结构应该基于抽象类 [OOP-40-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

公有的继承层次结构应该从抽象类开始。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

基于抽象类的层次结构倾向于关注能够生
成干净接口的设计，将实现细节从接口中
剥除，并且能减小编译的依赖性同时允许
与不同实现的共存。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B
{
};

class A: public B // Violation
{

};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B
{
public:
  virtual int foo()=0;
  /* ... */
};


class A: public B // OK
{
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
第4.10章，AV规则第87条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-41</key>
<configkey>OOP-41</configkey>
<name><![CDATA[ 在同一层次结构中，基类型不能同时具有虚拟及非虚拟的属性 [OOP-41] ]]></name>
<tag>oop</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在同一层次结构中，基类型不能同时具有虚拟及非虚拟的属性 [OOP-41-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在同一层次结构中一个基类型不能同时具有虚拟
及非虚拟的属性。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

层次结构更易于理解及使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {};
class B : virtual A {};
class C : B, A {};           // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {};
class B : virtual A {};
class C : B, virtual A {};   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.10章 类，AV规则第89条

2.MISRA C++：2008 - 在关键系统中使用C++语言的准则
  第6章，第10节，第10-1-3规则

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-42</key>
<configkey>OOP-42</configkey>
<name><![CDATA[ 在抽象类中，拷贝赋值运算符应该被声明为保护及私有 [OOP-42] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在抽象类中，拷贝赋值运算符应该被声明为保护及私有 [OOP-42-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“抽象类代表了层次结构的接口部分。
在这类层次结构顶层调用拷贝赋值运算
符会旁路掉潜在实现，从而导致仅有基
子类型被复制。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2


</PRE>
<STRONG>
注意
</STRONG>
<PRE>

用户定义的拷贝赋值运算符X::operator=
是类X的非静态、非模板成员函数，该类
仅有一个类型为X，X&amp;，常数X&amp;，非易失性
X&amp;或常数非易失性X&amp;的参数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“将抽象拷贝赋值运算符设置为保护类型
将允许从衍生类而非层次结构之外进行访
问。将拷贝赋值运算符设置为私有是一个
常用的限制拷贝该类类型的方法。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32_t;
class B1
{
    public:
        virtual void f( ) = 0;
        B1 &amp; operator= ( B1 const &amp; rhs );          // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int32_t;
class B1
{
    public:
        virtual void f( ) = 0;
    protected:
        B1 &amp; operator= ( B1 const &amp; rhs );          // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++：2008 在关键系统中使用C++语言的准则
第6章，第12节，第12-8-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-43</key>
<configkey>OOP-43</configkey>
<name><![CDATA[ 虚拟函数仅能被自身声明为纯虚拟的纯虚拟函数进行覆盖 [OOP-43] ]]></name>
<tag>oop</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
虚拟函数仅能被自身声明为纯虚拟的纯虚拟函数进行覆盖 [OOP-43-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“虚拟函数仅能被自身声明为纯虚拟的纯虚拟
函数进行覆盖”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止编写出与开发者本意向未被的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
    public:
    virtual void foo ( );
};
class B: public A
{
    public:
    virtual void foo ( ) = 0; // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止使用纯虚拟函数覆盖非纯虚拟函数



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 在关键系统中使用C++语言的准则
第6章，第10节，第10-3-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-44</key>
<configkey>OOP-44</configkey>
<name><![CDATA[ 在继承层次结构中，其每条路径中的每个虚拟函数应该有多个定义 [OOP-44] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在继承层次结构中，其每条路径中的每个虚拟函数应该有多个定义 [OOP-44-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“通过确保在类层次结构中的任意一点执行相应
函数的明确性，本规则的主要目的是为代码维护
人员及复审人员增强透明度。”


例外：

“在类层次结构中的多个成员中析构函数可以被
声明为虚拟。如果一个函数被声明为抽象的并且
在同一类中进行定义，那么将被本规则忽略。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“此外，菱形层次结构中的类被其属主（dominance）
调用可能会引起调用与开发者本意不相符的函数。本规则防止属主的调用。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* Examples of incorrect code */
class A
{
    public:
        virtual void f1 ( );
        virtual void f2 ( ) { }
};
void A::f1 ( )
{
}

class B : public A
{
    public:
        virtual void f1 ( ) { }  // Violation
        virtual void f2 ( );
};
void B::f2 ( )                   // Violation
{
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Examples of correct code */
class A
{
    public:
        virtual void f1 ( );
        virtual void f2 ( ) = 0;
        virtual ~A(){}
};
void A::f2 ( )
{
}

class B : public A
{
    public:
        virtual void f1 ( ) { }  // OK
        virtual void f2 ( );
        virtual ~B(){}           // OK
};
void B::f2 ( )                   // OK
{
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++：2008 在关键系统中使用C++语言的准则
第6章，第10节，第10-3-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-45</key>
<configkey>OOP-45</configkey>
<name><![CDATA[ 具有单一基本类型参数可调用的构造函数应该显式地声明 [OOP-45] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
具有单一基本类型参数可调用的构造函数应该显式地声明 [OOP-45-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“具有单一基本类型参数可调用的构造函数应
该显式地声明。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

基本类型包括如下一些：bool，char，short，vint，
long，long long，float，double，long double，wchar_t。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止构造函数被隐式地从基本类型转换为
类类型。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C
{
    public:
        C ( int a ) // Violation
        {
        }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C
{
    public:
        explicit C ( int a ) // OK
        {
        }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 在关键系统中使用C++语言的准则
第6章，第12节，第12-1-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-46</key>
<configkey>OOP-46</configkey>
<name><![CDATA[ 拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化 [OOP-46] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化 [OOP-46-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果编译器实现检测到了对某个拷贝构造函
数的调用是冗余的，则允许省略该调用，即使
该拷贝构造函数具有除构造该对象的拷贝的其
它副作用。”
本规则能报告出是否发现了全局或静态成员变
量在拷贝构造函数中发生了修改。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

本规则仅能监测处嵌套级数为一的函数调用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“因此，确保拷贝构造函数不会对程序状态进
行修改是相当重要的，因为这样的修改的影响
可能是不确定的。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
public:
    A ( A const &amp; rhs )
    : m_i ( rhs.m_i )
    {
         ++m_static;   // Violation
    }
private:
    int m_i;
    static int m_static;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止在拷贝构造函数内修改全局或静态成员变量。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++：2008 在关键系统中使用C++语言的准则
第6章，第12节，第12-8-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-47</key>
<configkey>OOP-47</configkey>
<name><![CDATA[ 类不能从虚拟基类型中衍生 [OOP-47] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
类不能从虚拟基类型中衍生 [OOP-47-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“不推荐使用虚拟基类型。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用虚拟基类型可能引起
一系列的未定义及潜在混淆
的行为。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B {};
class D: public virtual B {}; // Violation



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止从虚拟基类型进行继承



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - 在关键系统中使用C++语言的准则
第6章，第10节，第10-1-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-48</key>
<configkey>OOP-48</configkey>
<name><![CDATA[ 非POD类类型中的成员数据应具有私有的属性 [OOP-48] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
非POD类类型中的成员数据应具有私有的属性 [OOP-48-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“非POD类类型的成员数据应具有私有的属性。”
非POD类类型应至少满足下述条件之一：
-是一个类（不是PODs的类）
-是一个具有下列属性的结构体/联合体：
 +具有用户定义的构造函数
 +具有私有或保护的数据成员
 +具有基类型
 +具有虚拟函数
 +具有带有非POD类型的非静态成员（或非POD数组）
 +具有带有类引用的非静态成员
 +具有用户声明的拷贝赋值运算符
 +具有用户声明的析构函数



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“通过实现带有成员函数的类接口，
该实现将能更多地掌控如何修改对象
的状态，并允许在不影响客户端的前
提下对类进行维护。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int int32_t;
class C
{
    public:
        int32_t b; // Violation
    protected:
        int32_t c; // Violation
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef signed int int32_t;
class C
{
    private:
        int32_t b; // OK
        int32_t c; // OK
    protected:
        const int32_t access_b();
        const int32_t access_c();
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - 在关键系统中使用C++语言的准则
第6章，第11节，第11-0-1条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-49</key>
<configkey>OOP-49</configkey>
<name><![CDATA[ 禁止对多态类型进行从基类型到衍生类的类型转换 [OOP-49] ]]></name>
<tag>oop</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对多态类型进行从基类型到衍生类的类型转换 [OOP-49-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“下向类型转换指一个类类型转换为其衍生类的行为。
多台现象是接口和层次结构实现的强抽象。显式类型转
换会旁路抽象层，造成更高层级的相关性耦合。”
“从基类型到衍生类的类型转换是危险的，除非提供一
种多态机制类确保该类型转换是合法的。”
参见：OOP-29，OOP-50



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止非法类型转换并确保抽象层不会被旁路掉。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class B
{
    public:
    virtual int foo( );
};

class D : public B
{
    public:
    int foo( );
};
 
void main( )
{
    B *b;
    D *d;
    d = (D*) b; // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

禁止将指向基类型的指针转换为指向其衍生类的
指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - 在关键系统中使用C++语言的准则
第6章，第5节，第5-2-3条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-50</key>
<configkey>OOP-50</configkey>
<name><![CDATA[ 指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针 [OOP-50] ]]></name>
<tag>oop</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针 [OOP-50-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“由于继承的虚拟性不属于其基类型，
因此其衍生类对象的规划，通过虚拟基
类型的指针，在编译时是未知的。”
“采用除dynamic_cast外的其它方式进
行从虚拟基类型到衍生类的类型转换会
引起未定义的行为。”
参见：OOP-29，OOP-49



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

本规则能防止未定义行为的发生。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// The code is not compilable with all compilers
class B { 
public:
	virtual int foo();
};
class D: public virtual B {
public:
	virtual int foo(){}
};
void fun(){
    D d;
    B *pB = &amp;d;
    D *pD = static_cast&lt;D*&gt;(pB);  // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class B { 
public:
	virtual int foo();
};
class D: public virtual B {
public:
	virtual int foo(){}
};
void fun(){
    D d;
    B *pB = &amp;d;
    D *pD = dynamic_cast&lt;D*&gt;(pB);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1.JOINT STRIKE FIGHTER，AIR VEHICLE，C++编码规范
  第4.23章 类型转换，AV规则第179条

2.MISRA C++:2008 - 在关键系统中使用C++语言的准则
  第6章，第5节，第5-2-2条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OOP-51</key>
<configkey>OOP-51</configkey>
<name><![CDATA[ 使用命名空间而不是类或只包含静态的功能结构体 [OOP-51] ]]></name>
<tag>oop</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用命名空间而不是类或只包含静态的功能结构体 [OOP-51-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用命名空间来替代仅包含静态函数的类或结构体.
此规则在找到非模板类仅包含静态函数，且没有从任
何基类继承过来的话会报告违规.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则避免创建不必要的对象.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A{                     // 违规
    static void foo(){}
};

void foo(){
    A a;
    a.foo();
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace A{                 // OK
    void foo(){}
};

void foo(){
    A::foo();
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-01</key>
<configkey>OPT-01</configkey>
<name><![CDATA[ 尽可能地声明局部化的变量 [OPT-01] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽可能地声明局部化的变量 [OPT-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“变量应该在尽可能小的范围内声明，以改善 
代码的可读性，以便变量不是没有必要分配的。 
当一个变量在一个函数的开头声明却在代码的 
其他地方使用时，并不容易直接看到此变量
的类型。
此外，还有一个风险就是如果一个变量和声明在内部块的
局部变量同名，那么此变量将会无意中被隐藏。

许多局部变量只被用在很少发生的特殊情况中。 
如果一个变量被声明在外层，  
即使它不被使用也将分配内存。此外，当变量
在声明时就被初始化，可以获得比变量在使用时赋值 
更加高效的代码。”



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止使程序更难理解和维护。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int a;      // 违规
    {
        a = 0;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    {
        int a;  // OK
        a = 0;
    }
    int b;      // OK
    if (b&gt;0) {
        b = -1;
    } else {
        b = 1;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编码规范  
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#11</A>
   出自: 11 Variables - 第 41 条规则

2. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范” Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Coding Style", 第 18 条规则

3. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 3 节, 规则 3-4-1

4. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 6

5. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-02</key>
<configkey>OPT-02</configkey>
<name><![CDATA[ 避免未使用的局部变量 [OPT-02] ]]></name>
<tag>opt</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免未使用的局部变量 [OPT-02-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否所有声明的局部变量都被使用了。如果一个变量
在函数体内部的定义之后被找到，则此规则判断使用的是
一个局部变量。
参见: OPT-03, OPT-06



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

对象能够在其构造函数中执行一些操作。即使它们
在不使用之后也可能在创建过程中发挥作用。此规则 
不考虑这种对象为“已使用”并报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

消除未使用的局部变量提高效率和易读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    void displBalance();
};

void foo( ) {
    A a;        // 违规 
}

int func(int j) {
    int i = 0;  // 违规
    return j;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    void displBalance( );
};

void foo( ) {
    A a;
    a.displBalance( );  // OK
}

int func(int j) {
    int i = j + 1;      // OK
    return i;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 0 节, 规则 0-1-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-03</key>
<configkey>OPT-03</configkey>
<name><![CDATA[ 不应存在未使用的参数 [OPT-03] ]]></name>
<tag>opt</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应存在未使用的参数 [OPT-03-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当参数在函数体内部未使用时此规则报告 
违规。 建议删除未使用的参数或者忽略 
它们的名字 (可能只在 C++ 语言中)。 


例外:

此规则不会在虚函数和用来作为回调的函数上
报告违规。(函数地址是取自编译单元)。
此规则也不会在未命名参数上报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高易读性并提升了代码效率。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int i, int k) {      // 违规
    i = 5 * i;
    return i;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int i) {      // OK
    i = 5 * i;
    return i;
}

// Exceptions

class A {
public:
    virtual void foo(int a);
};

void A::foo(int a){          // OK - virtual function
}

int callback(int a, int b){} // OK - address of function is taken

void useCb(){
    int(*fp)(int, int);
    fp = callback;
}

int unpar(int a, int){       // OK - unnamed parameter
    a++;
    return a;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve
   Your Programs and Designs", Addison Wesley, (31 Mar 1996), Item 6

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-04</key>
<configkey>OPT-04</configkey>
<name><![CDATA[ 规范使用 ++ 和 --。尽量使用前缀形式 [OPT-04] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
规范使用 ++ 和 --。尽量使用前缀形式 [OPT-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在调用代码时, 通常都使用前缀形式除非你确实需要返回后缀形式原始值.
就想键入的字符多少一样前缀形式在语意上和后缀形式是一样的, 
而且可以提高效率.这不是提早优化而是避免提早劣化"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用规则可以避免后缀形式在被使用时必须有变量 
或对象的副本这种潜在低效执行.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class SampleMemberO {
public:
    SampleMemberO&amp; operator++();               
    SampleMemberO&amp; operator++(int x);          
};

class SampleGlobalO {};
SampleGlobalO&amp; operator++( SampleGlobalO&amp; t );        
SampleGlobalO&amp; operator++( SampleGlobalO&amp; t, int x ); 

void myFunction()
{
    SampleMemberO obj_MemberO;                          
    SampleGlobalO obj_GlobalO;
    
    obj_MemberO++;                             // 违规
    obj_GlobalO++;                             // 违规

    int i=0;
    i++;                                       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class SampleMemberO {
public:
    int m;
    SampleMemberO&amp; operator++();               
    SampleMemberO&amp; operator++(int x);          
};

class SampleGlobalO {};
SampleGlobalO&amp; operator++( SampleGlobalO&amp; t );        
SampleGlobalO&amp; operator++( SampleGlobalO&amp; t, int x ); 

void myFunction()
{
    SampleMemberO obj_MemberO;                          
    SampleGlobalO obj_GlobalO;
    
    ++obj_MemberO;                             // OK
    ++obj_GlobalO;                             // OK
    
    int i=0;
    ++i;                                       // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Functions and Operators", 规则 28

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Design Style", 规则 09

3. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: "Operators", 项 6

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-05</key>
<configkey>OPT-05</configkey>
<name><![CDATA[ 不应存在未使用的私有成员变量 [OPT-05] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应存在未使用的私有成员变量 [OPT-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果在代码中有没使用的私有成员变量，规则将报告违规。 
在构造函数列表中的初始化不作为一个变量的使用。
这条规则只适用于 C++ 语言.



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果类中包含一个不可访问的成员方法 
此规则不报告违规. 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

消除未使用的私有成员变量
提高易读性和效率.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
   A();
   int foo(A a);
private:
   int x; // Violation  
   int y; // Violation        
   int z; // Violation
};

// initialization is not detected as use
A::A() : x (0), y(1), z (2) {  
}

int A::foo(A a){
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
   A();
   int foo(A a);
private:
   int x; // OK  
   int y; // OK        
   int z; // OK
};

A::A() : x (0), y(1), z (2) {  
}

int A::foo(A a){
    x = a.y + this-&gt;z;    
    return x;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-06</key>
<configkey>OPT-06</configkey>
<name><![CDATA[ 避免不必要的局部变量 [OPT-06] ]]></name>
<tag>opt</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免不必要的局部变量 [OPT-06-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检查是否有任何声明的局部变量未使用
或没有副作用。
参见: OPT-02



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则不在有显式声明的构造函数或析构函数
type class/struct 的变量上报告违规。


优点:

消除未使用的局部变量提高效率和易读性。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

消除未使用的局部变量提高效率和易读性。
说明:

如果一个声明的局部变量在一个函数体内部
没有被使用，或者只在删除后却不改变函数功能
的表达式中使用时，此规则将报告一个违规。
参见: OPT-02



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

当变量只在 asm （汇编语言）程序块中使用
和文件是使用gcc来编译的，规则也可能误报。


示例:

void func() {
    int i = 0;    // 违规
}

int i = 0;
class A {
public:
    A(){};
};

class B {
public:
    B(){i++;};
};

void goo() {
    A a;	// 违规
    B b;	// OK
}


修复:

void func() { // OK
}

int i = 0;
class A {
public:
    A(){};
};

class B {
public:
    B(){i++;};
};

void goo() {  // OK
    B b;
}


参考资料:

1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 0 节, 规则 0-1-3

</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
};

int func(int p) {
    A a;       // 违规
    int i = 0; // 违规
    i = p;
    i++;
    return p;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A();
};

int func(int p) {
    A a;       // OK - implicit call of constructor can cause additional action
    int i = 0; // OK
    i = p;
    i++;
    return i;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 0 节, 规则 0-1-3


</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-07</key>
<configkey>OPT-07</configkey>
<name><![CDATA[ 尽量使用 "a @= b" 的形式，而不应使用 "a = a @ b"，其中 "@" 可以是 +, -, *, /, % [OPT-07] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽量使用 "a @= b" 的形式，而不应使用 "a = a @ b"，其中 "@" 可以是 +, -, *, /, % [OPT-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

尽量使用 "a @= b" 的形式，而不应使用 "a = a @ b"，其中 "@" 可以是 +, -, *, /, %.
参见: OPT-08



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可以提高代码易读性增加效率.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x, int y ) {
    x = x + 2; // 违规
    x = x - 2; // 违规
    x = x * 2; // 违规
    x = x / 2; // 违规
    x = x % 2; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x, int y ) {
    x += 2;    // OK
    x -= 2;    // OK
    x *= 2;    // OK
    x /= 2;    // OK
    x %= 2;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-08</key>
<configkey>OPT-08</configkey>
<name><![CDATA[ 尽量使用 "a @= b" 的形式，而不应使用 "a = a @ b"，其中 "@" 可以是 &, |, ^, <<, >> [OPT-08] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽量使用 "a @= b" 的形式，而不应使用 "a = a @ b"，其中 "@" 可以是 &amp;, |, ^, &lt;&lt;, &gt;&gt; [OPT-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

尽量使用 "a @= b" 的形式，而不应使用 "a = a @ b"，其中 "@" 可以是 &amp;, |, ^, &lt;&lt;, &gt;&gt;.
参加: OPT-07



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则能提高代码易读性增加效率.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int x, int y ) {
    x = x &amp; 2; // 违规
    x = x | 2; // 违规
    x = x ^ 2; // 违规
    x = x &lt;&lt; 2; // 违规
    x = x &gt;&gt; 2; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( int x, int y ) {
    x &amp;= 2;    // OK
    x |= 2;    // OK
    x ^= 2;    // OK
    x &lt;&lt;= 2;    // OK
    x &gt;&gt;= 2;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-09</key>
<configkey>OPT-09</configkey>
<name><![CDATA[ 删除布尔函数中不必要的 '== true' [OPT-09] ]]></name>
<tag>opt</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
删除布尔函数中不必要的 '== true' [OPT-09-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测代码中是否包含不必要的 "==true".



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

检测布尔表达式为真不是必要的. 
删除不必要的 "== true" 增加易读性提高效率.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

bool isPositive(int a);

bool foo() 
{
    return isPositive(5) == true;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

bool isPositive(int a);

bool foo1() 
{
    return isPositive(5);        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-10</key>
<configkey>OPT-10</configkey>
<name><![CDATA[ 不要在 "if", "for", "while", 和 "do while" 语句中声明变量 [OPT-10] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在 "if", "for", "while", 和 "do while" 语句中声明变量 [OPT-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要在 "if", "for", "while", 和 "do while" 中声明变量.
因为这样的声明会由于全局范围中也隐含了相同命名的变量而导致混乱.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则防止代码编写的不明确.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int bar( int&amp; x );
int lookup( int&amp; x );

void foo( int x ){
    if (x == 0) {
        int y;         // 违规
        y = bar(x);
    }
    for (x = 0; x &lt; 2;x++) {
        int y;         // 违规
        y = lookup(x);
        bar(y);
    }
    while (x &lt; 0) {
        int y;         // 违规
        y = bar(x);
    }
    do {
        int y;         // 违规
        y = bar(x);
    } while (x &lt; 0);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int bar( int&amp; x );
int lookup( int&amp; x );

void foo( int x ){
    int y;            // OK
    if (x == 0) {
        y = bar(x);
    }
    for (x = 0; x &lt; 2;x++) {
        y = lookup(x);
        bar(y);
    }
    while (x &lt; 0) {
        y = bar(x);
    }
    do {
        y = bar(x);
    } while (x &lt; 0);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-11</key>
<configkey>OPT-11</configkey>
<name><![CDATA[ 如果一个文件级的静态变量仅在一个函数中被使用/引用，就应该只在该函数内部包含此变量 [OPT-11] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个文件级的静态变量仅在一个函数中被使用/引用，就应该只在该函数内部包含此变量 [OPT-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果一个文件级的静态变量仅在一个函数中被使用/引用,
最好在函数本身中包含这个变量, 因为如果这个函数从未被调用, 
这个变量就不会被分配内存.
参见: OPT-12



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在 C++中, 全局变量被默认定义为静态常量.
Ref: ISO14882/1998 (3.5 #3, 7.1.5.1 #2)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

能优化内存表达清晰便于维护.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static int i = 0;            // 违规
const  int ci = 0;           // 仅在 C++中违规

void clear( ) {
    i = ci;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void clear( ) {
    static int i = 0;        // OK
    const  int ci = 0;       // OK
    i = ci;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-12</key>
<configkey>OPT-12</configkey>
<name><![CDATA[ 如果一个文件级的静态变量仅在一个类中被使用/引用，就应该只在该类内部包含此变量 [OPT-12] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果一个文件级的静态变量仅在一个类中被使用/引用，就应该只在该类内部包含此变量 [OPT-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果一个文件级的静态变量仅在一个类中被使用/引用,
最好在该类中包含这个变量.
参见: OPT-11



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

优化内存并能清晰表达代码含义增加可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static int s;               // 违规
const static int cs = 0;    // 违规

class A
{
    void foo1(int i) {
        s = i + cs;
    }
    void foo2(int j ) {
        s = j + cs;
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
    static int s;               // OK
    const static int cs = 0;    // OK
    void foo1(int i) {
        s = i + cs;
    }
    void foo2(int j ) {
        s = j + cs;
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-13</key>
<configkey>OPT-13</configkey>
<name><![CDATA[ 降序声明成员变量 [OPT-13] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
降序声明成员变量 [OPT-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当然, 问题不容易在项目的开始就显示出来. 
例如,在64位应用程序上长整型和指针都比较大, 
而且还增加了结构体中包含的这些数据类型的大小. 
结构体所需内存空间的大小取决于结构体中元素的布局方式. 
例如,在32位应用程序中一个长整型变量是8个字节, 
但在64为应用程序中,会在结构体中第一个元素后面填充4个字节 
来确保和第二个元素字节对齐. 
为了尽量减少这中字节填充, 数据结构元素的排序最好是从大到小. 
但是, 如果数据结果元素是按字节流来访问的, 
您需要调整代码的逻辑来适应数据结构元素的新顺序. 



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

继该规则假定的依赖:
bool &lt; long
float &lt; double &lt; long double
char &lt; short &lt; int &lt; reference, pointer, 
长数组和对象应该在成员列表的开头



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

帮助优化内存消耗



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
    char c;
    short int si;       // 违规
    int i;                // 违规
    void* p;           // 违规
    long int li;        // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {                        // OK
    long int li;
    void* p;
    int i;
    short int si;
    char c;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://www.ddj.com/184406427">http://www.ddj.com/184406427</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-14</key>
<configkey>OPT-14</configkey>
<name><![CDATA[ 使用引用而非数值传递对象 [OPT-14] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用引用而非数值传递对象 [OPT-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测如果有虚拟函数的类对象以值来
传递或返回而不是用引用. 用引用来传递 / 
返回比用值来传递更有效率. 因为不会创建
新的对象而且可避免 "切断问题."
参见: PB-20, PB-23, OPT-33


例外:

有种情况是对象是比较小，所以 
传值比传引用更有效率.
由于 C++ 的类型系统和 QString, RWCString and CString 等  
都是隐式共享, 它们可能被当作整数或其它基本类型.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范增加代码一贯性和运行效能.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    const A violation( A a ) {       // 违规 - 以值传递参数
        return a;                    // 违规 - 以值返回
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    const A&amp; valid( const A &amp;a ) {   // OK
        return a;                    // OK
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编程规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Design Style", 第 09 规则

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 4 章, 第 20 项

3. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., 
   章节: "Classes and Functions: Design and Declaration", 第 22 项

4. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 1 章, 第 3 项

5. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 9 Function - 9.1 Function Arguments - Rec. 43

6. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 125 规则

7. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-15</key>
<configkey>OPT-15</configkey>
<name><![CDATA[ 使用重载以避免隐式类型转换 [OPT-15] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用重载以避免隐式类型转换 [OPT-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如无必要勿增实体 (Occam's Razor): 隐式类型 
转换能提供方便的句法 (但参阅 40 条). 但当其运行创建临时对象是不必要的 
(参阅 8 条), 您可以提供与签名相匹配的常见参数类型的重载方法来避免隐式类型转换."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则能避免创建临时对象提高代码优化.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    A(int);                 // 违规
    bool operator==(A);
};

class C;
class B {
public:
    B(C);                   // 违规
    bool operator==(B);
};

class C {
public:
    bool operator==(B);
};

class AR {
public:
    AR(int&amp;);               // 违规
    bool operator==(AR&amp;);
};

class CR;
class BR {
public:
    BR(CR&amp;);                // 违规
    bool operator==(BR&amp;);
};

class CR {
public:
    bool operator==(BR&amp;);
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A(int);                 // OK
    bool operator==(A);
    bool operator==(int);
};
bool operator==(int, A);

class C;
class B {
public:
    B(C);                   // OK
    bool operator==(B);
    bool operator==(C);
};

class C {
public:
    bool operator==(B);
};

class AR {
public:
    AR(int&amp;);               // OK
    bool operator==(AR&amp;);
    bool operator==(int&amp;);
};
bool operator==(int&amp;, AR&amp;);

class CR;
class BR {
public:
    BR(CR&amp;);                // OK
    bool operator==(BR&amp;);
    bool operator==(CR&amp;);
};

class CR {
public:
    bool operator==(BR&amp;);
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Functions and Operators", Rule 29

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-16</key>
<configkey>OPT-16</configkey>
<name><![CDATA[ 含有递归、循环或者虚函数调用的全局函数不应定义为内联的 [OPT-16] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
含有递归、循环或者虚函数调用的全局函数不应定义为内联的 [OPT-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"经常被调用的方法要限制最小内联."
内联规则不运行:
带循环的全局函数, 全局的递归函数, 
带虚拟函数调用的全局函数.
参加: OPT-17, OPT-18



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"有利于代码调试,最大限度的减少代码占用,
并最大限度的发挥代码的运行速度."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

inline void sampleFunction( int p ) {  // 违规
    for (int i = 0; i &lt; 10; i++) {
        p = p + i;
    }
}

inline void otherFunction( ) {       // 违规
    otherFunction( );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void sampleFunction( int p ) {       // OK 
    for (int i = 0; i &lt; 10; i++) {
        p = p + i;
    }
}

void otherFunction( ) {              // OK
    otherFunction( );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 5 章,  第 30 条

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison Wesley,
   (C) 2005 Pearson Education, Inc., Chapter: "Classes and Functions: Implementation", 第 33 条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-17</key>
<configkey>OPT-17</configkey>
<name><![CDATA[ 避免使用内联构造函数和析构函数 [OPT-17] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用内联构造函数和析构函数 [OPT-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"函数调用其他内联函数时经常会使他们编译变的很复杂.
这是构造函数和析构函数非常常见的一个问题.
一个构造器在执行其自身代码前总是会先调用他的基类的成员数据."
规则不允许在构造器和析构函数内联.
参加: OPT-16, OPT-18



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

内联析构在接口中定义是允许的.
所谓接口类是指没有成员变量并且所有
成员函数（除析构函数）都是纯虚函数的类.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"有利于代码调试,最大限度的减少代码占用,
并最大限度的发挥代码的运行速度."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class MyClass1 {
public:
    inline MyClass1( );    // 违规
    inline ~MyClass1( );   // 违规
private:
    int i;
};

class MyClass2 {
public:
    MyClass2( ) {};        // 违规
    ~MyClass2( ) {};       // 违规
private:
    int i;
};

class MyClass3 {
public:
    MyClass3( );           // 违规
    ~MyClass3( );          // 违规
private:
    int i;
};

inline MyClass3::MyClass3(){}
inline MyClass3::~MyClass3(){}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass1 {
public:
    MyClass1( );    // OK
    ~MyClass1( );   // OK
private:
    int i;
};

MyClass1::MyClass1(){}
MyClass1::~MyClass1(){}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 5 章, 第 30 条

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison Wesley,
   (C) 2005 Pearson Education, Inc.,
   Chapter: "Classes and Functions: Implementation", 第 33 条

3. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   From: 7 Classes - 7.2 Inline Functions - Rec. 31

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-18</key>
<configkey>OPT-18</configkey>
<name><![CDATA[ 含有递归、循环的成员函数不应定义为内联的 [OPT-18] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
含有递归、循环的成员函数不应定义为内联的 [OPT-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"大多少编译器会拒接他们认为太过负责的内联函数
(例如那些包含循环和递归的内联函数)."
规则不允许含有递归和循环的函数定义为内联函数.
参加: OPT-16, OPT-17



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"有利于代码调试,最大限度的减少代码占用,
并最大限度的发挥代码的运行速度."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class MyClass{
public:
    void foo1( ) {              // 违规
        foo1( );
    }

    inline void foo2( int i );
};

void MyClass::foo2( int i ) {   // 违规
     while (i &gt; 0) {
         i--;
     }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class MyClass {
public:
    void foo1( ) ;           // OK
    void foo2( int i );      // OK
};

void MyClass::foo1( ) {
    foo1( );
}
void MyClass::foo2( int i ) {
    while (i &gt; 0) {
        i--;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", 第三版, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 5 章, 第 30 条

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", 第二版, Addison Wesley,
   (C) 2005 Pearson Education, Inc., 
   Chapter: "Classes and Functions: Implementation", 第 33 条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-19</key>
<configkey>OPT-19</configkey>
<name><![CDATA[ 使用 op= 而非单独的操作符 [OPT-19] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 op= 而非单独的操作符 [OPT-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当你声明独立的操作符:
+ , - , * , / ,  ^, % , | , &amp; , &gt;&gt; , &lt;&lt; (如, 操作符+), 操作符 
的赋值符 (如, 操作符+=) 也应定义.
"提供赋值符版本的操作符以及独立版本, 
让类的成员会难以在效率和便利中作出 
权衡."
"用户应该考虑以赋值符版本的操作符替代
独立版本每当性能是独特的因素."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"赋值符版本的操作符比独立版本的更有效率, 
因为独立版本通常需要返回新对象, 而那会 
需要暂时构造和解构造的动作. 赋值符版本的 
操作符直接写到左手边参数, 所以是没有必要
生成暂时的对象来存放操作符的返回值."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
};

A&amp; operator+( A&amp; a, A&amp; b );      // 违规
A&amp; operator-( A&amp; a, A&amp; b );      // 违规

class B {
public:
    B&amp; operator+=( B&amp; b );
};
B&amp; operator+( B&amp; a, B&amp; b );
void foo( ) {
    B ba, bb ,bc, bd;
    bb = ba + bc + bd;          // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    A&amp; operator+=( A&amp; a );
    A&amp; operator-=( A&amp; a );
};

A&amp; operator+( A&amp; a, A&amp; b );      // OK
A&amp; operator-( A&amp; a, A&amp; b );      // OK
class B {
public:
    B&amp; operator+=( B&amp; b );
};
B&amp; operator+( B&amp; a, B&amp; b );
void foo( ) {
    B ba, bb ,bc, bd;
    bb = ba;                    // OK
    bb += bc;                   // OK
    bb += bd;                   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: "Efficiency", 第 22 项

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 125 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-20</key>
<configkey>OPT-20</configkey>
<name><![CDATA[ 尽量推后变量定义 [OPT-20] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽量推后变量定义 [OPT-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当你定义一个构造或析构类型的变量时,
你会导致构造时为了达到变量定义时所造成浪费, 
你也会导致析构时释放变量的浪费.
这都是由于未使用变量引起的成本, 所以你要尽量避免他们.
你可能会认为你永远不会定义未使用的变量,
但你要三思. 考虑下如下函数:

std::string encryptPassword(const std::string&amp; password)
{
   using namespace std;
   string encrypted;
   if (password.length() &lt; MinimumPasswordLength) {
     throw logic_error("Password is too short");
   }
   //...  do whatever is necessary to place an
   return encrypted;
}

这个加密对象在这个函数里不是完全未使用的, 
但如果抛出异常的话就是个未使用对象."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码效率.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class BaseOne {};

int main( ) {
    int gc = 0;
    BaseOne one;      // 违规
    BaseOne two;      // 违规
    if (gc == 0) {
        return 0;
    }
    one = two;
    return gc;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class BaseOne {};

int main( ) {
    int gc = 0;
    if (gc == 0) {
        return 0;
    }
    BaseOne one;      // OK
    BaseOne two;      // OK
    one = two;
    return gc;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", 第三版, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., 第 5 章, 第 26 条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-21</key>
<configkey>OPT-21</configkey>
<name><![CDATA[ 任何一个 switch 语句都至少有一个非空 case 子句 [OPT-21] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
任何一个 switch 语句都至少有一个非空 case 子句 [OPT-21-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果在 switch 语句中没有非空的 case 子句，那这switch 语句是多余的. 
如果一个 switch 语句被证明每次的返回结果都是相同的, 
它极有可能是编程错误.
参见: MISRA2004-15_5, OPT-22



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则可以检测不需要的代码和编程错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int i) {
    switch(i) {    // 违规
        case 1:
        case 2:
        default:
            return 0;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int i) {
    return 0;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-22</key>
<configkey>OPT-22</configkey>
<name><![CDATA[ 不允许使用无用的 case 语句 [OPT-22] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许使用无用的 case 语句 [OPT-22-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免编写无用的case语句.
参见: MISRA2004-15_5, OPT-21



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果发现有空的case语句很可能是一个编程错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo(int i) {
    switch(i)      /* 违规 */
    {
        case 0:
            return 1;
        case 1:
        case 2:
        default:
            return 0;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int i) {
    switch(i)      /* OK */
    {
        case 0:
            return 1;
        default:
            return 0;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-23</key>
<configkey>OPT-23</configkey>
<name><![CDATA[ 短小而且简单的 accessor/mutator 语句应该为内联函数 [OPT-23] ]]></name>
<tag>opt</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
短小而且简单的 accessor/mutator 语句应该为内联函数 [OPT-23-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

较小的访问器和修改器 (accessor and mutator) 函数应被内联.
规范会在访问器/修改器 (accessor/mutator) 没有底下条件时报违例:
- loop 语句
- 虚函数调用
- 递归
- 超过 5 个语句

且没内联.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

内联简单和小的函数可以节省时间和空间.



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

此规范认为 getter/setter (访问器/修改器) 是拥有以
 get/Get 和 set/Set 开头命名或以下划线和大写字
母开头及:
- get 方法返回成员变量或引用
- set 方法设定数值到成员变量


例外:

模板和虚函数.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
 	int m_var;
 
 public:
 	 int get_m_var();
 	 void set_m_var();
};


int A::get_m_var()    // 违规
{
   return m_var;
}

void A::set_m_var()   // 违规
{
   m_var = 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
 	int m_var;
 
 public:
 	inline int get_m_var();
 	inline void set_m_var();
};


inline int A::get_m_var()   // OK
{
   return m_var;
}

inline void A::set_m_var()  // OK
{
   m_var = 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 122 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-24</key>
<configkey>OPT-24</configkey>
<name><![CDATA[ 较小的转调函数应被内联 [OPT-24] ]]></name>
<tag>opt</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
较小的转调函数应被内联 [OPT-24-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

较小的转调函数应被内联.
此规范会在函数仅运行单个动作如
调用的函数未被内联时报告违例.


例外:

构造函数, 解构造函数, 模板及虚函数.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

内联简单和小的函数可以节省时间和空间.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int goo(int a, int b)
{
 /* code */
 return 1;
}

int foo(int a, int b)        // 违规
{
  return(goo(a,b));
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int goo(int a, int b)
{
 /* code */
 return 1;
}

inline int foo(int a, int b) // OK
{
  return(goo(a,b));
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 124 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-25</key>
<configkey>OPT-25</configkey>
<name><![CDATA[ 如果函数中仅包含了 1 或 2 条语句，应该考虑成为内联函数 [OPT-25] ]]></name>
<tag>opt</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果函数中仅包含了 1 或 2 条语句，应该考虑成为内联函数 [OPT-25-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

当函数仅有 1 或 2 个语句时才考虑为需要
内联的函数对象.
此规范会在内联函数拥有2个以上的语句时
报告违例.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

内联复杂的函数可能导致明显的代码膨胀
而会增加代码调试的复杂度.



</PRE>
<STRONG>
不足
</STRONG>
<PRE>

每个声明的变量被视为不同的语句.

int a, b, c;  // 会被计算出3个语句



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

inline int foo(int a)   // 违规
{
  int b = 0;
  b = (b-a)/a;
  return b;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo(int a)          // OK
{
  int b = 0;
  b = (b-a)/a;
  return b;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   Chapter 4.13 Functions, AV Rule 121

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-26</key>
<configkey>OPT-26</configkey>
<name><![CDATA[ 如果变量不能被初始化为有意义的值就不应引入 [OPT-26] ]]></name>
<tag>opt</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果变量不能被初始化为有意义的值就不应引入 [OPT-26-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果变量不能被初始化为有意义的值就不应引入.
此规则会在以下情况报告违例:
- 局部变量在初始化时赋值却未使用 (例如在
  初始化语句后和赋予新值前未被使用)
- 局部变量太早声明且只在 for 迴圈使用时



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规范只对 C++ 代码有效.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免变量未被赋予有意义的数值而去存取.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int f(int);

void fun_1(int x)
{
   int i;             // 违规: i 太早声明 
                      // (目的只在 for 迴圈里使用i)

   int max=0;         // 违规: max 被伪值初始化

   max = f(x);
   for (i=0 ; i&lt;max ; ++i)
   {
   }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int f(int);

void fun_2(int x)
{

   int max = f(x);   // OK: max not introduced until meaningful
                     // value is available

   for(int i = 0; i &lt; max; i++) // OK
   {
   }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.16 章节 Initialization, AV 第 143 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-27</key>
<configkey>OPT-27</configkey>
<name><![CDATA[ 应尽量减少 accessor/mutator 函数的数目 [OPT-27] ]]></name>
<tag>opt</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
应尽量减少 accessor/mutator 函数的数目 [OPT-27-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

访问器和修改器 (accessor and mutator) 函数的数量
应控制与成员变量的数量相同. 此规范会在 setter
 或 getter 方法的数量超出成员变量的数量时
报告违例.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规范假设 setter/getter (修改器/访问器) 方法是从
 get/Get 或 set/Set 开头命名的且以下划线
或大写字母紧跟着.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

许多的访问器和修改器 (accessors and mutators) 可能说明一个类只是
简单的处理数据收集的合计而不是体现一个
明确的状态抽象或不变式. 这种情况而言, 
拥有公共数据的结构体将是较好的选择.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Sample // 违规
{
 private:
	int m_var;
 public:
    int get_m_var();
    void set_m_var();
    void set_m_var(int a);
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Sample // OK
{
 private:
	int m_var;
 public:
    int get_m_var();
    void set_m_var(int a = 0);
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.10 章节 Classes, AV 第 123 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-28</key>
<configkey>OPT-28</configkey>
<name><![CDATA[ 'strlen' 函数不应该用来检查字符串是否为NULL/非NULL [OPT-28] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
'strlen' 函数不应该用来检查字符串是否为NULL/非NULL [OPT-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果 strlen() 被用来检测字符串NULL/非NULL规则就会报告违规.
NULL/non-NULL. 使用 strlen() 会强迫处理器查完整个字符串非常耗费资源.
如果使用首字母检测NULL/非NULL会效率更高 .



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改善代码效率.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string.h&gt;

void myFunction()
{
    const char* x = "string";
    int a = 1;
	
    if (strlen(x) == 0)        // 违规
        a++;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string.h&gt;

void myFunction()
{
    const char* x = "string";
    int a = 1;
	
    if (x[0] == 0)    // OK
        a++;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-29</key>
<configkey>OPT-29</configkey>
<name><![CDATA[ 不允许冗余显式转换为同一类型 [OPT-29] ]]></name>
<tag>opt</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许冗余显式转换为同一类型 [OPT-29-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Explicit casting between identical types is unnecessary and clutters code.
Furthermore it can mask problems if changes are made to the code (e.g. one of 
the types changes and a conversion with possible loss of information occurs)"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"The use of casting should be sufficient to cause the calculations required 
to occur with the desired precision. Unnecessary casting adds the possibility
of confusion, and may be such that its interaction with the rules of promotion
leads to results other than those expected. Unnecessary casting may also lead
to code which is harder to maintain, should the types of variables change."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int INT;

int someFunction1();
INT someFunction2();

void foo(int p)
{
    /* ... */
    p = (int)someFunction1();  // 违规
    p = (int)someFunction2();  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int INT;

int someFunction1();
INT someFunction2();

void foo(int p)
{
    /* ... */
    p = someFunction1();  // OK
    p = someFunction2();  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Origin: Misra Guidelines - Rule 44

2. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.5 Libraries, AV Rule 181

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-30</key>
<configkey>OPT-30</configkey>
<name><![CDATA[ 每个定义的函数应该至少被调用一次 [OPT-30] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每个定义的函数应该至少被调用一次 [OPT-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"任何定义的函数都必须至少被调用一次."
如果定义函数未被使用规则会报告违规



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

此规则检测以下函数:
- 在 C语言中: 
  - 静态函数,
- 在 C++中: 
  - 非模板全局静态函数, 
  - 在匿名命名空间中的非模板全局静态函数,
  - 非模板 非静态 非运算符 私有成员函数



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"函数或者过程没有被调用是一个很严重的问题,
例如缺少路径."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

static void foo() // 违规
{
   /* ... */
}

int main()
{
  return (0);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

static void foo() // OK
{
   /* ... */
}

int main()
{
  foo(); 
  return (0);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
第 6 章, 第 0 节, 规则 0-1-10

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-31</key>
<configkey>OPT-31</configkey>
<name><![CDATA[ 不得在非虚函数中有未使用的参数（有名或无名） [OPT-31] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得在非虚函数中有未使用的参数（有名或无名） [OPT-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不得在非虚函数中有未使用的参数（有名或无名）."


例外:

"在一个被当作回调的函数中定义无名参数
不违反此规则."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"未使用函数往往由于设计变更和导致会造成
参数列表不匹配."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int Foo(int i, int k)   // 违规
{
    i = 5;
    return i;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int Foo(int i)          // OK
{
    i = 5;
    return i;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
第 6 章, 第 0 节, 规则 0-1-11

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-32</key>
<configkey>OPT-32</configkey>
<name><![CDATA[ 所有具有 viod 返回类型的函数应该具有外部副作用 [OPT-32] ]]></name>
<tag>opt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有具有 viod 返回类型的函数应该具有外部副作用 [OPT-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

一个没有外部返回值也没有外部作用的函数
只会增加时间的耗费而不会产生任何输出,
而这可能不能满足开发者的预期.
以下是外部左右的示范:
- 读或写一个文件或数据流等.;
- 改变一个非局部变量的值;
- 改变一个具有引用类型的参数值;
- 使用一个可变对象;
- 引发异常.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止没有必要的时间消耗.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( void ) // 违规
{
    int local;
    local = 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( int p ) // OK
{
    int local;
    local = 10*p;
    /* ... */
    return local;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
第6章, 第 0 节, 规则 0-1-8 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>OPT-33</key>
<configkey>OPT-33</configkey>
<name><![CDATA[ 考虑通过引用而不是值来返回对象 [OPT-33] ]]></name>
<tag>opt</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
考虑通过引用而不是值来返回对象 [OPT-33-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果一个class/struct/union类型的对象
的返回值是通过值传递的此规则就会报告违规. 
在这种情况下可以考虑返回这个引用的对象. 它可以比值传递更高效,
但在有些时候也是不安全的.所以使用者需要在改变前自己检查函数的定义, 
确保新的代码是安全高效的. 
参见: PB-20, OPT-14



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

增强代码的紧密性提高执行效能.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class Foo{};
class A {
public:
    Foo foo();         // 违规
    Foo goo( A&amp; a ) {  // 违规
        return foo();
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A2 {
public:
    Foo&amp; foo();
    Foo&amp; goo( A2&amp; a ) {  // OK
        return foo();
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-01</key>
<configkey>PB-01</configkey>
<name><![CDATA[ 不要使用解引用指针类型的表达式 [PB-01] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用解引用指针类型的表达式 [PB-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用解引用指针类型的表达式。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码的可读性与安全性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* pFun();

void goo()
{
    int* ptr;
    int a, b, c;
    a = *ptr++;      // 违规
    b = *pFun();     // 违规
    c = *(ptr + 5);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int* pFun();

void goo()
{
    int* ptr;
    int* ptr2;
    int a, b, c;
    
    ptr++;
    a = *ptr;       // OK
    
    ptr2 = pFun();
    b = *ptr2;      // OK
    
    ptr2 = ptr + 5;
    c = *ptr2;      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-02</key>
<configkey>PB-02</configkey>
<name><![CDATA[ 不要在 a(b),a[b] 和类型转换语句内部使用赋值 [PB-02] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在 a(b),a[b] 和类型转换语句内部使用赋值 [PB-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要在 a(b),a[b] 和类型转换语句内部使用赋值。
参见: MISRA2004-12_3 (operator sizeof), PB-22 (递增或递减表达式)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则规则提高代码的可读性与执行效率， 同时避免代码中快捷方式 
有可能引起的缺陷。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i ) 
{
    int* x;
    x[ i = 0 ];        // 违规
    foo( i = 0 );      // 违规
    i = (int) (x = 0); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在 a(b),a[b] 和类型转换语句内部使用赋值。


参见：

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-03</key>
<configkey>PB-03</configkey>
<name><![CDATA[ 不允许在三元运算符中使用混合类型 [PB-03] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许在三元运算符中使用混合类型 [PB-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许在三元运算符中使用混合类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防有可能导致信息丢失的隐式转换，
提高代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( ) {
    int x;
    int y;
    x = ((y &gt; 5) ? 1.1 : 0.2);      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo( ) {
    int x;
    int y;
    x = ((y &gt; 5) ? 1 : 0);      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-05</key>
<configkey>PB-05</configkey>
<name><![CDATA[ 函数的返回值必须与声明的返回类型一致 [PB-05] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数的返回值必须与声明的返回类型一致 [PB-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则在返回值类型与声明的函数返回值类型
不一致的情况下报告一个违规。
如果一个函数的返回类型属于以下情况，将不会报告违规：
- 一个 typedef 或返回类型的引用
- 一个只有通过来自返回类型 const 或 volatie 修饰符不同的类型
- 一个非空对象或函数的指针
- 一个返回类型的基类的引用
参见： MISRA-043, PORT-14, MISRA2004-10_1 (组), PB-06, PB-11



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

在 C 语言中单独的字符常量的类型是 'int'， 但是本规则
假设其为 'char' (类似于在 C++ 中的定义) 以防止混乱。 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则预防有可能导致信息丢失的隐式转换，n提高代码的可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

float foo1( int i ) {
    return i;            // 违规
}

void* foo3(int* ptr ) {
    return ptr;          // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int_t;

float foo1( int i ) {
    return (float)i;            // OK
}

void* foo2(int* ptr ) {
    return (void*)ptr;          // OK
}

int foo3(const volatile int_t cvi ) {
    return cvi;            // OK
}

int foo4(int&amp; ref ) {
    return ref;            // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-06</key>
<configkey>PB-06</configkey>
<name><![CDATA[ 赋值操作符应该有匹配的类型操作数 [PB-06] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
赋值操作符应该有匹配的类型操作数 [PB-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则报告赋值操作符的类型操作数不匹配
的违规。
匹配的类型包括：
- 相同类型
- 类型定义
- 对类型的引用
- 仅因常量或volatile 限定符而导致不同的类型
参见： MISRA-043, PORT-14, MISRA2004-10_1 (group), PB-05, PB-11



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

当派生类对象的指针/引用被赋予对基类对象的指针/引用，
该规则将不会报告违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免数据丢失，提高代码可读性
与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1(signed int a, int&amp; ref, int* ptr){
    const short cs = 10;
    unsigned int b;
    float f;
    void* pvoid;

    b = a;        // 违规
    b = ref;      // 违规
    a = f;        // 违规
    pvoid = ptr;  // 违规
    b = cs + 10;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef unsigned int u_int;

void foo1(u_int a, u_int&amp; ref, int* ptr){
    short s;
    unsigned int b;
    float f;
    void* pvoid;

    b = a;                // OK
    b = ref;              // OK
    a = (unsigned int)f;  // OK
    pvoid = (void*)ptr;   // OK
    s = 10;               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-08</key>
<configkey>PB-08</configkey>
<name><![CDATA[ 不允许将有符号常量赋值给无符号整型变量 [PB-08] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许将有符号常量赋值给无符号整型变量 [PB-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则在如下情况发生时，将报告违规：
- 有符号常量赋值给无符号变量或无符号参数
- 有符号常量被当做已声明为无符号类型的参数传给函数 
- 在一个已声明无符号类型的函数中，有符号常量被作为返回值
当且仅当常量小于零时，该规则将被触发。 
参见： INIT-02, MISRA2004_10_1_a



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则将不会报告初始化过程中的错误，在此种情况下 
违规将被 INIT-02报告。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免不必要的隐式类型转换。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1(unsigned int ui){
    unsigned char uc;
    ui = -10;             // 违规
    uc = -20;             // 违规
}

unsigned int foo2(){
    foo1(-10);            // 违规
    return -20;           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(signed int ui){
    signed char uc;
    ui = -10;             // OK
    uc = -20;             // OK
}

signed int foo2(){
    foo1(-10);            // OK
    return -20;           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-09</key>
<configkey>PB-09</configkey>
<name><![CDATA[ 操作符不能使用引用返回值 [PB-09] ]]></name>
<tag>pb</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
操作符不能使用引用返回值 [PB-09-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规则检测在需要返回对象的位置返回引用。
以下的操作符不可以通过引用返回值：
a&amp;b, a^b, a|b, ~a, a!=b, a&lt;=b, a&lt;b, a==b, a&gt;=b, a&gt;b, a!b, a&amp;&amp;b, a||b, 
+a, -a, a%b, a*b, a+b, a-b, a/b



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Prevents returning a reference instead of an object 
what may result in corrupt data or a memory leak.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    const A&amp; operator&amp;  ( A &amp;x );   // 违规- (a &amp; b)
    const A&amp; operator^  ( A &amp;x );   // 违规- (a ^ b)
    const A&amp; operator|  ( A &amp;x );   // 违规- (a | b)
    const A&amp; operator!= ( A &amp;x );   // 违规- (a != b)
    const A&amp; operator&lt;= ( A &amp;x );   // 违规- (a &lt;= b)
    const A&amp; operator&lt;  ( A &amp;x );   // 违规- (a &lt; b)
    const A&amp; operator== ( A &amp;x );   // 违规- (a == b)
    const A&amp; operator&gt;= ( A &amp;x );   // 违规- (a &gt;= b)
    const A&amp; operator&gt;  ( A &amp;x );   // 违规- (a &gt; b)
    const A&amp; operator&amp;&amp; ( A &amp;x );   // 违规- (a &amp;&amp; b)
    const A&amp; operator|| ( A &amp;x );   // 违规- (a || b)
    const A&amp; operator%  ( A &amp;x );   // 违规- (a % b)
    const A&amp; operator*  ( A &amp;x );   // 违规- (a * b)
    const A&amp; operator+  ( A &amp;x );   // 违规- (a + b)
    const A&amp; operator-  ( A &amp;x );   // 违规- (a - b)
    const A&amp; operator/  ( A &amp;x );   // 违规- (a / b)
    const A&amp; operator~  ( );        // 违规- (~a)
    const A&amp; operator!  ( );        // 违规- (!a)
    const A&amp; operator+  ( );        // 违规- (+a)
    const A&amp; operator-  ( );        // 违规- (-a)
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    const A operator&amp;  ( A &amp;x );   // OK - (a &amp; b)
    const A operator^  ( A &amp;x );   // OK - (a ^ b)
    const A operator|  ( A &amp;x );   // OK - (a | b)
    const A operator!= ( A &amp;x );   // OK - (a != b)
    const A operator&lt;= ( A &amp;x );   // OK - (a &lt;= b)
    const A operator&lt;  ( A &amp;x );   // OK - (a &lt; b)
    const A operator== ( A &amp;x );   // OK - (a == b)
    const A operator&gt;= ( A &amp;x );   // OK - (a &gt;= b)
    const A operator&gt;  ( A &amp;x );   // OK - (a &gt; b)
    const A operator&amp;&amp; ( A &amp;x );   // OK - (a &amp;&amp; b)
    const A operator|| ( A &amp;x );   // OK - (a || b)
    const A operator%  ( A &amp;x );   // OK - (a % b)
    const A operator*  ( A &amp;x );   // OK - (a * b)
    const A operator+  ( A &amp;x );   // OK - (a + b)
    const A operator-  ( A &amp;x );   // OK - (a - b)
    const A operator/  ( A &amp;x );   // OK - (a / b)
    const A operator~  ( );        // OK - (~a)
    const A operator!  ( );        // OK - (!a)
    const A operator+  ( );        // OK - (+a)
    const A operator-  ( );        // OK - (-a)
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第4章, 第 21项

2. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc.,
   Chapter: "Classes and Functions: Design and Declaration",第 23 项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-10</key>
<configkey>PB-10</configkey>
<name><![CDATA[ 不要将数组视为多态的 [PB-10] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要将数组视为多态的 [PB-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"数组被不适调整: 视多态数组是一种严重的 
类型错误而编译器也许只会无视这问题.
别跌入陷阱."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范预防造成代码问题的痛苦. 
数组操作几乎都是包含指针运算, 
所以数组和多态不能混合使用.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class BST {
public:
    void cleanBSTArray(BST array[], int numElements)
    {
        for (int i = 1; i &lt; numElements; ++i) 
        {
            array[i] = array[0];              
        }                             
    }                               
	
    void deleteArray(BST array[])
    {
        delete [] array;
    }
};

class BalancedBST: public BST {};

void foo()
{
    BalancedBST *p;
    BST BSTArray[10];
    BalancedBST bBSTArray[10];
	
    p-&gt;cleanBSTArray(bBSTArray, 10);   // 违规
    p-&gt;deleteArray(bBSTArray);         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class BST {
public:
    void cleanBSTArray(BST array[], int numElements)
    {
        for (int i = 1; i &lt; numElements; ++i) 
        {
            array[i] = array[0];              
        }                             
    }                               
	
    void deleteArray(BST array[])
    {
        delete [] array;
    }
};

class BalancedBST: public BST {};

void foo()
{
    BalancedBST *p;
    BST BSTArray[10];
    BalancedBST bBSTArray[10];
	
    p-&gt;cleanBSTArray(BSTArray, 10);    // OK
    p-&gt;deleteArray(BSTArray);          // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编程规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Type Safety", 第 100 规则

2. Scott Meyers, "More Effective C++: 35 New Ways to Improve 
   Your Programs and Designs", Addison-Wesley, Copyright 1996, 
   章节: "Basics", 第 3 项

3. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.10 章节 Classes, AV 第 96 规则

4. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-11</key>
<configkey>PB-11</configkey>
<name><![CDATA[ 函数声明的形参类型和实参必须匹配 [PB-11] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数声明的形参类型和实参必须匹配 [PB-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

传入函数的参数类型必须与
函数定义中的参数类型相一致。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>
 
该规则提高代码的可读性与可维护性，减少错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b)
{

}

void goo(float a, float b)
{
  foo(a, b);   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int a, int b)
{

}

void goo(int a, int b)
{
  foo(a, b);   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-12</key>
<configkey>PB-12</configkey>
<name><![CDATA[ 不要将有符号字符强制转换成无符号整型 [PB-12] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要将有符号字符强制转换成无符号整型 [PB-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有符号的丢失(符号错误)，可能出现在当将有符号字符强制转换成
无符号整型时。如果从有符号字符到无符号整型的显式强制转换，
那么可以改变直觉相反的表达式的值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免有符号的丢失(符号错误)。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int foo( char ch )
{
    unsigned int i = 10u
    if((unsigned int) ch &gt; i){   // 违规
        return 0;
    } else {
        return 1; 
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( unsigned char ch )
{
    unsigned int i = 10u
    if((unsigned int) ch &gt; i){  // OK
        return 0;
    } else {
        return 1; 
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-13</key>
<configkey>PB-13</configkey>
<name><![CDATA[ 不要释放空指针 [PB-13] ]]></name>
<tag>pb</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要释放空指针 [PB-13-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检测你是否释放空指针。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止释放空指针导致非法操作。


事例：

class Rhino {
public:
    Rhino( );
    Rhino( char* );
    Rhino( const char* );
    operator char*( );
};

void func()
{
    Rhino r;
    delete( r );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class Rhino {
public:
    Rhino( );
    Rhino( char* );
    Rhino( const char* );
    operator char*( );
};

void func()
{
    Rhino *r = new Rhino();
    delete r ;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-14</key>
<configkey>PB-14</configkey>
<name><![CDATA[ 不正确的 EOS(串尾)定义 [PB-14] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不正确的 EOS(串尾)定义 [PB-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

字符串结束位置应该定义为'\0'。
不要将 EOS定义为NULL或0。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则避免未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define EOS 0 // 违规
#undef EOS
#define EOS NULL // 违规
#undef EOS


修复：n
#define EOS '\0' // OK
#undef EOS



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-15</key>
<configkey>PB-15</configkey>
<name><![CDATA[ 不能将两个整数相除之后的结果赋给浮点类型 [PB-15] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将两个整数相除之后的结果赋给浮点类型 [PB-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该则检测是否将两个整数相除之后的结果
赋给一个浮点类型(float, double, long double).


优点：n
该规则避免可能的精度损失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void func()
{
   int a = 3;
   int b = 4;
   double d;
   d = a / b;		// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void func()
{
   int a = 3;
   int b = 4;
   double d;
   d = ((double)a) / b;	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-16</key>
<configkey>PB-16</configkey>
<name><![CDATA[ 避免将越界数值赋值给字符类型 [PB-16] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免将越界数值赋值给字符类型 [PB-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

This rule checks whether constants are greater than the char type's 
legal range. Rule checks assigning and initialization.
Range of values of char type is -128 to 127.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Prevents using illegal values as chars.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
  char c1, c2;  
  char c3 = 170;   // 违规
  char c4 = -130;  // 违规
  c1 = 145;        // 违规     
  c2 = -154;       // 违规    
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void fooOK()
{
  char c1, c2;
  char c3 = 70;    // OK
  char c4 = -30;   // OK
  c1 = 45;         // OK
  c2 = -54;        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-17</key>
<configkey>PB-17</configkey>
<name><![CDATA[ 避免将越界数值赋值给无符号字符类型 [PB-17] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免将越界数值赋值给无符号字符类型 [PB-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检测数值在初始化或赋值过程中
是否在字符类型的合法范围内。
字符类型的范围值为0 到 255。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免使用非法的字符类型数值。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
  unsigned char uc1, uc2 = 0;
  unsigned char uc3 = 298;    // 违规
  unsigned char uc4 = -15;    // 违规
  uc1 = 289;                  // 违规
  uc2 = (-5);                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void fooOK()
{
  unsigned char uc1, uc2 = 0;
  unsigned char uc3 = 98;     // OK
  unsigned char uc4 = 15;     // OK
  uc1 = 89;                   // OK
  uc2 = (5);                  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-18</key>
<configkey>PB-18</configkey>
<name><![CDATA[ 避免在指针和数字类型上使用重载 [PB-18] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在指针和数字类型上使用重载 [PB-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用一个为零的参数进行调用将会导致引用数字类型,
即使并没有直接定义。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

避免在指针和数字类型上使用重载。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    void func(A a, int *i) { }
    void func(A a, long i) { }	// 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not overload on a pointer and a numerical type.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 50 Specific Ways to Improve
Your Programs and Design", Second Edition, Addison-Wesley,
(C) 2005 Pearson Education, Inc., 
章节： "Classes and Functions: Design and Declaration", 第25项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-19</key>
<configkey>PB-19</configkey>
<name><![CDATA[ 不应创建带有局部静态数据的内联非成员函数 [PB-19] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应创建带有局部静态数据的内联非成员函数 [PB-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当用户创建一个带有局部静态对象的内联非成员函数之后，
可能会将会在代码中创建多个局部静态对象！"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止在内联非成员函数中声明带有局部静态数据的。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

inline int increase( ) {   // 违规
    static int count = 0;
    count++;
    return count;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int increase( ) {          // OK
    static int count = 0;
    count++;
    return count;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "More Effective C++: 35 New Ways to Improve 
Your Programs and Designs", Addison-Wesley, Copyright 1996, 
章节： "Techniques", 第 26 项

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-20</key>
<configkey>PB-20</configkey>
<name><![CDATA[ 避免函数参数或返回值导致的切片问题 [PB-20] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免函数参数或返回值导致的切片问题 [PB-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测如果有虚拟函数的类对象以值来 
传递或返回而不是用引用. 用引用来传递 / 
返回比用值来传递更有效率. 因为不会创建
新的对象而且可避免 "切断问题."
参见: OPT-14, PB-23



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范预防切断问题, 增加代码一贯性
和运行效能.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A {
public:
    virtual void someFun();
    const A violation( A a ) {       // 违规 - 以值传递参数
        return a;                    
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A {
public:
    virtual void someFun();
    const A&amp; valid( const A &amp;a ) {   // OK
        return a;                    
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编程规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Design Style", 第 09 规则

2. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 4 章, 第 20 项

3. Scott Meyers, "Effective C++: 50 Specific Ways to Improve
   Your Programs and Design", Second Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc.,
   章节: "Classes and Functions: Design and Declaration", 第 22 项

4. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., 第 1 章, 第 3 项

5. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 9 Function - 9.1 Function Arguments - Rec. 43

6. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 117 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-21</key>
<configkey>PB-21</configkey>
<name><![CDATA[ 提供正确的字符串终止符 [PB-21] ]]></name>
<tag>pb</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
提供正确的字符串终止符 [PB-21-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

程序员有时误将字符串 "\0" 当成 '\0' 
i作为终止字符串。 而多数 C++ 编译器 
不允许将这样的字符串赋值给数组，但C 
编译器允许， 该错误，易于检测，可能 
造成内存错误和程序崩溃。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则通过检查终止字符串是否正确以防止一些可能的程序崩溃问题。


事例：

struct S {
    char pc[10];
}* ps = 0;
void foo( ) {
    char pc[10];
    
    ps-&gt;pc[0] = "\0";           // 违规
    pc[0] = "\0";               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct S {
    char pc[10];
}* ps = 0;
void foo( ) {
    char pc[10];
    
    ps-&gt;pc[0] = '\0';           // OK
    pc[0] = '\0';               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://cwe.mitre.org/data/definitions/170.html">http://cwe.mitre.org/data/definitions/170.html</A>

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-22</key>
<configkey>PB-22</configkey>
<name><![CDATA[ 不能在 a(b),a[b] 和类型转换中使用递增或递减表达式 [PB-22] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能在 a(b),a[b] 和类型转换中使用递增或递减表达式 [PB-22-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不能在 a(b),a[b] 和类型转换中使用递增或递减表达式。
参见： MISRA2004-12_3 (operator sizeof), PB-02 (assign expression)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则提高代码可读性，效率，避免与代码中
不必要快捷方式引起的后遗症相关的潜在缺陷。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo( int i ) 
{
    int* x;
    x[ i++ ];          // 违规
    foo( i++ );        // 违规
    i = (int) (x++);   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>




</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-23</key>
<configkey>PB-23</configkey>
<name><![CDATA[ 如果类中含有非静态指针并且没有声明过拷贝构造函数，就应使用引用传递类对象 [PB-23] ]]></name>
<tag>pb</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果类中含有非静态指针并且没有声明过拷贝构造函数，就应使用引用传递类对象 [PB-23-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范检测含有指针成员的对象使用编
译器生成的拷贝构造函数来以值传递. 以
引用来传递对象可避免可能的拷贝成员指
针逐位拷贝的问题.
当类 / 结构体有非静态指针成员栏位, 没有
定义的拷贝构造函数, 且类 / 结构体对象以
值传递时则规范会报告违例.
参见: OPT-14, PB-20


例外:

该规则不包括检查名字以 'iterator' 结尾的类型为类/结构体
的对象 (例如 'iterator', 'const_iterator', 'normal_iterator',...)



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范协助避免可能的成员指针逐位拷贝问题 .



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A;
void foo1(A a);

class A
{
    int *x;
};

void foo(void)
{
    A a;
    foo1(a);     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A;
void foo1(A &amp;a);


class A
{
    int *x;
};

void foo(void)
{
    A a;
    foo1(a);     // OK - 以引用传递
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.13 章节 Functions, AV 第 117 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-24</key>
<configkey>PB-24</configkey>
<name><![CDATA[ 构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的拷贝构造函数完全一样的签名 [PB-24] ]]></name>
<tag>pb</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的拷贝构造函数完全一样的签名 [PB-24-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

成员函数的定义不应包含默认参数生成和相应
的类 / 结构体中隐形声明的拷贝构造函数一样
的参数签名.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果在类定义中没有明确声明拷贝构造函数,
将有一个隐式声明. 因此, 针对类定义而言
class X 
{
   X(const X&amp;, int);
};

拷贝构造函数会被隐式声明. 如果后来客制
化构造函数如

X::X(const X&amp; x, int i =0) 
{ 
   /* ... */ 
}

则 X 类拷贝构造函数的使用将是非法因为模糊不清.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
	A(const A&amp;, int);
	A(const A&amp;);
};

A::A(const A&amp; x, int i =0) // 违规
{
	 /* ... */ 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
	A(const A&amp;, int i=0);
	A(const A&amp;);
};

A::A(const A&amp; x, int i) // OK
{
	 /* ... */ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.10 章节 Classes, AV 第 77.1 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-25</key>
<configkey>PB-25</configkey>
<name><![CDATA[ 不应在算术运算中使用无符号类型的数据 [PB-25] ]]></name>
<tag>pb</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应在算术运算中使用无符号类型的数据 [PB-25-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不该使用无符号算术.
规范会在找到算术表达式的 
操作数是无符号类型时报违例.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

长久以来, 无符号数值和有符号数值混合都
有错误倾向因为它主要操作有许多算术转换
和整体提升规则.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(unsigned p)
{
   unsigned int a = 0;
   int b = 0;
  
   b = p + a;         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(signed p)
{
   signed int a = 0;
   int b = 0;
  
   b = p + a;         // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.21 章节 Operators, AV 第 163 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-26</key>
<configkey>PB-26</configkey>
<name><![CDATA[ 公共的(public)和被保护的(protected)方法不应被类的构造函数调用 [PB-26] ]]></name>
<tag>pb</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
公共的(public)和被保护的(protected)方法不应被类的构造函数调用 [PB-26-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

此规范的目的是预防未经完全初始化的
对象被使用. 当构造类包含了公有或受
保护的方法其对象得到充分初始化为方
法调用的先决条件.
如果构造类包含了公有或受保护的方法
规范会报告违例.
参见: OOP-16, INIT-06



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

公有方法 (有时受保护方法也是) 会假设对象和
类变量在调用前已设置和初始化. 因此,
在对象构造期间调用这些方法将有造成使用这
些未初始化的对象或不正确数据的风险因为类
变量的内容在对象完全构造前并不能保证.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
  public:
    A();
    void foo();
  private:
    int obj1;
};


A::A()
{
  foo();    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要从构造函数调用公有或受保护方法.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.10 章节 Classes, AV 第 71 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-27</key>
<configkey>PB-27</configkey>
<name><![CDATA[ 不能修改字符串内的字符 [PB-27] ]]></name>
<tag>pb</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能修改字符串内的字符 [PB-27-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

字符串文字不该被修改. 规范会在字符串
文字被赋予非常量的变量, 参数或表达式时报违例.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

试图修改一个字符串的影响是不可预知.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void moo(char * p)
{
}

void foo()
{
	char* c1 = "Hello";    // 违规
	char c2[] = "Hello";   // 违规
	char c3[6] = "Hello";  // 违规
	char* c12;
	c12 = "Hello";         // 违规
	moo("Hello");          // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void moo(const char * p)
{
}

void foo()
{
	const char* c1 = "Hello";    // OK
	const char c2[] = "Hello";   // OK
	const char c3[6] = "Hello";  // OK
	const char* c12;
	c12 = "Hello";               // OK
	moo("Hello");                // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.18 章节 Constants, AV 第 151.1 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-28</key>
<configkey>PB-28</configkey>
<name><![CDATA[ 下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 " [PB-28] ]]></name>
<tag>pb</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 " [PB-28-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

下面的字符序列不该出现在头文件
名称: ', \, /*, //, or ".



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果这些字符序列 ', \, /*, //, 或 " 出现在
头文件名 (如 &lt;字符序列&gt;), 将有无可预知
的结果.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "foo's.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;foo_s.h&gt; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.9 章节 Style, AV 第 53.1 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-29</key>
<configkey>PB-29</configkey>
<name><![CDATA[ 右移位操作符的左操作数不能是负数 [PB-29] ]]></name>
<tag>pb</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
右移位操作符的左操作数不能是负数 [PB-29-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规范会在右移运算符的左操作数是使用 
以下一种格式时报违例.
- constant with a negative value
- unary operator '-' followed by parameter, variable or expression
- parameter or variable of signed type
- expression of signed type that contains parameter, variable, dereferenced
  pointer or function call of signed type



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如 e1 &gt;&gt; e2 这例子, 如果 e1 是带符号类型且是负值, 则
(e1 &gt;&gt; e2) 的值是实现定义.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(signed int signed_param)
{
    signed int signed_variable;
    int variable;
    signed int* ptr_signed_variable;

    signed_param &gt;&gt; 5;         // 违规
    signed_variable &gt;&gt; 5;      // 违规
    -variable &gt;&gt; 5;            // 违规
    -100 &gt;&gt; 5;                 // 违规
    -100u &gt;&gt; 5;                // 违规
    *ptr_signed_variable &gt;&gt; 5; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(unsigned int unsigned_param)
{
    unsigned int unsigned_variable;
    int variable;
    unsigned int* ptr_signed_variable;

    unsigned_param &gt;&gt; 5;         // OK
    unsigned_variable &gt;&gt; 5;      // OK
    (unsigned int)variable &gt;&gt; 5; // OK
    100 &gt;&gt; 5;                    // OK
    100u &gt;&gt; 5;                   // OK
    *ptr_signed_variable &gt;&gt; 5;   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.21 章节 Operators, AV 第 164.1 规则

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-30</key>
<configkey>PB-30</configkey>
<name><![CDATA[ 多于一个枚举('enum')类型应该用作 switch 的条件或 case 语句的标签 [PB-30] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
多于一个枚举('enum')类型应该用作 switch 的条件或 case 语句的标签 [PB-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

由于不同枚举类型的枚举成员可以有相同的值， 
在switch表达式中使用不同的枚举类型可能会导致错误。
由于枚举值有不同的范围，
在switch表达式和标签中使用不同的枚举类型
可能会造成代码不可到达。statement expression and labels may lead to unreachable code because the
two enum types could be in different ranges.
该规则在使用不同枚举类型作为switch表达式的标签
或使用多个类型作为switch表达式的情况下会报告一个违规。


缺点：

在C语言下，该规则可能不能完全检测所有违规case条件Rule may not detect all violation cases in C code.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免不可到达代码，提高代码可读性与可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef enum E1 {EA, EB, EC} E1;
typedef enum F1 {FA = 3, FB = 4, FC = 5} F1;

void MyFunction(E1 e, int i) {
    switch(e) 
    {
    case FA :            // 违规  
        i++; 
    case FB :            // 违规
        break; 
    default:            
    i++; 
    break;
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef enum E1 {EA, EB, EC} E1;
typedef enum F1 {FA = 3, FB = 4, FC = 5} F1;

void MyFunction(E1 e, int i) {
    switch(e) 
    {
    case EA :            // OK
        i++; 
    case EB :            // OK
        break; 
    default:            
    i++; 
    break;
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-31</key>
<configkey>PB-31</configkey>
<name><![CDATA[ 不要在常量上调用 'sizeof' [PB-31] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在常量上调用 'sizeof' [PB-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则在常量使用sizeof表达式时提示一个违规。
Int 常量中使用Sizeof运算符不会按照开发者的意图
返回整数类型的大小。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免不使用正常类型表达式
而使用sizeof运算符错误造成的常量使用错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MAX 10

void myFunction()
{
    sizeof(MAX);    // 违规
    sizeof(2);      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在常量上调用 'sizeof'。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-32</key>
<configkey>PB-32</configkey>
<name><![CDATA[ 不要在指针类型上调用 'sizeof' [PB-32] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在指针类型上调用 'sizeof' [PB-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要在指针类型上调用 'sizeof'。
在指针类型上调用’sizeof’会导致
sizeof运算符返回指针大小。
(在32位平台下为4).
参见： MRM-45



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免在指针类型上调用’sizeof’ 
从而避免了该类型指针呗错误使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int * pint;

void myFunction(int* ptr_a)
{
    pint ptr_b;

    sizeof(ptr_a);    // 违规
    sizeof(ptr_b);    // 违规
    sizeof(pint);     // 违规
    sizeof(int *);    //  违规
}


</PRE>
<STRONG>
修复
</STRONG>
<PRE>
void mySndFunction(char tab10[10], char tabX[], char * ptr) 
{
    sizeof tab10;   // Violation
    sizeof tabX;    // Violation
    sizeof ptr;     // Violation
}






</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-33</key>
<configkey>PB-33</configkey>
<name><![CDATA[ 避免使用枚举类型隐式类型转换 [PB-33] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用枚举类型隐式类型转换 [PB-33-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在:
* 枚举和非枚举类型
* 枚举和不同的枚举类型
做隐式类型转换是不允许的.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可以防止改变取决于枚举常量的值



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum ABC0{A0, B0, C0};

void foo1(int arg1){}

int foo(int p)
{
    ABC0 x;
    int i = x; // 违规
    foo1(x);   // 违规
    return x;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum ABC0{A0, B0, C0};

void foo1(int arg1){}

int foo(int p)
{
    ABC0 x;
    int i = (int)x; // OK
    foo1((int)x);   // OK
    return (int)x;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-34</key>
<configkey>PB-34</configkey>
<name><![CDATA[ 'memcpy'/'strncpy'/'memmove' 的第三个参数不应该依赖于第二个参数 [PB-34] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
'memcpy'/'strncpy'/'memmove' 的第三个参数不应该依赖于第二个参数 [PB-34-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则在'memcpy'/'memmove' 或函数'strncpy'
的第三个参数依赖于第二个参数情况下
报告一个违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免未定义操作。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string.h&gt;

void foo(void)
{
	const int array1[10] = {0,1,2,3,4,5,6,7,8,9};
	int array2[10];
		
	memcpy ( array2, array1, sizeof(array1)); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string.h&gt;

void foo(void)
{
	const int array1[10] = {0,1,2,3,4,5,6,7,8,9};
	int array2[10];
		
	memcpy ( array2, array1, sizeof(array2)); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-35</key>
<configkey>PB-35</configkey>
<name><![CDATA[ 赋值操作符不得使用在没有括号的条件中 [PB-35] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
赋值操作符不得使用在没有括号的条件中 [PB-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

赋值操作符不得使用在没有括号的条件中。
不使用括号有可能导致只有一个分支被执行，
并有可能导致不可预知的程序行为。
参见： MISRA2004-13_1



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免不可预知的程序行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
   void foo();
};

void A::foo()
{
   int i = 1;
   int j = 0;
   if(i = j)j++;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
   void foo();
};

void A::foo()
{
   int i = 1;
   int j = 0;
   if( (i = j) )j++;   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-36</key>
<configkey>PB-36</configkey>
<name><![CDATA[ 对象的动态类型不能够从它的构造函数和析构函数的函数体中使用 [PB-36] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象的动态类型不能够从它的构造函数和析构函数的函数体中使用 [PB-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在一个对象的构造和析构过程中，其最后的类型
可能不同于完全构造对象的类型。”
“成员函数(包括虚成员函数)能够为正在构造的对象调用。
同样，正在构造的对象能够是 typeid 操作符
或者 dynamic_cast 的操作数。但是，如果这些
操作在所有基类的成员初始化器完成之前的
ctor-initializer 中执行(或者从 ctor-initializer
直接或间接调用的函数中)，那么该操作的结果是不确定的。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“在构造函数或析构函数中使用对象的动态类型的
结果可能不符合开发人员的期望。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* Examples of incorrect code */
#include &lt;typeinfo&gt;
class B2
{
    public:
        virtual ~B2 ( );
        virtual void foo ( );
        B2 ( )
        {
            typeid ( B2 );                // 违规
            foo ( );                      // 违规
            dynamic_cast&lt; B2* &gt; ( this ); // 违规
        }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Examples of correct code */
#include &lt;typeinfo&gt;
class B1
{
    public:
        B1 ( )
        {
            typeid ( B1 ); // OK - B1 not polymorphic
        }
};
class B2
{
    public:
        virtual ~B2 ( );
        virtual void foo ( );
        B2 ( )
        {
            B2::foo ( );   // OK - not a virtual call
        }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 12 节, 规则 12-1-1

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-37</key>
<configkey>PB-37</configkey>
<name><![CDATA[ 不得使用 <cstring> 库的无限制函数 [PB-37] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得使用 &lt;cstring&gt; 库的无限制函数 [PB-37-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在 &lt;cstring&gt; 库中的 strcpy, strcmp, strcat, strchr, strspn, strcspn, strpbrk, strrchr, strstr,
strtok 和 strlen 函数能够读取或写入超出缓冲区的末尾，
造成不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef char char_t;
#include &lt;cstring&gt;
void fn ( const char_t * pChar )
{
    char_t array [ 10 ];
    strcpy ( array, pChar ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* Ideally, a safe string handling library should be used.
Use of bounded functions (e.g. strncpy) is also possible. */
typedef char char_t;
#include &lt;cstring&gt;
void fn ( const char_t * pChar )
{
    char_t array [ 10 ];
    strncpy ( array, pChar, 10 ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 18 节, 规则 18-0-5

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-38</key>
<configkey>PB-38</configkey>
<name><![CDATA[ 不得级联窄的和宽的字符串字面量 [PB-38] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不得级联窄的和宽的字符串字面量 [PB-38-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

宽和窄的字符串字面量的级联导致不确定的行为。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

wchar_t array[] = "Hello" L"World";    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

wchar_t array[] = L"Hello" L"World";   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 2 节, 规则 2-13-5

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-39</key>
<configkey>PB-39</configkey>
<name><![CDATA[ 函数不得返回一个引用或指针给通过引用或 const 引用传递的参数 [PB-39] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不得返回一个引用或指针给通过引用或 const 引用传递的参数 [PB-39-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“函数不得返回一个引用或指针给通过引用
或 const 引用传递的参数。引用参数是否是
一个临时对象或一个参数的引用是实现定义
的行为。如果此实现使用本地副本（临时对象），
那么当函数换回的时候，它将被销毁。任何试图
在其析构之后使用该对象将会导致不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止非确定性的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* foo2 ( int&amp; x )
{
    return ( &amp;x );     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要返回一个引用或指针给通过引用
或 const 引用传递的参数。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-5-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-40</key>
<configkey>PB-40</configkey>
<name><![CDATA[ 函数不得返回一个引用或指针给定义在函数中的自动变量(包括参数) [PB-40] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数不得返回一个引用或指针给定义在函数中的自动变量(包括参数) [PB-40-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“函数不得返回一个引用或指针给定义在函数中
的自动变量(包括参数).”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“自动变量在函数调用结束时销毁。
返回一个引用或指针给这种变量允许
在它析构之后被使用，导致不确定的行为。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* foo( ) {
    int i;
    return &amp;i; // 违规
}

int&amp; bar( ) {
    int i;
    return i;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int foo( ) {
    int i = 0;
    return i;  // OK
}

int bar( ) {
    int i = 0;
    return i;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 7 节, 规则 7-5-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-41</key>
<configkey>PB-41</configkey>
<name><![CDATA[ 作为函数实参传递的数组类型标识符不得退化为一个指针 [PB-41] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
作为函数实参传递的数组类型标识符不得退化为一个指针 [PB-41-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“当一个具有数组类型的变量退化为一个指针时，它的边界都将丢失。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“如果设计需要不同长度的数组，那么应该
使用一个类来封装数组对象从而确保能够维持
数组的维数。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int int32_t;

void f1( int32_t p[ 10 ] );
void f2( int32_t *p );

void b ()
{
    int32_t a[ 10 ];
   
    f1( a ); // 违规
    f2( a ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int int32_t;

void f1( int32_t ( &amp;p )[ 10 ] );

void b ()
{
    int32_t a[ 10 ];
    f1( a );          // OK 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 5 节, 规则 5-2-12

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-42</key>
<configkey>PB-42</configkey>
<name><![CDATA[ 对象不能赋值给一个重叠的对象 [PB-42] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对象不能赋值给一个重叠的对象 [PB-42-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“对象不能赋值给一个重叠的对象。”
此规则检测是否同一个联合体(union)的
两个不同的成员使用相同的对象彼此给对方赋值。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"Assigning between objects that have an overlap in their physical storage
leads to undefined behaviour."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

void main( ) {
    union U a, b;
    union U *p;

    a.dValue  = a.lValue;    // 违规
    p-&gt;dValue = p-&gt;iValue;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

void main( ) {
    union U a, b;
    union U *p, *q;
    a.dValue  = b.lValue;     // OK
    p-&gt;dValue = q-&gt;iValue;    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 0 节, 规则 0-2-1 

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-43</key>
<configkey>PB-43</configkey>
<name><![CDATA[ 一个类的所有构造函数应该显式地为它的所有直接基类和所有虚基类调用一个构造函数 [PB-43] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个类的所有构造函数应该显式地为它的所有直接基类和所有虚基类调用一个构造函数 [PB-43-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“一个类的所有构造函数应该显式地为它的
所有直接基类和所有虚基类调用一个构造函数。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果类没有定义任何构造函数而它的一个基类却有构造函数，
那么规则也将报告一个违规。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则降低了关于哪个构造函数将被使用
和包含什么参数的混淆。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
    public:
        A ( )
        {
        }
};


class B : public A
{
    public:
        B ( ) // 违规
        {
        }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class A
{
    public:
        A ( )
        {
        }
};


class B : public A
{
    public:
        B ( ): A() // OK
        {
        }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 12 节, 规则 12-1-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-44</key>
<configkey>PB-44</configkey>
<name><![CDATA[ terminate() 函数不得被隐式地调用 [PB-44] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
terminate() 函数不得被隐式地调用 [PB-44-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“调用栈是否在调用 terminate() 之前被展开是
实现定义的，所以任何自动对象的析构函数可能被执行，
或者可能不被执行。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可防止实现定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class C 
{
 public:
    C() { throw 1; }
};

void fnExit1 (void)
{
  C c;
  /* ... */
}

void foo()
{
  atexit (fnExit1);  // 违规
  /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

class C 
{
 public:
    C() 
    {
    	try
    	{ 
    		/* ... */
    		throw 1;
    	}
    	catch(...)
    	{
    		/* ... */
    	} 
    }
};

void fnExit1 (void)
{
  C c;
  /* ... */
}

void foo()
{
  atexit (fnExit1);  // OK
  /* ... */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 C++语言在关键系统中的使用指南
第 6 章, 第 15 节, 规则 15-5-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-45</key>
<configkey>PB-45</configkey>
<name><![CDATA[ 在 'printf' 函数调用中格式字符串的 '%s' 或 '%c' 标签与它对应的参数之间不应该有任何不匹配 [PB-45] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'printf' 函数调用中格式字符串的 '%s' 或 '%c' 标签与它对应的参数之间不应该有任何不匹配 [PB-45-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The goal of this rule is to prevent a type mismatch between an argument type
specified as a tag in 'format' string and the actual type of an optional
argument passed in to function invocation.
The rule looks for invocations of functions which match "printf-like" pattern:
- contain "printf" in name (case insensitive)
- two last parameters in function declaration are a string and ellipsis
- the argument corresponding to the string parameter contains recognized "%" tags

The rule reports a violation if an argument passed in for a tag "%s" is not:
- pointer to char or void
- array of char type
- class containing 'String' in name and member function conversion operator
- typedefs to above types
- constant '0' (null)
or if an argument passed in for a tag "%c" is not:
- unsigned char
- integer constant with a value lower than 256
The rule does not report a violation if a number of tags specified in a 'format'
string is different than the number optional function arguments.
参见: PB-46, PB-47, PB-48, PB-49, PB-50



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The format tags follow this prototype:
%[flags][width][.precision][length]specifier
where specifier is the most significant one and defines the type
and the interpretation of the value of the corresponding argument.
The tag can also contain flags, width, .precision and modifiers sub-specifiers,
which are optional.
This rule as specifiers detects the following values:
c, d, i, e, E, f, g, G, a, A, o, s, u, x, X, p, n 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents program crashes and unintended side-effects.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    const char* name = "file.c";
    printf("file %s, number %s", name, value);  // 违规
    printf("file %s, letter %c", name, value);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    const char* name = "file.c";
    unsigned char ch = 'c';
    printf("file %s, number %u", name, value);                 // OK
    printf("file %s, letter %c", name, (unsigned char)value);  // OK
    printf("file %s, letter %c", name, ch);                    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/IEC 9899:1999 Programming languages -- C
   7.19.6 Formatted input/output functions

2. <A HREF="http://www.cplusplus.com/reference/clibrary/cstdio/printf/">http://www.cplusplus.com/reference/clibrary/cstdio/printf/</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-46</key>
<configkey>PB-46</configkey>
<name><![CDATA[ 在 'printf' 函数调用中格式字符串的 '%f' 标签与它对应的参数之间不应该有任何不匹配 [PB-46] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'printf' 函数调用中格式字符串的 '%f' 标签与它对应的参数之间不应该有任何不匹配 [PB-46-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The goal of this rule is to prevent a type mismatch between an argument type
specified as a tag in 'format' string and the actual type of an optional
argument passed in to function invocation.
The rule looks for invocations of functions which match "printf-like" pattern:
- contain "printf" in name (case insensitive)
- two last parameters in function declaration are a string and ellipsis
- the argument corresponding to the string parameter contains recognized "%" tags

The rule reports a violation if an argument passed in for a tag "%f" is not:
- float type
- double type
or if an argument passed in for a tag "%Lf" is not:
- long double type
The rule does not report a violation if a number of tags specified in a 'format'
string is different than the number optional function arguments.
参见: PB-45, PB-47, PB-48, PB-49, PB-50



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The format tags follow this prototype:
%[flags][width][.precision][length]specifier
where specifier is the most significant one and defines the type
and the interpretation of the value of the corresponding argument.
The tag can also contain flags, width, .precision and modifiers sub-specifiers,
which are optional.
This rule as specifiers detects the following values:
c, d, i, e, E, f, g, G, a, A, o, s, u, x, X, p, n 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents program crashes and unintended side-effects.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    float fl = 10.2f;
    long double ld = 1.0001L;
    printf("Value: %f", value);     // 违规
    printf("Value: %Lf", fl);       // 违规
    printf("Value: %f", ld);        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    float fl = 10.2f;
    long double ld = 1.0001L;
    printf("Value: %u", value);          // OK
    printf("Value: %f", (float)value);   // OK
    printf("Value: %f", fl);             // OK
    printf("Value: %Lf", ld);            // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/IEC 9899:1999 Programming languages -- C
   7.19.6 Formatted input/output functions

2. <A HREF="http://www.cplusplus.com/reference/clibrary/cstdio/printf/">http://www.cplusplus.com/reference/clibrary/cstdio/printf/</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-47</key>
<configkey>PB-47</configkey>
<name><![CDATA[ 在 'printf' 函数调用中格式字符串的 '%i' 或 '%d' 标签与它对应的参数之间不应该有任何不匹配 [PB-47] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'printf' 函数调用中格式字符串的 '%i' 或 '%d' 标签与它对应的参数之间不应该有任何不匹配 [PB-47-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The goal of this rule is to prevent a type mismatch between an argument type
specified as a tag in 'format' string and the actual type of an optional
argument passed in to function invocation.
The rule looks for invocations of functions which match "printf-like" pattern:
- contain "printf" in name (case insensitive)
- two last parameters in function declaration are a string and ellipsis
- the argument corresponding to the string parameter contains recognized "%" tags

The rule reports a violation if:
- an argument passed in for a tag "%i", "%d", "%li", "%ld", "%Ii", "%Id",
  "%I32i", "%I32d" is not:
  - parameter/variable of type signed int, signed long, short, char, enum, bool
  - expression of type int, long, short, char, enum, bool 
  - typedefs to above types
  - constants of int or long type in a range: -2147483648 to 2147483647
- an argument passed in for a tag "%hi", "%hd" is not:
  - parameter/variable of type signed short, char, enum, bool
  - expression of type short, char, enum, bool
  - typedefs to above types
  - constants in a range: -32768 to 32767
- an argument passed in for a tag "%hhi", "%hhd" is not:
  - parameter/variable of type signed char
  - expression of type char, enum, bool 
  - typedefs to above types
  - constants in a range: -128 to 127
- an argument passed in for a tag "%lli", "%lld" is not:
  - signed long long
  - typedef to above type
  - constants of long long type
The rule does not report a violation if a number of tags specified in a 'format'
string is different than the number optional function arguments.
参见: PB-45, PB-46, PB-48, PB-49, PB-50



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The format tags follow this prototype:
%[flags][width][.precision][length]specifier
where specifier is the most significant one and defines the type
and the interpretation of the value of the corresponding argument.
The tag can also contain flags, width, .precision and modifiers sub-specifiers,
which are optional.
This rule as specifiers detects the following values:
c, d, i, e, E, f, g, G, a, A, o, s, u, x, X, p, n 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents program crashes and unintended side-effects.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    int i;
    float f;

    printf("Value signed int: %i", value);           // 违规
    printf("Value signed short: %hi", i);            // 违规
    printf("Value signed char: %hhi", f);            // 违规
    printf("Value signed long long: %lli", 100);     // 违规
    printf("Value signed long: %ld", &amp;i);            // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    int i;
    float f;
    signed short s;
    long l;

    printf("Value unsigned int: %u", value);         // OK
    printf("Value signed short: %hi", s);            // OK
    printf("Value signed short: %hi", (short)i);     // OK
    printf("Value float: %f", f);                    // OK
    printf("Value signed long long: %lli", 100ll);   // OK
    printf("Value signed long: %ld", l);             // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/IEC 9899:1999 Programming languages -- C
   7.19.6 Formatted input/output functions

2. <A HREF="http://www.cplusplus.com/reference/clibrary/cstdio/printf/">http://www.cplusplus.com/reference/clibrary/cstdio/printf/</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-48</key>
<configkey>PB-48</configkey>
<name><![CDATA[ 在 'printf' 函数调用中格式字符串的 '%u' 标签与它对应的参数之间不应该有任何不匹配 [PB-48] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'printf' 函数调用中格式字符串的 '%u' 标签与它对应的参数之间不应该有任何不匹配 [PB-48-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The goal of this rule is to prevent a type mismatch between an argument type
specified as a tag in 'format' string and the actual type of an optional
argument passed in to function invocation.
The rule looks for invocations of functions which match "printf-like" pattern:
- contain "printf" in name (case insensitive)
- two last parameters in function declaration are a string and ellipsis
- the argument corresponding to the string parameter contains recognized "%" tags

The rule reports a violation if:
- an argument passed in for a tag "%u", "%lu", "%Iu", "%I32u" is not:
  - parameter/variable/expression of type unsigned char, unsigned short,
    unsigned int or unsigned long
  - typedefs to above types
  - constants of int or long type in a range: 0 to 4294967295
- an argument passed in for a tag "%hu" is not:
  - parameter/variable/expression of type unsigned char or unsigned short
  - typedefs to above types
  - constants in a range: 0 to 65535
- an argument passed in for a tag "%hhu" is not:
  - parameter/variable/expression of type unsigned char
  - typedef to unsigned char type
  - constants in a range: 0 to 255
- an argument passed in for a tag "%llu" is not:
  - parameter/variable/expression of type unsigned long long
  - typedef to above type
  - constants of long long type
The rule does not report a violation if a number of tags specified in a 'format'
string is different than the number optional function arguments.
参见: PB-45, PB-46, PB-47, PB-49, PB-50



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The format tags follow this prototype:
%[flags][width][.precision][length]specifier
where specifier is the most significant one and defines the type
and the interpretation of the value of the corresponding argument.
The tag can also contain flags, width, .precision and modifiers sub-specifiers,
which are optional.
This rule as specifiers detects the following values:
c, d, i, e, E, f, g, G, a, A, o, s, u, x, X, p, n 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents program crashes and unintended side-effects.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    int i;
    float f;

    printf("Value unsigned int: %u", i);           // 违规
    printf("Value unsigned short: %hu", value);    // 违规
    printf("Value unsigned char: %hhu", f);        // 违规
    printf("Value unsigned long long: %llu", 100); // 违规
    printf("Value unsigned long: %lu", &amp;i);        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    int i;
    float f;
    unsigned short int us;
    unsigned long int ul;

    printf("Value unsigned int: %u", value);                    // OK
    printf("Value unsigned short: %hu", us);                    // OK
    printf("Value unsigned short: %hu", (unsigned short)value); // OK
    printf("Value unsigned char: %f", f);                       // OK
    printf("Value unsigned long long: %llu", 100ull);           // OK
    printf("Value unsigned long: %lu", ul);                     // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/IEC 9899:1999 Programming languages -- C
   7.19.6 Formatted input/output functions

2. <A HREF="http://www.cplusplus.com/reference/clibrary/cstdio/printf/">http://www.cplusplus.com/reference/clibrary/cstdio/printf/</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-49</key>
<configkey>PB-49</configkey>
<name><![CDATA[ 在 'printf' 函数调用中格式字符串的 '%p' 标签与它对应的参数之间不应该有任何不匹配 [PB-49] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'printf' 函数调用中格式字符串的 '%p' 标签与它对应的参数之间不应该有任何不匹配 [PB-49-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The goal of this rule is to prevent a type mismatch between an argument type
specified as a tag in 'format' string and the actual type of an optional
argument passed in to function invocation.
The rule looks for invocations of functions which match "printf-like" pattern:
- contain "printf" in name (case insensitive)
- two last parameters in function declaration are a string and ellipsis
- the argument corresponding to the string parameter contains recognized "%" tags

The rule reports a violation if an argument passed in for a tag "%p" is not:
- pointer
- typedef to pointer
The rule does not report a violation if a number of tags specified in a 'format'
string is different than the number optional function arguments.
参见: PB-45, PB-46, PB-47, PB-48, PB-50



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The format tags follow this prototype:
%[flags][width][.precision][length]specifier
where specifier is the most significant one and defines the type
and the interpretation of the value of the corresponding argument.
The tag can also contain flags, width, .precision and modifiers sub-specifiers,
which are optional.
This rule as specifiers detects the following values:
c, d, i, e, E, f, g, G, a, A, o, s, u, x, X, p, n 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents program crashes and unintended side-effects.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    int i;
    int* ptr;
    printf("Value: %p", i);     // 违规
    printf("Value: %p", 0);     // 违规
    printf("Value: %p", *ptr);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    int i;
    int* ptr;
    printf("Value: %p", &amp;i);   // OK
    printf("Value: %i", 0);    // OK
    printf("Value: %p", ptr);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/IEC 9899:1999 Programming languages -- C
   7.19.6 Formatted input/output functions

2. <A HREF="http://www.cplusplus.com/reference/clibrary/cstdio/printf/">http://www.cplusplus.com/reference/clibrary/cstdio/printf/</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-50</key>
<configkey>PB-50</configkey>
<name><![CDATA[ 在 'printf' 函数调用中格式字符串标签的数量与它对应的参数个数之间必须相同 [PB-50] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在 'printf' 函数调用中格式字符串标签的数量与它对应的参数个数之间必须相同 [PB-50-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if a number of tags specified in a 'format'
string is different than the number optional function arguments.
The rule looks for invocations of functions which match "printf-like" pattern:
- contain "printf" in name (case insensitive)
- two last parameters in function declaration are a string and ellipsis
- the argument corresponding to the string parameter contains recognized "%" tags
参见: PB-45, PB-46, PB-47, PB-48, PB-49



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The format tags follow this prototype:
%[flags][width][.precision][length]specifier
where specifier is the most significant one and defines the type
and the interpretation of the value of the corresponding argument.
The tag can also contain flags, width, .precision and modifiers sub-specifiers,
which are optional.
This rule as specifiers detects the following values:
c, d, i, e, E, f, g, G, a, A, o, s, u, x, X, p, n 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents program crashes and unintended side-effects.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    const char* name = "file.c";
    printf("file %s, number %u", name);               // 违规
    printf("file %s, number %u", name, name, value);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

int main(){
    unsigned int value = 10;
    const char* name = "file.c";
    printf("file %s, number %u", name, value);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. ISO/IEC 9899:1999 Programming languages -- C
   7.19.6 Formatted input/output functions

2. <A HREF="http://www.cplusplus.com/reference/clibrary/cstdio/printf/">http://www.cplusplus.com/reference/clibrary/cstdio/printf/</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PB-51</key>
<configkey>PB-51</configkey>
<name><![CDATA[ 指针运算不得用于指向非数组类型变量的指针 [PB-51] ]]></name>
<tag>pb</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指针运算不得用于指向非数组类型变量的指针 [PB-51-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"Pointer arithmetic shall only be applied to pointers that address an array or 
array element.
Addition and subtraction of integers (including increment and decrement) from 
pointers that do not point to an array or array element results in undefined 
behaviour."
参见: MISRA2004-17_1



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v9.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule assumes that a pointer does not point to an array or array element
if to pointer is assigned null or an address of variable of non-array type.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule makes the code more readable and less confusing.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* example of incorrect code */
void func(int* ptr1, int a[5]){
    int i;
    int* ptr2 = 0;
    int* ptr3;
    ptr1 = &amp;i;

    ptr1++;          /* 违规 */
    ptr3 = ptr2 + 1; /* 违规 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* example of correct code */
void func(int* ptr1, int a[5]){
    int i;
    int* ptr2 = &amp;a;
    int* ptr3 = &amp;a[3];

    ptr1++;          /* OK - ptr1 may points to whatever */
    ptr1 = ptr2 + 1; /* OK - ptr2 points to an array */
    ptr3++;          /* OK - ptr3 points to an array element */
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA-C:2004 Guidelines for the use of the C language in critical systems
Chapter 6, Section 17

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-01</key>
<configkey>PFO-01</configkey>
<name><![CDATA[ 在头文件中不能定义带有连接的实体 [PFO-01] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在头文件中不能定义带有连接的实体 [PFO-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“头文件应该用来声明对象，函数，内联函数，
函数模板，类型定义(typedef)，宏，类和类模板。
并不得包含或者产生需要占据存储空间的对象或者函数的定义
（或者函数或者对象的片段）。”
参见：MISRA2004-8_5



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

作为头文件，规则检测包含如下扩展名的文件 ".h", ".hh", ".hxx", ".i"
(例如： "file.h", "file.hh", "file.hxx", "file.i").


例外:

在头文件允许下面的定义:
- 内联函数
- 函数模板
- 类模板的静态数据成员
- const 变量（如果它们有内部或没有连接）(C++ 模式)
- 静态 const 变量



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高可读性和可维护性。
通过不在头文件中包含定义，
可以在多个翻译单元包含头文件。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* file.h */
void f1(){}            // 违规
int var;               // 违规
class C {
   void f2();
};
void C::f2() {}        // 违规

/* file.cpp */
#include "file.h"



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

/* file.h */
void f1();             // OK
extern int var;        // OK
class C {
   void f2();
};
template &lt;typename T&gt;
void f3 ( T ) { }      // OK

/* file.cpp */
#include "file.h"
void f1(){}
int var;
void C::f2() {}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA-C:2004 C语言在关键系统中的使用指南
   第 6 章，第 8 节1. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章，第 3 节, 第 3-1-1 条规则

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Namespaces and Modules", Rule 61

3. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.7章 Header Files, AV Rule 39

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-02</key>
<configkey>PFO-02</configkey>
<name><![CDATA[ 使用多重包含保护机制 [PFO-02] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用多重包含保护机制 [PFO-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每一个包括文件必须包含一种机制，防止文件被多次 
列入."
多重包含机制应界定为:

#ifndef FILENAME_H
#define FILENAME_H
// 代码
#endif

或

#if !defined(FILENAME_H)
#define FILENAME_H
// 代码
#endif

参见: PFO-07, PFO-08, MISRA2004-19_15



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范可以提高代码可维护性和优化.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file foo.hh
// 违规 - 无多重包含机制存在



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file foo.hh
// 正确
#ifndef FOO_HH
#define FOO_HH
int i;
#endif


参考:

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   出处: 4 源码文件 - 4.4 头文件 - Rule 7

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.6 章节 预处理指令 (Pre-Processing Directives), AV Rule 27

3. MISRA C++:2008 - 在关键系统中使用 C++ 语言的
   指导, 第 6 章节, 16 段, Rule 16-2-3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-03</key>
<configkey>PFO-03</configkey>
<name><![CDATA[ 一个包含文件中只能带有一个类定义 [PFO-03] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个包含文件中只能带有一个类定义 [PFO-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果在一个头文件中声明了超过一个类，
这条规则报告一个违规超过一个类。规则不计数嵌套类。
参见: NAMING-32



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

头文件的定义是通过 #include 包含的任何文件。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

代码的可读性更好.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
#include "file.hh"

// file.hh             // 违规
class testClass1{};
class testClass2{};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cpp
#include "file.hh"

// file.hh             // 正确 - 仅定义一个类
class testClass1{};


参考:

Ellemtel 代码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#4.1">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#4.1</A>
出处: 4 Source Code in Files - 4.1 Structure of Code - Rec. 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-04</key>
<configkey>PFO-04</configkey>
<name><![CDATA[ 包含常量字符串描述文件 [PFO-04] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
包含常量字符串描述文件 [PFO-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每个实现文件(源文件)应该声明一个局部常量字符串来描述
文件。这样我们才能用 UNIX 命令 'what' 来获取
文件修订的信息."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高获取文件修订信息的可能性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// 违规- No local constant string describing the file



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// OK
static const char* sccsid = 
"@(#) Exception.cc ; rev. A, Copyright ... ";



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
出处: 4 Source Code in Files - 4.4 include Files - Rec 12

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-05</key>
<configkey>PFO-05</configkey>
<name><![CDATA[ 带有 '.c' 扩展名的文件不能包含其它带有 '.c' 扩展名的文件 [PFO-05] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
带有 '.c' 扩展名的文件不能包含其它带有 '.c' 扩展名的文件 [PFO-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

.c 或 .C 文件 (源文件) 本质上来说
应独自编译， 而不是被包含在其他文件。
这对 C 和 C++ 代码而言是认可的物理  
组织模型。 

许多构建环境都会自动分别
编译每个 c 文件. 假设 c 文件
被包含在另外的 .c 文件里, 将 
会引发连接错误。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高代码的可读性与维护性, 并 
避免构建错误。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

//file.c
#include "file2.c"  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

1. 分别编译和链接每个 .c 文件。
2. 建立一个规范来检测所有包含的
源文件名没有用 .c 或 .C 后缀名。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft 所推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-06</key>
<configkey>PFO-06</configkey>
<name><![CDATA[ 禁止在带有 '.icc' 扩展名的文件中包含其它文件 [PFO-06] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在带有 '.icc' 扩展名的文件中包含其它文件 [PFO-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"禁止在带有 .icc 扩展名的文件中包含其它文件."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范避免在 .icc 文件包含其他文件.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// some.icc
#include &lt;stdio.h&gt;        // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// File some.icc do not include any other files   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
出处: 4 Source Code in Files - 4.4 Include Files - Rec. 13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-07</key>
<configkey>PFO-07</configkey>
<name><![CDATA[ 使用基于头文件名的多重包含保护机制 [PFO-07] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用基于头文件名的多重包含保护机制 [PFO-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每一个包括文件必须包含一种机制，防止文件被多次 
列入."
多重包含机制应界定为:

#ifndef FILENAME_H
#define FILENAME_H
// code
#endif

或者

#if !defined(FILENAME_H)
#define FILENAME_H
// code
#endif

参见: PFO-02, PFO-08, and MISRA2004-19_15



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

如果文件的名称是filename.h, 在多重包含机制 
中的名称应转换为以下格式 FILENAME_H (需大写
且以下划线连结后缀名)



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范可以提高代码可维护性和优化.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file goo.hh
#ifndef GUARD_GOO // 违规 - 未遵循命名约定 (GUARD_GOO)
#define GUARD_GOO
int i;
#endif /*GUARD_GOO*/



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file goo.hh
#ifndef GOO_HH // OK
#define GOO_HH
int i;
#endif /*GUARD_HH*/



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
出处: 4 Source Code in Files - 4.4 Include Files - Rule 7

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-08</key>
<configkey>PFO-08</configkey>
<name><![CDATA[ 使用某种机制以防止文件的多重包含，例如，包含保护或者使用 "#pragma once" 预处理指令 [PFO-08] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用某种机制以防止文件的多重包含，例如，包含保护或者使用 "#pragma once" 预处理指令 [PFO-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每一个包括文件必须包含一种机制，防止文件被多次 
列入."
多重包含机制应界定为:

- #pragma once - 预处理指令

或

- 如下方式定义包含防护:
#ifndef FILENAME_H
#define FILENAME_H
// 代码
#endif

或

#if !defined(FILENAME_H)
#define FILENAME_H
// 代码
#endif

参见: PFO-02, PFO-07, and MISRA2004-19_15



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范可以提高代码可维护性和优化.


始自:

v7.1



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file foo.hh
// 违规 - 无多重包含机制存在



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file foo.hh
// 正确
#pragma once


参考:

1. Ellemtel 代码规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
   出处: 4 源码文件 - 4.4 头文件 - Rule 7

2. 联合攻击战斗机, 飞行器, C++ 代码规范
   第 4.7 章节 头文件, AV Rule 35

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PFO-09</key>
<configkey>PFO-09</configkey>
<name><![CDATA[ "#pragma once"  预处理指令不能使用在源代码文件中 [PFO-09] ]]></name>
<tag>pfo</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
"#pragma once"  预处理指令不能使用在源代码文件中 [PFO-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#pragma once 是非标准却广泛支持的预处理器指令
用于使头文件在每一次的编译过程中只被引用一次.
使用 #pragma once 在源码里是无用的，因为源代
码文件是不被用来包含在另外的文件里. 因此, 我们
应该考虑如果被包含的不是头文件而使用 #pragma 
once 在源文件里是不正确的.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范提高了代码的可维护性与优化.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file foo.cpp
#pragma once    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file foo.h
#pragma once    // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft 推荐

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-01</key>
<configkey>PORT-01</configkey>
<name><![CDATA[ 使用大写 'L' 而非小写 'l' 来指定 long 类型 [PORT-01] ]]></name>
<tag>port</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用大写 'L' 而非小写 'l' 来指定 long 类型 [PORT-01-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用大写 'L' 而非小写 'l' 来指定 long 类型
小写字母’l’极容易与数字’1’混淆
此种混淆在定义整数常量为long值时
尤其容易出现。使用大写 'L' 而非小写 'l' 来指定 long 类型
可以避免意义含糊不清的表达式。
同样的，当定义一个long long类型的时候，
推荐使用’LL’代替’ll’。




</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免引起混乱的代码，提高代码可读性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define S1 11l    // 违规

void foo1(){
    long l;
    long long ll;
    unsigned long ul;

    ul = 11lu;    // 违规
    l  = 11l;     // 违规
    ll = 11111ll; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define S1 11L    // OK

void foo1(){
    long l;
    long long ll;
    unsigned long ul;

    ul = 11LU;    // OK
    l  = 11L;     // OK
    ll = 11111LL; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

CERT C Secure 编码规范, Declarations and Initialization, DCL16-C

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-02</key>
<configkey>PORT-02</configkey>
<name><![CDATA[ 如果将整型操作的结果赋值给 long，其中至少一个整型必须强制转换成 long [PORT-02] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果将整型操作的结果赋值给 long，其中至少一个整型必须强制转换成 long [PORT-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果将整型操作的结果赋值给 long，
其中至少一个整型必须强制转换成 long


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

当操作int时，其中至少一个整型必须强制转换成 long, 
否则将会导致精度丢失.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
   int a = 72;
   int b = 55;
   long result = 0;
   result = (long)(a*b);        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
   int a = 72;
   int b = 55;
   long result = 0;
   result = (long)((long)a*b);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-03</key>
<configkey>PORT-03</configkey>
<name><![CDATA[ 不能在结构体中使用硬编码的数值作为偏移量 [PORT-03] ]]></name>
<tag>port</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能在结构体中使用硬编码的数值作为偏移量 [PORT-03-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

该规则检测是否在结构体中
使用硬编码的数值作为偏移量
在32位环境下，有4字节的偏移量 (4*8比特=32 比特),
但是当环境转换成为64位时
偏移量将会增长到8字节(8*8*比特=64比特)




</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守该规则将使用编译器计算偏移量。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
# define ARCH32 true
#ifdef ARCH32
#define __int3264 int // win32和unix32下的32位类型
#else //ARCH64
#ifdef win64 
#define __int3264 __int64//win64下的64位类型
                          //(警告：长整型在win64位下是32比特类型)
#else //unix64
#define __int3264 long //unix64位下的64位类型(长整型在unix64下为64位)
#endif
#endif
struct myStruct {
   void *ptr;
   int i;
};

void foo() {
   myStruct s; 
   myStruct *ps = new myStruct();
   int j;
   s.i = 22;      
   ps-&gt;i = 22;
   j= *(int *)((unsigned __int3264)&amp;s + sizeof(void*));        // 违规
   j= *(int *)((unsigned __int3264)&amp;s + 4 );                   // 违规
   j= *(int *)((unsigned __int3264)&amp;s.i + 0 );                 // 违规
   j= *(int *)((unsigned __int3264)ps + sizeof(void*));        // 违规
   j= *(int *)((unsigned __int3264)ps + 4);                    // 违规
   j= *(int *)((unsigned __int3264)&amp;ps-&gt;i + 0);                // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stddef.h&gt;
#define ARCH32 true
#ifdef ARCH32
#define __int3264 int //win32和unix32下的32位类型
#else //ARCH64
#ifdef win64 
#define __int3264 __int64 //win64下的64位类型
                          //(警告：长整型在win64位下是32比特类型)
#else //unix64
#define __int3264 long //unix64位下的64位类型(长整型在unix64下为64位)
#endif
#endif
struct myStruct {
   void *ptr;
   int i;
};

void foo() {
   myStruct s; 
   myStruct *ps = new myStruct();
   int j;
   s.i = 22;      
   ps-&gt;i = 22;
   j= *(int *)((unsigned __int3264)&amp;s + offsetof(myStruct,i)); // OK
   j= *(int *)((unsigned __int3264)ps + offsetof(myStruct,i)); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-04</key>
<configkey>PORT-04</configkey>
<name><![CDATA[ 不要使用十六进制常数 '0xffffffff' 作为一个错误标识符 [PORT-04] ]]></name>
<tag>port</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用十六进制常数 '0xffffffff' 作为一个错误标识符 [PORT-04-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在某些情况下值’-1’被当做错误代码或
其他特殊记号被写作 '0xffffffff'。
在64位环境中此表达式是不错误的。
此时需要显式定义值 '-1'."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免产生错误代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifndef size_t
typedef unsigned int size_t;
#endif

#define INVALID_RESULT (0xFFFFFFFFu)          // 违规
#define NULL 0

size_t MyStrLen(const char *str) {
   size_t n;
   if (str == NULL)
     return INVALID_RESULT;
   // ... 
   return n;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef size_t
typedef unsigned int size_t;
#endif

#define INVALID_RESULT (size_t(-1))          // OK
#define NULL 0

size_t MyStrLen(const char *str) {
   size_t n;
   if (str == NULL)
     return INVALID_RESULT;
   // ...
   return n;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://software.intel.com/en-us/articles/lessons-on-development-of-64-bit-cc-applications/">http://software.intel.com/en-us/articles/lessons-on-development-of-64-bit-cc-applications/</A>
Lesson 9.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-05</key>
<configkey>PORT-05</configkey>
<name><![CDATA[ 指向 long 的指针不能强制转换成指向整型的指针 [PORT-05] ]]></name>
<tag>port</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指向 long 的指针不能强制转换成指向整型的指针 [PORT-05-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"避免默认整型和长整型有相同位数。"
指向长整型的指针不能强制转换成指向整型的指针
参见： PORT-06, PORT-07, PORT-08, PORT-10, PORT-11, PORT-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免资源泄露。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    int *intPointer;
    long *longPointer;
    intPointer = (int *)longPointer; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

指向 long 的指针不能强制转换成指向整型的指针。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2</A>
   From: 18 Portable Code - 18.2 Sizes of Types - Port. Rec. 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-06</key>
<configkey>PORT-06</configkey>
<name><![CDATA[ 不能将长整型赋值给整型 [PORT-06] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将长整型赋值给整型 [PORT-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"默认整型和长整型位数相同是错误的。"
将一个长整型转换为整型有可能会导致不必要的截断，
当程序从32位环境移植到64位的时候。
参见： PORT-05, PORT-07, PORT-08, PORT-10, PORT-11, PORT-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(){
    int iVal = 72;
    long lVal = 6;
    iVal = lVal;	// 违规
    iVal = (int)lVal; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not assign a long int to an int.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2</A>
From: 18 Portable Code - 18.2 Sizes of Types - Port. Rec. 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-07</key>
<configkey>PORT-07</configkey>
<name><![CDATA[ 不能在函数调用中将 long 类型强制转换后传递给整型 [PORT-07] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能在函数调用中将 long 类型强制转换后传递给整型 [PORT-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"默认整型和长整型位数相同是错误的。"
将一个长整型转换为整型有可能会导致不必要的截断，
当程序从32位环境移植到64位的时候。
参见：PORT-05, PORT-06, PORT-08, PORT-10, PORT-11, PORT-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则避免数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int iVal){
    long lVal;
    foo(lVal);		// 违规
    foo((int)lVal);	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不能将长整型赋值给整型



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2</A>
From: 18 Portable Code - 18.2 Sizes of Types - Port. Rec. 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-08</key>
<configkey>PORT-08</configkey>
<name><![CDATA[ 将常量赋值给 long 时，应在数字结尾加上大写字母L [PORT-08] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
将常量赋值给 long 时，应在数字结尾加上大写字母L [PORT-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"默认整型和长整型位数相同是错误的。"
将一个长整型转换为整型有可能会导致不必要的截断，
当程序从32位环境移植到64位的时候。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule prevents loss of data.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
    long longValue;
    longValue &amp;= ~(0x0000000000000101); // 违规
    longValue = 0x0000000000000101; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    long longValue;
    longValue &amp;= ~(0x0000000000000101L); // OK
    longValue = 0x0000000000000101L; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel 编码规范 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2</A>
From: 18 Portable Code - 18.2 Sizes of Types - Port. Rec. 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-10</key>
<configkey>PORT-10</configkey>
<name><![CDATA[ 不能使用整数直接初始化长整型 [PORT-10] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用整数直接初始化长整型 [PORT-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不要假设整形和长整型有同样的大小."
一个整形值有32位的长度. 分配一个整形值 
给一个长整型变量会导致32位以上的数据的浪费,
或者整形变量超过32位的数据会被截断.
参见: PORT-05, PORT-06, PORT-07, PORT-08, PORT-11, PORT-12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止数据丢失.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(){
    long lVal = 1;  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(){
    long lVal = 1L; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel编码标准 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2</A>
From: 18 Portable Code - 18.2 Sizes of Types - Port. Rec. 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-11</key>
<configkey>PORT-11</configkey>
<name><![CDATA[ 不能将整型指针强制类型转化成 long 指针 [PORT-11] ]]></name>
<tag>port</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将整型指针强制类型转化成 long 指针 [PORT-11-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"一个指向整型的指针和一个指向长整型的指针不匹配. 即使使用e
强制转换也不正确."
一个指向整型的指针具有4个字节的对准, 一个指向长整型的指针具有8个字节
的对准在一些64位平台上面.
参见: PORT-05, PORT-06, PORT-07, PORT-08, PORT-10, PORT-12



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该条规则只检查强制转换.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则防止了在64位平台上面的不对齐的内存访问.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void f2005() {
    int *intPointer;
    long *longPointer;
    longPointer = (long *)intPointer;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要将整型指针转化为长整型指针.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2</A>
   From: 18 Portable Code - 18.2 Sizes of Types - Port. Rec. 2

2. <A HREF="http://developers.sun.com/solaris/articles/64_bit_driver.html">http://developers.sun.com/solaris/articles/64_bit_driver.html</A>
   3.1.1 Converting Driver Code to Be 64-Bit Clean, Example 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-12</key>
<configkey>PORT-12</configkey>
<name><![CDATA[ 不能将 32 位乘法运算的数值赋值给 long 类型 [PORT-12] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将 32 位乘法运算的数值赋值给 long 类型 [PORT-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不要误认为整型和长整型变量的长度一样."
32位乘法运算的数值的结果赋给长整型变量会引起截断.
参见: PORT-05, PORT-06, PORT-07, PORT-08, PORT-10, PORT-11



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止数据丢失.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() {
   long longValue;
   longValue = 2000000 * 3000000;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() {
    long longValue;
    longValue = 2000000L * 3000000;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.2</A>
From: 18 Portable Code - 18.2 Sizes of Types - Port. Rec. 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-13</key>
<configkey>PORT-13</configkey>
<name><![CDATA[ 整型 int 类型必须声明为无符号整型或者有符号整型 [PORT-13] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
整型 int 类型必须声明为无符号整型或者有符号整型 [PORT-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"不要假设整型数据为32位长度 (它可能只有16位长)."



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守这条规则会让代码更加的安全可读.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo()
{
    int a; // 违规
};

int goo();     // 违规n



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo()
{
    signed int a;   // OK
};

unsigned int goo();     // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel Coding Standards 
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 18 Portable Code - 18.2 Sizes of Types - Port. Rec. 3

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-14</key>
<configkey>PORT-14</configkey>
<name><![CDATA[ 避免在赋值操作中从"短"("shorter")的类型转换成"长"("longer")的类型 [PORT-14] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在赋值操作中从"短"("shorter")的类型转换成"长"("longer")的类型 [PORT-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"从"短"("shorter")的类型转换成"长"("longer")的类型要注意."
参见: PB-06, MISRA-043, PORT-15, PORT-16



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则会防止数据丢失.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1() {
   int intValue;
   long longValue = 1L;
   longValue = intValue;	// 违规
}

void foo2() {
    int intValue=1;
    float floatValue;
    floatValue = intValue;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要将shorter类型转换为longer类型.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3</A>
   From: 18 Portable Code - 18.3 Type Conversions - Port. Rec. 6

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-15</key>
<configkey>PORT-15</configkey>
<name><![CDATA[ 不能将 "短"("shorter") 类型强制转换成 "长"("longer") 类型 [PORT-15] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将 "短"("shorter") 类型强制转换成 "长"("longer") 类型 [PORT-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"注意不要做从短类型到长类型的转换."
参见: PORT-14, PORT-16,  MISRA2004-10_1, MISRA2004-10_2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范预防资料丢失.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo3() {
    int longValue = 1L;
    (double)longValue;	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要做从短类型到长类型的转换.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3</A>
   来自: 18 Portable Code - 18.3 Type Conversions - Port. Rec. 6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-16</key>
<configkey>PORT-16</configkey>
<name><![CDATA[ 避免在函数调用中从"短"("shorter")的类型转换成"长"("longer")的类型 [PORT-16] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在函数调用中从"短"("shorter")的类型转换成"长"("longer")的类型 [PORT-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

32位一下的平台double类型可以保留所有的标记位.
64位平台double类型可以保留52标记位,并且有位被丢失.
参见: PORT-14, PORT-15



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该规则防止数据丢失.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void moo (double d) {}
void foo () {
    long longValue = 1L;
    moo(longValue);	// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void moo (double d) {}
void foo () {
    double longValue = 1;
    moo(longValue);	// OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel Coding Standards 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html#18.3</A>
   From: 18 Portable Code - 18.3 Type Conversions - Port. Rec. 6

2. ISO/DIS 26262
   point 8.4.4

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-17</key>
<configkey>PORT-17</configkey>
<name><![CDATA[ 不能直接使用 'i64' 或者 'L' 后缀 [PORT-17] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能直接使用 'i64' 或者 'L' 后缀 [PORT-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果代码中有常量的后缀，你将需要修改
64位架构上的代码使用，因为'L' or 'l'后缀 
(意味着长整型) 在Windows(64位)上是一个32位的类型. Windows(64位) 使用
 'i64' 后缀.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在文件中间增加一个宏定义将使代码变得通用,
它将通用在UNIX(64位)
和Windows(64位) 操作系统上被编译. 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(){
    long l;
    unsigned long ul;
    l = 123456789l;   // 违规
    l = 123456789L;   // 违规
    ul = 123456789ul; // 违规
    ul = 123456789uL; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifdef _WIN64
   #define CONST3264(a) (a##i64)
#else
   #define CONST3264(a) (a##L)
#endif

void foo(){
    long l;
    unsigned long ul;
    l = CONST3264( 123456789 );   // OK
    ul = CONST3264( 123456789u ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

<A HREF="http://software.intel.com/en-us/articles/support-integer-constant-type-suffixes-on-64-bit-architecture/">http://software.intel.com/en-us/articles/support-integer-constant-type-suffixes-on-64-bit-architecture/</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-19</key>
<configkey>PORT-19</configkey>
<name><![CDATA[ 不要在表达式中将长类型操作符强制转换成整型，将表达式的结果进行强制转换 [PORT-19] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在表达式中将长类型操作符强制转换成整型，将表达式的结果进行强制转换 [PORT-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这规范检测是否使用显式转换在长类型的操作数. 
长类型的显式缩小转换应该使用在表达式中， 
而不是操作数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

遵守这一规则可以防止数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   int int1, int2;
   long longValue;
   int2 = ((int)longValue)/int1; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo() 
{
   int int1, int2;
   long longValue;
   int2 = (int)(longValue/int1); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-20</key>
<configkey>PORT-20</configkey>
<name><![CDATA[ 不能直接声明 long 类型的变量 [PORT-20] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能直接声明 long 类型的变量 [PORT-20-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这种代码检查不管你使用长整型. 
在 win32/unix32/win64上, 长整型有32位. 在unix64机器上, 长整型有64位. 
用你自己的或者自己定义的变量类型取代长整型.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

用以下的规则可以避免数据丢失.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define ARCH32 true
#ifndef __int3264
#ifdef ARCH32
#define __int3264 int // 32位类型在win32和 unix32系统上
#else //ARCH64
#ifdef win64 
#define __int3264 __int64 // 64位类型在 win64系统上
#else //unix64
#define __int3264 int64_t //64位类型在 unix64系统上
#endif
#endif
#endif
long lVal;        // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define ARCH32 true
#ifndef __int3264
#ifdef ARCH32
#define __int3264 int // 32位类型在win32和 unix32系统上
#else //ARCH64
#ifdef win64 
#define __int3264 __int64 // 64位类型在 win64系统上
#else //unix64
#define __int3264 int64_t //64位类型在 unix64系统上
#endif
#endif
#endif
__int3264 newlVal; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-21</key>
<configkey>PORT-21</configkey>
<name><![CDATA[ 不能将 long 变量赋值给 double [PORT-21] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将 long 变量赋值给 double [PORT-21-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在32位系统下，double可以支持所有的标记位. 
在64位系统下，double可以支持52个标记位，有些位将丢失.
参见: MISRA-043, PB-06



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则防止有可能的数据截断以及丢失.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo() 
{
   double doubleValue;
   long longValue = 1L;
   doubleValue = longValue;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要将一个长整型的数据赋值给double.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-22</key>
<configkey>PORT-22</configkey>
<name><![CDATA[ 使用整型数组而非使用 long 类型的大数组 [PORT-22] ]]></name>
<tag>port</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用整型数组而非使用 long 类型的大数组 [PORT-22-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"大的long或者unsigned的类型数组, 会引起严重的 
性能衰退在LP64数据类型模型，相对于
int或者unsigned类型的数组.大的lon类型数组会引起
明显的缓存遗漏并且耗费更多的内存. 
这样一来,如果int类型和long类型一样能满足应用程序需求, 
那么最好使用int类型而不是long类型." 
参见: PORT-23, PORT-24


注意: 这条规则检查静态long类型的数组分配超过 2^16-1
        个元素.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

减少内存消耗以及避免可能的性能衰退.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef long LONG;

long tab1[12];                            // OK
long tab2[65536];                         // 违规
long int tab3[65536];                     // 违规
long tab4[256][32][16];                   // 违规
unsigned long int tab5[65536];            // 违规
LONG tab6[100000];                        // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

long tab1[12];                            // OK
int tab2[65536];                          // OK
int tab4[256][32][16];                    // OK
unsigned int tab5[65536];                 // OK
int tab6[100000];                         // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Converting 32-bit Applications Into 64-bit Applications: Things to Consider
    <A HREF="http://developers.sun.com/prodtech/cc/articles/ILP32toLP64Issues.html">http://developers.sun.com/prodtech/cc/articles/ILP32toLP64Issues.html</A>
     
2. Multiplatform Porting to 64 Bits
    <A HREF="http://www.ddj.com/184406427">http://www.ddj.com/184406427</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-23</key>
<configkey>PORT-23</configkey>
<name><![CDATA[ 使用整型数组而非使用动态分配的 long 类型的大数组 [PORT-23] ]]></name>
<tag>port</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用整型数组而非使用动态分配的 long 类型的大数组 [PORT-23-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"大的long或者unsigned的类型数组, 会引起严重的 
性能衰退在LP64数据类型模型，相对于
int或者unsigned类型的数组.大的lon类型数组会引起
明显的缓存遗漏并且耗费更多的内存. 
这样一来,如果int类型和long类型一样能满足应用程序需求, 
那么最好使用int类型而不是long类型." 
参见: PORT-23, PORT-24


注意: 这条规则检查静态long类型的数组分配超过 2^16-1
        个元素.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

减少内存消耗以及避免可能的性能衰退.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

long *arr1 = new long[70000];        // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int *arr1 = new int[70000];           // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Converting 32-bit Applications Into 64-bit Applications: Things to Consider
    <A HREF="http://developers.sun.com/prodtech/cc/articles/ILP32toLP64Issues.html">http://developers.sun.com/prodtech/cc/articles/ILP32toLP64Issues.html</A>
     
2. Multiplatform Porting to 64 Bits
    <A HREF="http://www.ddj.com/184406427">http://www.ddj.com/184406427</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-24</key>
<configkey>PORT-24</configkey>
<name><![CDATA[ 不能使用指向布尔、字符、短型、整型和浮点类型的指针的大数组 [PORT-24] ]]></name>
<tag>port</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用指向布尔、字符、短型、整型和浮点类型的指针的大数组 [PORT-24-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"大的long或者unsigned的类型数组, 会引起严重的 
性能衰退在LP64数据类型模型，相对于
int或者unsigned类型的数组.大的lon类型数组会引起
明显的缓存遗漏并且耗费更多的内存(...)
这就需要用数据类型的数组代替指针类型的数组
 一些C的应用程序饱受严重的性能
减退的困扰在转换为LP64数据类型模型以后，因为
他们依赖于很多，大的指针数组"
参见: PORT-22, PORT-23


注意:规则报告违规的大的指针数组(超过2^16 个元素) 
      指向bool, char, short, int ，float 这些类型.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

减少内存消耗以及避免可能的性能衰退.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int* arr1[100000];       // 违规
float* arr2[100000];     // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int arr1[100000];       // OK
float arr2[100000];     // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Converting 32-bit Applications Into 64-bit Applications: Things to Consider
    <A HREF="http://developers.sun.com/prodtech/cc/articles/ILP32toLP64Issues.html">http://developers.sun.com/prodtech/cc/articles/ILP32toLP64Issues.html</A>
     
2. Multiplatform Porting to 64 Bits
    <A HREF="http://www.ddj.com/184406427">http://www.ddj.com/184406427</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-25</key>
<configkey>PORT-25</configkey>
<name><![CDATA[ 用户指定的标识符(内部或者外部的)不能多于 64 个字符 [PORT-25] ]]></name>
<tag>port</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
用户指定的标识符(内部或者外部的)不能多于 64 个字符 [PORT-25-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

超过64个字符的标志符不允许被使用.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则确保代码在大多数的编译器/链接器
的可移植性，不需要修改或者(缩小)标志符的名称



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int really_long_paaaaaaaaaaaaaaaaraaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaam) // 违规 65 字符
{

}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo(int really_long_paaaaaaaaaaaaaaaaraaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaam)  // OK 64 字符
{

}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.9 Style, AV Rule 46

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-26</key>
<configkey>PORT-26</configkey>
<name><![CDATA[ 算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序 [PORT-26] ]]></name>
<tag>port</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序 [PORT-26-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则是为了防止应用程序被假设
关于被标志符分隔的非静态成员的顺序
是有序的.
规则报告一个违规信息如果如果静态转换的类型指向一个类
具有被分隔符分隔的非静态数据成员.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

被标志符分隔的非静态成员的顺序
不确定.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A
{
   protected: // a比b先被存储, 或者反过来也一样
      int a;
   private:
      int b;
};


class M: A
{
};

void foo(M* message_buffer_ptr)
{
   A* a_ptr = static_cast&lt;A*&gt;(message_buffer_ptr);     // 违规
                                                       // 应用程序架设对象的
                                                       //数据类型将总是先拥有属性a
                                                       // 被存储，先于属性b.
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

struct A
{
    int a;
    int b;
};

class M: A
{
};

void foo(M* message_buffer_ptr)
{
   A* a_ptr = static_cast&lt;A*&gt;(message_buffer_ptr);     // OK
                                                       // 属性B没有被标识符
                                                       // 分隔
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第4.28章节 Portable Code, AV Rule 210.1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-27</key>
<configkey>PORT-27</configkey>
<name><![CDATA[ 避免隐式转换为窄大小类型 [PORT-27] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免隐式转换为窄大小类型 [PORT-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if parameter/variable/expression of integral
type is implicitly converted to a narrower integral type
or parameter/variable/expression of floating type is implicitly converted
to a narrower floating type.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v9.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule does not check:
- conversions of constant expressions.
- conversions of bit fields
- conversions between integral and floating types

Enumeration types are treated in the same way as integral types.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents possible loss of data.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

enum E1_int{
    E1_int = 0xFFFF,
    E2_int
}e1;

void foo(unsigned int i){
    unsigned char c1 = e1;  // 违规
    unsigned char c2 = i;   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

enum E1_int{
    E1_int = 0xFFFF,
    E2_int
}e1;

void foo(){
    unsigned int c = e1;                // OK
    unsigned char c2 = (unsigned int)i; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PORT-28</key>
<configkey>PORT-28</configkey>
<name><![CDATA[ 避免将常数值转换为一个窄类型 [PORT-28] ]]></name>
<tag>port</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免将常数值转换为一个窄类型 [PORT-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

The rule reports a violation if an integer or enumeration constant is passed
to a type that is not enough to hold its value.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v9.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

The rule does not report violations on complex constant expressions.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

The rule prevents a loss of data.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo1(){
    unsigned char c = 256;  // 违规
    short s = 32768;        // 违规
    int i = 2147483648;     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void foo1(){
    unsigned short c = 256;       // OK
    int s = 32768;                // OK
    unsigned int i = 2147483648;  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-01</key>
<configkey>PREPROC-01</configkey>
<name><![CDATA[ 避免使用宏 [PREPROC-01] ]]></name>
<tag>preproc</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用宏 [PREPROC-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

宏通常是从 C 语言继承来的一个陈旧的构造。 
使用宏的主要问题是:
- 不是类型安全的
- 是被预处理器扩大了，所以调试它们是不可能的
- 纯粹根据运气创建丑陋问题的程序可以编译


例外:

宏几乎没有必要存在于 C++ 语言中。此规则的例外是:
- #ifdef
- #ifndef
- #if
- #if defined
当被用作 include 防范和条件编译。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可靠性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PI 3.14  // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

const double PI = 3.14; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, “C++ 编码规范” Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   章节: "Coding Style", 第 16 条规则

2. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 31 条规则

3. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-02</key>
<configkey>PREPROC-02</configkey>
<name><![CDATA[ 不应在 include 语句中使用宏 [PREPROC-02] ]]></name>
<tag>preproc</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不应在 include 语句中使用宏 [PREPROC-02-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查宏在include语句中不被使用. 
包含 "#define"的头文件被预定义使得代码
的可读性变差.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

可读性和清晰性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

/* 注意:
 * 你必须保证你的编译器可以做到
 * 而且它给出的头文件是可以获得的
 * 在gcc条件下工作
 */
#define A(string) #string
#define HEADER_FILE(nr) A(MacroWithinInclude ## nr)

#include HEADER_FILE(12)                // 违规

#include "MacroWithinInclude12"         // OK



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在 include语句中使用宏



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-03</key>
<configkey>PREPROC-03</configkey>
<name><![CDATA[ 不能重定义原始类型 [PREPROC-03] ]]></name>
<tag>preproc</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能重定义原始类型 [PREPROC-03-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
描述:

这条规则检查是否使用#define directive重新定义原始类型.
可以避免生成新的不必要的类型以增强代码的可读性.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

增强代码的可读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define T30 char                // 违规
#define T31 unsigned char   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define T30 char_def               // OK
#define T31 unsigned_char_def   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft推荐规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-04</key>
<configkey>PREPROC-04</configkey>
<name><![CDATA[ 不能只定义一部分语句 [PREPROC-04] ]]></name>
<tag>preproc</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能只定义一部分语句 [PREPROC-04-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查是否只定义了一部分语句.
定义一部分语句会使代码不易读、极容易出错.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防代码不可读.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PARTIAL(a) ((a) * // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define PARTIAL(a) ((a) * (a)) // OK



相关资料:

Parasoft推荐规则.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-05</key>
<configkey>PREPROC-05</configkey>
<name><![CDATA[ 在宏函数中，应使用括号将乘法和除法操作括起来 [PREPROC-05] ]]></name>
<tag>preproc</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在宏函数中，应使用括号将乘法和除法操作括起来 [PREPROC-05-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查在宏函数中，是否使用括号将乘法和除法操作括起来.


例外:

这条规则不会报出违规如果是常量使用乘法和除法操作.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码可读性、确保操作顺序.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define DIVISION_1(x)  ( x / (x))    // 违规
#define DIVISION_2(x)  ((x) / 2 + 5) // 违规
#define DIVISION_3(x)  (256 / x)     // 违规
#define MULTI_1(x)  (x * (x))        // 违规
#define MULTI_2(x)  ((x) * 2 + 5)    // 违规
#define MULTI_3(x)  (256 * x)        // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define DIVISION_1(x)  ( (x) / (x))     // OK
#define DIVISION_2a(x)  ((x) / (2 + 5)) // OK
#define DIVISION_2b(x)  (((x) / 2) + 5) // OK
#define DIVISION_3(x)  (256 / (x))      // OK
#define MULTI_1(x)  ( (x) * (x))        // OK
#define MULTI_2a(x)  ((x) * (2 + 5))    // OK
#define MULTI_2b(x)  (((x) * 2) + 5)    // OK
#define MULTI_3(x)  (256 * (x))         // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

ParaSoft推荐资料

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-06</key>
<configkey>PREPROC-06</configkey>
<name><![CDATA[ 不允许在 #include 语句中带有相对路径名 [PREPROC-06] ]]></name>
<tag>preproc</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许在 #include 语句中带有相对路径名 [PREPROC-06-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不允许在 #include 语句中带有相对路径名.
规则禁止使用:
-任何包括相对路径名的"/"符号
-在#include 文件开头的"/"符号包含相对路径名
-任何".."符号



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则预防在#include语句中带有相对路径名.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "inc/foo.hh"       // OK
#include "inc/../foo.hh"    // 违规
#include &lt;sys/../time.h&gt;    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include "inc/foo.hh"       // OK
#include "inc/foo.hh"       // OK
#include &lt;sys/time.h&gt;       // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Ellemtel代码规则
<A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A> 
From: 4 Source Code in Files - 4.4 Include Files - Rule 10

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-07</key>
<configkey>PREPROC-07</configkey>
<name><![CDATA[ 不正确的 'NULL' 定义 [PREPROC-07] ]]></name>
<tag>preproc</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不正确的 'NULL' 定义 [PREPROC-07-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检查是否使用(void*)0定义NULL.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

任何NULL的其他用途很有能会引起问题.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

Example:

#define NULL 0 // 违规
#undef NULL
#define NULL // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define NULL (void*)0 // OK


相关资料:

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-08</key>
<configkey>PREPROC-08</configkey>
<name><![CDATA[ 仅可以在包含头文件(*.h)时使用 #include 预处理指令 [PREPROC-08] ]]></name>
<tag>preproc</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
仅可以在包含头文件(*.h)时使用 #include 预处理指令 [PREPROC-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#include 预处理指令只能用来包含
头文件 (*.h).


例外:

在类模板或函数定义, 代码可能
由头文件和实施文件划分. 此情
况下, 实施文件可能是头文件的
一部分. 规范允许此例外如果实
施文件有着和头文件一样的名字.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改善代码的清晰.
在 .cpp 文件里的包含将
只和头文件 (*.h) 相关.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.cpp
#include &lt;file2.cpp&gt;  // 违规
#include &lt;file3.hh&gt;   // 违规

// file.h
#include &lt;file2.cpp&gt;  // 违规
#include &lt;file3.hh&gt;   // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.cpp
#include &lt;file2.h&gt;    // OK - 头文件 (*.h)
#include &lt;file3.h&gt;    // OK - 头文件 (*.h)

// file.h
#include &lt;file.cpp&gt;   // OK - 和 file.h 同名的实施文件 file.cpp
#include &lt;file2.h&gt;    // OK - 头文件 (*.h)
#include &lt;file3.h&gt;    // OK - 头文件 (*.h)



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机, 飞行器, C++ 编程规范
第 4.6 章节 Pre-Processing Directives, AV 第 32 规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-09</key>
<configkey>PREPROC-09</configkey>
<name><![CDATA[ #include 指令只能使用 <filename.h> 符号来包含头文件 [PREPROC-09] ]]></name>
<tag>preproc</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
#include 指令只能使用 &lt;filename.h&gt; 符号来包含头文件 [PREPROC-09-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#include 指令只能使用&lt;filename.h&gt;符号来包含头文件.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

include指令格式 "filename.h" 通常是用于包括当地的头文件
然而，由于在供应商在实现方面的分歧，只有&lt;filename.h&gt;形式将被使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include "foo.h" // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;foo.h&gt;           // OK
#include &lt;dir1/dir2/foo.h&gt; // OK: 使用相对路径



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

联合攻击战斗机,飞行器,C++编码标准
第4.7章,第AV 33条规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-10</key>
<configkey>PREPROC-10</configkey>
<name><![CDATA[ #ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [PREPROC-10] ]]></name>
<tag>preproc</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
#ifndef 和 #endif 预处理指令将仅用于防止重复地包含相同的头文件 [PREPROC-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

#ifndef 和 #endif 预处理指令将仅用于
下面的例子中定义那样来防止重复地包含
相同的头文件。

#ifndef Header_filename
#define Header_filename
// 头文件声明...
#endif



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

有条件的代码编译应该保持最小量，
因为他能显著地使测试和维护工作变得不清晰。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifndef MAX                 // 违规

int max = 10;

#endif                      // 违规

int a;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef FOO_H               // OK
#define FOO_H 

int max = 10;
int a;

#endif                      // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 28 条规则

2. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1
3. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-11</key>
<configkey>PREPROC-11</configkey>
<name><![CDATA[ 只有下列预处理器指令才能被使用: #ifndef, #define, #endif, #include [PREPROC-11] ]]></name>
<tag>preproc</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只有下列预处理器指令才能被使用: #ifndef, #define, #endif, #include [PREPROC-11-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只有下列预处理器指令才应该被使用: #ifndef,
#define, #endif, #include



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

限制预处理器的使用的情况是必要的。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#pragma once // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#ifndef FOO_H              // OK
#define FOO_H
/* ... */
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. 联合攻击战斗机, 飞行器, C++ 编码规范
   第 4.6 章 Pre-Processing Directives, AV 第 26 条规则

2. MISRA C++:2008 - C++语言在关键系统中的使用指南
   第 6 章, 第 16 节, 规则 16-2-1

3. The Power of Ten - Rules for Developing Safety Critical Code.
   Rule 8

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-12</key>
<configkey>PREPROC-12</configkey>
<name><![CDATA[ C++ 宏应该只能用于包含保护(include guards)，类型修饰符，或存储类限定符 [PREPROC-12] ]]></name>
<tag>preproc</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
C++ 宏应该只能用于包含保护(include guards)，类型修饰符，或存储类限定符 [PREPROC-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“C++ 宏应该只能用于包含保护(include guards)，类型修饰符，
或存储类限定符。这是唯一允许使用宏的情况。C++ 提供
const 变量和函数模板，它为预处理器提供了一个类型安全
的替代”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

类型修饰符和存储类限定符的列表:
// 类型修饰符:
    const
    volatile
// 存储类限定符:
    auto
    register
    static
    extern
    mutable 



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

提高代码的可靠性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PI 3.14         // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define STOR extern     // OK storage class specifier
const double PI = 3.14; // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

MISRA C++:2008 - C++语言在关键系统中的使用指南
第 6 章, 第 16 节, 规则 16-2-2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-13</key>
<configkey>PREPROC-13</configkey>
<name><![CDATA[ 宏不应该包含标记(token)粘贴，变量参数列表，也不包括递归宏调用 [PREPROC-13] ]]></name>
<tag>preproc</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
宏不应该包含标记(token)粘贴，变量参数列表，也不包括递归宏调用 [PREPROC-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

头文件和简单宏定义必须限制预处理器的使用.
标记(token)粘贴,变量参数列表(省略号),递归宏调用是不允许的.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.3



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

该规则检测直接递归和间接递归，如果它是有限的
到2级和宏定义在相同的文件。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C预处理器是一个强大的模糊处理工具，它可以破坏代码
清晰度和许多基于文本的检查器.对于不受限制的预编译代码,
此构造的影响很难消除,即使人工去写.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define PASTING(a, b) a ## b       // 违规 - 标记(token)粘贴

#define ELLIP(a, b, ...) a + b     // 违规 - 省略号

#define RECUR(a, b) RECUR(a, a)    // 违规 - 递归调用 



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在宏中使用标记(token)粘贴，变量参数列表，也不包括递归宏调用



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

开发安全关键代码规十大则则第八条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-14</key>
<configkey>PREPROC-14</configkey>
<name><![CDATA[ 所有宏必须扩展到完整的句法单位 [PREPROC-14] ]]></name>
<tag>preproc</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
所有宏必须扩展到完整的句法单位 [PREPROC-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"所有宏必须扩展到完整的句法单位.
宏定义对于完整的句法单位的限制意味着
所有的宏定义体必须包括在小括号或者大括号里.


例外:

该规则在宏定义为字符,字符串或者数字常量时不会报告违规,
例如:
  #define CONST1 10   // OK
  #define CONST2 'A'   // OK
  #define CONST3 "foo"  // OK
这些例子很简单不需要括号.
请注意，负数像-10仍违反本规则.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

C预处理器是一个强大的模糊处理工具，它可以破坏代码
清晰度和许多基于文本的检查器.对于不受限制的预编译代码,
此构造的影响很难消除,即使人工去写.


出自:

v7.3



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MAC1(a, b) a + b                 // 违规 - 没有括号



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define MAC1(a, b) (a + b)               // OK


相关资料:

制定安全规则的关键代码十大规则第八条

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>PREPROC-15</key>
<configkey>PREPROC-15</configkey>
<name><![CDATA[ 指针解引用操作不应该被隐藏在宏定义中 [PREPROC-15] ]]></name>
<tag>preproc</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
指针解引用操作不应该被隐藏在宏定义中 [PREPROC-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

指针的使用应该被限制.指针解引用操作不应该被隐藏在宏定义中.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

指针很容易被滥用,甚至包括有经验的程序员.
使得程序很难分析数据流,特别是基本工具的静态分析.


自:

v7.3



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define MAC1(a, b)  *a + b      // 违规
#define MAC2(a, b) (a + *b)     // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not use pointer dereference operations in macro definitions.
不要在宏定义中使用指针解操作.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

开发安全关键代码十大规则第九条.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-01</key>
<configkey>QT-01</configkey>
<name><![CDATA[ 每一个 QObject 子类只能包含一个 Q_OBJECT 宏 [QT-01] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个 QObject 子类只能包含一个 Q_OBJECT 宏 [QT-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

每一个QObject子类只能包含一个Q_OBJECT宏.
否则Qt元类型系统不会使用.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果Q_OBJECT宏没有使用,可能使用没有包含Q_OBJECT宏和
继承对象代码的QObject子类作为基类,而不是信号槽也不
是任何其他基于特征的元型特征（属性,类名,继承检查,
国际化,动态的QObject铸件).从继承对象系统的角度上看,
一个没有元代码的QObject子类相当于其最接近的祖先.
这意味着例如,QMetaObject::的className()将不会返
回类的实际名称，而是祖先类的名称.
此外,使用功能的动态铸造qobject_cast(对象的QObject *)
将只能转换为祖先类的类型.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

class QFigure: public QObject
{
    Q_OBJECT

private:
    Q_DISABLE_COPY(QFigure)
};

class QCircle: public QFigure       // Violation - no Q_OBJECT macro present
{
private:
    Q_DISABLE_COPY(QCircle)
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

class QFigure: public QObject
{
    Q_OBJECT

private:
    Q_DISABLE_COPY(QFigure)
};

class QCircle: public QFigure       // OK
{
    Q_OBJECT

private:
    Q_DISABLE_COPY(QCircle)
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则.
<A HREF="http://doc.trolltech.com/4.2/metaobjects.html">http://doc.trolltech.com/4.2/metaobjects.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-02</key>
<configkey>QT-02</configkey>
<name><![CDATA[ QObject 不能被继承超过一次 [QT-02] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
QObject 不能被继承超过一次 [QT-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

QObject 继承不能超过一次.


好处:

元对象系统不能正常合并从两个QObject的派生类的元信息.
由此产生的元对象文件也许不能编译,你将无法访问超类的对象.
你也不能传递对象给超类.
QObjects多重继承也意味着内部重复数据结构.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;
#include &lt;QtGui/QWidget&gt;

class ClipboardInterface : public QObject
{
    Q_OBJECT

public slots:
    void cut();
    void copy() const;
    void paste();

private:
    Q_DISABLE_COPY(ClipboardInterface)
};

class CustomWidget : public QWidget, public ClipboardInterface // 违规
{                                             // 继承了两次QObjects类
    Q_OBJECT

private:
    Q_DISABLE_COPY(CustomWidget) 
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// for workaround detailed description visit:
// <A HREF="http://doc.trolltech.com/qq/qq15-academic.html">http://doc.trolltech.com/qq/qq15-academic.html</A>
#include &lt;QtCore/QObject&gt;
#include &lt;QtGui/QWidget&gt;

class ClipboardInterface
{
public:
    virtual void cut() = 0;
    virtual void copy() const = 0;
    virtual void paste() = 0;
};

class ClipboardWrapper;

class CustomWidget : public QWidget, public ClipboardInterface  // OK
{
    Q_OBJECT

public:
    CustomWidget(QWidget *parent = 0);

    void cut();
    void copy() const;
    void paste();

private:
    ClipboardWrapper *wrapper;
    Q_DISABLE_COPY(CustomWidget)
};

class ClipboardWrapper : public QObject, public ClipboardInterface
{
    Q_OBJECT

public:
    ClipboardWrapper(QObject *parent): QObject(parent)
    {
        Q_ASSERT(parent);
        wrappedObject = qobject_cast&lt;CustomWidget *&gt;(parent);
        Q_ASSERT(wrappedObject);
    }

public slots:
    void cut() { wrappedObject-&gt;cut(); }
    void copy() const { wrappedObject-&gt;copy(); }
    void paste() { wrappedObject-&gt;paste(); }

private:
    ClipboardInterface *wrappedObject;
    Q_DISABLE_COPY(ClipboardWrapper)
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则
<A HREF="http://doc.trolltech.com/qq/qq15-academic.html#multipleinheritance">http://doc.trolltech.com/qq/qq15-academic.html#multipleinheritance</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-03</key>
<configkey>QT-03</configkey>
<name><![CDATA[ 只能将一个信号与一个插槽 slot 连接，一个信号只能与另一个信号连接 [QT-03] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
只能将一个信号与一个插槽 slot 连接，一个信号只能与另一个信号连接 [QT-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

只能将一个信号与一个插槽 slot 连接.
一个信号只能与另一个信号连接.


好处:

插槽被认为是观察员,并无法连接在一起因为
不会触发信号源的插槽.但是,您可能一个信号
连接多个插槽.一个槽不能连接到信号,但有
一个信号可以连接到它的一个插槽;的方向连
接是重要的.您可以连接许多信号,你要一个插槽,
一个信号可以连接到尽可能多的插槽,
你需要的.它甚至可以直接连接一个信号到另一个信号.
(这将立即发出第二个信号是发射时的第一个).



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

class MyQObject: public QObject
{
    Q_OBJECT

public:
    MyQObject();

public slots:
    int sampleSlot(QString qStr, const MyQObject&amp; myQObjRef, int* i);

signals:
    void someSignal(QString qStr);

private:
    Q_DISABLE_COPY(MyQObject)
};

void myFunction(QString qStr)
{
    MyQObject obj1, obj2;
    QObject::connect(&amp;obj1,                                        // 违规
                     SLOT(sampleSlot(QString, const MyQObject&amp;, int*)),
                     &amp;obj2, SIGNAL(someSignal(QString)));
    QObject::connect(&amp;obj1,                                        // 违规
                     SLOT(sampleSlot(QString, const MyQObject&amp;, int*)),
                     &amp;obj2, SLOT(sampleSlot(QString, const MyQObject&amp;, int*)));
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

class MyQObject: public QObject
{
    Q_OBJECT

public:
    MyQObject();

public slots:
    int sampleSlot(QString qStr, const MyQObject&amp; myQObjRef, int* i);

signals:
    void someSignal(QString qStr);

private:
    Q_DISABLE_COPY(MyQObject)
};

void myFunction(QString qStr)
{
    MyQObject obj1, obj2;
    QObject::connect(&amp;obj1, SIGNAL(someSignal(QString)),    // OK
                     &amp;obj2, SIGNAL(someSignal(QString)));
    QObject::connect(&amp;obj1, SIGNAL(someSignal(QString)),    // OK
                     &amp;obj2, SLOT(sampleSlot(QString, const MyQObject&amp;, int*)));
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则
<A HREF="http://doc.trolltech.com/4.2/signalsandslots.html">http://doc.trolltech.com/4.2/signalsandslots.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-04</key>
<configkey>QT-04</configkey>
<name><![CDATA[ SIGNAL 和 SLOT 宏里的方法必须存在 [QT-04] ]]></name>
<tag>qt</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
SIGNAL 和 SLOT 宏里的方法必须存在 [QT-04-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

SIGNAL 和 SLOT 宏里的方法必须存在(参数必须
匹配) 并且这些方法需要标以 Q_SLOTS 或 Q_SIGNALS。 
这里以一个简单的事例代码，该事例试图输出 ”goodbye“ 
消息, 通知连接中的 SLOT 的名字没有与声明匹配。 
该事例能够编译和运行， 但得不到期望的结果。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

"Q_SLOTS" 和 "Q_SIGNALS" 等于"slots" 和 "signals".


声明：

Qt's signal &amp; slot 机制是非常强大的，因为其提供在 signals 
和 slots 之间的运行时的动态连接。 这支持灵活脚本和动态用
户接口开发, 但同时也带来相应的代价：
在编译阶段，当 signal 和 slot 连接无效时, 
编译器不会提示你。 在运行时，你会得到一个警告，但这太迟了。
该规则在代码分析阶段强制检测 signal 和 slot 连接的有效性。


事例：

#include &lt;QtGui/QtGui&gt;

class MyWidget: public QWidget
{
    Q_OBJECT
public:
    MyWidget( char* initText ) { qDebug() &lt;&lt; initText; }
public slots:
    void showGoodByeMessage() { qDebug() &lt;&lt; "GoodBye"; }
private:
    Q_DISABLE_COPY(MyWidget)
};

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    MyWidget w1( "New MyWidget" );
    MyWidget w2( "New MyWidget" );

    w1.show();
    w2.show();

    // 违规 showGoodBye() 不是 slot 方法
    QObject::connect(&amp;app, SIGNAL(lastWindowClosed()),
                     &amp;w1, SLOT(showGoodBye()));

    return app.exec();
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

class MyWidget: public QWidget
{
    Q_OBJECT
public:
    MyWidget( char* initText ) { qDebug() &lt;&lt; initText; }
public slots:
    void showGoodByeMessage() { qDebug() &lt;&lt; "GoodBye"; }
private:
    Q_DISABLE_COPY(MyWidget)
};

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    MyWidget w1( "New MyWidget" );
    MyWidget w2( "New MyWidget" );

    w1.show();
    w2.show();

    // OK
    QObject::connect(&amp;app, SIGNAL(lastWindowClosed()),
                     &amp;w1, SLOT(showGoodByeMessage()));

    return app.exec();
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by Parasoft and Trolltech

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-05</key>
<configkey>QT-05</configkey>
<name><![CDATA[ 使用关键字 "emit" 标示信号量(signal emissions)，以区别从普通方法调用的信号量(signal emissions) [QT-05] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用关键字 "emit" 标示信号量(signal emissions)，以区别从普通方法调用的信号量(signal emissions) [QT-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

应该使用关键字 "emit" 标示信号量(signal emissions),
以区别从普通方法调用的信号量(signal emissions).



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

'emit'没有必要扩展,但是被认为是一种好的风格.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

class QFigure : public QObject
{
    Q_OBJECT

public:
    void someSignal(double);
    void test();

signals:
    void someSignal(int);

private:
    Q_DISABLE_COPY(QFigure)
};

void QFigure::test()
{
    emit someSignal(1);
    emit someSignal(1.5); // 违规 - someSignal(double)不是信号
    someSignal(1);        // 违规 - 省略'emit'关键字
    someSignal(1.5);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

class QFigure : public QObject
{
    Q_OBJECT

public:
    void someSignal(double);
    void test();

signals:
    void someSignal(int);

private:
    Q_DISABLE_COPY(QFigure)
};

void QFigure::test()
{
    emit someSignal(1);
    someSignal(1.5);       // OK
    emit someSignal(1);    // OK
    someSignal(1.5);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-06</key>
<configkey>QT-06</configkey>
<name><![CDATA[ 不能将 QThreads 的优先级设置为 Idle 或者 Critical，只能设置成 High/Low/Med [QT-06] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将 QThreads 的优先级设置为 Idle 或者 Critical，只能设置成 High/Low/Med [QT-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

能将 QThreads 的优先级设置为 Idle 或者 Critical,只能设置成 High/Low/Med.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Idle和Critica优先级会引起死锁.
某些操作系统将不允许设置线程的优先级,
这样的结果是平台特定的.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

void myFunction( QThread* qt1, QThread* qt2 ) {
    qt1-&gt;start( QThread::IdlePriority );           // 违规
    qt2-&gt;setPriority( QThread::IdlePriority );     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

void myFunction( QThread* qt1, QThread* qt2 ) {
    qt1-&gt;start( QThread::NormalPriority );         // OK
    qt2-&gt;setPriority( QThread::InheritPriority );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-07</key>
<configkey>QT-07</configkey>
<name><![CDATA[ 不要通过访问 QThread::terminate() 强迫终止线程 [QT-07] ]]></name>
<tag>qt</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要通过访问 QThread::terminate() 强迫终止线程 [QT-07-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要通过访问 QThread::terminate() 强迫线程退出。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

该函数危险，不鼓励使用它。线程可能立即或
不立即终止，这依赖于操作系统的调度策略。
线程可能在代码执行的任何路径上终止. 可
能在修改数据时终止。没有任何机会清除它
自己，解锁互斥体等。


事例：

#include &lt;QtGui/QtGui&gt;

class MyQThread : public QThread
{
    Q_OBJECT

public:
    void terminate();
    void run();
    MyQThread();

private:
    Q_DISABLE_COPY(MyQThread)
};

void MyQThread::terminate()
{
    QThread::terminate(); // 违规
}

void foo(){
    MyQThread qt;
    qt.terminate();
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 QThread::terminate()。 使用线程的 run() 
函数返回替代， 或者抛出异常并在 run() 函数末尾截获该异常。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by Parasoft and Trolltech
<A HREF="http://doc.trolltech.com/4.2/qthread.html#terminate">http://doc.trolltech.com/4.2/qthread.html#terminate</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-08</key>
<configkey>QT-08</configkey>
<name><![CDATA[ 如果在某函数中使用互斥锁，应由同一个函数进行释放 [QT-08] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果在某函数中使用互斥锁，应由同一个函数进行释放 [QT-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果在某函数中使用互斥锁,应由同一个函数进行释放.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

不解锁功能在同一互斥锁可能导致不一致锁定和解锁,
这将打开你的代码导致潜在的死锁.为了确保始终锁定
互斥锁函数结束时,双方通过正常的和异常的代码路径,
考虑使用QMutexLocker类.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include&lt;QtGui/QtGui&gt;

void myExample(bool isBlue, bool isFigure)
{
    QMutex m;
    QMutex n;
    m.lock();

    if (isBlue &amp;&amp; isFigure)
        return;                  // 违规

    m.unlock();

    /* code */

    m.lock();                    // 违规
    n.lock();                    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include&lt;QtGui/QtGui&gt;

void myExample(bool isBlue, bool isFigure)
{
    QMutex m;
    QMutex n;

    m.lock();               // OK

    if (isBlue &amp;&amp; isFigure){
        m.unlock();
        return;             // OK
    }else{
        m.unlock();
    }

    m.lock();               // OK
    n.lock();               // OK

    /* code */

    m.unlock();             // OK
    n.unlock();             // OK
}


</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则.
<A HREF="http://doc.trolltech.com/4.2/qmutex.html#details">http://doc.trolltech.com/4.2/qmutex.html#details</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-09</key>
<configkey>QT-09</configkey>
<name><![CDATA[ 针对 QMutexLocker 不要使用 new [QT-09] ]]></name>
<tag>qt</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
针对 QMutexLocker 不要使用 new [QT-09-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

针对 QMutexLocker 不要使用 new。  事例说明了 QMutexLocker 
错误的使用方式， 事例编译能通过，但是包含了一个定时炸弹
(INT_MAX 迭代后的死锁问题)。 该代码可以通过将 QMutexLocker
放在栈上防止此类问题。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

QMutexLocker 是唯一方便的用于锁和解锁互斥体的类。
将其放在栈上，代码中的异常将释放可能发生错误的
互斥体。


事例：

#include &lt;QtCore/QMutex&gt;
#include &lt;limits.h&gt;

QMutex mutex;
int i = 0;

void increaseCounter()
{
    QMutexLocker *locker = new QMutexLocker(&amp;mutex);   // 违规

    if (i == INT_MAX) {
        qDebug("WARNING: Maximum count reached!!");
        return;
    }
    ++i;
    delete locker;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtCore/QMutex&gt;
#include &lt;limits.h&gt;

QMutex mutex;
int i = 0;

void increaseCounter()
{
    QMutexLocker locker(&amp;mutex);   // OK

    if (i == INT_MAX) {
        qDebug("WARNING: Maximum count reached!!");
        return;
    }
    ++i;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by Parasoft and Trolltech
<A HREF="http://doc.trolltech.com/4.2/qmutexlocker.html">http://doc.trolltech.com/4.2/qmutexlocker.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-10</key>
<configkey>QT-10</configkey>
<name><![CDATA[ 为任何带有指针的 Qt 继承对象声明拷贝构造函数和 = 操作符 [QT-10] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
为任何带有指针的 Qt 继承对象声明拷贝构造函数和 = 操作符 [QT-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

赋值运算符和拷贝构造函数应该是私有的,
没有实现所有的QObject子类.


好处:

有成员指针的类不能执行复制构造函数或赋值操作,
因为编译时会打破隐式共享,并可能导致意外崩溃.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

class MyQObject : public QObject       // 违规
{
    Q_OBJECT
};

class MyQWidget : public QWidget       // 违规
{
    Q_OBJECT

public:
    MyQWidget( MyQWidget&amp; );
    MyQWidget&amp; operator=( MyQWidget&amp; );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

class MyQObject : public QObject       // OK
{
    Q_OBJECT

private:
    MyQObject( MyQObject&amp; );
    MyQObject&amp; operator=( MyQObject&amp; );
};

class MyQWidget : public QWidget       // OK
{
    Q_OBJECT

private:
    Q_DISABLE_COPY(MyQWidget)
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft and Trolltech推荐规则.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-11</key>
<configkey>QT-11</configkey>
<name><![CDATA[ 不能在 Widget 上使用 setWindowFlags 函数 [QT-11] ]]></name>
<tag>qt</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能在 Widget 上使用 setWindowFlags 函数 [QT-11-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不能在 Widget 上使用 setWindowFlags 函数.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在代码中使用setWindowFlags会导致Widge的消失和
重新出现,并改变他们的结构.widget被破坏并为每次
调用重新创建.setWindowFlags功能应该只使用在没有
显示的widget上.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtGui/QWidget&gt;

class PreviewWindow : public QWidget
{
    Q_OBJECT
public:
    PreviewWindow( QWidget *parent = 0, Qt::WindowFlags flags = 0 );
    void setWindowFlags( Qt::WindowFlags flags );
    void setProperty( Qt::WindowFlags flags )
    {
        setWindowFlags( flags );                                    // Violation
    }

private:
    Q_DISABLE_COPY(PreviewWindow)
};

void updatePreview( )
{
    Qt::WindowFlags flags = 0;

    PreviewWindow *previewWindow = new PreviewWindow( 0, flags );
    PreviewWindow previewWindowObj( 0, flags );

    previewWindow-&gt;setWindowFlags( flags );                         // 违规
    previewWindowObj.setWindowFlags( flags );                       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtGui/QWidget&gt;

class PreviewWindow : public QWidget
{
    Q_OBJECT
public:
    PreviewWindow( QWidget *parent = 0, Qt::WindowFlags flags = 0 );
    void setWindowFlags( Qt::WindowFlags flags );
    void setProperty( Qt::WindowFlags flags )
    {
        // OK
    }

private:
    Q_DISABLE_COPY(PreviewWindow)
};

void updatePreview( )
{
    Qt::WindowFlags flags = 0;

    PreviewWindow *previewWindow = new PreviewWindow( 0, flags );  // OK
    PreviewWindow previewWindowObj( 0, flags );                    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-12</key>
<configkey>QT-12</configkey>
<name><![CDATA[ 不要直接设置某个在 Qt 内核中设置的 Widget 属性 [QT-12] ]]></name>
<tag>qt</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要直接设置某个在 Qt 内核中设置的 Widget 属性 [QT-12-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要直接设置某个在 Qt 内核中设置的 Widget 属性。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Qt 使用 widget 属性改变信号状态。
修改由 Qt 内核设置的属性可能导致不同的
影响，最坏的情况可能导致你的应用程序崩溃.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtGui/QWidget&gt;

class PreviewWindow : public QWidget
{
    Q_OBJECT

public:
    PreviewWindow(QWidget *parent = 0, Qt::WindowFlags flags = 0);

private:
    Q_DISABLE_COPY(PreviewWindow) 
};

void updatePreview( Qt::WindowFlags flags )
{
    PreviewWindow *previewWindow = new PreviewWindow( 0, flags );

    previewWindow-&gt;setAttribute(Qt::WA_UnderMouse, true);    // 违规
    previewWindow-&gt;setAttribute(Qt::WA_Disabled, true);      // 违规
    previewWindow-&gt;setAttribute(Qt::WA_SetPalette, true);    // 违规
    previewWindow-&gt;setAttribute(Qt::WA_SetCursor, true);     // 违规
    previewWindow-&gt;setAttribute(Qt::WA_SetFont, true);       // 违规
    previewWindow-&gt;setAttribute(Qt::WA_Disabled, true);      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要直接设置某个在 Qt 内核中设置的 Widget 属性。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by Parasoft and Trolltech
<A HREF="http://doc.trolltech.com/4.2/qt.html#WidgetAttribute-enum">http://doc.trolltech.com/4.2/qt.html#WidgetAttribute-enum</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-13</key>
<configkey>QT-13</configkey>
<name><![CDATA[ 禁止在赋值语句中混合常量和非常量循环符 [QT-13] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止在赋值语句中混合常量和非常量循环符 [QT-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>
..
禁止在赋值语句中混合常量和非常量循环符.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>


常量和非常量循环符混合的时候就没有使用常量循环符的好处,
因为非常量循环符可以分离数据的循环.
此外，在常量数据上使用非常量循环符将无法工作,并会
发生产编译错误.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtGui/QWidget&gt;

void myFunction()
{
    QList&lt;int&gt; nonConstList;

    for (QList&lt;int&gt;::ConstIterator it = nonConstList.begin(); ; ) // 违规
    {
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtGui/QWidget&gt;

void myFunction()
{
    QList&lt;int&gt; nonConstList;
    const QList&lt;int&gt; constList;
    for (QList&lt;int&gt;::ConstIterator it = nonConstList.constBegin(); ; )   // OK
    {
    }

    for (QList&lt;int&gt;::ConstIterator cit = constList.begin(); ; )          // OK
    {
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-14</key>
<configkey>QT-14</configkey>
<name><![CDATA[ 使用 Q_DECLARE_FLAGS 时，必须同时使用 Q_DECLARE_OPERATORS_FOR_FLAGS [QT-14] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 Q_DECLARE_FLAGS 时，必须同时使用 Q_DECLARE_OPERATORS_FOR_FLAGS [QT-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用 Q_DECLARE_FLAGS 时,必须同时使用 Q_DECLARE_OPERATORS_FOR_FLAGS.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Q_DECLARE_FLAGS创造了一个典型的安全方式来储存枚举类型的值.
Q_DECLARE_OPERATORS_FOR_FLAGS声明一个全局性的操作|()作为
此典型的安全标志,所以他们也许会在标志声明的范围以外被使用.


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

enum Value { FirstVal, SecondVal, ThirdVal };

Q_DECLARE_FLAGS(Values,Value)                    // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

enum Value { FirstVal, SecondVal, ThirdVal };

Q_DECLARE_FLAGS(Values,Value)                    // OK
Q_DECLARE_OPERATORS_FOR_FLAGS(Values)



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-15</key>
<configkey>QT-15</configkey>
<name><![CDATA[ Q_DECLARE_OPERATORS_FOR_FLAGS 必须位于全局命名空间，Q_DECLARE_FLAGS 应位于 enum 的命名空间 [QT-15] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Q_DECLARE_OPERATORS_FOR_FLAGS 必须位于全局命名空间，Q_DECLARE_FLAGS 应位于 enum 的命名空间 [QT-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

Q_DECLARE_OPERATORS_FOR_FLAGS 必须位于全局命名空间,
Q_DECLARE_FLAGS 应位于 enum 的命名空间.


</PRE>
<STRONG>
优点
</STRONG>
<PRE>

在enum范围和全局的操作符范围中声明标志,你可以使用
类型安全OR连接范围内的标志.如果Q_DECLARE_FLAGS
或Q_DECLARE_OPERATORS_FOR_FLAGS在错误的范围,
将无法OR代码中的任何标志,即使你使用了正确的范围



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

namespace N
{
    enum Value { FirstVal, SecondVal, ThirdVal };
    namespace M
    {
        Q_DECLARE_FLAGS(Values, Value)               // 违规
        Q_DECLARE_OPERATORS_FOR_FLAGS(Values)        // 违规
    }
}

namespace S
{
    enum Item { FirstVal, SecondVal, ThirdVal };
    Q_DECLARE_FLAGS(Items, Item)
    Q_DECLARE_OPERATORS_FOR_FLAGS(Items)             // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtGui/QtGui&gt;

namespace N 
{
    enum Value { FirstVal, SecondVal, ThirdVal };
    Q_DECLARE_FLAGS(Values, Value)                   // OK
}

Q_DECLARE_OPERATORS_FOR_FLAGS(N::Values)             // OK

namespace S
{
    enum Item { FirstVal, SecondVal, ThirdVal };
    Q_DECLARE_FLAGS(Items, Item)                     // OK
}

Q_DECLARE_OPERATORS_FOR_FLAGS(S::Items)              // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
Parasoft和Trolltech推荐规则

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-16</key>
<configkey>QT-16</configkey>
<name><![CDATA[ 必须有针对 Q_PROPERTY 的获取(getters)和设置(setters)操作，类型必须匹配 [QT-16] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
必须有针对 Q_PROPERTY 的获取(getters)和设置(setters)操作，类型必须匹配 [QT-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

必须有针对 Q_PROPERTY 的获取(getters)和设置(setters),类型必须匹配.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Q_PROPERTY宏告诉QT元类型系统怎样获取(getters)和设置(setters)
属性.该属性有类型、名称和获取和设置方法.获取(getter)操作应该
返回操作类型并不能有任何参数,设置(setters)应该有一个准确的参数,
或者是属性类型或者是常量相关类型.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

enum MyEnum { FirstVal, SecondVal, ThirdVal };

class MyQObject: public QObject  // 违规(错误的返回类型,
                                 // 只允许一个参数)
{
    Q_OBJECT
    Q_ENUMS(MyEnum)
    Q_PROPERTY(MyEnum id READ id WRITE setId)

public:
    void id();                        // 错误的返回类型
    void setId(MyEnum, int);          // 只允许一个参数

private:
    Q_DISABLE_COPY(MyQObject)
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

enum MyEnum { FirstVal, SecondVal, ThirdVal };

class MyQObject: public QObject       // OK
{
    Q_OBJECT
    Q_ENUMS(MyEnum)
    Q_PROPERTY(MyEnum id READ id WRITE setId)

public:
    MyEnum id();
    void setId(MyEnum);

private:
    Q_DISABLE_COPY(MyQObject)



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-17</key>
<configkey>QT-17</configkey>
<name><![CDATA[ 枚举(enum)类型的属性必须使用 Q_ENUMS [QT-17] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
枚举(enum)类型的属性必须使用 Q_ENUMS [QT-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

枚举(enum)类型的属性必须使用 Q_ENUMS.
这条规则确保QT设计器和其他的工具正确认识属性.



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Q_ENUM注册一个Qt元对象系统枚举类型,使
这种类型属性可适当反思.如果它是widget成员,
QSA改变属性的值的话,设计器可以修改值.
.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

enum MyEnum { FirstVal, SecondVal, ThirdVal };

class MyQObject: public QObject  // 违规
{
    Q_OBJECT
    Q_PROPERTY(MyEnum id READ id WRITE setId)

public:
    MyEnum id();
    void setId(MyEnum);

private:
    Q_DISABLE_COPY(MyQObject)
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtCore/QObject&gt;

enum MyEnum { FirstVal, SecondVal, ThirdVal };

class MyQObject: public QObject  // OK
{
    Q_OBJECT
    Q_ENUMS(MyEnum)
    Q_PROPERTY(MyEnum id READ id WRITE setId)

public:
    MyEnum id();
    void setId(MyEnum);

private:
    Q_DISABLE_COPY(MyQObject)
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则
<A HREF="http://doc.trolltech.com/4.2/properties.html">http://doc.trolltech.com/4.2/properties.html</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>QT-18</key>
<configkey>QT-18</configkey>
<name><![CDATA[ 不能对 Qt 对象调用非常量函数 [QT-18] ]]></name>
<tag>qt</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能对 Qt 对象调用非常量函数 [QT-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不能对 Qt 对象调用非常量函数.
例如:QList::at(int)是常量函数,但是operator[] (list_obj[i])
是非常量函数.

   list_obj[i] = 1234;    // 设置新值
   list_obj.at(i) = 1234; // not possible, const T &amp; at (int i) const

注意这并不依赖编译器,虽然有些编译器在一些情况知道
const T &amp; operator[] (int i) const的意义.但是一般
情况下建议开发者不要依赖编译器.




</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Qt的有许多隐式共享类.这些类数据共享,
但彼此分离,并做了深度的拷贝,当一个
非const函数被对象调用.


自:

v7.0



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;QtCore/QList&gt;

// Using the non-const operator[](int) function
int main(int argc, char **argv)
{
    QList&lt;int&gt; list_obj;
    list_obj &lt;&lt; 10 &lt;&lt; 100 &lt;&lt; 1000;
    
    QList&lt;int&gt; copy = list_obj; // Create a shared copy
    for (int i = 0; i &lt; list_obj.size(); ++i)
        printf("Index %d: %d\n", i, list_obj[i]); // Violation, detaches
    
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;QtCore/QList&gt;

// Using the const at(int) function
int main(int argc, char **argv)
{
    QList&lt;int&gt; list_obj;
    list_obj &lt;&lt; 10 &lt;&lt; 100 &lt;&lt; 1000;                   // OK
    list_obj[1] = 20;                                // OK  
    
    QList&lt;int&gt; copy = list_obj; // Create a shared copy
    for (int i = 0; i &lt; list_obj.size(); ++i)
        printf("Index %d: %d\n", i, list_obj.at(i)); // OK
    
    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Parasoft和Trolltech推荐规则.

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-01</key>
<configkey>SECURITY-01</configkey>
<name><![CDATA[ 避免使用标准 C 库中与时间有关的函数 [SECURITY-01] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用标准 C 库中与时间有关的函数 [SECURITY-01-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则用于检测来自标准 C 库的时间相关函数的使用情况
另见: MISRA2004-20_12



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用来自标准 C 库的函数， 
这可能打开安全漏洞。 
获取当前系统时间可能是可疑的 
并且如果作为访问敏感信息的键值 
或允许访问指定函数 
将会导致安全问题。 
不要使用下面的函数： 
time, clock, ctime, gmtime, localtime, mktime, strftime.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;time.h&gt;
void dangerFunction(time_t time);
int main ()
{
  time_t rawtime;
  tm * ptm;
  time ( &amp;rawtime );          // 违规
  ptm = gmtime ( &amp;rawtime );  // 违规
  dangerFunction(rawtime);

  return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

删除来自于标准 C 库与时间相关函数的使用



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. David A. Wheeler, Programming Secure Applications for Unix-like Systems (pdf),
   <A HREF="http://www.dwheeler.com/secure-programs">http://www.dwheeler.com/secure-programs</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-02</key>
<configkey>SECURITY-02</configkey>
<name><![CDATA[ 避免使用标准 C 库中与随机数有关的函数 [SECURITY-02] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用标准 C 库中与随机数有关的函数 [SECURITY-02-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则用于检测对下面来自标准 C 库函数的使用， 
其生成随机数： 
-rand
-random
-randomize
-srand



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止对来自标准 C 库使用随机数函数的调用。 
因为 rand() 和类似的函数使用最后生成的数 
作为创建下一个数的种子， 
这会有可能猜测或计算下一个数。 
多数情况下，对 Web 会话的随机会话 ID 
使用随机数生成器来生成。
因为这个随机数生成器来自于标准 C 库 
是不够健壮，黑客可以猜测到下一个数 
并 “欺骗(spoof)” 此会话， 
获得访问需要有权限的数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

void main( void )
{
  srand((unsigned)time( NULL ));  // 违规
  int y = rand();                 // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

删除对 rand(), random(), randomize(), srand() 函数的使用。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/flawfinder/">http://www.dwheeler.com/flawfinder/</A>

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications
4. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-327
   <A HREF="http://cwe.mitre.org/top25/#CWE-327">http://cwe.mitre.org/top25/#CWE-327</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-03</key>
<configkey>SECURITY-03</configkey>
<name><![CDATA[ 限制使用系统中的环境变量 [SECURITY-03] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
限制使用系统中的环境变量 [SECURITY-03-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测使用系统属性，或环境变量的代码。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

通过对应用程序中环境变量使用的控制，它们将会 
更安全。环境变量可以被用作安全漏洞 
如果一个恶意用户通过环境变量传递一个专门制作的字符串 
到一个运行的程序中，可以启动一个缓冲区溢出攻击。 
另一方面， 如果一个应用程序将敏感信息 
(例如密码) 通过 putenv 写入到一个环境变量中， 它就会被捕获并使用 
以获得未经授权的权限或访问敏感数据。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;

void foo( void ) {
    char *envvar;
    envvar = getenv( "LIB" );                   // 违规
    putenv( "LIB=c:\\mylib;c:\\yourlib" );      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在源代码中使用系统属性和环境变量。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="https://buildsecurityin.us-cert.gov/portal/article/knowledge/coding_rules/RULE_0051.xml">https://buildsecurityin.us-cert.gov/portal/article/knowledge/coding_rules/RULE_0051.xml</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-04</key>
<configkey>SECURITY-04</configkey>
<name><![CDATA[ 小心使用以确保 LoadLibrary() 会加载正确的库 [SECURITY-04] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
小心使用以确保 LoadLibrary() 会加载正确的库 [SECURITY-04-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"确保您为库指定一个完全修饰的文件名
以保证正确的库始终被加载。
当需要加载一个库的时候，您需要考虑使用包含 LOAD_WITH_ALTERED_SEARCH_PATH 
参数的 LoadLibraryEx 函数以确保加载
正确的库。"
当在代码中使用没有包含 LOAD_WITH_ALTERED_SEARCH_PATH 参数的
LoadLibrary 函数或 LoadLibraryEx 函数时这条规则将报告一个违规。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

"如果您不能使用 LoadLibraryEx， 请确保 lpszFileName 参数
是完全修饰的文件名，包括文件扩展名。如果它不是完全
修饰的，那么期望的模块可以被攻击者所取代。
此外，如果没有指定的话系统将会使用 '.dll' 作为文件扩展名，
所以如果期望的库文件没有一个扩展名则应该将 '.' 追加
到最后。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则的使用防止一个攻击者可以注入一个 DLL 木马
在您的进程中，通常通过在期望的 DLL 之前找到的 DLL 搜索路径
的某个位置中放置一个 'tainted(受污染的)' DLL 来进行。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;windows.h&gt;

void foo()
{
    HMODULE hModule1 = LoadLibrary(TEXT("someapp.dll"));  // 违规

    HMODULE hModule2 = LoadLibraryEx(                     // 违规
        TEXT("someapp.dll"),
        NULL,
        0
    );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;windows.h&gt;

void foo()
{
    HMODULE hModule = LoadLibraryEx(                      // OK
        TEXT("C:\\The\\Right\\Directory\\someapp.dll"),
        NULL,
        LOAD_WITH_ALTERED_SEARCH_PATH
    );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/766-BSI.html">https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/766-BSI.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-05</key>
<configkey>SECURITY-05</configkey>
<name><![CDATA[ 避免使用仅带有一个可变参数的 printf/wprintf 函数 [SECURITY-05] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用仅带有一个可变参数的 printf/wprintf 函数 [SECURITY-05-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测仅带一个可变参数和没有格式指示符 
的 printf/wprintf 函数的使用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则防止使用格式字符串的安全攻击。如果一个 printf 函数 
传递了一个没有格式指示符的变量，这个变量可以包含一个 
巧妙的格式化字符串 (包括格式字符 %n, %x, 和 %s) 
该字符串可以被用于执行恶意指令或使应用程序崩溃。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;wchar.h&gt;
#include &lt;stdio.h&gt;

void foo( ) {
    char* caption = "caption";
    wchar_t widechar = L'x';

    printf( caption );          // 违规
    wprintf( &amp;widechar );     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;wchar.h&gt;
#include &lt;stdio.h&gt;

void foo( ) { 
    char* caption = "caption";
    wchar_t wch = L'x';
    int k = 7;

    printf( "char: %s", caption );  // OK
    printf( "int: %s", k );         // OK

    wprintf( L"wide char:%ls", wch );// OK
    wprintf( L"int: %d ", k );      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/control-formatting.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/control-formatting.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-134
   <A HREF="http://cwe.mitre.org/top25/#CWE-134">http://cwe.mitre.org/top25/#CWE-134</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-06</key>
<configkey>SECURITY-06</configkey>
<name><![CDATA[ 避免使用 MFC 库中的时间函数 [SECURITY-06] ]]></name>
<tag>security</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用 MFC 库中的时间函数 [SECURITY-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测来自 MFC 库的时间相关函数的使用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用来自 MFC 库的函数， 这可能打开安全漏洞。 
获取当前系统时间如果用作访问敏感信息的一个键值
或允许访问特殊函数可能会很可疑并且可能导致
安全问题。 不要使用以下函数：
- GetTime
- GetYear
- GetMonth
- GetDay
- GetHour
- GetMinute
- GetSecond
- GetDayOfWeek



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;afx.h&gt;
void dangerFunction(time_t t);
int main () {
    CTime t(NULL);
    time_t Time = t.GetTime(); // 违规
    t.GetHour();               // 违规
    t.GetMinute();             // 违规
    dangerFunction(Time);
    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

删除来自 MFC 库函数的使用，这可能会打开安全漏洞。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. David A. Wheeler, Programming Secure Applications for Unix-like Systems (pdf),
   <A HREF="http://www.dwheeler.com/secure-programs">http://www.dwheeler.com/secure-programs</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-07</key>
<configkey>SECURITY-07</configkey>
<name><![CDATA[ 不能使用向未作边界检查的缓冲区做写操作的不安全的 C 函数 [SECURITY-07] ]]></name>
<tag>security</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用向未作边界检查的缓冲区做写操作的不安全的 C 函数 [SECURITY-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用不安全的 C 遗留写法： strcpy, strcat, sprintf, vsprintf, gets, 
strncpy, strncat, snprintf, fgets - 写入边界未检查缓冲区的函数， 
和/或不检查和正确地处理超出边界的错误。
参见: SECURITY-12,SECURITY-13,SECURITY-16



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则阻止使用可能导致溢出的函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string.h&gt;

void foo( void ) {
    char* str1 = "testcase";
    char* str2 = "testcase";
    char* str3 = 0;
    str3 = strcat( str1, str2 );    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用不安全的 C 遗留写法。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ 编码规范," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Type Safety", Rule 99

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-08</key>
<configkey>SECURITY-08</configkey>
<name><![CDATA[ 避免使用仅带两个参数，而且第二个参数是变量的 fprintf/fwprintf 函数 [SECURITY-08] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用仅带两个参数，而且第二个参数是变量的 fprintf/fwprintf 函数 [SECURITY-08-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测有两个参数在当第二个参数是一个变量参数时，
没有格式指示符的 fprintf/wfprintf 函数的使用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则防止使用格式字符串的安全攻击。
如果一个 fprintf 函数传递一个没有格式指示符的变量时， 
此变量可以包含一个灵活的格式化的字符串 
(包括格式字符 %n, %x, 和 %s) ，该字符串可以被用来执行 
恶意指令或使应用程序崩溃。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
#include &lt;wchar.h&gt;

void foo( ) {
   FILE *stream;
   char   c = '\n';
   wchar_t d=8;
   stream = fopen( "fprintf.out", "w" );

   fprintf( stream, &amp;c );           // 违规
   fwprintf( stream, &amp;d );          // 违规

   fclose( stream );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
#include &lt;wchar.h&gt;

void foo( ) {
   FILE *stream;
   int    i = 10;
   char   s[] = "example string";
   char   c = '\n';
   unsigned short d=8;
   stream = fopen( "fprintf.out", "w" );

   fprintf( stream,"abcd");        // OK
   fprintf( stream, "%s%c", s, c );// OK
   fprintf( stream, "%d\n", i );   // OK
 
   fwprintf(stream,L"abc:%d",i);   // OK
   fwprintf(stream,L"abcd");       // OK
  
   fclose( stream );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/control-formatting.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/control-formatting.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-09</key>
<configkey>SECURITY-09</configkey>
<name><![CDATA[ 避免使用标准库中 'string' 类中的 data() 函数 [SECURITY-09] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用标准库中 'string' 类中的 data() 函数 [SECURITY-09-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测使用来自标准库中 'string' 类中的 data() 函数 
的代码。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

String::data() 返回字符串，该字符串对象中没有 
包含一个终止字符。在某种情况下，特别是当跟 C 风格 
遗留代码接口交互时， 这可能会导致缓冲区溢出 
和其他字符串相关的安全漏洞。
相反使用 data() 函数，使用 c_str(), 
这些函数始终返回一个终止字符串。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string&gt; 

void bar(const char* param);
 
void  foo()
{
    using namespace std; 
    string str1 ( "example string" ); 
    bar(str1.data());                 // 违规
 
    string *ptr;
    ptr=&amp;str1;
    const char *ptr2 = 	 ptr-&gt;data();  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string&gt; 

void bar(const char* param);
 
void  foo()
{
    using namespace std; 
    string str1 ( "example string" ); 
    bar(str1.c_str());                 // OK
 
    string *ptr;
    ptr=&amp;str1;
    const char *ptr2 = 	 ptr-&gt;c_str();  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/library-c.html#STD-STRING">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/library-c.html#STD-STRING</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-10</key>
<configkey>SECURITY-10</configkey>
<name><![CDATA[ 避免使用 vfork() 函数 [SECURITY-10] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用 vfork() 函数 [SECURITY-10-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测使用 vfork() 函数的代码。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用 vfork() 函数， 
该函数在当代码改变或甚至当编译器 
版本改变的时候很容易失败。 
使用 vfork() 有很多的问题。 
从可移植性角度来看， 
使用 vfork() 的问题，实际上它对于一个进程 
不妨碍其父进程上是相当棘手的， 
特别是在高级语言中。 
其中 "不妨碍" 需求适用于实际机器代码生成， 
而且许多编译器生成隐藏的临时对象 
和其他代码结构，这会造成意想不到的干扰。
请使用 fork() 函数而不是 vfork() 函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;unistd.h&gt;

void main( void )
{
	vfork( );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;unistd.h&gt;

void main( void )
{
	fork( );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/avoid-vfork.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/avoid-vfork.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-11</key>
<configkey>SECURITY-11</configkey>
<name><![CDATA[ 避免使用可能被 Shell 中元字符(metacharacters)影响的不安全的 shell 函数 [SECURITY-11] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用可能被 Shell 中元字符(metacharacters)影响的不安全的 shell 函数 [SECURITY-11-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测使用环境函数的代码:
popen, system, execlp, execvp, _exec, exec
根据 David A. Wheeler (见下面的参考资料):
"许多系统， 例如命令行 shell 和 SQL 解释器， 
有 "元字符(metacharacters)" - 不被解释为数据的字符。 
这些字符是: { &amp; ; ` ' \ " | * ? ~ &lt; &gt; ^ ( ) [ ] { } $ \n \r }. 
这些字符可能是命令, 或从命令或其他数据中分隔的数据。
如果您的程序调用其他系统并允许攻击者插入 
这些元字符。通常的结果是，攻击者可以完全
控制你的程序。
让这些 shell 元字符变得特别普遍的是对一些
重要库的调用，如 popen() 和 system() 通过 
调用命令脚本来实现， 这意味着它们将受到 shell 
元字符影响。 
同样， execlp() 和 execvp() 可能会导致 shell 被调用。 
很多指南建议当试图生成一个进程时避免使用 popen(), system(), 
execlp(), execvp() 而在 C 语言中直接地使用 execve()。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止不安全 shell 函数的使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifdef __GNUC__
#include &lt;unistd.h&gt;
#else
#include &lt;process.h&gt;
#endif

void main( void ) {
    execl( "c:\\command.com", "", "_execl", "", "" );   // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在程序中使用不安全的系统函数。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/handle-metacharacters.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/handle-metacharacters.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-12</key>
<configkey>SECURITY-12</configkey>
<name><![CDATA[ 避免使用可能造成缓冲区溢出的不安全的字符串函数 [SECURITY-12] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用可能造成缓冲区溢出的不安全的字符串函数 [SECURITY-12-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测使用来自 C 库的不安全字符串函数:
strcpy, strcat, sprintf, vsprintf, gets
根据 David A. Wheeler (参见下面的参考资料), 
"C 函数的使用者必须避免使用不检查边界的
危险函数，除非他们已经确保 
将永远不会得到超过该边界。
在大多数情况下要避免的函数 (或确保保护) 包括函数 
strcpy(), strcat(), sprintf() (包括 vsprintf()), 和 gets()。 
这些应该被替换成其他函数，例如分别是
strncpy(), strncat(), snprintf(), fgets()。"
参见; SECURITY-12,SECURITY-13, SECURITY-16



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用可能造成缓冲区溢出的函数。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string.h&gt;

void test()
{
    char buffer[16];
    strcpy(buffer, "To be ");              // 违规
    strcat(buffer, "or not to be");        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;string.h&gt;

void test()
{
    char buffer[16];
    strncpy(buffer, "To be ", 7);          // OK
    strncat(buffer, "or not to be", 6);    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/dangers-c.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/dangers-c.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-13</key>
<configkey>SECURITY-13</configkey>
<name><![CDATA[ 避免使用不进行范围检查的不安全的字符串函数 [SECURITY-13] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用不进行范围检查的不安全的字符串函数 [SECURITY-13-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测使用不安全字符串函数的使用:
scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf, realpath,
getopt, getpass, streadd, strecpy, strtrns, getwd, snprintf
根据 David A. Wheeler (参见下面的参考资料), 
"C 函数的使用者必须避免使用不检查边界的 
危险函数，除非他们已经确保 
将永远不会得到超过该边界。 
函数 strlen() 应该要避免 
除非您能确保会有一个终止 NIL 字符找到。
函数 scanf() 系列 (scanf(), fscanf(), sscanf(), vscanf(), vsscanf(), 
和 vfscanf()) 通常是危险的使用； 
不要使用它来发送数据到一个字符串而不控制最大长度 
(格式 %s 是一个特别常见的问题)。
其他可以允许缓冲区溢出危险的函数 
(根据其用途) 包括 realpath(), getopt(), getpass(), streadd(), strncpy(), 和 strtrns()。 
您必须小心使用 getwd(); 
发送给 getwd() 的缓冲区必须至少有 PATH_MAX 字节长。
select() 帮助宏 FD_SET(), FD_CLR(), 和 FD_ISSET() 
不检查索引 fd 在边界内; 
确保 fd &gt;= 0 并且 fd &lt;= FD_SETSIZE 
(这个特别在 pppd 被采用). 
不幸的是， snprintf() 的变种有其他问题。 
正式来说， 在 ISO 1990 (ANSI 1989) 标准中 
snprintf() 不是一个标准 C 函数，
虽然 sprintf() 是， 所以不是所有系统包括 snprintf() 
其他直接调用 sprintf 可以做出什么可怕的事情。"
另见: SECURITY-07,SECURITY-12, SECURITY-16



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止使用可能导致溢出o的函数。 



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

void main( void ) {
    char* str = 0;
    scanf( "%s", str );   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

删除对不安全字符串函数的使用。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/dangers-c.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/dangers-c.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-14</key>
<configkey>SECURITY-14</configkey>
<name><![CDATA[ 不要使用没有在格式化字符串中指定变量大小的 scanf 和 fscanf 函数 [SECURITY-14] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用没有在格式化字符串中指定变量大小的 scanf 和 fscanf 函数 [SECURITY-14-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则用于检测使用 'scanf' 和 'fscanf' 函数时 
却不在格式字符串中指定变量大小的代码。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

通常情况下， scanf 函数用于读取指定用户的
参数到变量数组。 
除非在格式字符串中变量的大小被指定， 
攻击者可能使用特制的字符串来利用 
包含固定大小数组的缓冲区溢出 
通过要求约束使用变量大小的格式规范，
该规则防止此安全漏洞。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

void  main( ) {
    char tcChar[10];
    char cChar;
    float fFloat;
    FILE *stream;
    stream = fopen( "fprintf.out", "w" );

    scanf("%s",&amp;tcChar);                  // 违规
    scanf("%f",&amp;fFloat);                  // 违规

    fscanf(stream,"%s",&amp;tcChar);          // 违规
    fscanf(stream,"%c%f",&amp;cChar,&amp;fFloat); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

void  main( ) {
    char tcChar[10];
    char cChar;
    float fFloat;
    FILE *stream;
    stream = fopen( "fprintf.out", "w" );

    scanf("%c",&amp;cChar);                  // OK
    scanf("%10s",&amp;tcChar);               // OK
    scanf("%5f",&amp;fFloat);                // OK

    fscanf(stream,"%c",&amp;cChar);          // OK
    fscanf(stream,"%10s",&amp;tcChar);       // OK
    fscanf(stream,"%5f",&amp;fFloat);        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/c-cpp.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/c-cpp.html</A>
   <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO</A>
   /control-formatting.html
   <A HREF="https://buildsecurityin.us-cert.gov/portal/article/knowledge">https://buildsecurityin.us-cert.gov/portal/article/knowledge</A>
   /coding_rules/RULE_0119.xml

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-15</key>
<configkey>SECURITY-15</configkey>
<name><![CDATA[ 不能打印由于系统错误导致异常而产生的潜在的敏感信息 [SECURITY-15] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能打印由于系统错误导致异常而产生的潜在的敏感信息 [SECURITY-15-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要打印潜在的敏感信息，
结果来自一个应用程序出错进入异常消息。
规则不不允许在 catch 块中打印消息。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止应用程序泄漏敏感信息， 
结果是来自一个应用程序出错。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

class LoginException{ 
public:
	int tmp;
	char* getMessage();
};

class CLogin {
public:
	void login(){};
};

void log( char *text){};

void foo( int i ) {
	CLogin lc;
	try {
		lc.login();		
	} catch (LoginException le1) {
		// login failed
		::printf( le1.getMessage() );  // 违规
		exit( 1 );
	}
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

class LoginException{ 
public:
	int tmp;
	char* getMessage();
};

class CLogin {
public:
	void login(){};
};

void log( char *text){};

void foo( int i ) {
	CLogin lc;
	try {
		lc.login();		
	} catch (LoginException le2) {  // OK
		exit( 1 );
	}
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.atsec.com/downloads/pdf/secure-coding-guidelines.pdf">http://www.atsec.com/downloads/pdf/secure-coding-guidelines.pdf</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-16</key>
<configkey>SECURITY-16</configkey>
<name><![CDATA[ 绝不使用 gets() 函数 [SECURITY-16] ]]></name>
<tag>security</tag>
<priority>BLOCKER</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
绝不使用 gets() 函数 [SECURITY-16-1]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“绝不使用 gets(). 因为事先并不知道 gets() 
读取多少数据，同时 gets() 函数将不断存储
传入的字符直到缓冲区满，这在使用时非常危险。
该函数已经被利用来破坏电脑安全性。使用 fgets()
替代。”
参见: SECURITY-07,SECURITY-12,SECURITY-13



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

预防使用该函数时造成缓存溢出。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

void main( ) {
   char line[100];

   printf( "Input a string: " );
   gets( line );                                     // 违规 
   printf( "The line entered was: %s\n", line );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

void main( ) {
   char line[100];

   printf( "Input a string: " );
   fgets( line, 100, stdin );                        // OK
   printf( "The line entered was: %s\n", line );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>
1. Linux Programmer's Manual (3), 
   <A HREF="http://trajano.us.es/clases/lcd/man/man3/ungetc.3.html">http://trajano.us.es/clases/lcd/man/man3/ungetc.3.html</A>

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

4. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-17</key>
<configkey>SECURITY-17</configkey>
<name><![CDATA[ 避免将非常量参数或变量传递给 exec [SECURITY-17] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免将非常量参数或变量传递给 exec [SECURITY-17-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则检测传递动态创建的字符串给 exec 的代码。
注意: 规则检查是否传递给 exec 的参数或变量不是 const
另见: SECURITY-18



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

攻击者有可能插入一个恶意字符串片段 
到一个动态创建的字符串中。 
这些片段可能允许攻击者执行一个指定的命令，
造成了安全漏洞。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
#ifdef __GNUC__
#include &lt;unistd.h&gt;
#define _execl execl
#else
#include &lt;process.h&gt;
#endif

void foo( ) {
    char *param = "C:\\command.com";
    _execl( param, "", "_execl", "", NULL );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
#ifdef __GNUC__
#include &lt;unistd.h&gt;
#define _execl execl
#else
#include &lt;process.h&gt;
#endif

void foo( ) {
    _execl( "C:\\command.com", "", "_execl", "", NULL ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-18</key>
<configkey>SECURITY-18</configkey>
<name><![CDATA[ 避免将动态生成的字符串传递给 exec [SECURITY-18] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免将动态生成的字符串传递给 exec [SECURITY-18-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免传递动态创建的字符串给 exec。
规则检查是否字符串变量， 参数， 或值
没有传递给 exec() 方法。
参见: SECURITY-17



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止运行本地应用程序。 经字符串变量传递到 
一个 exec() 方法中可以提供系统访问一个外部程序。 
服务器应用程序不应该访问本地应用程序。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
#ifdef __GNUC__
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#define _execl execl
#else
#include &lt;process.h&gt;
#endif

class MyClass {
public:
    char* text( );
};

void foo( char* prog ) {
    MyClass  *v1 = 0;
    char * v4=v1-&gt;text();
    prog = strcat( "c:\\", "command.com" );
    _execl( prog, "", "_execl", "", NULL );      // 违规
    _execl( v1-&gt;text(), "", "_execl", "", NULL );// 违规
    _execl( v4, "", "_execl", "", NULL );        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
#ifdef __GNUC__
#include &lt;unistd.h&gt;
#define _execl execl
#else
#include &lt;process.h&gt;
#endif

void foo( char* prog ) {
    _execl( "C:\\command.com", "", "_execl", "", NULL );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-19</key>
<configkey>SECURITY-19</configkey>
<name><![CDATA[ 不允许使用可能产生资源竞争的函数 [SECURITY-19] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不允许使用可能产生资源竞争的函数 [SECURITY-19-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"竞争条件" 可以被定义为 "由于对事件的相对时间 
具有特别严重依赖性的异常行为"。 
竞争条件通常涉及一个或多个进程访问 
一个共享资源 (例如一个文件或变量)， 
那里这个多重访问没有得到妥善的控制。
规则检查是否使用下列函数:
access, creat, pathconf, opendir, dirname, scandir, 
fopen, lstat, stat, open, rename, remove, lexecve, 
execl, execlp, execle, execv, execvp, freopen, mktemp, 
link, unlink



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止竞争条件函数的异常行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#ifdef __GNUC__
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#else
#include &lt;io.h&gt;
#endif

void foo( ) {
    access( "path", 0 );    // 违规
    unlink( "/pathname" );  // 违规
    mktemp( "template" );   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Remove usage of prone to race functions.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/avoid-race.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/avoid-race.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-20</key>
<configkey>SECURITY-20</configkey>
<name><![CDATA[ 避免将用户的输入作为参数传递给方法 [SECURITY-20] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免将用户的输入作为参数传递给方法 [SECURITY-20-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

避免将用户输入作为参数传递到方法中。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

使用在应用程序中的直接用户输入可以开启 
缓冲区溢出的后门并造成 SQL 注入攻击。 
用户输入必须在应用程序处理之前进行验证。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;
void function( int param );
void foo( int param ) {
	int var1;
	int var2=0;

	cin &gt;&gt; var1;
	function( var1 );		// 违规
	scanf( "%d", &amp;var2 );
	function( var2 );		// 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;
void function( int param );
void foo( ) {
	int var1 = 0;
	int var2 = 0;

	cin &gt;&gt; var1;
	// part of code manipulating var1 without using function with var1 as parameter
	scanf( "%d", &amp;var2 );
	// part of code manipulating var2 without using function with var2 as parameter
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. David A. Wheeler, Programming Secure Applications for Unix-like Systems (pdf), 
   <A HREF="http://www.dwheeler.com/secure-programs">http://www.dwheeler.com/secure-programs</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-21</key>
<configkey>SECURITY-21</configkey>
<name><![CDATA[ 不能将 'syslog' 函数用于登录目的 [SECURITY-21] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能将 'syslog' 函数用于登录目的 [SECURITY-21-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

方法 'syslog' 不应该被用于日志记录。

这个函数不检查文件系统 
环境变量的有效性。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止使用不安全的 'syslog' 函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;syslog.h&gt;
int main()
{
  syslog(LOG_INFO, "Some info"); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要在代码中使用 'syslog' 函数。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-22</key>
<configkey>SECURITY-22</configkey>
<name><![CDATA[ 不能使用 mbstowcs() 函数 [SECURITY-22] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用 mbstowcs() 函数 [SECURITY-22-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不应该使用 mbstowcs() 函数。
内部堆栈分配的缓冲区可以在某些版本中溢出。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止使用不安全的 mbstowcs() 函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main( void )
{
    int i;
    char    *pmbhello = (char *)malloc( MB_CUR_MAX );
    wchar_t *pwc      = (wchar_t *)malloc( sizeof( wchar_t ));
	
    i = mbstowcs( pwc, pmbhello, MB_CUR_MAX );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 mbstowcs()。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="https://buildsecurityin.us-cert.gov/portal/article/knowledge/coding_rules/RULE_0072.xml">https://buildsecurityin.us-cert.gov/portal/article/knowledge/coding_rules/RULE_0072.xml</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-23</key>
<configkey>SECURITY-23</configkey>
<name><![CDATA[ 警惕使用那些返回当前目录或窗口目录的函数 [SECURITY-23] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
警惕使用那些返回当前目录或窗口目录的函数 [SECURITY-23-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则在代码中如果使用 GetTempPath() 函数时报告一个违规。.
"GetTempPath() 返回到临时目录的文件路径。
GetTempPath() 提出了两个问题。 首先， 如果到临时目录
的路径大于分配给存储这些信息的缓冲区可能存在缓冲区
溢出条件。 其次， 可能返回一个到不安全目录的路径
此外， Windows 并不能保证对临时文件返回的路径是
有效的或可用的(例如，可写的)。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"攻击者可以利用在 GetTempPath() 功能中的任何弱点。
首先，如果 Windows 返回一个攻击者可以读取或
写入的路径 (例如， c:\temp)， 攻击者将能够
读取或修改在临时文件中的任何数据。这将各自
导致违反保密性和完整性。
第二个攻击媒介是实现一个缓冲区溢出攻击。
没有迹象显示该值在任何环境变量
中(TMP, TEMP) 被截断为 MAX_PATH。 因此， 如果
缓冲区的长度没有正确设置的话，一个攻击者
可以指定一个环境变量其长度比路径缓冲区的长度长。
当程序在这种环境下运行时，路径缓冲区会溢出。"
该规则可阻止此类攻击。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;afx.h&gt;

const char * virus_temp_sig = "XXX";

char * get_temp_file()

{
    char wintemp_path[1024];
    char *temp_path=new char[1024];

    GetTempPath(1024,wintemp_path);                              // 违规
    GetTempFileName(wintemp_path,virus_temp_sig,1234,temp_path);
    return temp_path;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

Do not use the GetTempPath() functions or at least be careful what you place
in locations returned by them.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/758-BSI.html">https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/coding/758-BSI.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-24</key>
<configkey>SECURITY-24</configkey>
<name><![CDATA[ 避免使用 InitializeCriticalSection [SECURITY-24] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用 InitializeCriticalSection [SECURITY-24-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

InitializeCriticalSection 方法不应该被用于代码中 - 在 
低内存情况下可以抛出异常。
InitializeCriticalSectionAndSpinCount 应该作为替代使用。
当 'InitializeCriticalSectionAndSpinCount' 方法被使用， 
调用线程避免当关键部分在微调操作过程中变成释放时 
避免等待操作。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则通过为短暂的关键部分选择一个小微调数 
来改善性能。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#define _WIN32_WINNT  0x0501
#include &lt;afx.h&gt;
class Queue {
public:
    Queue(int limit)
    {   
        InitializeCriticalSection(&amp;lock);    // 违规
    } 
    
    ~Queue()
    {
        ::DeleteCriticalSection(&amp;lock);
    } 
    
    void AddTail()
    { 
        ::EnterCriticalSection(&amp;lock);
        ::LeaveCriticalSection(&amp;lock);        
    } 
protected:
    CRITICAL_SECTION lock; 
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#define _WIN32_WINNT  0x0501
#include &lt;afx.h&gt;
class Queue1 {
public:
    Queue1(int limit)
    {
        if (!InitializeCriticalSectionAndSpinCount(&amp;lock, 0x80000400) )  // OK
        {
            exit(0);
        }
    } 
    
    ~Queue1()
    {
        ::DeleteCriticalSection(&amp;lock);
    } 
    
    void AddTail()
    { 
        ::EnterCriticalSection(&amp;lock);
        ::LeaveCriticalSection(&amp;lock);
    } 
protected:
    CRITICAL_SECTION lock; 
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-25</key>
<configkey>SECURITY-25</configkey>
<name><![CDATA[ 避免使用对线程不安全(thread-unsafe)的函数 [SECURITY-25] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用对线程不安全(thread-unsafe)的函数 [SECURITY-25-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

线程不安全函数不应该在代码中使用。
应该用线程安全库中的函数来代替它。比如：

char *ttyname(int fildes);
int ttyname_r(int fildes, char *name, size_t namesize);

'ttyname_r'是安全的线程应该被优先使用。



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

这条规则专用于类似UNIX系统。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用不安全得线程函数，
不安全的线程函数会导致结果不正确当在一个多线程程序中。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;unistd.h&gt;

void foo()
{
  char *name = ttyname(1);   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;unistd.h&gt;

void foo1()
{
  char name[100];
  int status = ttyname_r(1,name,100);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://docs.sun.com/app/docs/doc/816-5137/6mba5vpk6?a=view">http://docs.sun.com/app/docs/doc/816-5137/6mba5vpk6?a=view</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-26</key>
<configkey>SECURITY-26</configkey>
<name><![CDATA[ 不要在源代码中使用 'setuid' [SECURITY-26] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要在源代码中使用 'setuid' [SECURITY-26-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

'setuid'方法不应该在源代码中使用。
如果uid需要被改变， 应该使用'seteuid'而非'setuid'。
作为一个替代函数，'setreuid'应该被使用。
有了它我们可以恢复实际的uid 
或者先前保存的uid。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用不安全的'setuid'函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int main()
{
  setuid(34);            // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int main()
{
  seteuid(34);           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. David A. Wheeler, Programming Secure Applications for Unix-like Systems (pdf), 
   <A HREF="http://www.dwheeler.com/secure-programs">http://www.dwheeler.com/secure-programs</A>
   <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/avoid-setuid.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/avoid-setuid.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-27</key>
<configkey>SECURITY-27</configkey>
<name><![CDATA[ 不能使用 chmod(),chown(),chgrp() [SECURITY-27] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用 chmod(),chown(),chgrp() [SECURITY-27-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用chmod(), chown(), chgrp()。
使用fchmod(), fchown()来代替。
fchmod()更有效因为不需要一个必须有一个隔离的
需要查阅的名字，但是chmod()却必须这样做。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用不安全的chmod(), chown(), chgrp()函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

void foo(const char* path)
{
	chmod(path, S_IRWXU);     // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

void goo(int fildes)
{
	fchmod(fildes, S_IRWXU);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-28</key>
<configkey>SECURITY-28</configkey>
<name><![CDATA[ 不能出于安全目的使用随机数生成函数产生随机数 [SECURITY-28] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能出于安全目的使用随机数生成函数产生随机数 [SECURITY-28-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

标准的随机数字产生器不应该应用于
产生随意的数字出于安全目的。
出于安全目的，一个密码写的随机产生器
可以提供应该被使用，它可以足够的安全信息。
这条规则可以检查下面的函数：
drand48, erand48, initstate, jrand48, cong48, lrand48, mrand48, 
nrand48, seed48, setstate, srand48, strfry, memfrob, crypt, srandom



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用不安全的随机数字产生器。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdlib.h&gt;

void goo()
{
    double rnumber = drand48(); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用标准的随机数字产生器。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. David A. Wheeler, Programming Secure Applications for Unix-like Systems (pdf), 
   <A HREF="http://www.dwheeler.com/secure-programs">http://www.dwheeler.com/secure-programs</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-327
   <A HREF="http://cwe.mitre.org/top25/#CWE-327">http://cwe.mitre.org/top25/#CWE-327</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-29</key>
<configkey>SECURITY-29</configkey>
<name><![CDATA[ 不能使用已经废弃的 C 例程 ulimit() [SECURITY-29] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用已经废弃的 C 例程 ulimit() [SECURITY-29-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

C语言中的 ulimit()是过时的。
使用getrlimit()，setrlimit()， 或者 sysconf()来代替。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用不安全的过时的C语言程序。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;ulimit.h&gt;

void foo(int cmd, long newlimit)
{
    ulimit(cmd, newlimit);  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;sys/types.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;unistd.h&gt;

void foo(int who, struct rlimit *rlim)
{
    getrlimit(who, rlim);  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-30</key>
<configkey>SECURITY-30</configkey>
<name><![CDATA[ 不能在程序代码中使用 'getpw' 函数 [SECURITY-30] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能在程序代码中使用 'getpw' 函数 [SECURITY-30-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

函数'getpw'是不安全的。
它可能会产生溢出问题。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用不安全的'getpw'函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;pwd.h&gt;
#include &lt;sys/types.h&gt;

int main()
{
  char* buf;
  getpw(0,buf);                     // 违规
  return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;pwd.h&gt;
#include &lt;sys/types.h&gt;

int main()
{
  char* buf;
  struct passwd * ps = getpwuid(0); // OK
  return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

2. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-31</key>
<configkey>SECURITY-31</configkey>
<name><![CDATA[ 不能使用 'cuserid' 函数 [SECURITY-31] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能使用 'cuserid' 函数 [SECURITY-31-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

'cuserid'不应该使用来登陆目的。
这个函数定义得不规范比如
不同系统下有不同的参数。
这是不便捷的。
'curseid'会导致buffer溢出当buffer太小的时候。
推荐使用'getpwuid(geteuid())'代替。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用不安全的'cuserid'函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

void foo( ) {
    char * w = cuserid( "userName" );    // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;sys/types.h&gt;
#include &lt;pwd.h&gt;

void foo( ) {
    struct passwd * t =  getpwuid( 12 );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

2. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-676
   <A HREF="http://cwe.mitre.org/top25/#CWE-676">http://cwe.mitre.org/top25/#CWE-676</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-32</key>
<configkey>SECURITY-32</configkey>
<name><![CDATA[ 避免使用已经废弃的 C 例程 'usleep' [SECURITY-32] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用已经废弃的 C 例程 'usleep' [SECURITY-32-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

C例程'usleep()'是过时的。
这个函数和SIGALARM的接口以及
其他时间函数比如sleep()，alarm()，setitimer()，
和nanosleep()都是未具体说明的。
使用'nanosleep()'或者'setitimer()'代替。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免未具体说明的过时的'usleep()'C例程



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;unistd.h&gt;
int main()
{
  usleep(7);                  // 违规
  return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;time.h&gt;
void foo(timespec *req, timespec *rem)
{
  nanosleep(req, rem);   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-33</key>
<configkey>SECURITY-33</configkey>
<name><![CDATA[ 禁止使用那些不能正确处理非空结束的字符串的函数 [SECURITY-33] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用那些不能正确处理非空结束的字符串的函数 [SECURITY-33-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

使用不适当的处理一个非空字符串结尾 
的函数的函数是不允许的。
这不会导致不能利用的代码，
但是会导致存取违规。
规则检查是否有下面的函数用来测长度，
_tcslen, _mbslen和wcslen。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免使用
不适当的处理一个非空字符串结尾的函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string.h&gt;

void foo()
{
    char buffer[61] = "string example";
    unsigned int len;
    len = strlen(buffer);               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用 strlen, lstrlen, _tcslen, _mbslen, 和 wcslen 函数。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-34</key>
<configkey>SECURITY-34</configkey>
<name><![CDATA[ 避免使用环境变量 [SECURITY-34] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用环境变量 [SECURITY-34-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

环境变量是不可信赖的输入。
它们可以使任何长度，可以包含任何数据。
如果可能尽量避免使用它们。
这条规则检查NLSPATH, LC_ALL, LC_MESSAGES
和IFS等环境变量的使用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则检查NLSPATH, LC_ALL, LC_MESSAGES和
IFS等环境变量的使用。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;locale.h&gt;
void foo() 
{
  setlocale(LC_ALL,""); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

不要使用上面描述的环境变量。



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-35</key>
<configkey>SECURITY-35</configkey>
<name><![CDATA[ 不要相信任何可能被攻击者设置的命令行值 [SECURITY-35] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要相信任何可能被攻击者设置的命令行值 [SECURITY-35-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要相信任何可能被攻击者设置的命令行值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

不要相信任何可能被攻击者设置的命令行值。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int main(int argc, char **argv)
{
  int local = 0;
  local += argc;     // 违规
  return 1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int main()           // OK
{
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/command-line.html">http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/command-line.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-36</key>
<configkey>SECURITY-36</configkey>
<name><![CDATA[ 禁止使用来自不信任用户的未经过滤的数据作为格式化参数 [SECURITY-36] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止使用来自不信任用户的未经过滤的数据作为格式化参数 [SECURITY-36-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

从不使用不信任用户的未经过过滤的数据
作为格式化的参数。不遵循这条规则通常会导致
危险的格式化字符串。一个特别的例子就是
printf's %n 转换格符，写
一定字符串长度到指针所值的参数，
利用这点攻击者可以重写覆盖一个
期望输出的值。
这条规则检查格式化参数是否有使用。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免了覆盖一个想要输出
的值。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
void foo( char* stringFromUntrustedUser ) {
    printf( stringFromUntrustedUser );          // 违规
    printf( "stringFromUntrustedUser" );        // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;
void foo( char* stringFromUntrustedUser ) {
    const char *format = "%s";

    printf( "%s",stringFromUntrustedUser );     // OK
    printf( format, stringFromUntrustedUser );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. David A. Wheeler, Programming Secure Applications for Unix-like Systems (pdf), 
   <A HREF="http://www.dwheeler.com/secure-programs">http://www.dwheeler.com/secure-programs</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-37</key>
<configkey>SECURITY-37</configkey>
<name><![CDATA[ 不要使用弱加密函数 [SECURITY-37] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用弱加密函数 [SECURITY-37-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则报告一个违规当crypt()函数被使用或者encrypt()
函数被调用时第二个参数(edflag)等于'0'。如果edflag是0，
块作为第一个参数是可以通过的。 这种加密方式密码
是弱加密的可以被破译的。同样crypt()是
也是弱加密的并且更好的选择是使用
散列密码。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则检查弱加密函数。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;unistd.h&gt;

void myCrypt(const char* key, const char *salt)
{
    char *hash = crypt(key, salt);    // 违规

    /* ... */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

应该用更安全的函数来代替crypt()和encrypt()。
下面的信息提供了一个很好的参考：

* OpenSSL (e.g. SHA1 function)
* Crypto++
* BSAFE - RSA Security's widely deployed commercial library
* Cryptlib (Peter Gutmann)



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. <A HREF="https://buildsecurityin.us-cert.gov/daisy/bsi-rules/home/g1/728.html">https://buildsecurityin.us-cert.gov/daisy/bsi-rules/home/g1/728.html</A>

2. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

3. CWE/SANS Top 25 Most Dangerous Software Errors: CWE-327
   <A HREF="http://cwe.mitre.org/top25/#CWE-327">http://cwe.mitre.org/top25/#CWE-327</A>

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SECURITY-38</key>
<configkey>SECURITY-38</configkey>
<name><![CDATA[ 不可信的数据用作循环边界 [SECURITY-38] ]]></name>
<tag>security</tag>
<priority>CRITICAL</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不可信的数据用作循环边界 [SECURITY-38-2]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

这条规则会报告一个违规如果用户输入的数据
直接作为循环边界。使用用户输入的值作为循环边界
会导致一个拒绝服务判断。
下面的函数和对象会返回
不可信的用户数据：
  extern istream cin;
  int scanf(const char *format, ...);
  int fscanf( FILE *stream, ...);
  int fwscanf( FILE *stream, ...);

这条规则不会报告违规如果：

* 用户输入被间接使用(比如下面例子中的num，
它被分配限制变量，这个限制的变量是
循环的边界)

/* ... */
scanf("%u",&amp;num);
limit = num;
  
for (i = 0; i &lt; limit; i++)  // 用户输入不是直接被使用
{

}

* 用户输入值被传递给函数以指针方式或者引用方式
或者它的值在分配语句中被改变


bool validateData(int, float, char*);
    
void example()
{    
    int n, i; float x; char name[50];
    n = scanf("%d%f%s", &amp;i, &amp;x, name);      // 用户输入

    validateData(i, x, name)                // 'name' 以指针方式传递给validateData
    while(name[param]);                     // OK
    while(name[i]);                         // 违规 'i'
 
    x = 10;
    while(name[x]);                         // OK - 用户输入x并且置新值

}

可以参考: SECURITY-20.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则避免潜在的内存溢出和SQL注入攻击。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

void foo();

void iterateFoo()
{
  unsigned num;
  int i;
  scanf("%u",&amp;num);
  
  for (i = 0; i &lt; num; i++){  // 违规
    foo();
  }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;stdio.h&gt;

void foo();

bool validate(unsigned int param);

void iterateFoo()
{
  unsigned int num;
  int i, limit;
  scanf("%u",&amp;num);

  if(validate(num))
  {
    limit = num;
  }else{
  
   limit = 0;
  }
  
  for (i = 0; i &lt; limit; i++){  // OK
    foo();
  }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. PCI Data Security Standard (PCI DSS) Version 1.2
   Requirement 6: Develop and maintain secure systems and applications

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-01</key>
<configkey>STL-01</configkey>
<name><![CDATA[ 选择使用类的封装，而不是编写与容器无关的代码 [STL-01] ]]></name>
<tag>stl</tag>
<priority>INFO</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
选择使用类的封装，而不是编写与容器无关的代码 [STL-01-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"鉴于不时地需要更改容器的类型的必然性
你可以用一种通常的方式适应这种变化,
通过封装, 封装，封装。 最早的这么做的方式是通过
为容器和迭代器类型自由的使用类型定义.(...) 一个类型定义就是
其他类型的同义词, 所以它提供的封装是简洁的词法
一个类型定义不能预防一个客户端做(或者依赖于)
任何他们不能做 (或者依赖于)的事.你需要更大的武器
如果你想要限制客户端暴露给容器你已经做的选择 
你需要类. 去限制将会需要修改的代码.
如果你要取代一个容器的类型, 在一个类里面隐藏容器的类型, 并且
可以限制类接口具体可见的容器信息的数量. 举个例子说, 如果你需要创建一个客户列表, 不需要
直接只用一个列表. 然而, 可以创建一个客户列表的类, 在它的私有区域
存储一个列表"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"当你考虑到这种变化, 你仍然需要检查每一个客户列表成员函数
以及每一个友元，来看看他们是怎么被影响到的.
(依据性能的表现并且算子/指针/引用实效, 等等.),
但是如果你已经很好的封装用户列表实现的细节，
对用户列表客户端的影响应该很小.你不能写一个
独立于容器的代码, 但是你以后有可能去写."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;list&gt;

using namespace std;

class Customer{};

list&lt;Customer&gt; customers1;                                // 违规

typedef list&lt;int&gt; CustomersContainer;                  // 违规
CustomersContainer customers2;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;list&gt;

using namespace std;

class Customer{};

class CustomerList {
private:
    typedef list&lt;Customer&gt; CustomerContainer;
    typedef CustomerContainer::iterator CCIterator;
    CustomerContainer customers;                        // OK
public:
                     // 限制可见
                     // 信息的数量
};                   // 在这个接口中



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
Standard Template Library", Chapter 1, item 2

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-02</key>
<configkey>STL-02</configkey>
<name><![CDATA[ 要使复制有效、正确且不会产生切片问题，应该创建指针容器而不是对象容器 [STL-02] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
要使复制有效、正确且不会产生切片问题，应该创建指针容器而不是对象容器 [STL-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"容器控制对象, 但是不是你给他们的那种. 此外, 当你
从容器中获得一个对象, 你得到的对象并不一定是容器中的那个.
 反而, 当你往容器中插入一个对象 (通过. 比方说..
insert或者push_back. 等等.), 进入容器的是你指定对象的一份拷贝
当你从容器中获取一个对象 (通过.比方说.. front
后者back), 你设置的是一个被容器包含的拷贝. 拷进，拷出.
这就是STL的方式.

一个简单的途径使得拷贝更加正确有效并且不受切片问题的影响
就是创建指针或者智能指针的容器来取代
对象指针."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"拷贝指针速度很快,它总是想你希望的那样准确(它拷贝
组成指针的那些位), 当指针被拷贝的时候，并没有
切片生成."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;map&gt;
using namespace std;

class example {
};

void foo() 
{
  list&lt;example&gt; cont1;            // 违规
  map&lt;int,example&gt; cont2;      // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;map&gt;
using namespace std;

class example {
};

void foo() {
  list&lt;example*&gt; cont1;            // OK
  map&lt;int,example*&gt; cont2;      // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
   Standard Template Library", Chapter 1, item 3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-03</key>
<configkey>STL-03</configkey>
<name><![CDATA[ 调用 empty 而不要判断 size() 是否为 0 [STL-03] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
调用 empty 而不要判断 size() 是否为 0 [STL-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"调用 empty 而不要判断 size() 是否为 0. 你应该更喜欢
构造函数使用empty , 并且原因很简单: empty 是一个恒定时间的
操作对于所有的标准容器来讲, 但是有些list的实现,
size 需要线性时间."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的效率.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;

int foo()
{
    std::vector&lt;char&gt; vVector;
	
    if(vVector.size() == 0) // 违规
        return 1;
	
    if(vVector.size())      // 违规
        return 1;

    return 0;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;

int foo()
{
    std::vector&lt;char&gt; vVector;
	
    if(vVector.empty() == 0) // OK
        return 1;
	
    if(vVector.empty())      // OK
        return 1;

    return 0;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 1, item 4

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-04</key>
<configkey>STL-04</configkey>
<name><![CDATA[ 避免在显式的循环中递归调用插入操作 [STL-04] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免在显式的循环中递归调用插入操作 [STL-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在显式的循环中递归调用插入操作,这个看上去
或多或少的有点像下面:

   vector&lt;int&gt;::iterator insertLoc(v.begin());
   for (int i = 0; i &lt; numValues; ++i) {
   insertLoc = v.insert(insertLoc, data[i]);
   }

注意，我们是怎么样小心的存取下一次循环迭代的返回值
如果我们在每次插入操作之后不更新, 我们将会
有两个问题. 第一,第一次以后的所有循环迭代将让位于未定义的行为 
, 因为每次插入调用将会使 insertLoc无效. 第二, 尽管 
insertLoc保持有效, 我们将会总是在队首进行插入， 
(i.e., at v.begin()), 并且结果将是被复制进v的整形值将
在一个反转的顺序下结束. 如果 我们按照第 43条的指引并且替代 
一个循环使用复制的调用, 我们将得到以下的式样:

   copy(data. data + numValues, inserter(v, v.begin()));

当复制的模板已经被实例化的时候, 基于拷贝的和
使用基本循环的代码将会差不多一样l, 所以 
按照有效分析的代码, 我们将专注于显式循环,记住 
这种代码和使用拷贝的代码一样有效. 看那个
显式循环 ，就使得更容易的明白效率点从何而出。 
是的那就是 "采样数." 复数, 因为那些代码使用单一元素的 
版本是插入税点在那三个不同表现的税在你身上, 如果 
你只用一系列的插入版本，你将不需要付出任何的insert.(...)操作"
参见: STL-05



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了性能和预防未定义行为的表现在
不适当的更新 insert操作的位置.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

void foo()
{
    vector&lt;int&gt; v;
    const int numValues = 10;
    int data[numValues]={0,1,2,3,4,5,6,7,8,9};

    vector&lt;int&gt;::iterator insertLoc(v.begin());
       
    for (int i = 0; i &lt; numValues; i++)
    {
        insertLoc = v.insert(insertLoc, data[i]);     // 违规
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

void foo()
{
    vector&lt;int&gt; v;
    const int numValues = 10;
    int data[numValues]={0,1,2,3,4,5,6,7,8,9};

    v.insert(v.begin(),data,data+numValues);           // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
   Standard Template Library", Chapter 1, item 5

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-05</key>
<configkey>STL-05</configkey>
<name><![CDATA[ 几乎所有的复制是通过调用成员函数而不是插入迭代器来确定目的范围 [STL-05] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
几乎所有的复制是通过调用成员函数而不是插入迭代器来确定目的范围 [STL-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"(...)当目的范围被指定使用插入迭代子的时候 ，
(例如.. 通过 inserter, back_inserter. 或者front_inserter) 可以
—应该可以— 被取代为一些列成员函数的调用. 许多的STL
程序过度使用copy,所以我再重复给出一遍一件: 几乎所有
用到复制的那些目标范围被指使用迭代子的地方都可以
被一些列指向成员函数的调用地方所取代."
参见: STL-04



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"简而言之, 区间成员函数的产出的代码，很容易被写以及
容易理解. (...) 它将会更广泛的作用于
商定的标准去搭建成员函数
对于一个单元素角色的优越性. 对于一个标准的序列容器
,我们有一个: 效率.当我们处理标准的序列容器
的时候,一个拥有单元素成员函数在内存分配上面有更多需要的应用程序
, 拷贝对象更佳的频繁, 与或执行冗余
相对于一些烈成员函数可以达到一样的目的."



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class Widget{};

void  myFunction()
{
    vector&lt;Widget&gt; v1, v2;
    v1.clear();
    copy(v2.begin() + v2.size() / 2, v2.end(), back_inserter(v1 )); // Violation
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class Widget{};

void  myFunction()
{
    vector&lt;Widget&gt; v1, v2;
    v1.clear();
    v1 .insert(v1 .end(), v2.begin() + v2.size() / 2, v2.end());   // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
   Standard Template Library", Chapter 1, item 5

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-06</key>
<configkey>STL-06</configkey>
<name><![CDATA[ 当用作函数参数时，应使用 istream_iterator 名字而不是匿名的 istream_iterator 对象 [STL-06] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当用作函数参数时，应使用 istream_iterator 名字而不是匿名的 istream_iterator 对象 [STL-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"警惕C + +中最棘手的解析."
当用作函数参数时，应使用 istream_iterator 名字而不是匿名的 istream_iterator 对象 
在C++中有一条通用的规则, 说道 
几乎任何东西将作为一个函数的声明解析.
防止模棱两可的代码的最佳解方案是从
使用匿名的istream_iterator对象在数据声明的方法中退出，
简单的使用迭代器的名字.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可维护性以及防止产生模棱两可的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;

using namespace std;

void foo()
{
    ifstream dataFile("ints.dat");
	
    list&lt;int&gt; data2(istream_iterator&lt;int&gt;(dataFile),  // 违规
	                istream_iterator&lt;int&gt;()); 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;

using namespace std;

void foo()
{
    ifstream dataFile(" ints.dat");
    istream_iterator&lt;int&gt; dataBegin(dataFile);
    istream_iterator&lt;int&gt; dataEnd;
				 
    list&lt;int&gt; data(dataBegin,dataEnd);     // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
Standard Template Library", Chapter 1, item 6

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-07</key>
<configkey>STL-07</configkey>
<name><![CDATA[ 容器中如果有新创建的指针，切记删除容器之前先删除指针 [STL-07] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
容器中如果有新创建的指针，切记删除容器之前先删除指针 [STL-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"所有你真正需要记住的是STL容器是智能的, 但是他们
没有足够智能到t知道是否删除他们所含有的指针.来避免这种
资源泄漏，当你有容器指针的时候应该被删除,
你必须要么取代现在的指针用智能引用计数指针
对象(例如 Boost's shared_ptr) 或者你必须按照手册删除在容器中的每一个指针
在容器被销毁之前."
规则加强了取代指针和 智能引用计数指针对象
 (例如 Boost's shared_ptr) 把它作为异常安全的解决方案.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则帮助提供异常安全的解决方案并且防止资源泄漏.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;boost/shared_ptr.hpp&gt;

#define NUMBER 10

using namespace std;

class Widget
{
public:
	Widget(){}
	~Widget(){}
	
};

void foo()
{
	vector&lt;Widget*&gt; vwp;
	for (int i = 0; i &lt; NUMBER; ++i)
		vwp.push_back(new Widget);               // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;boost/shared_ptr.hpp&gt;

#define NUMBER 10

using namespace std;

class Widget
{
public:
	Widget(){}
	~Widget(){}
	
};

void foo()
{
	typedef boost::shared_ptr&lt;Widget&gt; WidgetPtr;
	vector&lt;WidgetPtr&gt; vwp;
	
	for (int i = 0; i &lt; NUMBER; ++i)
		vwp.push_back(WidgetPtr(new Widget));        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 1, item 7

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-08</key>
<configkey>STL-08</configkey>
<name><![CDATA[ 禁止创建 auto_ptrs 的容器 [STL-08] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止创建 auto_ptrs 的容器 [STL-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"永远不要创建 auto_ptrs容器. 唉,许多程序员使用STL
平台不能拒绝COAPs  (auto_ptrs容器). 更不幸的是,
许多程序员把COAPs看成一个简单的嵌入体, 更直接的说,
对于解决资源泄漏的有效的途径经常伴随着容器指针
结果是,许多程序员倾向使用COAPs, 尽管
不太可能去创建它们."



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的效率，正确性，以及可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;boost/shared_ptr.hpp&gt;

using namespace std;

void foo( ) {
    typedef auto_ptr&lt;int&gt; q; 
    vector&lt;q&gt; v;                // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;boost/shared_ptr.hpp&gt;

using namespace std;

void foo( ) {
    typedef boost::shared_ptr&lt;int&gt; w; 
    vector&lt;w&gt; v;               // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 1, item 8

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-09</key>
<configkey>STL-09</configkey>
<name><![CDATA[ 避免对 list 和标准关联容器使用 remove 算法 [STL-09] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免对 list 和标准关联容器使用 remove 算法 [STL-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在擦除选项中仔细选择.
如果你有一个连续内存的容器 (vector, deque, or string),
最好的方式就是有 erase-remove 习惯:

c.erase( remove(c.begin(), c.end(), 1963), c.end());

这个选择对于列表同样有用, 但是队列成员的删除更多
作用: 

c. remove(1963);

当c是一个标准的关联容器 (比如说.. set. multiset, map. 
or multimap), 使用任何名为remove的事情都是完全错误的. 
这样的容器没有任何成员函数名为remove,并且使用remove
算法会覆盖容器的值, 会有潜在可能性损坏 
容器."规则不允许使用任何关于list 的remove操作的算法以及相关于容器的 
标准.



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

Rule improves efficiency of code amd prevents possibility of data corruption.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;algorithm&gt;
#include &lt;list&gt;

using namespace std;

bool goo( int x );

void foo( ) {
    list&lt;int&gt; list_int;

    list_int.erase( remove( list_int.begin( ),                     // 违规
                            list_int.end( ), 1963 ), list_int.end( ) );      
    list_int.erase( remove_if( list_int.begin( ),                  // 违规
                               list_int.end( ),  goo ), list_int.end( ) );   
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;algorithm&gt;
#include &lt;list&gt;

using namespace std;

bool goo( int x );

void foo( ) {
    list&lt;int&gt; list_int;

    list_int.remove( 1963 );    // OK
    list_int.remove_if( goo );  // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 1, item 09

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-10</key>
<configkey>STL-10</configkey>
<name><![CDATA[ 对于动态分配的数组最好使用 vector 或 string [STL-10] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对于动态分配的数组最好使用 vector 或 string [STL-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当你决定使用new来做动态内存分配的那分钟, 你应该承担 
一下责任:
1. 你必须确保有人来释放分配的内存. 
2. 你必须确保以正确的形式来释放. 对于 
单个对象的分配, "delete" 必须被使用. 
对于任何数组分配, "delete []" 被要求. 
3. 你必须确保delete被正确的一次使用. 
任何时候当你发现你已经准备好去动态分配一个数组的时候,
你可以考虑用一个向量或者字符串来取代.(...) 向量和字符串g
可以消除上述的问题,因为他们管理自己的内存. 他们的
内存伴随着新的元素被添加到他们的容器内而增长,并且当向量或者
字符串被销毁, 他们的析构函数自动的销毁他们在容器内的元素 
并且释放持有这些元素的内存."
参见: STL-11



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则帮助写更加安全和可扩展的代码.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

class A{};
void foo()
{
  A *p;
  p = new A[10]; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

class A{};

void foo()
{
  A obj;
  vector &lt;A&gt; vectorA; // OK
  vectorA.push_back(obj);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
   Standard Template Library", Chapter 2, item 13

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-11</key>
<configkey>STL-11</configkey>
<name><![CDATA[ 使用 vector<char> 而非 string [STL-11] ]]></name>
<tag>stl</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 vector&lt;char&gt; 而非 string [STL-11-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"考虑使用 vector&lt;char&gt; 而不是字符串。向量 vector 的
实现不允许被引用计数， 所以不会出现隐藏的多线程性能
问题。"
参见: STL-10



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于编写更加安全和可扩展的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;string&gt;
using namespace std;

void foo( ) {
    string sName;         // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

void foo( ) {
    vector &lt;char&gt; sName; // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
Standard Template Library", Chapter 2, item 13

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-12</key>
<configkey>STL-12</configkey>
<name><![CDATA[ 使用 reserve 来避免不必要的重复分配 [STL-12] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 reserve 来避免不必要的重复分配 [STL-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"使用 reserve 以避免不必要的重新分配。其中 reserve 成员函数
能够使你减少必须执行重新分配的最小数量，
从而避免实际位置的消耗和 50 迭代器(iterator)/指针(pointer)/引用(reference)
无效。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的效率，正确性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;

using namespace std;

void foo()
{
    vector&lt;int&gt; v;
    for (int i = 1; i &lt;= 1000; ++i) v.push_back(i); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;

using namespace std;

void foo()
{
    vector&lt;int&gt; v;
    v.reserve(1000);
    for (int i = 1; i &lt;= 1000; ++i) v.push_back(i); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 2, item 14

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-13</key>
<configkey>STL-13</configkey>
<name><![CDATA[ 每一个 vector 和 string 在被传递给 C 函数之前，应该对它们是否为空做一个检查 [STL-13] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个 vector 和 string 在被传递给 C 函数之前，应该对它们是否为空做一个检查 [STL-13-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"(...) 不过，障碍依然存在，并且最常见的一种情况是遗留的
C 语言 API 数据交互在数组和 char* 指针上而不是 vector 和
字符串对象。这些 API 将会存在很长一段时间， 所以如果我们
打算有效地使用 STL那么我们必须和它们和平共处。 幸运地是，这很容易。
如果您有一个向量 vector v 并且您需要有一个指向 v 中数据的指针
可以作为一个数组来查看，简单地使用 &amp;v[0]。唯一的症结点是如果 v 为空。
如果是这样的话， v.size() 为零， 并且 &amp;v[0] 试图去产生一个指针指向
不存在的东西。"
规则强制检查是否 vector/string 为空在其被传递给 C
函数之前。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止不确定的结果。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.c
#include &lt;stddef.h&gt;
void doSomething( const int* pInts, size_t numlnts ) {
    /*...*/
}

// file.cpp
#include "file.c"
#include &lt;vector&gt;

using namespace std;

void foo( ) {
    vector&lt;int&gt; v;
    doSomething( &amp;v[ 0 ], v.size( ) ); // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.c
#include &lt;stddef.h&gt;
void doSomething( const int* pInts, size_t numlnts ) {
    /*...*/
}

// file.cpp
#include "file.c"
#include &lt;vector&gt;

using namespace std;

void foo( ) {
    vector&lt;int&gt; v;

    if (!v.empty( )) {
        doSomething( &amp;v[ 0 ], v.size( ) ); // OK
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 2, item 16

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-14</key>
<configkey>STL-14</configkey>
<name><![CDATA[ 避免使用 vector<bool> [STL-14] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免使用 vector&lt;bool&gt; [STL-14-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"避免使用 vector&lt;bool&gt;。 作为一个 STL 容器， 使用 vector&lt;bool&gt; 
确实只存在两个方面的错误。首先，其不是一个 STL 容器。
其次，它并不容纳布尔类型。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于编写更加安全和可扩展的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

void foo(vector&lt;bool&gt; bParam)      // 违规
{
	vector&lt;bool&gt; sName;        // 违规
	vector&lt;bool&gt; *psName;      // 违规
}

vector&lt;bool&gt; vec_fun();            // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

void foo(vector&lt;int&gt; bParam)      // OK
{
	vector&lt;int&gt; sName;        // OK
	vector&lt;int&gt; *psName;      // OK
}

vector&lt;int&gt; vec_fun();            // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
Standard Template Library", Chapter 2, item 18

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-15</key>
<configkey>STL-15</configkey>
<name><![CDATA[ 对存放指针的关联容器指定比较方式 [STL-15] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对存放指针的关联容器指定比较方式 [STL-15-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"为指针的关联容器指定比较方式。 (...) 在任何时候
您创建了一个指针的标准关联容器， 您必须牢记
容器将按照指针的值来排序。 很少情况是按照您希望
那样，所以您总是希望创建您自己的
函数类来作为比较方式。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止未定义的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

void myFunction()
{
    set&lt;string*&gt; ssp;                     // 违规
    ssp.insert(new string("Anteater"));
    ssp.insert(new string("Wombat"));
    ssp.insert(new string("Lemur"));
    ssp.insert(new string("Penguin"));
 
    set&lt;string*&gt;::const_iterator i;
    
    for (i = ssp.begin(); i != ssp.end();++i)
        cout &lt;&lt; *i &lt;&lt; endl;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

struct StringPtrLess:
public binary_function&lt;const string*, const string*,bool&gt; 
{ 
    bool operator()(const string *ps1, const string *ps2) const
    {
        return *ps1 &lt; *ps2;
    }
};

void myFunction2()
{
    set&lt;string*, StringPtrLess&gt; ssp;       // OK
    ssp.insert(new string("Anteater"));
    ssp.insert(new string("Wombat"));
    ssp.insert(new string("Lemur"));
    ssp.insert(new string("Penguin"));
    
    set&lt;string*, StringPtrLess&gt;::const_iterator i;
    
    for (i = ssp.begin(); i != ssp.end();++i)
        cout &lt;&lt; **i &lt;&lt; endl;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 3, item 20

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-16</key>
<configkey>STL-16</configkey>
<name><![CDATA[ 禁止对关联容器使用判定相等数值为真的比较函数 [STL-16] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对关联容器使用判定相等数值为真的比较函数 [STL-16-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"创建一个使用 less_equal 作为比较方式的 set， 然后在此 set
中插入 10:
set&lt;int, less_equal&lt;int&gt; &gt; s;
s.insert(10); 
s.insert(10); // 现在尝试再次插入 10:

对于这次插入的调用，set 必须要知道是否 10 已经
存在。为了更加容易理解在当 set 做此操作的时候到底发生了什么，
我们称最初插入的 10 为 10A 而称正试图插入的 10 为
10B。此 set 在其内部数据结构中查找用于插入 10B 的
位置。最终需要检查 10B 是否与 10A 相同。
对于关联容器来说，"相同" 的定义是值等价(equivalence)，
所以 set 测试以了解是否 10B 和 10A 是等价的。 当执行
此测试时，它自然会使用 set 的比较函数。 在这个例子中， 就是指
&lt;= 操作符， 因为我们指定了 less_equal 为 set 的比较函数，
并且 less_equal 表示操作符。 因此 set 检查看看是否这个表达式
为真(true):

!(10A&lt;= 10B)&amp;&amp;!(10B&lt;= 10A) // 测试 10A 和 10B 是否等价

由于 10A 和 10B 都是 10，所以很清楚地知道 10A &lt;= 10B 为 true。同样
清楚的是 10B &lt;= 10A 也为 true。 因此上面的表达式简化为 !(true)&amp;&amp;!(true)
再进一步简化为 false &amp;&amp; false 结果即为 false。 也就是说，set
判定 10A 和 10B 不是等价的， 因此不是相同的，换句话说其可以和 10A 一起将
10B 插入到容器中。 从技术上讲，这样的操作
会产生不确定的行为， 但是几乎普遍的结果是
set 以两个值为 10 的拷贝结尾，这意味着其不再是
一个 set 了。"
参见: STL-17



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"通过使用 less_equal 作为我们的比较类型，我们将破坏容器!
此外，任何对于相等数值返回 true 的比较函数都会做同样的事。
按照定义相等的值并不是等价!"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;set&gt;
#include &lt;functional&gt;
using namespace std;

void myFunction()
{
    set&lt; int, less_equal&lt;int&gt; &gt; setInt;  // 违规
    setInt.insert(1);
    setInt.insert(10);
    setInt.insert(10);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;set&gt;
#include &lt;functional&gt;
using namespace std;

void myFunction()
{
    set&lt; int, less&lt;int&gt; &gt; setInt;        // OK
    setInt.insert(1);
    setInt.insert(10);
    setInt.insert(10);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
Standard Template Library", Chapter 3, item 21

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-17</key>
<configkey>STL-17</configkey>
<name><![CDATA[ 禁止对关联容器使用判定相等数值为真的比较函数 [STL-17] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
禁止对关联容器使用判定相等数值为真的比较函数 [STL-17-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"(...) 假设对于一个按降序排序的 string* 指针的
容器您需要一个比较函数。自然想到的事情就是利用
现有的代码并修改它。如果您不小心，您可能会出现
如下的情况 (...):

struct StringPtrGreater:                               // 这段代码是有缺陷的!
public binary_function&lt;const string*, const string*, bool&gt; 
{
   bool operator()(const string *ps1, const string *ps2) const
   {
       return !(*ps1 &lt;*ps2); //只是对旧的测试取反;
   }                         // 这是不正确的!
};

这里的想法是通过对比较函数内部的测试取反
来颠倒排序顺序。 不幸的是，取反 "&lt;" 并不是 "&gt;" 
(你所希望的)， 你得到的是 "&gt;="。 那么你现在明白了 "&gt;="
对于关联容器是一个无效的比较函数，原因是对于相等的数值
它将返回 true。为了避免落入这个陷阱，您所需要记住的是
一个比较函数的返回值表明是否一个值在该函数定义的排序顺序
中先于另一个。相等的值绝对不会先于另一个，
所以比较函数应该对相等数值
总是返回 false。"
See also: STL-16



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"除非您的比较函数对相等数值始终返回 false，
您打破了所有的标准关联容器，无论它们是否
允许存储重复值。"


</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;set&gt;
using namespace std;

struct IntGreater:
public binary_function&lt;const int,const int, bool&gt; {
    bool operator()(const int ps1, const int ps2) const
    {
        return !(ps1 &lt; ps2);
    }
};

void myFunction()
{
    set&lt; int, IntGreater&gt; setInt; // 违规
    setInt.insert(1);
    setInt.insert(10);
    setInt.insert(10);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;set&gt;
using namespace std;

struct IntGreater:
public binary_function&lt;const int,const int, bool&gt; {
    bool operator()(const int ps1, const int ps2) const
    {
        return (ps1 &gt; ps2);
    }
};

void myFunction()
{
    set&lt; int, IntGreater&gt; setInt; // OK
    setInt.insert(1);
    setInt.insert(10);
    setInt.insert(10);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 3, item 21

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-18</key>
<configkey>STL-18</configkey>
<name><![CDATA[ 使用 iterator 而不是 const iterator,reverse_iterator,或 const_reverse_iterator [STL-18] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 iterator 而不是 const iterator,reverse_iterator,或 const_reverse_iterator [STL-18-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"使用迭代器 iterator 而不是 const iterator, reverse_iterator, 或
const_reverse_iterator。 更倾向于使用迭代器 iterators 而不是 const
和 reverse iterators 的意义在于:
- 插入和删除的某些版本需要迭代器 iterators。 如果您希望
  调用这些函数， 您将会需要产生迭代器 iterators，而 const 和 reverse
  iterators 将不会这样做。
- 不可能显式地转换一个 const iterator 为一个 iterator
- 从一个 reverse_iterator 到一个 iterator 的转换可能需要在转换之后
  调整 iterator。

所有这些原因共同让使用容器变得更加容易，更加高效，
并且如果您使用 iterators 而不是其它同类的 const 和
reverse，会让隐藏细小的缺陷的可能变得更小。

从 const 正确性的角度 (可以肯定的是一个更有价值的角度)，
远离 const_iterators 可以简单地避免潜在的执行方面
似乎不合理的缺陷 (所有这些都有解决方法)， 但是一些
容器的成员函数在关联 iterators 的状态中，
难以避免实际的结论是 const_iterators
比起 iterators 不仅缺乏有用性， 有时它们还会造成不值得
的麻烦。"


例外:

Const 容器。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的效率和可移植性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;

using namespace std;

void sampleFunction(const std::vector&lt;int&gt; &amp;o)
{
    vector&lt;int&gt; v;
    
    typedef vector&lt;int&gt;::const_iterator ConstIter;
    typedef vector&lt;int&gt;::iterator Iter;
    
    ConstIter c_it;
    c_it= v.begin();                             // 违规 
    c_it = o.begin();                            
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;

using namespace std;

void sampleFunction(const std::vector&lt;int&gt; &amp;o)
{
    vector&lt;int&gt; v;
    
    typedef vector&lt;int&gt;::const_iterator ConstIter;
    typedef vector&lt;int&gt;::iterator Iter;
    
    ConstIter c_it;
    Iter it = v.begin();                         // OK
    c_it = o.begin();                            // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 4, item 26

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-19</key>
<configkey>STL-19</configkey>
<name><![CDATA[ 使用 distance 和 advance 将容器的 const_iterators 转换为 iterators [STL-19] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 distance 和 advance 将容器的 const_iterators 转换为 iterators [STL-19-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"强制转换 const iterators 为 iterators 是不明智的，甚至对于 vector
和 string， 因为它的可移植性值得怀疑。使用 distance() 和
advance() 来转换一个容器的 const_iterators 为 iterators。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可移植性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// Compiles with vc++ 6.0

#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

void foo( ) {
    typedef vector&lt;int&gt; IntVector;
    typedef vector&lt;int&gt;::iterator Iter;
    typedef vector&lt;int&gt;::const_iterator ConstIter;

    ConstIter citer;

    Iter iter = const_cast&lt;Iter&gt;( citer );   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

void goo( ) {
    typedef vector&lt;int&gt; IntVector;
    typedef vector&lt;int&gt;::iterator Iter;
    typedef vector&lt;int&gt;::const_iterator ConstIter;

    IntVector v;
    ConstIter citer;

    Iter iter( v.begin( ) );
    advance( iter, distance&lt;ConstIter&gt;( iter, citer ) ); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 4, item 27

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-20</key>
<configkey>STL-20</configkey>
<name><![CDATA[ 出于删除目的时，应谨慎使用 reverse_iterator 的基迭代器 [STL-20] ]]></name>
<tag>stl</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
出于删除目的时，应谨慎使用 reverse_iterator 的基迭代器 [STL-20-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"了解如何使用一个 reverse_iterator 的基本迭代器(iterator)。
(...) 一个 reverse_iterator 的 base 成员函数返回
"对应的" 迭代器(iterator)是不准确的说法。对于插入目的， 确实
是这样，但是对于删除目的，它却不是。 当转换 reverse_iterators
为迭代器(iterator)时， 重要的是您知道对于产生的迭代器
应该要做什么，因为只有这样您才能确定是否您拥有的就是
您所需要的。
为了模拟删除由一个 reverse_iterator ri 指定的位置， 相反在
ri.base() 之前删除这个位置。 对于删除的目的， ri 
和 ri.base() 是不相同的， 并且 ri.base() 也不等同于对应于 ri 的
迭代器(iterator)。" 
当在删除调用中发现使用基本迭代器并且对于
基本迭代器没有执行递增/递减运算时规则报告
警告消息。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止不确定的结果。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;

using namespace std;

void foo()
{
	vector&lt;int&gt; v;
	list&lt;int&gt; li;
	vector&lt;int&gt;::reverse_iterator ri = find(v.rbegin(), v.rend(), 3);
	list&lt;int&gt;::reverse_iterator ri2 = find(li.rbegin(), li.rend(), 3);
	
        v.reserve(5);
	for(int i = 1;i &lt;= 5;++i){
		v.push_back(i);
		li.push_back(i);
	}
	
	v.erase(ri.base());     // 违规	
	li.erase(ri2.base());   // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;

using namespace std;

void foo()
{
	vector&lt;int&gt; v;
	list&lt;int&gt; li;
	vector&lt;int&gt;::reverse_iterator ri = find(v.rbegin(), v.rend(), 3);
	list&lt;int&gt;::reverse_iterator ri2 = find(li.rbegin(), li.rend(), 3);
	
        v.reserve(5);
	for(int i = 1;i &lt;= 5;++i){
		v.push_back(i);
		li.push_back(i);
	}
	
	v.erase((--ri).base()); // OK
	li.erase(--ri2.base()); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
Standard Template Library", Chapter 4, item 28

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-21</key>
<configkey>STL-21</configkey>
<name><![CDATA[ 逐字符输入时，使用 istreambuf 的迭代器 [STL-21] ]]></name>
<tag>stl</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
逐字符输入时，使用 istreambuf 的迭代器 [STL-21-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果你需要在一个字符流中逐个读取字符， 您不需要借助
格式化的输入，并且您关心的是读取这个字符流需要花费
多长的时间，在每个迭代器中输入三个额外的字符作为
显著提升性能是一个小的代价。 对于未格式化的字符
按照 - 字符输入，您应该始终考虑 istreambuf_iterators。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高代码的性能和效率。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;

using namespace std;

void myFunction()
{
    ifstream dataFile("some_file.dat");
    istream_iterator&lt;char&gt; dataBegin(dataFile); // 违规
    istream_iterator&lt;char&gt; dataEnd;             // 违规
    
    list&lt;char&gt; data(dataBegin, dataEnd);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;

using namespace std;

void myFunction()
{
    ifstream dataFile("some_file.dat");
    istreambuf_iterator&lt;char&gt; dataBegin(dataFile); // OK
    istreambuf_iterator&lt;char&gt; dataEnd;             // OK
    
    list&lt;char&gt; data(dataBegin, dataEnd);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
Standard Template Library", Chapter 4, item 29

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-22</key>
<configkey>STL-22</configkey>
<name><![CDATA[ 确保目标范围足够大 [STL-22] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保目标范围足够大 [STL-22-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当程序员考虑将对象插入到容器中时将会出现问题
但是并没有告诉 STL 他们想要干什么。 这里是一个
常用的方法可以体现出来。:

 vector&lt;int&gt; values;
 vector&lt;int&gt; results;
 transform( values.begin(), values.end(), results.end(), transmogrify);

在这个例子中，告诉了 transform 转换目标范围的开始
是 results.end()，所以这就是在每个元素值上调用
transmogrify 开始写入结果的位置。像每个使用一个
目标范围的算法一样， transform 通过在目标范围中
分配元素来写入结果， 因此 transform 应用 transmogrify 到
values[0] 并分配结果到 *results.end()。 然后其将应用
transmogrify 到 values[1] 并分配结果到 *(results.end()+1)。
这样的调用 transform 是错误的，因为它要求实施分配的对象
并不存在。(...) 这样的说法 "请在调用结果的容器结尾
放置 transform 的结果" 是调用 back_inserter 来
生成指定目标范围起始的迭代器(iterator)。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"这可能导致灾难，因为在 *results.end() 位置没有对象，
在 *(results.end()+1) 少得多! 调用 transform 是错误的，
因为其要求实施分配的对象是不存在的。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int transmogrify(int x);

void myFunction()
{
    vector&lt;int&gt; values;
    vector&lt;int&gt; results;
    // put values to vector
    transform(values.begin(), values.end(),        // 违规
              results.end(), transmogrify); 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int transmogrify(int x);

void myFunction()
{
    vector&lt;int&gt; values;
    vector&lt;int&gt; results;
    // put values to vector
    transform(values.begin(), values.end(),           // OK
              back_inserter(results), transmogrify); 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
   Standard Template Library", Chapter 5, item 30

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-23</key>
<configkey>STL-23</configkey>
<name><![CDATA[ 如果进行删除操作，采取类似 remove 的算法 [STL-23] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果进行删除操作，采取类似 remove 的算法 [STL-23-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果您真的想要删除某些内容请遵照通过 erase 的
类似 remove 算法。从一个容器中消除一个元素的唯一方式
是在此容器上调用一个成员函数，并且由于 remove 并不知道
包含正在其上操作元素的容器，不可能从一个容器中
通过删除 remove 以消除元素。"


例外:

"事实上， remove 和 erase 是如此密切相关的，两者被合并到
列表成员函数的删除中。这是在 STL 中唯一命名为 remove 的函数
以用于从一个容器中消除元素。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高效率并防止内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

void foo( ) {
    vector&lt;int&gt; coll;
    for ( int i=0; i &lt; 10; i++ ) {
        coll.push_back( i + 65 );
    }
    vector&lt;int&gt;::iterator pos;
    pos = remove( coll.begin( ), coll.end( ), 5 ); // Violation no erase call
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

void foo( ) {
    vector&lt;int&gt; coll;
    for ( int i=0; i &lt; 10; i++ ) {
        coll.push_back( i + 65 );
    }
    vector&lt;int&gt;::iterator pos;
    pos = remove( coll.begin( ), coll.end( ), 5 );  // OK                      
    coll.erase( pos, coll.end( ) );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
    Standard Template Library", Chapter 5, item 32

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "STL: Containers", Rule 82

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-24</key>
<configkey>STL-24</configkey>
<name><![CDATA[ 避免对存放动态内存指针的容器使用 remove 或类似的算法 [STL-24] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免对存放动态内存指针的容器使用 remove 或类似的算法 [STL-24-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"警惕在指针的容器上使用类似 remove 的算法。这会使得
资源泄漏尤其明显，现在应该清楚为什么您需要尽量避免
对存放动态分配内存指针的容器使用 remove 和类似的算法 
(例如， remove_if 和 unique)。在许多情况下，你会发现
该分割算法是一个合理的选择。如果您不能避免在这样的
容器上使用 remove 的话， 消除这个问题的一种方式
是在应用 erase-remove 模式之前删除这些指针并把。
它们设置为 null， 然后在容器中消除所有的 null 指针。
如果您愿意通过使用执行引用计数的智能指针的容器
去替换指针的容器， 则跟 remove 相关的困难就会消失，
并且您可以直接使用 erase-remove 模式。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"警惕作用于指针容器的类似 remove 的算法。
如果不注意这样的建议将会导致资源泄漏。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

using namespace std;

class Widget{
public:
     bool isCertified();
};

void myFunction()
{
    vector&lt;Widget*&gt; v;
    v.push_back(new Widget);
    v.erase( remove_if(v.begin(), v.end(),                          // 违规
                       not1(mem_fun(&amp;Widget::isCertified))),v.end());
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
using namespace std;

class Widget{
public:
    bool isCertified();
};

void delAndNullifyUncertified(Widget*&amp; pWidget)
{
  if (!pWidget-&gt;isCertified()) { // delete the pointer
    delete pWidget;            // and set it to null pWidget
    pWidget = 0;
  }
}

void myFunction()
{
  vector&lt;Widget*&gt; v;
  v.push_back(new Widget);
   
  for_each(v.begin(), v.end(), delAndNullifyUncertified);
  v.erase( remove(v.begin(), v.end(), static_cast&lt;Widget*&gt;(0)), v.end()); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 5, item 33

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-25</key>
<configkey>STL-25</configkey>
<name><![CDATA[ 将一个已排序的区域传给某个算法，而该算法同时操作一个比较函数时，应确保该算法的比较操作和对区域排序操作是一致的 [STL-25] ]]></name>
<tag>stl</tag>
<priority>MINOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
将一个已排序的区域传给某个算法，而该算法同时操作一个比较函数时，应确保该算法的比较操作和对区域排序操作是一致的 [STL-25-4]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"(...) 最常见的一些算法需要排序值的范围。
非常重要的是无论它适不适用您都坚持这一需求，
因为违反它不会导致编译器的诊断程序，但是会导致的
未定义运行时行为。 (...) 需要在上面对数据进行排序的
算法的列表:
binary_search, lower_bound, upper_bound, equal_range, set_union,
set_intersection, set_difference, set_symmetric_difference, 
merge inplace_merge, includes

有这么多不同的排序方式，关键在于您提供 STL
一致的与其处理的信息相关的排序。 如果您传递
一个排序后的范围给一个也需要比较函数的算法， 
请确保您传递的比较函数与您用于排序范围那样
具有相同的行为。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"这十一个需要排序后范围的算法这样做是为了
比本来可能提供更高的效率。只要您记得要传递
给它们排序好的范围，并且只要您确认此算法
使用的比较函数和用于排序的算法是一致的，
那么你就会非常方便的进行无障碍搜索，设置和合并操作，
再加上您会发现 unique 和 unique_copy 算法消除了所有的
重复值，因为您可以很确定的说是希望达到这样的目的。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

void myFunction()
{
    vector&lt;int&gt; v;
    sort(v.begin(), v.end(), greater&lt;int&gt;());
    bool a3exists = binary_search(v.begin(),v.end(),3);           // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

void myFunction()
{
    vector&lt;int&gt; v;
    sort(v.begin(), v.end(), greater&lt;int&gt;());
    bool a3exists = binary_search(v.begin(),v.end(),3, greater&lt;int&gt;()); // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
Standard Template Library", Chapter 5, item 34

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-26</key>
<configkey>STL-26</configkey>
<name><![CDATA[ 正确执行 copy_if 的前提是不应该在谓词前返回带有 not1 的 remove_copy_if [STL-26] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
正确执行 copy_if 的前提是不应该在谓词前返回带有 not1 的 remove_copy_if [STL-26-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"STL 最有趣的方面之一是虽然有 11 个在名称中
包含 "copy" 的算法， 其中没有一个是 copy_if。 为了实现
copy_if， 那么似乎所有我们需要做的是在我们希望传递给 copy_if
的谓词前面抛出一个 not1， 然后传递此结果谓词给 remove_copy_if。
其结果是下面的代码。

// 一个对 copy_if 不很正确的实现
template&lt; typename Inputlterator, typename Outputlterator, typename Predicate&gt; 
Outputlterator copy_if( InputIterator begin, Inputlterator end, 
                        Outputlterator destBegin, Predicate p)
{
    return remove_copy_if(begin, end, destBegin, not1(p));
}

如果上述推理是有效的，我们可以写出这样我们不完美的构建
如下:

// 出于表述目的可能不能编译的代码
copy_if( widgets.begin(), widgets.end(), ostream_iterator&lt;Widget&gt;(cerr, "\n"),
         isDefective);

您的 STL 平台可能对这个代码有区别， 因为它试图去将 not1
应用到 isDefective。 但是 not1 不能被直接应用到一个函数 
指针: 函数指针必须首先被传递给 ptr_fun。 要调用这个
对 copy_if 的实现，您必须传递的不仅仅是一个函数对象， 而是
一个适配的函数对象。 这是很容易做的，但是原本是 STL 的算法
的客户端不应该是必须的。 标准的 STL 算法从来不要求
其仿函数是适配的， 并且也绝对不是 copy_if。"
如果对 copy_if 的实现是基于在谓词前返回一个包含 not1 的
remove_copy_if，规则将报告一个违规。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"鉴于 copy_if 是多么有用，再加上新的 STL 程序员往往
期望其存在的事实， 有一个很好的方式来实现 copy_if 
— 正确的那个!"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;functional&gt;

using namespace std;

template &lt;typename Inputlterator,typename Outputlterator, typename Predicate&gt;
    Outputlterator copy_if( Inputlterator begin, Inputlterator end,
        Outputlterator destBegin, Predicate p ) {
    return remove_copy_if( begin, end, destBegin,             // 违规
                           not1( ptr_fun( p ) ) ); 
}

template &lt;class T&gt; bool is_not_3( T val ) {
    return val != 3;
}

void foo( ) {
    vector&lt;int&gt; v;
    v.push_back( 1 );
    v.push_back( 2 );
    v.push_back( 3 );

    copy_if( v.begin( ), v.end( ), ostream_iterator&lt;int&gt;( cout, " " ),
             is_not_3&lt;int&gt; );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

using namespace std;

template &lt;typename Inputlterator, typename Outputlterator, typename Predicate&gt;
    Outputlterator copy_if( Inputlterator begin, Inputlterator end,
        Outputlterator destBegin, Predicate p ) {
    while (begin != end) {        // OK
        if (p(*begin))
            *destBegin++ = *begin;
        ++begin;
    }
    return destBegin;
}

template &lt;class T&gt; bool is_not_3( T val ) {
    return val != 3;
}

void foo( ) {
    vector&lt;int&gt; v;
    v.push_back( 1 );
    v.push_back( 2 );
    v.push_back( 3 );

    copy_if( v.begin( ), v.end( ), ostream_iterator&lt;int&gt;( cout, " " ),
             is_not_3&lt;int&gt; );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 5, Item 36

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-27</key>
<configkey>STL-27</configkey>
<name><![CDATA[ 如果 accumulate() 用于包含浮点指针值的容器，必须使用浮点数值初始化 [STL-27] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
如果 accumulate() 用于包含浮点指针值的容器，必须使用浮点数值初始化 [STL-27-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果执行了 accumulate 例如， 浮点型的列表并且初始值设置
为 int 0， 则 accumulate 内部将会使用一个 int 来存储其
正在运算的值。 "此 int 会最终成为 accumulate 的返回值，
并且它将被用来初始化 sum 变量。 该代码可以编译和运行，
但是 sum 的值是不正确的。相对于保持浮点类型列表的 
真正的 sum， 更倾向于具有所有浮点型加在一起的结果，
而后再在每次相加之后转换这个结果为 int 。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止数据丢失。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;numeric&gt;

using namespace std;
void foo()
{
	list&lt;double&gt; li; 
	double sum = accumulate(li.begin(), li.end(), 0);      // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;numeric&gt;

using namespace std;
void foo()
{
	list&lt;double&gt; li; 
	double sum = accumulate(li.begin(), li.end(), 0.0);    // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 5, item 37

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-28</key>
<configkey>STL-28</configkey>
<name><![CDATA[ 按传递值来设计 functor 类 [STL-28] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
按传递值来设计 functor 类 [STL-28-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"因为函数对象是按值传递和返回的，所以你的需要做的
就是确保您的函数对象当通过这种方式传递时行为正常
(例如，复制的)。 这意味着两件事。首先， 你的函数
对象必须要小。否则复制起来非常麻烦。 其次，您的
函数对象必须是单态性 (例如，不是多态性) — 它们
必须要不使用虚函数。 这是因为派生类对象按值传递到
基类类型的参数正面临这样的切割问题: 在复制过程中，
其派生的部分被删除。对多态仿函数的禁止同样是
不现实的。可以肯定的是有一种方式让函数对象更大
和/或多态性， 但是仍然允许它们符合遍布整个 STL 的
按值传递仿函数的原则。 这样， 获得你想要放置在
你的仿函数类中的数据和/或多态性，并将其移动到一个
不同的类。然后给你的仿函数类提供一个指向此新类的指针。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

按照小的类仿函数规则意味着其
包含非静态成员的数量不超过 5。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止切割问题和代价很大的复制。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// compiles with msvc 6.0, 7.1
#include &lt;functional&gt;
using namespace std;

class Widget;

template&lt;typename T&gt;                       
class BPFC: public unary_function&lt;T, void&gt;       // 违规
{
private:
    Widget w;
    int x;
    int y;
    void someFunction();
    bool checkWidget(Widget &amp;);
    
public:
    virtual void operator()(const T&amp; val) const; // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;functional&gt;
using namespace std;

class Widget;

template &lt;typename T&gt; class BPFC{};

template&lt;typename T&gt; 
class BPFCImpl
{
private:
    Widget w;
    int x;
    
    virtual ~BPFCImpl();
    virtual void operator()(const T&amp; val) const;
    friend class BPFC&lt;T&gt;; 
};

template&lt;typename T&gt;                              // OK
class BPFC2: public unary_function&lt;T, void&gt; 
{ 
private:
    BPFCImpl&lt;T&gt; *pImpl;
public:
    void operator()(const T&amp; val) const
    {
        pImpl-&gt;operator() (val );
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 6, item 38

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-29</key>
<configkey>STL-29</configkey>
<name><![CDATA[ 使谓词成为 const 纯函数 [STL-29] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使谓词成为 const 纯函数 [STL-29-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"谓词是指一个返回 bool 值的函数 (或者其他可以被
隐式转换为 bool 值的东西)。 一个纯函数是指返回值
只依赖于其参数的函数。 如果 f 是一个纯函数并且 x
和 y 是对象， f(x, y) 的返回值只可以根据 x 或 y 的
值改变而变更。 有必要在谓词类中声明 operator() const
以实现正确的行为。 但是这并不是足够的。一个正确行为的
operator() 当然是 const 的。但是它不只如此。还是一个纯函数。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

如果您试图去更改谓词类型可能有的任何数据成员，
规则防止从检测到错误后禁用编译器。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;

using namespace std;

int global;
class Widget{};

class MeetsThreshold: public std::unary_function&lt;Widget, bool&gt; {
public:
    bool operator( ) ( const Widget&amp; ) {    // 违规
        return ++global == 0;
    }
private:
    size_t current, n_;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;

using namespace std;

class SampleVol: public std::unary_function&lt;int, bool&gt; {
    bool operator( ) ( const int&amp; b ) const {   // OK
        int a = 0;
        return a == b;
    }
public:
    size_t current, n_;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 6, item 39

2. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "STL: Algorithms", Rule 87

3. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-30</key>
<configkey>STL-30</configkey>
<name><![CDATA[ 每一个 functor 类应该有且只有一个 operator()，并且其参数和返回值类型应该通过 unary_function 或 binary_function 来指定 [STL-30] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
每一个 functor 类应该有且只有一个 operator()，并且其参数和返回值类型应该通过 unary_function 或 binary_function 来指定 [STL-30-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"(...) unary_function 和 binary_function 是模板，所以你
不能直接从它们那里继承。相反，你必须继承它们生成的结构体
(structs)，并且需要你指定某种类型的参数。对于 unary_function，
你必须指定仿函数类的 operator() 所带参数类型，以及它的返回
类型。对于 binary_function， 你需要指定三个类型: 你的 operator 
操作符的第一个和第二个参数的类型， 和你 operator 操作符的 
返回值类型。让我们不要忘了所有这些 unary_function 和 
binary_function 基类难解语言的根本原因。 这些类提供
函数对象适配器所需要的 typedefs， 所以从这些类继承能够
产生适配的函数对象。"

STL 函数对象是在 C++ 函数上模拟的， 并且一个 C++ 函数
只有一组参数类型和一个返回值。因此， STL 隐性假设每个
仿函数类只有一个 operator() 函数， 并且对于这个函数的参数
和返回类型应该应该传递给 unary_function 或 binary_function。
这意味着，很有可能是这样， 但是你不应该通过创建一个包含两个
operator() 函数的单一的结构体以尝试合并 WidgetNameCompare 和
PtrWidgetNameCompare 的功能。如果你这样做了， 仿函数将适配
关于其最常用的一种调用形式，并且一个仿函数可能只有一半时间
是适配的而不是所有时间都是适配的。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"适配性非常重要，在每次你写一个仿函数类的时候
你应该努力做到。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;functional&gt;
using namespace std;

class Widget{};

template&lt;typename T&gt;
class MeetsThreshold2: public std::unary_function&lt;Widget, int&gt;  // 违规
{
private:
    const T threshold;
public:
    MeetsThreshold2(const T&amp; threshold);
    bool operator()(const Widget&amp;) const;
};


struct WidgetNameCompare:std::binary_function&lt;Widget, Widget, int&gt;  // 违规
{
    bool operator()(const Widget&amp; lhs, const Widget&amp; rhs) const;
    bool operator()(const Widget&amp; lhs) const;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;functional&gt;
using namespace std;

class Widget{};

template&lt;typename T&gt;
class MeetsThreshold: public std::unary_function&lt;Widget, bool&gt;      // OK
{
private:
    const T threshold;
public:
    MeetsThreshold(const T&amp; threshold);
    bool operator()(const Widget&amp;) const;
};


struct WidgetNameCompare:                                             // OK
std::binary_function&lt;Widget, Widget, bool&gt;{
    bool operator()(const Widget&amp; lhs, const Widget&amp; rhs) const;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 6, item 40

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-31</key>
<configkey>STL-31</configkey>
<name><![CDATA[ 将函数传递给 STL 构件时，必须使用 ptr_fun,mem_fun,或者 mem_fun_ref [STL-31] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
将函数传递给 STL 构件时，必须使用 ptr_fun,mem_fun,或者 mem_fun_ref [STL-31-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"如果你不清楚什么时候使用 ptr_fun 什么时候不使用， 
在每次你传递一个函数给 STL 组件的时候考虑使用它。 
只要在传递一个成员函数给 STL 组件时你就必须使用它们
(mem_fun 和 mem_fun_ref)，因为，除了添加 typedefs  
(可能需要也可能不需要)， 它们适应从通常成员函数
所使用的调用语法到即使在 STL 中使用的调用语法。如果 
当传递成员函数指针时你不使用它们， 您的代码将不会编译。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"由 mem_fun 和 mem_fun_ref 产生的对象超过了允许 STL 
组件以假设所有的函数使用一个单一的语法来调用。 它们 
也提供重要的 typedefs， 就像 ptr_fun 产生的对象。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class Widget {
};

int test(Widget&amp; x) { return 0; };

void myFunction() 
{
    vector&lt;Widget&gt; WidgetVector;
    for_each(WidgetVector.begin(),WidgetVector.end(), test);    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class Widget {
};

int test(Widget&amp; x) { return 0; };

void myFunction() 
{
    vector&lt;Widget&gt; WidgetVector;
    for_each(WidgetVector.begin(), WidgetVector.end(), ptr_fun(test));  // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
   Standard Template Library", Chapter 6, item 41

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-32</key>
<configkey>STL-32</configkey>
<name><![CDATA[ 确保 less<T> 与操作符 < 语义一致 [STL-32] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
确保 less&lt;T&gt; 与操作符 &lt; 语义一致 [STL-32-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"C++ 程序员做的某些假设是可以原谅的。 (...) 他们假设
使用 less 是等于使用 &lt; 操作符。 操作符 &lt; 不仅仅只是
实现 less 的默认的方式， 这是程序员期望 less 要完成的功能。
让 less 做一些除了调用 &lt; 操作符外的事情违反了程序员对其
的期望。你不应该这样做。如果你使用 less (显式或者隐式)，
请确保它是指 &lt; 操作符。 如果你希望使用其他标准来排序对象，
创建一个特殊的不调用 less 的仿函数类。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"让 less 做一些除了调用 &lt; 操作符外的事情违反了程序员对其
的期望。这就违背了称之为 "最小惊讶（对期望结果的误解）
原则。" 这是无情的，意思是，不好的。(...)
不要误导所有的程序员对 less 的定义模糊认识。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;functional&gt;
using namespace std;

class Widget {
public:
  
    size_t weight() const;
    size_t maxSpeed() const;
};

bool operator&lt;(const Widget&amp; lhs, const Widget&amp; rhs)
{
    return lhs.weight() &lt; rhs.weight();
}

template&lt;&gt; 
struct std::less&lt;Widget&gt;:                                // 违规
public 
std::binary_function&lt; Widget, Widget, bool&gt; 
{
    bool operator()(const Widget&amp; lhs, const Widget&amp; rhs) const  
    {
        return lhs.maxSpeed() &lt; rhs.maxSpeed();
    }
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;functional&gt;
using namespace std;

class Widget {
public:
  
    size_t weight() const;
    size_t maxSpeed() const;
};

bool operator&lt;(const Widget&amp; lhs, const Widget&amp; rhs)
{
    return lhs.weight() &lt; rhs.weight();
}

struct maxSpeedCompare:                                  // OK
public binary_function&lt;Widget, Widget, bool&gt; {
    bool operator()(const Widget&amp; lhs, const Widget&amp; rhs) const
    {
        return lhs.maxSpeed() &lt; rhs.maxSpeed();
    }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the
   Standard Template Library", Chapter 6, item 42

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-33</key>
<configkey>STL-33</configkey>
<name><![CDATA[ 尽量采用算法调用而不是手写循环 [STL-33] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
尽量采用算法调用而不是手写循环 [STL-33-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"尽量使用算法调用而不是手写循环。
对于许多 C++ 程序员来说， 编写循环是比调用算法
更加自然的想法，并且读取循环是更方便的 (...)。
然而，这个示例证明算法调用更加可取。
事实上，这个示例证明了调用一个算法通常
是优于任何手写的循环。为什么呢?

有以下的三个原因:
-  效率: 算法通常比程序员创建的循环更有效。
-  正确性: 编写循环比起调用算法更加容易产生错误。
-  可维护性: 算法调用比起对应的显式循环通常产生
更加清晰和直接的代码。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高效率，正确性和代码的可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

void foo()
{
    const int VECTOR_SIZE = 8 ;
    vector&lt;int&gt; Numbers(VECTOR_SIZE) ;
    vector&lt;int&gt;::iterator start, end, it ;
    start = Numbers.begin() ;   
    end = Numbers.end() ;       
	
    for(it = start; it != end; it++)  // 违规
        cout &lt;&lt; *it;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

void print(int n)
{
    cout &lt;&lt; n;
}

void foo()
{
    const int VECTOR_SIZE = 8 ;
    vector&lt;int&gt; Numbers(VECTOR_SIZE) ;
    vector&lt;int&gt;::iterator start, end, it ;
    start = Numbers.begin() ;   
    end = Numbers.end() ;       
    
    for_each(start, end, print) ;     // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 7, item 43

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-34</key>
<configkey>STL-34</configkey>
<name><![CDATA[ 最好采用成员函数而不是采用同名算法 [STL-34] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
最好采用成员函数而不是采用同名算法 [STL-34-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"某些容器有与 STL 算法名称相同的成员函数。
关联的容器提供 count, find, lower_bound. upper_bound, 和
equal_range, 而列表提供 remove, remove_if, unique, sort, merge, 和
reverse。 大部分时间，你会想要使用成员函数而不是算法。
有两方面的原因。 首先， 成员函数的速度更快。
其次，它们比算法来说更好地集成容器 (特别
是关联的容器)。 这就是因为算法和成员函数共享同一个名称
通常却不是做完全一样的东西。(...)"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高效率和稳定性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
using namespace std;

void myFunction( ) {
   set&lt;int&gt; s; 
   list&lt;int&gt; l;
   list&lt;int&gt;::iterator begin = l.begin();
   list&lt;int&gt;::iterator end = l.end();
   set&lt;int&gt;::iterator i = find(s.begin(), s.end(), 727);  // 违规
   reverse(begin,end);                                    // 违规
   reverse(l.begin(),l.end());                            // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
using namespace std;

void myFunction( ) {
   set&lt;int&gt; s;
   list&lt;int&gt; l;
   set&lt;int&gt;::iterator i = s.find(727); // OK
   l.reverse();                        // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 7, item 44

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-35</key>
<configkey>STL-35</configkey>
<name><![CDATA[ 不能简单的将某个非零的常量转换为真，将零转换为假 [STL-35] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能简单的将某个非零的常量转换为真，将零转换为假 [STL-35-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"使用 count 作为一个存在测试， count 返回零
或正数，所以我们依赖于判断非零值为 true 并且
零为 false。如果我们更明确需要做什么，那将无疑
会更加清晰。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高了代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;algorithm&gt;

using namespace std;

void foo()
{
    list&lt;int&gt; lw;
    int w;
    
    if(count(lw.begin(), lw.end(), w))      // 违规
    {
        /*...*/
    } 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;list&gt;
#include &lt;algorithm&gt;

using namespace std;

void foo()
{
    list&lt;int&gt; lw;
    int w;

    if(count(lw.begin(), lw.end(), w) == 0) // OK
    {
        /*...*/
    } 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective STL: 50 Specific Ways to Improve Your Use of the 
   Standard Template Library", Chapter 7, item 45

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-36</key>
<configkey>STL-36</configkey>
<name><![CDATA[ 不要使用一个不是真实范围的迭代器( iterator )范围 [STL-36] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用一个不是真实范围的迭代器( iterator )范围 [STL-36-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

不要使用一个不是真实范围的迭代器范围(iterator)。
这里有两种常用的方式来使用一个不是真实范围的迭代器范围:
"第一种方式发生在当两个迭代器划定了指向同一个容器内 
的范围时， 但是第一个迭代器实际上并不在第二个之前。
第二种常见的情况是发生在当迭代器指向不同的容器时。 "



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高效率并防止内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

void setElem( int elem ) {
    elem = 1;
}

void foo( ) {
    vector&lt;int&gt; coll;
    vector&lt;int&gt; moll;
	
    for_each( coll.begin( ), moll.end( ), setElem );  // 违规    
    for_each( moll.begin( ), coll.end( ), setElem );  // 违规    
    for_each( coll.end( ), coll.begin( ), setElem );  // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

void setElem( int elem ) {
    elem = 1;
}

void foo( ) {
    vector&lt;int&gt; coll;
    for_each( coll.begin( ), coll.end( ), setElem );  // OK       
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "STL: Algorithms", Rule 83

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-37</key>
<configkey>STL-37</configkey>
<name><![CDATA[ 使用 vector 和 string 代替数组 [STL-37] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 vector 和 string 代替数组 [STL-37-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"避免实现数组抽象具有 C 语言风格的数组，指针算术运算， 
和内存管理原型。" 使用 vector 或 string 可以帮助你编写更安全 
和更加可扩展的软件。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则有助于编写更加安全和可扩展的代码。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

class A{};
void foo( ) {
  A arrayA[10]; // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

class A{};

void foo( ) {
  A obj;
  vector &lt;A&gt; vectorA; // OK
  vectorA.push_back(obj);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
(C) 2005 Pearson Education, Inc.
Chapter: "STL: Containers", Rule 77

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-38</key>
<configkey>STL-38</configkey>
<name><![CDATA[ 使用 != 代 替 < 来比较迭代器 [STL-38] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
使用 != 代 替 &lt; 来比较迭代器 [STL-38-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"使用最通用和抽象的方式来实现一部分 
功能: 使用 != 而不是 &lt; 来比较迭代器。 
使用 != 是更加常见并且适用于一个更大的对象类; 
根据需要才使用 &lt; 。"



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则提高效率和防止内存泄漏。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

void foo( ) {
    vector&lt;int&gt; coll;
    vector&lt;int&gt; moll;

    vector&lt;int&gt;::iterator c_pos = coll.begin( );
    vector&lt;int&gt;::iterator m_pos = moll.begin( );
    if (c_pos &lt; m_pos) {}                       // 违规
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

void foo( ) {
    vector&lt;int&gt; coll;
    vector&lt;int&gt; moll;

    vector&lt;int&gt;::iterator c_pos = coll.begin( );
    vector&lt;int&gt;::iterator m_pos = moll.begin( );
    if (c_pos != m_pos) {}                      // OK
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Templates and Genericity", Rule 67

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-39</key>
<configkey>STL-39</configkey>
<name><![CDATA[ 将 traits 类与重载关联使用 [STL-39] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
将 traits 类与重载关联使用 [STL-39-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"我们真正想要的是一个在编译期间计算的有条件的结构
 (例如， 一个 if...else 语句)类型。 碰巧的是， C++ 已经
有一种方式来获得这种行为。这就是所谓的重载。"
注意: 示例的源代码是只针对 "VC++.NET2003" 编译器。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"Traits 类提取在编译过程中可用类型的 
信息。它们是使用模板和模板特化来实现的。
在重载的同时， traits 类使其能够根据
类型执行编译时 if...else 。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#if _MSC_VER == 1310
#include &lt;typeinfo&gt;
template &lt;typename IterT, typename DistT&gt; 
void advancedd( IterT&amp; iter, DistT d ) {
    //**** construction if-else  
    if (typeid( typename std::iterator_traits&lt;IterT&gt;              // 违规
                            ::iterator_category ) ==   
        typeid( std::random_access_iterator_tag )) {
            iter += d;
    } else {
        if (d &gt;= 0) { while (d--) ++iter; }
        else { while (d++) --iter; }
    }
}

#include &lt;vector&gt;
void example( std::vector&lt;int&gt;::iterator iterator, int distant ){
    advancedd&lt;std::vector&lt;int&gt;::iterator, int&gt;( iterator, distant );
}
#endif



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#if _MSC_VER == 1310

//**** overloading
template&lt;typename IterT, typename DistT&gt;          // use this impl for
void doAdvance( IterT&amp; iter, DistT d,              // random access
               std::random_access_iterator_tag ) { // iterators
    iter += d;
}

template&lt;typename IterT, typename DistT&gt;          // use this impl for
void doAdvance( IterT&amp; iter, DistT d,              // bidirectional
               std::bidirectional_iterator_tag ) { // iterators
    if (d &gt;= 0) { while (d--) ++iter; }
    else { while (d++) --iter; }
}

template&lt;typename IterT, typename DistT&gt;          // use this impl for
void doAdvance( IterT&amp; iter, DistT d,              // input iterators
               std::input_iterator_tag ) {
    if (d &lt; 0 ) {
        throw std::out_of_range("Negative distance"); 
    }
    while (d--) ++iter;
}

template&lt;typename IterT, typename DistT&gt;
void advancett( IterT&amp; iter, DistT d ) {
    doAdvance(                            // call the version of doAdvance that
              iter, d,                    // is appropriate for iter's iterator
              typename                                         
              std::iterator_traits&lt;IterT&gt;::iterator_category( ) // OK
             );                                                 
}

#include &lt;vector&gt;
void repair( std::vector&lt;int&gt;::iterator iterator, int distant ) {
    advancett&lt;std::vector&lt;int&gt;::iterator, int&gt;( iterator, distant );
}
#endif



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Scott Meyers, "Effective C++: 55 Specific Ways to Improve
Your Programs and Design", Third Edition, Addison-Wesley, 
(C) 2005 Pearson Education, Inc., Chapter 7, Item 47-48

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-40</key>
<configkey>STL-40</configkey>
<name><![CDATA[ 调用 swap 时，使用 using 声明 std::swap，然后调用 swap 不需要命名空间限定 [STL-40] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
调用 swap 时，使用 using 声明 std::swap，然后调用 swap 不需要命名空间限定 [STL-40-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当调用 swap 时，, 为 std::swap 使用一个 using 声明，
然后调用 swap 而不需要命名空间限定。"
参见: STL-41, STL-42



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"当编译器碰到对 swap 的调用时， 它会搜索正确的 swap 来调用。
C++ 的名称查找规则确保这会在全局范围或与类型 T 在同一个
命名空间中找到任何T-标记的 swap。 如果没有T-标记的 swap
存在，编译器将使用 std 中的 swap， 感谢 using 声明能够使
std::swap 在函数内可见。 然而即使这样， 编译器跟倾向于
一个 std::swap T-标记的特化而不是一般的模板， 所以
如果 std::swap 已经由 T 特化， 特定的版本将会被使用。
你需要小心的一件事情是不限定调用， 因为这将会影响到 
C++ 如何确定要调用的函数。 例如， 如果你要编写对 swap 
的调用以下列方式，

std::swap(obj1, obj2); // 错误的方式来调用 swap

你会强制编译器来对待只有在 std 的 swap，  
从而消除在其他地方定义了得到一个更合适的特定 T 
版本的可能性。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;

using namespace std;

template&lt;typename T&gt;
void doSomething( T&amp; obj1, T&amp; obj2 ) {
    std::swap( obj1, obj2 );              // 违规
}

void foo( int a, int b ) {
    doSomething&lt;int&gt;( a, b );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;

using namespace std;

template&lt;typename T&gt;
void doSomething( T&amp; obj1, T&amp; obj2 ) {
    using std::swap;
    swap( obj1, obj2 );                   // OK
}

void foo( int a, int b ) {
    doSomething&lt;int&gt;( a, b );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 4, Item 25

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-41</key>
<configkey>STL-41</configkey>
<name><![CDATA[ 不能声明非成员作为 std::swap 的重载 [STL-41] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不能声明非成员作为 std::swap 的重载 [STL-41-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"在一般情况下， 重载函数模板是好的，但是 std 是一个特殊的
命名空间， 并且管理它的规则也是特殊的。 在 std 中完全特化模板
是没有问题的， 但是添加新的模板到 std 却不是很好的做法。
那应该怎么样做呢? 我们仍然需要一个方式来让其他人员调用 swap 并得到
我们更有效的特定的模板版本。 答案很简单，我们仍然声明一个
非成员 swap 来调用成员 swap， 我们只是不要声明非成员
为一个特化或重载 std::swap。"
参见: STL-40, STL-42



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

规则检测到正在试图重载 std::swap。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"违法这条规则的程序当然可以编译和运行，但是
它们的行为将是不确定的。如果你希望你的软件具有
可预测的行为，你最好不要添加新的东西到 std 中。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template&lt;typename T&gt;
class WidgetImpl {};

template&lt;typename T&gt;
class Widget {
public:
    void swap( Widget&lt;T&gt;&amp; other ) {
        using std::swap;
        swap(pImpl, other.pImpl );
    }
private:
    WidgetImpl&lt;T&gt; *pImpl;
};

namespace std {
    template&lt;typename T&gt;
    void swap( Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b ) {  // 违规
        a.swap( b );
    }
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

namespace WidgetStuff {
    template&lt;typename T&gt;
    class WidgetImpl {};

    template&lt;typename T&gt; 
    class Widget { 
    public:
        void swap( Widget&lt;T&gt;&amp; other ) {
            using std::swap;
            swap( pImpl, other.pImpl );
        }
    private:
        WidgetImpl&lt;T&gt; *pImpl;
    };

    template&lt;typename T&gt;
    void swap( Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b ) {  // OK
        a.swap( b );
    }
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 4, Item 25

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>STL-42</key>
<configkey>STL-42</configkey>
<name><![CDATA[ Swap 的成员版本应该禁止抛出异常 [STL-42] ]]></name>
<tag>stl</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
Swap 的成员版本应该禁止抛出异常 [STL-42-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"我的告诫中唯一的松散部分是让 swap 的成员版本
永远不要抛出异常。 这是因为 swap 最有用的应用之一
是帮助类(和类模板) 提供强大的异常安全机制保证。
(...) 这项技术的前提是假设 swap 的成员版本绝对 
不会抛出异常。"
参见: STL-40, STL-41



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"这是因为 swap 最有用的应用之一是帮助类
(和类模板) 提供强大的异常安全机制保证。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
class WidgetImpl {};

class Widget { 
public:
    void swap( Widget&amp; other ) {            // 违规
        try {
            using std::swap;
            swap( pImpl, other.pImpl );
        } catch(...) {
            throw;
        }
    }
private:
    WidgetImpl *pImpl;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
class WidgetImpl {};

class Widget { 
public:
    void swap( Widget&amp; other ) {           // OK
        try {
            using std::swap;
            swap( pImpl, other.pImpl );
        } catch(...) {
            // something else than "throw;"
        }
    }
private:
    WidgetImpl *pImpl;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 4, Item 25

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-01</key>
<configkey>TEMPL-01</configkey>
<name><![CDATA[ 从模板中分离出参数无关的代码 [TEMPL-01] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
从模板中分离出参数无关的代码 [TEMPL-01-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当你正在编写一个函数并且你意识到这个函数实现的
一部分是和另外一个函数的实现本质上是相同的，
你会只是复制这段代码吗? 当然不是， 你会从这两个
函数中分离出共同的代码， 并把其放在第三个函数中，
然后让这两个函数调用这个新的函数。当编写模板的时候，
你应该做相同的分析， 会避免同样方式的重复，但是这有
点不同。 在非模板代码中，重复是明显的: 你可以看到
在两个函数或两个类中有重复的代码。 在模板代码中，
重复是隐式的: 这里只有一个模板源代码的拷贝，所以
当一个模板被多次实例化时你需要让自己能够察觉可能替代
的重复代码。 如果你具有非类型模板参数的类， 请考虑
创建具有相同函数的基类， 但是从继承的类中作为一个 
额外的参数非类型模板参数。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则防止可能隐含的代码重复。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;iostream&gt;
template&lt;typename T&gt; 
class SquareMatrixBase { 
protected:
    void invert( std::size_t matrixSize );
};

template&lt; typename T, std::size_t n&gt;
class SquareMatrix: private SquareMatrixBase&lt;T&gt; { // 违规 (no foo()
                                                  // in SquareMatrixBase)
public:
    void foo( );
};

template&lt; typename T, std::size_t n&gt;
class SquareMatrix2 {                             // 违规(no base class)
public:
    void foo( );
    void invert( );
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;iostream&gt;
template&lt;typename T&gt;
class SquareMatrixBase {
protected:
    void invert( std::size_t matrixSize );
};

template&lt; typename T, std::size_t n&gt;
class SquareMatrix: private SquareMatrixBase&lt;T&gt; {
private:
    using SquareMatrixBase&lt;T&gt;::invert;
public:
    void invert( ) { this-&gt;invert(n); }        // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 7, Item 44

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-02</key>
<configkey>TEMPL-02</configkey>
<name><![CDATA[ 需要类型转换时在模板内定义非成员函数 [TEMPL-02] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
需要类型转换时在模板内定义非成员函数 [TEMPL-02-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当需要类型转换时在模板内部定义非成员函数。
当编写一个类模板提供跟这个模板相关的函数
支持所有参数的隐式类型转换， 在类模板的内部
定义这些函数为友元函数。"



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"定义跟模板相关的并支持所有参数的隐式类型 
转换的函数作为友元函数，以防止不正确地使用
这些函数。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template&lt;typename T&gt;
class Rational {
public:
    Rational( const T&amp; ); 
};

template&lt;typename T&gt;
const Rational&lt;T&gt; operator*( // 违规
const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs ) 
{ /* ... */ }



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

template&lt;typename T&gt;
class Rational {
public:
    Rational( const T&amp; ); 

    friend
    const Rational&lt;T&gt; operator*( // OK
    const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs ) 
    { /* ... */ }
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 7, Item 46

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-03</key>
<configkey>TEMPL-03</configkey>
<name><![CDATA[ 不要重载模板类中的函数 [TEMPL-03] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要重载模板类中的函数 [TEMPL-03-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

重载模板类内部的函数可能会出现问题。
这种情况发生在它们的一个之中显式出现元素类型。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则检测如果你在一个模板类中有重载函数。
重载函数可能显示在模板类中的一个设计缺陷。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template &lt;class T&gt; class A 
{
    public:
        int foo( T );
        int foo( int );    // 违规
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

template &lt;class T&gt; class A 
{
    public:
        int foo( T );    // OK
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-04</key>
<configkey>TEMPL-04</configkey>
<name><![CDATA[ 在全局模板函数中使用 'typename' 去标识嵌套依赖类型名 [TEMPL-04] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在全局模板函数中使用 'typename' 去标识嵌套依赖类型名 [TEMPL-04-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

在模板的全局函数中使用 typename 来识别
嵌套依赖类型名。
参见: TEMPL-05



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"嵌套依赖名可能会导致解析困难。 (...) 如果解析器
在一个模板中遇到了一个嵌套依赖名， 它会假设此名称
不是一个类型，除非你告诉它。 默认情况下，嵌套依赖名
不是类型。 一般规则很简单: 任何时候你在一个模板中涉及到
一个嵌套依赖类型名，你必须立刻在其前面使用关键字 typename。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

template&lt;typename T&gt;
void print2nd( const T&amp; container ) {
    if (container.size( ) &gt;= 2) {
        T::const_iterator iter( container.begin( ) );    // 违规
        ++iter;
        int value = *iter;
        cout &lt;&lt; value;
    }
}

void test( ) {
    typedef vector&lt;int&gt; int_v;
    int_v container( 10 );

    print2nd&lt;int_v&gt;( container );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

template&lt;typename T&gt;
void print2nd( const T&amp; container ) {
    if (container.size( ) &gt;= 2) {
        typename T::const_iterator iter( container.begin( ) );    // OK
        ++iter;
        int value = *iter;
        cout &lt;&lt; value;
    }
}

void test( ) {
    typedef vector&lt;int&gt; int_v;
    int_v container( 10 );

    print2nd&lt;int_v&gt;( container );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 7, Item 42

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-05</key>
<configkey>TEMPL-05</configkey>
<name><![CDATA[ 在模板类中使用 'typename' 去标识嵌套依赖类型名 [TEMPL-05] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在模板类中使用 'typename' 去标识嵌套依赖类型名 [TEMPL-05-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"使用 typename 来识别嵌套依赖类型名，除了在基类列表中 
或作为一个基类标识符在一个成员初始化列表中。"
参见: TEMPL-04



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

"嵌套依赖名可能会导致解析困难。 (...) 如果解析器
在一个模板中遇到了一个嵌套依赖名， 它会假设此名称
不是一个类型，除非你告诉它。 默认情况下，嵌套依赖名
不是类型。 一般规则很简单: 任何时候你在一个模板中涉及到
一个嵌套依赖类型名，你必须立刻在其前面使用关键字 typename。"



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

template&lt;class T&gt;
class Base {
public:
    class Nested {
    public:
        Nested( int a );
        Nested( );
        void foo( );
    };
};

template&lt;typename T&gt;
class Derived2: public Base&lt;T&gt;::Nested {
public:
    explicit Derived2( int x ): Base&lt;T&gt;::Nested( x ) {
        Base&lt;T&gt;::Nested temp;           // 违规
        temp.foo( );
    }
    void goo(Base&lt;T&gt;::Nested temp){}    // 违规 
};

void test( ) {
    Derived2&lt;int&gt; obj(1);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

#include &lt;vector&gt;
using namespace std;

template&lt;class T&gt;
class Base {
public:
    class Nested {
    public:
        Nested( int a );
        Nested( );
        void foo( );
    };
};

template&lt;typename T&gt;
class Derived2: public Base&lt;T&gt;::Nested {
public:
    explicit Derived2( int x ): Base&lt;T&gt;::Nested( x ) {
        typename Base&lt;T&gt;::Nested temp;           // OK
        temp.foo( );
    }
    void goo( typename Base&lt;T&gt;::Nested temp ){}    // OK 
};

void test( ) {
    Derived2&lt;int&gt; obj(1);
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley, 
   (C) 2005 Pearson Education, Inc., Chapter 7, Item 42

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-06</key>
<configkey>TEMPL-06</configkey>
<name><![CDATA[ 在模板类中，不要改变默认的虚函数参数 [TEMPL-06] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在模板类中，不要改变默认的虚函数参数 [TEMPL-06-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"当重载一个虚函数时，请保留可替代性;特别是，
注意到这个函数在基类中的的前置(pre-)和后置(post-)条件。
不要改变虚函数默认的参数。 应该显式地重新声明虚函数
的重载。 请注意到在基类中隐藏的重载。"
参见: OOP-15, OOP-17



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

这条规则可以防止通过默认方式传递值的误解。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template&lt;class T&gt; class Base {
public:
    virtual void foo( T i = 1 ) { }
};

template&lt;class T&gt; class Derived: public Base&lt;T&gt; {
public:
    virtual void foo( T i = 0 ) { }    // 违规
};

void foo( ) {
    Base&lt;int&gt;    b;
    Derived&lt;int&gt; d;
    d.foo( );
    b.foo( );
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

template&lt;class T&gt; class Base {
public:
    virtual void foo( T i = 1 ) { }
};

template&lt;class T&gt; class Derived: public Base&lt;T&gt; {
public:
    virtual void foo( T i = 1 ) { }    // OK
};

void foo( ) {
    Base&lt;int&gt;    b;
    Derived&lt;int&gt; d;
    d.foo( );
    b.foo( );
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Herb Sutter, Andrei Alexandrescu, "C++ Coding Standards," Addison-Wesley, 
   (C) 2005 Pearson Education, Inc.
   Chapter: "Class Design and Inheritance", Rule 38

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-07</key>
<configkey>TEMPL-07</configkey>
<name><![CDATA[ 当存在一个包含单个泛型参数的模板构造函数时，拷贝构造函数应该被声明 [TEMPL-07] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
当存在一个包含单个泛型参数的模板构造函数时，拷贝构造函数应该被声明 [TEMPL-07-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“可能和开发人员的预期相反，一个模板构造函数
将不会抑制编译器生成的拷贝构造函数。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

模板类型参数 T 如果在函数声明中有(可能 cv-限定的)
T &amp;[opt] 的格式，那么它是一个泛型参数。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止对需要深度拷贝成员不正确拷贝语义。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int int32_t;
class A                        // 违规
{
    public:
        A ( );
        template &lt;typename T&gt;
        A ( T const &amp; rhs )
        : i ( new int32_t )
        {
            *i = *rhs.i;
        }
    private:
            int32_t * i;
};



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef signed int int32_t;
class A                         // OK
{
    public:
        A ( );
        A ( A const &amp; rhs );
        template &lt;typename T&gt;
        A ( T const &amp; rhs )
        : i ( new int32_t )
        {
            *i = *rhs.i;
        }
    private:
            int32_t * i;
};



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-5-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-08</key>
<configkey>TEMPL-08</configkey>
<name><![CDATA[ 函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化 [TEMPL-08] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化 [TEMPL-08-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“函数调用的可行函数集合应该要么不包括
函数特化，要么只包括函数特化。如果一个
函数和一个函数模板的特化在重载解析之后
被认为等价，那么非特化函数会在函数特化
中被选择。”


例外:

“此规定不适用于拷贝构造函数或拷贝赋值运算符。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止编写的代码可能与
开发人员的期望不一致。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void f ( short b){}                    // Example 1
template &lt;typename T&gt; void f ( T ){}   // Example 2

void b ( short s )
{
    f ( s );      // 违规 - Calls Example 1
    f ( s + 1 );  // 违规 - Calls Example 2
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

void f ( short b){}                    // Example 1
template &lt;typename T&gt; void f ( T ){}   // Example 2

void b ( short s )
{
    f&lt;&gt; ( s );      // OK - Calls Example 2
    f&lt;&gt; ( s + 1 );  // OK - Calls Example 2
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-8-2

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-09</key>
<configkey>TEMPL-09</configkey>
<name><![CDATA[ 重载函数模板不得显式地特化 [TEMPL-09] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
重载函数模板不得显式地特化 [TEMPL-09-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“重载函数模板不得显式地特化。
显式的特化将只在重载解析已经从原始函数模板集中
选择了一个最佳匹配之后被考虑。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“凡是模板没有被其他模板重载，或者被
非模板函数重载那么它可以显式地特化，
因为它是符合开发人员的预期：显式的特化
将只在选择了原始模板时才被考虑。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

template &lt;typename T&gt; void f ( T );
template &lt;typename T&gt; void f ( T* );
template &lt;&gt; void f&lt;int*&gt; ( int* ); // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

template &lt;typename T&gt; void f ( T );
template &lt;&gt; void f&lt;int*&gt; ( int* );  // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-8-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-10</key>
<configkey>TEMPL-10</configkey>
<name><![CDATA[ 一个模板的所有局部和显式的特化应该在它们原始模板声明的同一个文件中被声明 [TEMPL-10] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
一个模板的所有局部和显式的特化应该在它们原始模板声明的同一个文件中被声明 [TEMPL-10-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“如果对于一个模板参数集，隐式的实例是由
编译器自动生成的，并且局部的或显式的
特化是在程序的其他匹配模板参数集的地方
声明和定义的，那么这是一个不确定的行为。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

此规则可防止不确定的行为。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// file.h

template &lt;typename T&gt; void foo () {}

// file.cpp

#include "file.h"

template &lt;&gt; void foo&lt;int&gt; () {} // 违规



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// file.h

template &lt;typename T&gt; void foo () {}

template &lt;&gt; void foo&lt;int&gt; () {} // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-7-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-11</key>
<configkey>TEMPL-11</configkey>
<name><![CDATA[ 存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明 [TEMPL-11] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明 [TEMPL-11-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“可能和开发人员的预期相反，一个模板赋值运算符
将不会抑制编译器生成的拷贝赋值运算符。”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

模板类型参数 T 如果在函数声明中有(可能 cv-限定的)
T &amp;[opt] 的格式，那么它是一个泛型参数。
用户声明的拷贝赋值运算符 X::operator= 
是精确地包含一个 type X, X&amp;, const X&amp;, volatile X&amp;
或 const volatile X&amp; 参数的非静态非模板成员函数



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

防止对需要深度拷贝成员不正确拷贝语义。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef signed int int32_t;
class A       // 违规
{
    public:
        template &lt;typename T&gt;
        T &amp; operator= ( T const &amp; rhs )
        {
            if ( this != &amp;rhs ) {
                delete i;
                i = new int32_t; 
                *i = *rhs.i;
            }
            return *this;
         }
    private:
        int32_t * i;
};
void f ( A const &amp; a1, A &amp; a2 )
{
    a2 = a1;
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef signed int int32_t;
class A     // OK
{
    public:
        A &amp; operator= ( A const &amp; rhs )
        {
            i = rhs.i;
            return *this; 
        }
        template &lt;typename T&gt;
        T &amp; operator= ( T const &amp; rhs )
        {
            if ( this != &amp;rhs ) {
                delete i;
                i = new int32_t; 
                *i = *rhs.i;
            }
            return *this;
         }
    private:
        int32_t * i;
};
void f ( A const &amp; a1, A &amp; a2 )
{
    a2 = a1;
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-5-3

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>TEMPL-12</key>
<configkey>TEMPL-12</configkey>
<name><![CDATA[ 在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识或 -> [TEMPL-12] ]]></name>
<tag>templ</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识或 -&gt; [TEMPL-12-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

“在含有依赖基础的类模板中，任何可能在这个依赖类中
被发现的名称都应该引用使用限定标识或 -&gt;”



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.2



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

“使用限定标识或用 -&gt; 限定标识符的前缀
确保选择的实体符合开发人员的预期。”



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

typedef int TYPE;
void g ( );
int i;
template &lt;typename T&gt;
class B;
template &lt;typename T&gt;
class A : public B&lt;T&gt;
{
    void f1 ( )
    {
        TYPE t = 0; // 违规
        g ( );      // 违规
        i++;        // 违规
    }
};
template &lt;typename T&gt;
class B
{
public:
    typedef T TYPE;
    void g ( );
    int i;
};
template class A&lt;int&gt;;



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

typedef int TYPE;
void g ( );
int i;
template &lt;typename T&gt;
class B;
template &lt;typename T&gt;
class A : public B&lt;T&gt;
{
    void f1 ( )
    {
        ::TYPE t1 = 0; // OK - explicit use global TYPE
        ::g ( );       // OK - explicit use global func
        ::i++;         // OK - explicit use global var
        typename B&lt;T&gt;::TYPE t2 = 0; // OK - explicit use base TYPE
        this-&gt;g ( );                // OK - explicit use base "g"
        this-&gt;i;                    // OK - explicit use base "i"
    }
};
template &lt;typename T&gt;
class B
{
public:
    typedef T TYPE;
    void g ( );
    int i;
};
template class A&lt;int&gt;;



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. MISRA C++:2008 C++语言在关键系统中的使用指南
   第 6 章, 第 14 节, 规则 14-6-1

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-CODSTA-15</key>
<configkey>SF-CODSTA-15</configkey>
<name><![CDATA[ 当数组作为参数传入一个函数时不要声明数组的大小 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-COMMENT-03</key>
<configkey>SF-COMMENT-03</configkey>
<name><![CDATA[ 对每一个文件进行注释 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
对每一个文件进行注释 [SF-COMMENT-03_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

"每个包含源码的文件必须以注解的方式提供
文件名和其内容介绍来记录."


记事:

C 和 C++ 的注解方式是认同的。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规范改进可读性和维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

// No comment "File:"           // 违规 - 没有介绍的注解



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// File: &lt;short description of the file&gt;   // OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

1. Ellemtel 编程规范 
   <A HREF="http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html">http://www.chris-lott.org/resources/cstyle/Ellemtel-rules-mm.html</A>
   出自: 4 Source Code in Files - 4.3 Comments - Rule 4

2. 联合攻击战斗机, 飞行器, C++ 编程规范
   第 4.14 章节 Comments, AV Rule 133

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-04</key>
<configkey>SF-FORMAT-04</configkey>
<name><![CDATA[ 单行字符应该不超过 80 个 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-06</key>
<configkey>SF-FORMAT-06</configkey>
<name><![CDATA[ 每行只允许有一条语句 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-07</key>
<configkey>SF-FORMAT-07</configkey>
<name><![CDATA[ 二元操作符两侧要加空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-08</key>
<configkey>SF-FORMAT-08</configkey>
<name><![CDATA[ 二元操作符两侧要加空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-12</key>
<configkey>SF-FORMAT-12</configkey>
<name><![CDATA[ 关键字 if switch for while 之后要加空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-16</key>
<configkey>SF-FORMAT-16</configkey>
<name><![CDATA[ 二元操作符两侧要加空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-17</key>
<configkey>SF-FORMAT-17</configkey>
<name><![CDATA[ 在 '.' 或 '->' 操作符之后不能有空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-18</key>
<configkey>SF-FORMAT-18</configkey>
<name><![CDATA[ 在 '.' 或 '->' 操作符之前不能有空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-19</key>
<configkey>SF-FORMAT-19</configkey>
<name><![CDATA[ 如果逗号后面没有立即换行, 要在后面加空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-20</key>
<configkey>SF-FORMAT-20</configkey>
<name><![CDATA[ 如果分号后面没有立即换行, 要在后面加空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-21</key>
<configkey>SF-FORMAT-21</configkey>
<name><![CDATA[ 在前缀一元运算符及其操作之间不能有空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-22</key>
<configkey>SF-FORMAT-22</configkey>
<name><![CDATA[ 在后缀一元运算符及其操作之间不能有空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-32</key>
<configkey>SF-FORMAT-32</configkey>
<name><![CDATA[ 解引用操作符 '*' 和地址操作符 `&' 应直接与类型名连接在一起 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-36</key>
<configkey>SF-FORMAT-36</configkey>
<name><![CDATA[ 同级语句行应该缩进到相同的水平 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-FORMAT-41</key>
<configkey>SF-FORMAT-41</configkey>
<name><![CDATA[ 在开始方括号 '[' 和前面的标识符之间不应该有空格 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[  <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-METRICS-01</key>
<configkey>SF-METRICS-01</configkey>
<name><![CDATA[ 避免函数超过 100 行 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
避免函数超过 100 行 [SF-METRICS-01_1-5]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

如果一个函数太长，可能很难理解。
如果一个程序包含函数的不操过 100 行，
该程序就很容易创建和理解。
规则计数的代码行包括括号{}的开始和结束之间的函数体。
参见: METRICS-20, METRICS-21, METRICS-22



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则改进代码的可读性和可维护性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void too_long_function() 	// 违规
{
  int a1;
  int a2;
  int a3;
/*
 * lines of code, comment lines, empty lines
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

限制函数的大小到100行.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Recommended by ParaSoft
Sangfor checklist C&amp;C++/function/line

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-METRICS-18</key>
<configkey>SF-METRICS-18</configkey>
<name><![CDATA[ 将圈复杂度限制在 20 之内 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
将圈复杂度限制在 20 之内 [SF-METRICS-18_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

规则找出那些不符合用户定义的圈复杂度的方法.

圈复杂度的计算公式:
CC = 分支判断的数量 + 1
对于分支判断表示每次出现以下的:
-'if'
-'for'
-'while'
-'do-while'
-'case'
-'catch'
-条件表达式 'a?b:c'
-逻辑运算符 '&amp;&amp;' 和 '||'
当函数的圈复杂度高出10时，报告出来.
参见: METRICS-28, METRICS-29, METRICS-33, METRICS-34, METRICS-35



</PRE>
<STRONG>
注意
</STRONG>
<PRE>

可以通过修改rule的定义，来修改默认的10的定义。
要更改圈复杂度的默认限制，修改规则主要的
收集器 "Count" 表达式 (Collector A) 从 "$$ &gt; 10" 到 "$$ &gt; N"，
使用 N 表示期望阀值。规则的头部也应该做相应的
修改。

如果要忽视在圈复杂度计算中的开关语句,
修改层次的收集器 "Count" 表达式 (Collector C) 从 "$$ &gt; 0" 
到 "$$ == 0".

如果要忽视在圈复杂度的计算中的具有超过N层的
开关语句, 修改层次的收集器 "Count" 表达式
(Collector C) 从 "$$ &gt; 0" 到 "$$ &lt;= N" ，使用 N 表示期望阀值。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

研究发现，具有较高圈复杂度的地方，是错误的多发地.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b) // 违规- CC value: 11
{
    switch (a)
    {
        case 1:        // 1
            break;        
        case 2:        // 2
            break;
        case 3:        // 3
            break;
        default:      
            break;
    }
    if(a||b)           // 4, 5
    {
    }
    if((a||b)&amp;&amp;(a&amp;&amp;b)) // 6, 7, 8, 9
    {
    }
    do                 // 10
    {
    }while(0);
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

保持圈复杂度的值在10之内.



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

McCabe, T., "A Complexity Measure," IEEE Transactions on Software
Engineering, December 1976.

HIS Source Code Metriken, version 1.3.1
Metrik "v(G)"

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-METRICS-27</key>
<configkey>SF-METRICS-27</configkey>
<name><![CDATA[ 函数的参数不要多于 5 个 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
不要使用多于 5 个参数的函数 [SF-METRICS-27_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

有长参数列表的函数是难以阅读，使用和维护的。
同时也表明，没有很好的使用抽象和对象的概念。



</PRE>
<STRONG>
始于
</STRONG>
<PRE>

v7.1



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则帮助改进代码的可维护性和可阅读性.



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

void foo(int a, int b, int c, int d, int e, int f, int g, int h)  // 违规
{ 
}



</PRE>
<STRONG>
修复
</STRONG>
<PRE>

// 限制函数的参数在7个之内.

void foo(int a, int b, int c, int d, int e, int f, int g)  // OK
{ 
}



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
4.13 Function, AV Rule 110

Sangfor checklist C&amp;C++/function/parameter

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
<rule>
<key>SF-NAMING-18</key>
<configkey>SF-NAMING-18</configkey>
<name><![CDATA[ 全局变量名以 'g_' 或 's_' 开头 ]]></name>
<tag>sf</tag>
<priority>MAJOR</priority>
<description><![CDATA[ <BODY BGCOLOR=#FFFFFF>
<STRONG>
全局变量名以 'g_' 或 's_' 开头 [SF-NAMING-18_1-3]
</STRONG>
<BR><BR>
<STRONG>
说明
</STRONG>
<PRE>

所有全局变量命名都应该用 's_'或'g_'开头。



</PRE>
<STRONG>
优点
</STRONG>
<PRE>

规则可以改善代码的可读性和可维护性。



</PRE>
<STRONG>
示例
</STRONG>
<PRE>

int global_var;	  // 违规
static int static_var; //违规


</PRE>
<STRONG>
修复
</STRONG>
<PRE>

int g_var; // OK
static int s_var; //OK



</PRE>
<STRONG>
参考资料
</STRONG>
<PRE>

Sangfor Checklist C&amp;C++/label/name

</PRE>
</BODY> <SMALL>ATT 2015</SMALL>]]></description>
</rule>
</rules>